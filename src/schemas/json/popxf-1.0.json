{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://json.schemastore.org/popxf-1.0.json",
  "definitions": {
    "conditionScaleArrayPolynomial": {
      "type": "object",
      "properties": {
        "metadata": {
          "type": "object",
          "properties": {
            "polynomial_names": {},
            "scale": { "type": "array" }
          },
          "required": ["polynomial_names", "scale"]
        }
      }
    },
    "stringifiedTuplePattern": {
      "type": "string",
      "pattern": "^\\(\\s*'[^']*'\\s*(,|(,\\s*'[^']*'\\s*)+\\s*,?)\\s*\\)$"
    },
    "monomialKeyPatternDeg1": {
      "type": "object",
      "propertyNames": {
        "pattern": "^\\(\\s*'[^']*'\\s*,\\s*('[IR]'\\s*,?)?\\s*\\)$"
      }
    },
    "monomialKeyPatternDeg2": {
      "type": "object",
      "propertyNames": {
        "pattern": "^\\(\\s*('[^']*'\\s*,\\s*){1}'[^']*'(\\s*,\\s*'[IR]{2}')?\\s*,?\\s*\\)$"
      }
    },
    "monomialKeyPatternDeg3": {
      "type": "object",
      "propertyNames": {
        "pattern": "^\\(\\s*('[^']*'\\s*,\\s*){2}'[^']*'(\\s*,\\s*'[IR]{3}')?\\s*,?\\s*\\)$"
      }
    },
    "monomialKeyPatternDeg4": {
      "type": "object",
      "propertyNames": {
        "pattern": "^\\(\\s*('[^']*'\\s*,\\s*){3}'[^']*'(\\s*,\\s*'[IR]{4}')?\\s*,?\\s*\\)$"
      }
    },
    "monomialKeyPatternDeg5": {
      "type": "object",
      "propertyNames": {
        "pattern": "^\\(\\s*('[^']*'\\s*,\\s*){4}'[^']*'(\\s*,\\s*'[IR]{5}')?\\s*,?\\s*\\)$"
      }
    },
    "monomialKeyPatternConstantDeg1": {
      "type": "object",
      "minProperties": 1,
      "maxProperties": 1,
      "propertyNames": {
        "pattern": "^\\(\\s*''\\s*,\\s*('R'\\s*,?)?\\s*\\)$"
      }
    },
    "monomialKeyPatternConstantDeg2": {
      "type": "object",
      "minProperties": 1,
      "maxProperties": 1,
      "propertyNames": {
        "pattern": "^\\(\\s*(''\\s*,\\s*){1}''(\\s*,\\s*'RR')?\\s*,?\\s*\\)$"
      }
    },
    "monomialKeyPatternConstantDeg3": {
      "type": "object",
      "minProperties": 1,
      "maxProperties": 1,
      "propertyNames": {
        "pattern": "^\\(\\s*(''\\s*,\\s*){2}''(\\s*,\\s*'RRR')?\\s*,?\\s*\\)$"
      }
    },
    "monomialKeyPatternConstantDeg4": {
      "type": "object",
      "minProperties": 1,
      "maxProperties": 1,
      "propertyNames": {
        "pattern": "^\\(\\s*(''\\s*,\\s*){3}''(\\s*,\\s*'RRRR')?\\s*,?\\s*\\)$"
      }
    },
    "monomialKeyPatternConstantDeg5": {
      "type": "object",
      "minProperties": 1,
      "maxProperties": 1,
      "propertyNames": {
        "pattern": "^\\(\\s*(''\\s*,\\s*){4}''(\\s*,\\s*'RRRRR')?\\s*,?\\s*\\)$"
      }
    }
  },
  "type": "object",
  "title": "Specification of Fields in the `POPxf` `JSON` Format",
  "description": "A detailed specification of all fields in the proposed `POPxf` data format is given below. Each subsection describes the structure, expected data type, and allowed values of the corresponding entries in the `JSON` object. The data type *object* mentioned below refers to a `JSON` object literal and corresponds to a set of key/value pairs representing named subfields. The format is divided into two main components: the `metadata` and `data` fields. An additional `$schema` field is included to specify the version of the `POPxf` `JSON` schema used. All quantities defined in this specification refer to a single datafile. They may be indexed by a superscript $(n)$ with $n \\in [1,N]$ to denote quantities in a collection of $N$ datafiles. This is particularly relevant for discussing correlated predictions stored in separate files. Since this specification focuses on the format of a single datafile, we will omit the superscript $(n)$ to keep the notation concise. As a convention, we assume that all dimensionful quantities are given in units of GeV.",
  "properties": {
    "$schema": {
      "type": "string",
      "const": "https://json.schemastore.org/popxf-1.0.json",
      "title": "`$schema` Field",
      "description": "The `$schema` field allows identifying a `JSON` file as conforming to the `POPxf` format and specifies the version of the `POPxf` `JSON` schema used. It must be set to\n\n`\"https://json.schemastore.org/popxf-1.0.json\"`\n\nfor files conforming to this version of the specification. The version number will be incremented for future revisions of the `JSON` schema."
    },
    "metadata": {
      "type": "object",
      "title": "`metadata` Field",
      "description": "The `metadata` field contains all contextual and structural information required to interpret the numerical predictions. It is a `JSON` object with the following subfields:",
      "properties": {
        "observable_names": {
          "type": "array",
          "description": "Array of $M$ names identifying each observable $O_m$. Must be an array of unique, non-empty strings, with at least one entry.",
          "minItems": 1,
          "items": {
            "type": "string",
            "minLength": 1
          },
          "uniqueItems": true,
          "examples": [
            {
              "observable_names": ["observable1", "observable2", "observable3"]
            }
          ]
        },
        "parameters": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "string",
            "minLength": 1
          },
          "uniqueItems": true,
          "description": "Array of $S$ names identifying each model parameter $C_s$ (e.g., Wilson coefficient names). Must be an array of unique, non-empty strings, with at least one entry. In general, this includes $S_\\mathbb{R}$ real-valued and $S_\\mathbb{C}$ complex-valued parameters with $S = S_\\mathbb{R} + S_\\mathbb{C}$. The real-valued parameters and the real and imaginary parts of the complex-valued parameters are used as the $R=S_\\mathbb{R} + 2\\ S_\\mathbb{C}$ independent variables of all polynomial terms and can be grouped together in a real-valued parameter vector $\\vec{C}$ of length $R$.",
          "examples": [
            {
              "parameters": ["C1", "C2", "C3"]
            }
          ]
        },
        "basis": {
          "type": "object",
          "description": "Defines the parameter basis (e.g. an operator basis in an EFT). At least one of the two subfields `wcxf` and `custom` has to be present. If both subfields are present, any element of `parameters` (see above) not belonging to the `wcxf` basis is interpreted as belonging to the `custom` basis. The subfields are defined as follows:",
          "properties": {
            "wcxf": {
              "type": "object",
              "description": "Specifies an EFT basis defined by the Wilson Coefficient exchange format (WCxf) [@Aebischer:2017ugx]. This object contains the following fields:",
              "properties": {
                "eft": {
                  "type": "string",
                  "description": "EFT name defined by WCxf (e.g., `\"SMEFT\"`)"
                },
                "basis": {
                  "type": "string",
                  "description": "Operator basis name defined by WCxf (e.g., `\"Warsaw\"`)"
                },
                "sectors": {
                  "type": "array",
                  "items": { "type": "string" },
                  "description": "Array of renormalisation-group-closed sectors of Wilson coefficients containing the Wilson coefficients given in `parameters` (see above). The available sectors for each EFT are defined by WCxf."
                }
              },
              "required": ["eft", "basis"],
              "additionalProperties": false
            },
            "custom": {
              "description": "Field of any type and substructure to unambiguously specify any parameter basis not defined by WCxf."
            }
          },
          "anyOf": [
            {
              "type": "object",
              "properties": { "wcxf": {} },
              "required": ["wcxf"]
            },
            {
              "type": "object",
              "properties": { "custom": {} },
              "required": ["custom"]
            }
          ],
          "additionalProperties": false,
          "examples": [
            {
              "basis": {
                "wcxf": {
                  "eft": "SMEFT",
                  "basis": "Warsaw",
                  "sectors": ["dB=de=dmu=dtau=0"]
                }
              }
            }
          ]
        },
        "polynomial_names": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "string",
            "minLength": 1
          },
          "uniqueItems": true,
          "description": "*This field is required to express observables as functions of polynomials. It requires the simultaneous presence of `metadata.observable_expressions` and `data.polynomial_central`.*\n\nArray of $K$ names identifying the individual polynomials $P_k$ that enter the observable predictions through the functions defined in `metadata.observable_expressions` (see below). Must contain unique, non-empty strings.",
          "examples": [
            {
              "polynomial_names": ["polynomial 1", "polynomial 2"]
            }
          ]
        },
        "observable_expressions": {
          "type": "array",
          "description": "*This field is required to express observables as functions of polynomials. It requires the simultaneous presence of `metadata.polynomial_names` and `data.polynomial_central`.*\n\nDefines how each observable is constructed from the named polynomials. Must be an array of $M$ objects, one per observable. The length and order of the array must match those of the `observable_names` field. Each object must contain:",
          "minItems": 1,
          "items": {
            "type": "object",
            "properties": {
              "variables": {
                "type": "object",
                "minProperties": 1,
                "propertyNames": { "minLength": 1 },
                "additionalProperties": {
                  "type": "string",
                  "minLength": 1
                },
                "description": "An object where each key is a string that is a Python-compatible variable name (used as variable in the `expression` field described below), and each value is a string identifying a polynomial name from `polynomial_names`. For example, `{\"num\": \"polynomial 1\", \"den\": \"polynomial 2\"}`."
              },
              "expression": {
                "type": "string",
                "minLength": 1,
                "description": "A Python-compatible mathematical expression using the variable names defined in `variables`, e.g. `\"num/den\"`. Standard mathematical functions like `sqrt` or `cos` that are implemented in packages like `numpy` may be used."
              }
            },
            "required": ["variables", "expression"],
            "additionalProperties": false
          },
          "examples": [
            {
              "observable_expressions": [
                {
                  "variables": { "num": "polynomial 1", "den": "polynomial 2" },
                  "expression": "num / den"
                },
                {
                  "variables": { "num": "polynomial 2", "den": "polynomial 1" },
                  "expression": "num / den"
                },
                {
                  "variables": { "p1": "polynomial 1" },
                  "expression": "sqrt(p1**2)"
                }
              ]
            }
          ]
        },
        "scale": {
          "oneOf": [
            { "type": "number" },
            {
              "type": "array",
              "minItems": 1,
              "items": { "type": "number" }
            }
          ],
          "description": "The renormalisation scale in GeV at which the parameter vector $\\vec{C}$, the polynomial coefficients ${\\vec{p}_k \\supset \\vec{b}_k, \\vec{c}_k, ...}$, and the observable coefficients ${\\vec{o}_m \\supset \\vec{b}_m, \\vec{c}_m, ...}$ and their uncertainties $\\vec{\\sigma}_m$ are defined. The parameter vector $\\vec{C}$ that enters a given polynomial $P_k$ or observable $O_m$ has to be given at the same scale at which the polynomial coefficients $\\vec{p}_k$ or observable coefficients $\\vec{o}_m$ are defined, such that the polynomial or observable itself is scale-independent up to higher-order corrections in perturbation theory.\n\nThis field can take one of two forms:\n\n- **single number**: A common scale $\\mu$ at which all polynomial coefficients $\\vec p_k$ or observable coefficients $\\vec o_m$ are defined.\n\n  - If the observables $O_m$ are expressed in terms of polynomials $P_k$, the polynomials are functions of the parameters evolved to the common scale $\\mu$:\n\n    $$P_k = a_{k} + \\vec{C}(\\mu) \\cdot \\vec{b}_{k}(\\mu) + \\dots\\ $$\n\n  - If the observables $O_m$ are themselves polynomials, they are themselves functions of the parameters evolved to the common scale $\\mu$:\n\n    $$O_m = a_m + \\vec{C}(\\mu) \\cdot \\vec{b}_m(\\mu) + \\dots\\ $$\n\n- **array of numbers**: An array defining separate scales $\\mu_k$ of polynomial coefficients $\\vec p_k$  if `metadata.polynomial_names` is present, or separate scales $\\mu_m$ of observable coefficients $\\vec o_m$ if `metadata.polynomial_names` is absent.\n\n  - If `metadata.polynomial_names` is present, the observables $O_m$ are expressed in terms of polynomials $P_k$ and each polynomial is a function of the parameters evolved to its corresponding scale $\\mu_k$:\n\n    $$P_k = a_{k} + \\vec{C}(\\mu_k) \\cdot \\vec{b}_{k}(\\mu_k) + \\dots\\ $$\n\n    The length and order of the array defining the scales $\\mu_k$ must match those of the field `metadata.polynomial_names`. To avoid ambiguities, the following restrictions apply to this case:\n\n    - `data.observable_central` must be absent;\n    - `data.observable_uncertainties` must be absent or only define uncertainties for the parameter-independent terms (i.e. only the SM uncertainties in EFT applications).\n  - If `metadata.polynomial_names` is absent, the observables $O_m$ are themselves polynomials and each observable is a function of the parameters evolved to its corresponding scale $\\mu_m$:\n\n    $$O_m = a_m + \\vec{C}(\\mu_m) \\cdot \\vec{b}_m(\\mu_m) + \\dots\\ $$\n\n    The length and order of the array defining the scales $\\mu_m$ must match those of the field `metadata.observable_names`.",
          "examples": [
            {
              "scale": 91.1876
            },
            {
              "scale": [100.0, 200.0, 300.0, 400.0, 500.0]
            }
          ]
        },
        "polynomial_degree": {
          "type": "integer",
          "enum": [1, 2, 3, 4, 5],
          "description": "Specifies the maximum degree of polynomial terms included in the expansion. If omitted, the default value is 2 (i.e., quadratic polynomial). Values higher than 2 may be used to represent observables involving higher-order terms in the model parameters. The current implementation of the `JSON` schema defining the data format supports values up to 5. Higher degrees are not prohibited in principle but are currently unsupported to avoid excessively large data structures.",
          "examples": [
            {
              "polynomial_degree": 2
            }
          ]
        },
        "reproducibility": {
          "type": "array",
          "minItems": 1,
          "description": "Collects relevant data that may be required by a third party to reproduce the prediction. Each element of the array should be an object that corresponds to a step in the workflow and has three predefined fields: `description`, `tool` and `inputs`, specified below. In addition, any additional fields containing data deemed useful in this context can be included.\n\nSchematic example:\n\n```json\n  \"reproducibility\": [\n    {\n      \"description\": \"Description of the first step\",\n      \"tool\": { ... },\n      \"inputs\": { ... }\n    },\n    {\n      \"description\": \"Description of the second step\",\n      \"tool\": { ... },\n      \"inputs\": { ... }\n    },\n    ...\n  ]\n```\nThe predefined fields are as follows:",
          "items": {
            "type": "object",
            "minProperties": 1,
            "properties": {
              "description": {
                "type": "string",
                "minLength": 1,
                "description": "Free-form text description of the method and tool used in this step of obtaining the predictions."
              },
              "inputs": {
                "type": "object",
                "minProperties": 1,
                "description": "Specifies the numerical values of input parameters used by the tool in producing the numerical values of the polynomial coefficients. Each entry maps an input name (a string) or a group of names (a stringified tuple such as `\"('m1','m2')\"`) to one of the following:",
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "number",
                      "description": "A single number: interpreted as the central value of a single, uncorrelated input parameter without uncertainty;"
                    },
                    {
                      "type": "object",
                      "description": "An object representing a uni- or multi-variate normal distribution describing one or more possibly correlated input parameters with uncertainties. This object can contain the subfields `mean`, `std`, and `corr`. If the key of the object is a stringified tuple of $N$ input names (e.g., `\"('m1','m2')\"` with $N = 2$), describing a group of $N$ possibly correlated input parameters, then `mean` and (if present) `std` must be arrays of length $N$, and (if present) `corr` must be an $N \\times N$ matrix, expressed as an array of $N$ arrays of $N$ numbers. The subfields are defined as follows:",
                      "properties": {
                        "mean": {
                          "description": "central value / mean; a single number for a single input name, or an array of numbers for a group of input names;",
                          "anyOf": [
                            { "type": "number" },
                            {
                              "type": "array",
                              "minItems": 2,
                              "items": { "type": "number" }
                            }
                          ]
                        },
                        "std": {
                          "description": "uncertainty / standard deviation; a single number for a single input name, or an array of numbers for a group of input names;",
                          "anyOf": [
                            { "type": "number" },
                            {
                              "type": "array",
                              "minItems": 2,
                              "items": { "type": "number" }
                            }
                          ]
                        },
                        "corr": {
                          "type": "array",
                          "minItems": 2,
                          "items": {
                            "type": "array",
                            "minItems": 2,
                            "items": { "type": "number" }
                          },
                          "description": "correlation matrix; must only be used if a group of input names is given and requires the presence of `std`."
                        }
                      },
                      "required": ["mean"],
                      "dependencies": {
                        "corr": ["std"]
                      },
                      "additionalProperties": false
                    },
                    {
                      "type": "object",
                      "description": "An object representing an arbitrary user-defined uni- or multi-variate probability distribution describing one or more input parameters. This object contains the following subfields:",
                      "properties": {
                        "distribution_type": {
                          "type": "string",
                          "minLength": 1,
                          "description": "a user-defined name identifying the probability distribution (e.g. `\"uniform\"`);"
                        },
                        "distribution_parameters": {
                          "type": "object",
                          "minProperties": 1,
                          "description": "an object where each key is a user-defined name of a parameter of the probability distribution, and each value is a single number in the univariate case, or an array of numbers or arrays in the multivariate case (e.g. `{\"a\":0, \"b\":1}` for a uniform distribution with boundaries $a$ and $b$).",
                          "additionalProperties": {
                            "anyOf": [
                              { "type": "number" },
                              {
                                "type": "array",
                                "minItems": 2,
                                "items": {
                                  "anyOf": [
                                    { "type": "number" },
                                    {
                                      "type": "array",
                                      "minItems": 2,
                                      "items": { "type": "number" }
                                    }
                                  ]
                                }
                              }
                            ]
                          }
                        },
                        "distribution_description": {
                          "type": "string",
                          "minLength": 1,
                          "description": "Description of the custom distribution implemented, defining the fields in `distribution_parameters`."
                        }
                      },
                      "required": [
                        "distribution_type",
                        "distribution_parameters",
                        "distribution_description"
                      ],
                      "additionalProperties": false
                    }
                  ]
                },
                "examples": [
                  {
                    "description": "In the example below, `\"m1\"` is an input parameter with no associated uncertainty, `\"m2\"` and `\"m3\"` are a pair of input parameters with correlated, Gaussian uncertainties, and `\"m4\"` is a parameter that is uniformly distributed between 0 and 1.",
                    "inputs": {
                      "m1": 1.0,
                      "('m2','m3')": {
                        "mean": [1.0, 2.0],
                        "std": [0.1, 0.1],
                        "corr": [
                          [1.0, 0.3],
                          [0.3, 1.0]
                        ]
                      },
                      "m4": {
                        "distribution_type": "uniform",
                        "distribution_parameters": {
                          "a": 0,
                          "b": 1
                        },
                        "distribution_description": "Uniform distribution with boundaries $a$ and $b$."
                      }
                    }
                  }
                ]
              },
              "tool": {
                "type": "object",
                "description": "Provides free-form information about the tool, software or technique used in a particular step of the workflow. The predefined subfields are `name`, `version`, and `settings`. Any number of additional fields may be included to record or link to supplementary metadata, such as model information/configuration, perturbative order, scale choice, PDF sets, simulation settings, input parameter cards, etc. The predefined subfields are as follows:",
                "properties": {
                  "name": {
                    "type": "string",
                    "minLength": 1,
                    "description": "name of tool, e.g. `\"MadGraph5_aMC@NLO\"`, `\"POWHEG\"`,  `\"SHERPA\"`, `\"WHIZARD\"`, `\"flavio\"`, `\"FeynCalc\"`, `\"analytical calculation\"`, ..."
                  },
                  "version": {
                    "type": "string",
                    "minLength": 1,
                    "description": "version of the tool, e.g. `\"1.2\"`"
                  },
                  "settings": {
                    "type": "object",
                    "minProperties": 1,
                    "description": "object containing information about the tool settings with free-form substructure. For example:\n      - `perturbative_order` (e.g. `\"LO\"`, `\"NLO\"`, `\"NLOQCD\"`, ...)\n      - `PDF`: name, version, and set of the PDF used.\n      - `UFO`: name and version of UFO model used, as well as any other relevant information such as flavor schemes or webpage link.\n      - `scale_choice`: Nominal scale choice employed when computing the predictions. This could be an array of fixed scales or a string describing a dynamical scale choice like `\"dynamical:HT/2\"`. This field is particularly relevant when RGE effects are folded into the prediction, see the description of `metadata.scale` above.\n      - `renormalization_scheme`: details of the renormalization scheme used in the computation.\n      - `covariant_derivative_sign`: sign convention used for the covariant derivative (`\"+\"` or `\"-\"`).\n      - `gamma5_scheme`: scheme used for $\\gamma_5$ in dimensional regularization (`\"BMHV\"`, `\"KKS\"`, ...).\n      - `evanescent`: details of the treatment of evanescent operators, e.g. a reference to the scheme used.\n      - `approximations`: Any relevant approximations used, such as the use of the first leading-logarithmic approximation for RG evolution.\n      - any other relevant settings specific to the tool or calculation."
                  }
                },
                "required": ["name"],
                "examples": [
                  {
                    "tool": {
                      "name": "EFTTool",
                      "version": "1.0.0"
                    }
                  },
                  {
                    "tool": {
                      "name": "MadGraph5_aMC@NLO",
                      "version": "3.6.2",
                      "settings": {
                        "UFO": {
                          "name": "SMEFTUFO",
                          "version": "1.0.0",
                          "webpage": "https://smeftufo.io"
                        },
                        "PDF": {
                          "name": "LHAPDF",
                          "version": "6.5.5",
                          "set": "331700"
                        },
                        "perturbative_order": "NLOQCD",
                        "scale_choice": [91.1876, 125.0]
                      }
                    }
                  },
                  {
                    "tool": {
                      "name": "analytical calculation",
                      "settings": {
                        "gamma5_scheme": "KKS",
                        "covariant_derivative_sign": "-",
                        "renormalization_scheme": "MSbar (WCs), On-shell (mass, aS, aEW)",
                        "evanescent": "https://doi.org/10.1016/0550-3213(90)90223-Z"
                      }
                    }
                  },
                  {
                    "tool": {
                      "name": "RGEtool",
                      "version": "1.0.0",
                      "settings": {
                        "perturbative_order": "one-loop",
                        "method": "evolution matrix formalism"
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "misc": {
          "type": "object",
          "minProperties": 1,
          "description": "Optional free-form metadata for documentation purposes. May include fields such as authorship, contact information, date, description of the observable, information identifying the associated correlation file (e.g. hash value or filename), or external references. The format is unrestricted, allowing any `JSON`-encodable content.",
          "examples": [
            {
              "misc": {
                "author": "John Doe",
                "contact": "john.doe@example.com",
                "description": "Example dataset",
                "URL": "johndoe.com/exampledata",
                "correlation_file": "correlations.json",
                "correlation_file_hash": "AB47BG3F11DA7DCAA5726008BAAFE176"
              }
            }
          ]
        }
      },
      "required": ["observable_names", "basis", "parameters", "scale"],
      "dependencies": {
        "polynomial_names": ["observable_expressions"],
        "observable_expressions": ["polynomial_names"]
      },
      "additionalProperties": false
    },
    "data": {
      "type": "object",
      "title": "`data` Field",
      "description": "The `data` field contains the numerical representation of all polynomial terms, which define the polynomials $P_k$ and observables $O_m$. This information is provided in terms of central values of polynomial coefficients $\\vec{p}_k$ and observable coefficients $\\vec{o}_m$, and uncertainties of observable coefficients $\\vec{\\sigma}_m$.\n\nEach component of $\\vec{o}_m$, $\\vec{p}_k$, and $\\vec{\\sigma}_m$ is labelled by a *monomial key*, written as a stringified tuple of model parameters (e.g., Wilson coefficients) defined in `metadata.parameters`. For example, the key `\"('C1', 'C2')\"` corresponds to the monomial $C_1 C_2$. While the model parameters can be complex numbers, the monomials are defined for the real and imaginary parts of the model parameters (see below) and are therefore strictly real. The format and conventions for monomial keys are as follows:\n\n- Each key is a string representation of a Python-style tuple: a comma-separated array of strings enclosed in parentheses.\n- The length of the tuple is determined by the polynomial degree $d$, as defined by the `metadata` field `polynomial_degree` (default value: $d=2$, i.e. quadratic polynomial, if `polynomial_degree` is omitted). The tuple length equals $d$, unless a real/imaginary tag is included (see below), in which case the length is $d+1$.\n- The first $d$ entries in the tuple are model parameter names, as defined in the `metadata` field `parameters`. These names must be sorted alphabetically to ensure unique monomial keys (assuming the same sorting rules as Python's `sort()` method which sorts alphabetically according to ASCII or UNICODE-value, where all upper-case letters come before all lower-case letters, and shorter strings take precedence). Empty strings `''` are used to represent constant terms (equivalent to $1$) and to pad monomials of lower degree. For example, for a quadratic polynomial in real parameters (see below for how complex parameters are handled):\n  - A constant $1$ is written as `\"('','')\"`,\n  - A linear term $C_1$ is written as `\"('', 'C1')\"`,\n  - A quadratic term $C_1 C_2$ is written as `\"('C1', 'C2')\"`.\n- To handle complex parameters, the tuple may optionally include a real/imaginary tag as its final element. This tag consists of `R` (real) and `I` (imaginary) characters, and its length must match the polynomial degree $d$. It indicates whether each parameter refers to its real or imaginary part. For example:\n  - `\"('', 'C1', 'RI')\"` corresponds to $\\mathrm{Im}(C_1)$;\n  - `\"('C1', 'C2', 'IR')\"` corresponds to $\\mathrm{Im}(C_1)\\mathrm{Re}(C_2)$.\n- If the real/imaginary tag is omitted, the parameters are assumed to be real. For example:\n  - `\"('', 'C1')\"` corresponds to $\\mathrm{Re}(C_1)$;\n  - `\"('C1', 'C2')\"` corresponds to $\\mathrm{Re}(C_1)\\mathrm{Re}(C_2)$.\n\nThese conventions ensure a canonical and unambiguous representation of polynomial terms while offering flexibility in the naming of model parameters. Missing monomials are implicitly treated as having zero coefficients.\n\n The `data` field is a `JSON` object with the following subfields:",
      "properties": {
        "polynomial_central": {
          "type": "object",
          "minProperties": 1,
          "additionalProperties": {
            "type": "array",
            "minItems": 1,
            "items": { "type": "number" }
          },
          "description": "*This field is required to express observables as functions of polynomials. It requires the simultaneous presence of `metadata.polynomial_names` and `metadata.observable_expressions`.*\n\nAn object representing the central values of the polynomial coefficients $\\vec{p}_k$ for each named polynomial $P_k$. Each key must be a monomial key as defined above. Each value must be an array of $K$ numbers whose order matches `metadata.polynomial_names`.",
          "examples": [
            {
              "description": "Specifying two polynomials, $P_k$, given in terms of two complex parameters $C_1$ and $C_2$ as\n\n$$\n\\begin{aligned}\n    P_1 &= 1.0 + 1.2 \\ \\mathrm{Im}(C_1) + 0.8 \\ \\mathrm{Re}(C_1) \\mathrm{Re}(C_2) + 0.5 \\ \\mathrm{Re}(C_1) \\mathrm{Im}(C_2)+ 0.2 \\ \\mathrm{Im}(C_1) \\mathrm{Im}(C_2)\\ , \\\\\n    P_2 &= 1.1 + 1.3 \\ \\mathrm{Im}(C_1)  + 0.85 \\ \\mathrm{Re}(C_1) \\mathrm{Re}(C_2) + 0.55 \\ \\mathrm{Re}(C_1) \\mathrm{Im}(C_2)+ 0.25 \\ \\mathrm{Im}(C_1) \\mathrm{Im}(C_2)\\ .\n\\end{aligned}\n$$",
              "polynomial_central": {
                "('', '', 'RR')": [1.0, 1.1],
                "('', 'C1', 'RI')": [1.2, 1.3],
                "('C1', 'C2', 'RR')": [0.8, 0.85],
                "('C1', 'C2', 'RI')": [0.5, 0.55],
                "('C1', 'C2', 'II')": [0.2, 0.25]
              }
            }
          ]
        },
        "observable_central": {
          "type": "object",
          "minProperties": 1,
          "additionalProperties": {
            "type": "array",
            "minItems": 1,
            "items": { "type": "number" }
          },
          "description": "An object representing the central values of the observable coefficients $\\vec{o}_m$ for each observable<span>&nbsp;</span>$O_m$. In case the observables are not themselves polynomials, the observable coefficients correspond to the polynomial approximation of the observables obtained from a Taylor expansion of the observable expressions defined in `metadata.observable_expressions`. Each key must be a monomial key as defined above. Each value must be an array of $M$ numbers whose order matches `metadata.observable_names`.",
          "examples": [
            {
              "description": "Specifying three observable predictions, $O_{m}$, given in terms of the three real parameters $C_1$, $C_2$, and $C_3$ as\n\n$$\n\\begin{aligned}\n    O_1 &= 1.0 + 1.2 \\ C_1 + 1.4 \\ C_1C_2+ 1.6 \\ C_1C_3\\ , \\\\\n    O_2 &= 1.1 + 1.3 \\ C_1 + 1.5 \\ C_1C_2+ 1.7 \\ C_1C_3\\ , \\\\\n    O_3 &= 2.3 + 0.3\\ C_1 + 0.7 \\ C_1C_2 + 0.5 \\ C_1C_3\\ .\n\\end{aligned}\n$$",
              "observable_central": {
                "('', '')": [1.0, 1.1, 2.3],
                "('', 'C1')": [1.2, 1.3, 0.3],
                "('C1', 'C2')": [1.4, 1.5, 0.7],
                "('C1', 'C3')": [1.6, 1.7, 0.5]
              }
            }
          ]
        },
        "observable_uncertainties": {
          "type": "object",
          "minProperties": 1,
          "description": "An object representing the uncertainties on the observable coefficients $\\vec{\\sigma}_m$ for each observable<span>&nbsp;</span>$O_m$. In case the observables are not themselves polynomials, the observable coefficients correspond to the polynomial approximation of the observables obtained from a Taylor expansion of the observable expressions defined in `metadata.observable_expressions`. The fields specify the nature of quoted uncertainty. In many cases there may only be a single top-level field, `\"total\"`, but multiple fields can be used to specify a breakdown into several sources of uncertainty (e.g., statistical, scale, PDF, ...). To avoid mistakes, the names of the top-level fields must not have the format of a monomial key (i.e., stringified tuples as defined above). The value of each top-level field can either be an object or an array of floats. Objects must have the same structure as `observable_central`, arrays must have length $M$. If instead of an object, an array of floats is specified, it is assumed to correspond to the parameter independent uncertainty only (e.g. the uncertainty on the SM prediction). This would be equivalent to specifying an object containing a single element with the monomial key of the constant term (e.g.&nbsp;`\"('','')\"` for a quadratic polynomial).",
          "additionalProperties": {
            "oneOf": [
              {
                "type": "object",
                "minProperties": 1,
                "additionalProperties": {
                  "type": "array",
                  "minItems": 1,
                  "items": { "type": "number" }
                }
              },
              {
                "type": "array",
                "minItems": 1,
                "items": { "type": "number" }
              }
            ]
          },
          "examples": [
            {
              "observable_uncertainties": {
                "total": {
                  "('', '')": [0.05, 0.06, 0.01],
                  "('', 'C1')": [0.1, 0.12, 0.01],
                  "('C1', 'C2')": [0.02, 0.03, 0.02],
                  "('C1', 'C3')": [0.05, 0.06, 0.01]
                }
              }
            },
            {
              "description": "Specifying only the SM uncertainties:",
              "observable_uncertainties": {
                "total": [0.05, 0.06, 0.01]
              }
            },
            {
              "description": "Specifying an uncertainty breakdown:",
              "observable_uncertainties": {
                "MC_stats": {
                  "('', '')": [0.002, 0.0012, 0.001],
                  "('', 'C1')": [0.001, 0.0015, 0.0001]
                },
                "scale": {
                  "('', '')": [0.04, 0.05, 0.06],
                  "('', 'C1')": [0.1, 0.12, 0.01]
                },
                "PDF": {
                  "('', '')": [0.03, 0.04, 0.05],
                  "('', 'C1')": [0.02, 0.08, 0.01]
                }
              }
            },
            {
              "description": "Specifying a breakdown for SM uncertainties only:",
              "observable_uncertainties": {
                "MC_stats": [0.002, 0.0012, 0.001],
                "scale": [0.04, 0.05, 0.06],
                "PDF": [0.03, 0.04, 0.05]
              }
            }
          ]
        }
      },
      "anyOf": [
        {
          "type": "object",
          "properties": { "observable_central": {} },
          "required": ["observable_central"]
        },
        {
          "type": "object",
          "properties": { "polynomial_central": {} },
          "required": ["polynomial_central"]
        }
      ],
      "additionalProperties": false
    }
  },
  "required": ["$schema", "metadata", "data"],
  "additionalProperties": false,
  "allOf": [
    {
      "if": {
        "properties": {
          "metadata": {
            "type": "object",
            "properties": { "polynomial_names": {} },
            "required": ["polynomial_names"]
          }
        }
      },
      "then": {
        "properties": {
          "data": {
            "type": "object",
            "properties": { "polynomial_central": {} },
            "required": ["polynomial_central"]
          }
        }
      }
    },
    {
      "if": {
        "properties": {
          "data": {
            "type": "object",
            "properties": { "polynomial_central": {} },
            "required": ["polynomial_central"]
          }
        }
      },
      "then": {
        "properties": {
          "metadata": {
            "type": "object",
            "properties": { "polynomial_names": {} },
            "required": ["polynomial_names"]
          }
        }
      }
    },
    {
      "if": {
        "$ref": "#/definitions/conditionScaleArrayPolynomial"
      },
      "then": {
        "properties": {
          "data": {
            "not": {
              "type": "object",
              "properties": { "observable_central": {} },
              "required": ["observable_central"]
            }
          }
        }
      }
    },
    {
      "if": {
        "oneOf": [
          {
            "not": {
              "properties": {
                "metadata": {
                  "type": "object",
                  "properties": { "polynomial_degree": {} },
                  "required": ["polynomial_degree"]
                }
              }
            }
          },
          {
            "properties": {
              "metadata": {
                "type": "object",
                "properties": { "polynomial_degree": { "const": 2 } },
                "required": ["polynomial_degree"]
              }
            }
          }
        ]
      },
      "then": {
        "allOf": [
          {
            "properties": {
              "data": {
                "type": "object",
                "patternProperties": {
                  "^(observable_central|polynomial_central)$": {
                    "$ref": "#/definitions/monomialKeyPatternDeg2"
                  },
                  "^observable_uncertainties$": {
                    "type": "object",
                    "propertyNames": {
                      "not": { "$ref": "#/definitions/stringifiedTuplePattern" }
                    },
                    "additionalProperties": {
                      "oneOf": [
                        { "type": "array", "items": { "type": "number" } },
                        { "$ref": "#/definitions/monomialKeyPatternDeg2" }
                      ]
                    }
                  }
                }
              }
            }
          },
          {
            "if": { "$ref": "#/definitions/conditionScaleArrayPolynomial" },
            "then": {
              "properties": {
                "data": {
                  "type": "object",
                  "properties": {
                    "observable_uncertainties": {
                      "type": "object",
                      "additionalProperties": {
                        "oneOf": [
                          { "type": "array", "items": { "type": "number" } },
                          {
                            "$ref": "#/definitions/monomialKeyPatternConstantDeg2"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      }
    },
    {
      "if": {
        "properties": {
          "metadata": {
            "type": "object",
            "properties": { "polynomial_degree": { "const": 1 } },
            "required": ["polynomial_degree"]
          }
        }
      },
      "then": {
        "allOf": [
          {
            "properties": {
              "data": {
                "type": "object",
                "patternProperties": {
                  "^(observable_central|polynomial_central)$": {
                    "$ref": "#/definitions/monomialKeyPatternDeg1"
                  },
                  "^observable_uncertainties$": {
                    "type": "object",
                    "propertyNames": {
                      "not": { "$ref": "#/definitions/stringifiedTuplePattern" }
                    },
                    "additionalProperties": {
                      "oneOf": [
                        { "type": "array", "items": { "type": "number" } },
                        { "$ref": "#/definitions/monomialKeyPatternDeg1" }
                      ]
                    }
                  }
                }
              }
            }
          },
          {
            "if": { "$ref": "#/definitions/conditionScaleArrayPolynomial" },
            "then": {
              "properties": {
                "data": {
                  "type": "object",
                  "properties": {
                    "observable_uncertainties": {
                      "type": "object",
                      "additionalProperties": {
                        "oneOf": [
                          { "type": "array", "items": { "type": "number" } },
                          {
                            "$ref": "#/definitions/monomialKeyPatternConstantDeg1"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      }
    },
    {
      "if": {
        "properties": {
          "metadata": {
            "type": "object",
            "properties": { "polynomial_degree": { "const": 3 } },
            "required": ["polynomial_degree"]
          }
        }
      },
      "then": {
        "allOf": [
          {
            "properties": {
              "data": {
                "type": "object",
                "patternProperties": {
                  "^(observable_central|polynomial_central)$": {
                    "$ref": "#/definitions/monomialKeyPatternDeg3"
                  },
                  "^observable_uncertainties$": {
                    "type": "object",
                    "propertyNames": {
                      "not": { "$ref": "#/definitions/stringifiedTuplePattern" }
                    },
                    "additionalProperties": {
                      "oneOf": [
                        { "type": "array", "items": { "type": "number" } },
                        { "$ref": "#/definitions/monomialKeyPatternDeg3" }
                      ]
                    }
                  }
                }
              }
            }
          },
          {
            "if": { "$ref": "#/definitions/conditionScaleArrayPolynomial" },
            "then": {
              "properties": {
                "data": {
                  "type": "object",
                  "properties": {
                    "observable_uncertainties": {
                      "type": "object",
                      "additionalProperties": {
                        "oneOf": [
                          { "type": "array", "items": { "type": "number" } },
                          {
                            "$ref": "#/definitions/monomialKeyPatternConstantDeg3"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      }
    },
    {
      "if": {
        "properties": {
          "metadata": {
            "type": "object",
            "properties": { "polynomial_degree": { "const": 4 } },
            "required": ["polynomial_degree"]
          }
        }
      },
      "then": {
        "allOf": [
          {
            "properties": {
              "data": {
                "type": "object",
                "patternProperties": {
                  "^(observable_central|polynomial_central)$": {
                    "$ref": "#/definitions/monomialKeyPatternDeg4"
                  },
                  "^observable_uncertainties$": {
                    "type": "object",
                    "propertyNames": {
                      "not": { "$ref": "#/definitions/stringifiedTuplePattern" }
                    },
                    "additionalProperties": {
                      "oneOf": [
                        { "type": "array", "items": { "type": "number" } },
                        { "$ref": "#/definitions/monomialKeyPatternDeg4" }
                      ]
                    }
                  }
                }
              }
            }
          },
          {
            "if": { "$ref": "#/definitions/conditionScaleArrayPolynomial" },
            "then": {
              "properties": {
                "data": {
                  "type": "object",
                  "properties": {
                    "observable_uncertainties": {
                      "type": "object",
                      "additionalProperties": {
                        "oneOf": [
                          { "type": "array", "items": { "type": "number" } },
                          {
                            "$ref": "#/definitions/monomialKeyPatternConstantDeg4"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      }
    },
    {
      "if": {
        "properties": {
          "metadata": {
            "type": "object",
            "properties": { "polynomial_degree": { "const": 5 } },
            "required": ["polynomial_degree"]
          }
        }
      },
      "then": {
        "allOf": [
          {
            "properties": {
              "data": {
                "type": "object",
                "patternProperties": {
                  "^(observable_central|polynomial_central)$": {
                    "$ref": "#/definitions/monomialKeyPatternDeg5"
                  },
                  "^observable_uncertainties$": {
                    "type": "object",
                    "propertyNames": {
                      "not": { "$ref": "#/definitions/stringifiedTuplePattern" }
                    },
                    "additionalProperties": {
                      "oneOf": [
                        { "type": "array", "items": { "type": "number" } },
                        { "$ref": "#/definitions/monomialKeyPatternDeg5" }
                      ]
                    }
                  }
                }
              }
            }
          },
          {
            "if": { "$ref": "#/definitions/conditionScaleArrayPolynomial" },
            "then": {
              "properties": {
                "data": {
                  "type": "object",
                  "properties": {
                    "observable_uncertainties": {
                      "type": "object",
                      "additionalProperties": {
                        "oneOf": [
                          { "type": "array", "items": { "type": "number" } },
                          {
                            "$ref": "#/definitions/monomialKeyPatternConstantDeg5"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      }
    }
  ]
}
