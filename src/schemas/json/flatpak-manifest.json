{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://www.schemastore.org/flatpak-manifest.json",
  "$comment": "https://docs.flatpak.org/en/latest/flatpak-builder-command-reference.html#flatpak-manifest",
  "title": "flatpak-builder manifest",
  "description": "Configuration manifest for flatpak-builder describing how to build a Flatpak application or runtime",
  "type": "object",
  "definitions": {
    "ignored-prop-custom": {
      "description": "Custom property (ignored by flatpak-builder)"
    },
    "ignored-prop-comment": {
      "description": "Comment property (ignored by flatpak-builder)"
    },
    "ignored-prop-schema": {
      "description": "JSON schema (ignored by flatpak-builder)"
    },
    "build-options": {
      "description": "Object specifying the build environment",
      "type": "object",
      "properties": {
        "cflags": {
          "description": "This is set in the environment variable CFLAGS during the build. Multiple specifications of this (in e.g. per-arch area) are concatenated, separated by spaces",
          "type": "string"
        },
        "cflags-override": {
          "description": "If this is true, clear cflags from previous build options before adding it from these options",
          "type": "boolean"
        },
        "cppflags": {
          "description": "This is set in the environment variable CPPFLAGS during the build. Multiple specifications of this (in e.g. per-arch area) are concatenated, separated by spaces",
          "type": "string"
        },
        "cppflags-override": {
          "description": "If this is true, clear cppflags from previous build options before adding it from these options",
          "type": "boolean"
        },
        "cxxflags": {
          "description": "This is set in the environment variable CXXFLAGS during the build. Multiple specifications of this (in e.g. per-arch area) are concatenated, separated by spaces",
          "type": "string"
        },
        "cxxflags-override": {
          "description": "If this is true, clear cxxflags from previous build options before adding it from these options",
          "type": "boolean"
        },
        "ldflags": {
          "description": "This is set in the environment variable LDFLAGS during the build. Multiple specifications of this (in e.g. per-arch area) are concatenated, separated by spaces",
          "type": "string"
        },
        "ldflags-override": {
          "description": "If this is true, clear ldflags from previous build options before adding it from these options",
          "type": "boolean"
        },
        "prefix": {
          "description": "The build prefix for the modules (defaults to /app for applications and /usr for runtimes)",
          "type": "string"
        },
        "libdir": {
          "description": "The build libdir for the modules (defaults to /app/lib for applications and /usr/lib for runtimes)",
          "type": "string"
        },
        "append-path": {
          "description": "This will get appended to PATH in the build environment (with an leading colon if needed)",
          "type": "string"
        },
        "prepend-path": {
          "description": "This will get prepended to PATH in the build environment (with an trailing colon if needed)",
          "type": "string"
        },
        "append-ld-library-path": {
          "description": "This will get appended to LD_LIBRARY_PATH in the build environment (with an leading colon if needed)",
          "type": "string"
        },
        "prepend-ld-library-path": {
          "description": "This will get prepended to LD_LIBRARY_PATH in the build environment (with an trailing colon if needed)",
          "type": "string"
        },
        "append-pkg-config-path": {
          "description": "This will get appended to PKG_CONFIG_PATH in the build environment (with an leading colon if needed)",
          "type": "string"
        },
        "prepend-pkg-config-path": {
          "description": "This will get prepended to PKG_CONFIG_PATH in the build environment (with an trailing colon if needed)",
          "type": "string"
        },
        "env": {
          "description": "This is a dictionary defining environment variables to be set during the build. Elements in this override the properties that set the environment, like cflags and ldflags. Keys with a null value unset the corresponding variable",
          "type": "object",
          "patternProperties": {
            "^[^=]+$": {
              "description": "An environment variable",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "secret-env": {
          "description": "This is a array defining which host environment variables is transferred to build-commands or post-install environment",
          "type": "array",
          "items": {
            "description": "Host environment variable to transfer",
            "type": "string"
          }
        },
        "build-args": {
          "description": "This is an array containing extra options to pass to flatpak build",
          "type": "array",
          "items": {
            "description": "Extra option to pass to flatpak build",
            "type": "string"
          }
        },
        "test-args": {
          "description": "Similar to build-args but affects the tests, not the normal build",
          "type": "array",
          "items": {
            "description": "Similar to build-arg but affects the tests, not the normal build",
            "type": "string"
          }
        },
        "config-opts": {
          "description": "This is an array containing extra options to pass to configure",
          "type": "array",
          "items": {
            "description": "Extra option to pass to configure",
            "type": "string"
          }
        },
        "secret-opts": {
          "description": "This is an array of options that will be passed to configure, meant to be used to pass secrets through host environment variables. Put the option with an environment variables and will be resolved beforehand. '-DSECRET_ID=$CI_SECRET'",
          "type": "array",
          "items": {
            "description": "Extra option to pass to configure",
            "type": "string"
          }
        },
        "make-args": {
          "description": "An array of extra arguments that will be passed to make",
          "type": "array",
          "items": {
            "description": "Extra argument that will be passed to make",
            "type": "string"
          }
        },
        "make-install-args": {
          "description": "An array of extra arguments that will be passed to make install",
          "type": "array",
          "items": {
            "description": "Extra argument that will be passed to make install",
            "type": "string"
          }
        },
        "strip": {
          "description": "If this is true (the default is false) then all ELF files will be stripped after install",
          "type": "boolean"
        },
        "no-debuginfo": {
          "description": "By default (if strip is not true) flatpak-builder extracts all debug info in ELF files to a separate files and puts this in an extension. If you want to disable this, set no-debuginfo to true",
          "type": "boolean"
        },
        "no-debuginfo-compression": {
          "description": "By default when extracting debuginfo we compress the debug sections. If you want to disable this, set no-debuginfo-compression to true",
          "type": "boolean"
        },
        "arch": {
          "description": "This is a dictionary defining for each arch a separate build options object that override the main one",
          "type": "object",
          "patternProperties": {
            ".*": {
              "$ref": "#/definitions/build-options"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "extension": {
      "description": "Extension define extension points in the app/runtime that can be implemented by extensions, supplying extra files which are available during runtime",
      "type": "object",
      "properties": {
        "directory": {
          "description": "The directory where the extension is mounted. If the extension point is for an application, this path is relative to /app, otherwise it is relative to /usr",
          "type": "string"
        },
        "bundle": {
          "description": "If this is true, then the data created in the extension directory is omitted from the result, and instead packaged in a separate extension",
          "type": "boolean"
        },
        "remove-after-build": {
          "description": "If this is true, the extension is removed when finishing. This is only interesting for extensions in the add-build-extensions property",
          "type": "boolean"
        },
        "autodelete": {
          "description": "Whether to automatically delete extensions matching this extension point when deleting a 'related' application or runtime. Available since 0.6.7",
          "type": "boolean"
        },
        "no-autodownload": {
          "description": "Whether to automatically download extensions matching this extension point when updating or installing a 'related' application or runtime. Available since 0.6.7",
          "type": "boolean"
        },
        "subdirectories": {
          "description": "If this key is set to true, then flatpak will look for extensions whose name is a prefix of the extension point name, and mount them at the corresponding name below the subdirectory. Available since 0.1",
          "type": "boolean"
        },
        "add-ld-path": {
          "description": "A condition that must be true for the extension to be auto-downloaded. As of 1.1.1 this supports multiple conditions separated by semi-colons",
          "type": "string"
        },
        "download-if": {
          "description": "A condition that must be true for the extension to be auto-downloaded",
          "type": "string",
          "anyOf": [
            {
              "enum": ["active-gl-driver", "active-gtk-theme", "have-intel-gpu"]
            },
            {
              "pattern": "^have-kernel-module-.*"
            },
            {
              "pattern": "^on-xdg-desktop-.*"
            }
          ]
        },
        "enable-if": {
          "description": "A condition that must be true for the extension to be enabled. As of 1.1.1 this supports multiple conditions separated by semi-colons",
          "type": "string",
          "anyOf": [
            {
              "enum": ["active-gl-driver", "active-gtk-theme", "have-intel-gpu"]
            },
            {
              "pattern": "^have-kernel-module-.*"
            },
            {
              "pattern": "^on-xdg-desktop-.*"
            }
          ]
        },
        "autoprune-unless": {
          "description": "A condition that must be false for the extension to be considered unused when pruning. For example, flatpak uninstall --unused uses this information",
          "type": "string",
          "anyOf": [
            {
              "enum": ["active-gl-driver", "active-gtk-theme", "have-intel-gpu"]
            },
            {
              "pattern": "^have-kernel-module-.*"
            },
            {
              "pattern": "^on-xdg-desktop-.*"
            }
          ]
        },
        "merge-dirs": {
          "description": "A list of relative paths of directories below the extension point directory that will be merged. Available since 0.9.1, and backported to the 0.8.x branch in 0.8.3",
          "type": "string"
        },
        "subdirectory-suffix": {
          "description": "A suffix that gets appended to the directory name. This is very useful when the extension point naming scheme is reversed. For example, an extension point for GTK+ themes would be /usr/share/themes/$NAME/gtk-3.0, which could be achieved using subdirectory-suffix=gtk-3.0. Available since 0.9.1, and backported to the 0.8.x branch in 0.8.3",
          "type": "string"
        },
        "locale-subset": {
          "description": "If set, then the extensions are partially downloaded by default, based on the currently configured locales. This means that the extension contents should be a set of directories with the language code as name. Available since 0.9.13 (and 0.6.6 for any extensions called *.Locale)",
          "type": "boolean"
        },
        "version": {
          "description": "The branch to use when looking for the extension. If this is not specified, it defaults to the branch of the application or runtime that the extension point is for. Available since 0.4.1",
          "type": "string"
        },
        "versions": {
          "description": "The branches to use when looking for the extension. If this is not specified, it defaults to the branch of the application or runtime that the extension point is for. Available since 0.9.1, and backported to the 0.8.x branch in 0.8.4",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "module": {
      "description": "Each module specifies a source that has to be separately built and installed. It contains the build options and a list of sources to download and extract before building. Modules can be nested, in order to turn related modules on and off with a single key",
      "type": "object",
      "properties": {
        "name": {
          "description": "The name of the module, used in e.g. build logs. The name is also used for constructing filenames and commandline arguments, therefore using spaces or '/' in this string is a bad idea",
          "type": "string"
        },
        "disabled": {
          "description": "If true, skip this module",
          "type": "boolean"
        },
        "sources": {
          "description": "An array of objects defining sources that will be downloaded and extracted in order. String members in the array are interpreted as the name of a separate json or yaml file that contains sources",
          "type": "array",
          "items": {
            "if": {
              "type": "object"
            },
            "then": {
              "$ref": "#/definitions/source"
            },
            "else": {
              "type": "string",
              "description": "Name of a separate json or yaml file that contains sources"
            }
          }
        },
        "config-opts": {
          "description": "An array of options that will be passed to configure",
          "type": "array",
          "items": {
            "description": "Option that will be passed to configure",
            "type": "string"
          }
        },
        "secret-opts": {
          "description": "An array of options that will be passed to configure, meant to be used to pass secrets through host environment variables. Put the option with an environment variables and will be resolved beforehand. '-DSECRET_ID=$CI_SECRET'",
          "type": "array",
          "items": {
            "description": "Extra option to pass to configure",
            "type": "string"
          }
        },
        "make-args": {
          "description": "An array of arguments that will be passed to make",
          "type": "array",
          "items": {
            "description": "Argument that will be passed to make",
            "type": "string"
          }
        },
        "make-install-args": {
          "description": "An array of arguments that will be passed to make install",
          "type": "array",
          "items": {
            "description": "Argument that will be passed to make install",
            "type": "string"
          }
        },
        "rm-configure": {
          "description": "If true, remove the configure script before starting build",
          "type": "boolean"
        },
        "no-autogen": {
          "description": "Ignore the existence of an autogen script",
          "type": "boolean"
        },
        "no-parallel-make": {
          "description": "Don't call make with arguments to build in parallel",
          "type": "boolean"
        },
        "install-rule": {
          "description": "Name of the rule passed to make for the install phase, default is install",
          "type": "string"
        },
        "no-make-install": {
          "description": "Don't run the make install (or equivalent) stage",
          "type": "boolean"
        },
        "no-python-timestamp-fix": {
          "description": "Don't fix up the *.py[oc] header timestamps for ostree use",
          "type": "boolean"
        },
        "cmake": {
          "description": "Use cmake instead of configure (deprecated: use buildsystem instead)",
          "type": "boolean"
        },
        "buildsystem": {
          "description": "Build system to use: autotools, cmake, cmake-ninja, meson, simple, qmake",
          "enum": [
            "autotools",
            "cmake",
            "cmake-ninja",
            "meson",
            "simple",
            "qmake"
          ]
        },
        "builddir": {
          "description": "Use a build directory that is separate from the source directory",
          "type": "boolean"
        },
        "subdir": {
          "description": "Build inside this subdirectory of the extracted sources",
          "type": "string"
        },
        "build-options": {
          "$ref": "#/definitions/build-options"
        },
        "build-commands": {
          "description": "An array of commands to run during build (between make and make install if those are used). This is primarily useful when using the simple buildsystem. Each command is run in /bin/sh -c, so it can use standard POSIX shell syntax such as piping output",
          "type": "array",
          "items": {
            "description": "Command to run during build (between make and make install if those are used). This is primarily useful when using the simple buildsystem. Each command is run in /bin/sh -c, so it can use standard POSIX shell syntax such as piping output",
            "type": "string"
          }
        },
        "post-install": {
          "description": "An array of shell commands that are run after the install phase. Can for example clean up the install dir, or install extra files",
          "type": "array",
          "items": {
            "description": "Shell command that is run after the install phase. Can for example clean up the install dir, or install extra files",
            "type": "string"
          }
        },
        "cleanup": {
          "description": "An array of file patterns that should be removed at the end. Patterns starting with / are taken to be full pathnames (without the /app prefix), otherwise they just match the basename. Note that any patterns will only match files installed by this module",
          "type": "array",
          "items": {
            "description": "File pattern that should be removed at the end. Patterns starting with / are taken to be full pathnames (without the /app prefix), otherwise they just match the basename. Note that any patterns will only match files installed by this module",
            "type": "string"
          }
        },
        "ensure-writable": {
          "description": "The way the builder works is that files in the install directory are hard-links to the cached files, so you're not allowed to modify them in-place. If you list a file in this then the hardlink will be broken and you can modify it. This is a workaround, ideally installing files should replace files, not modify existing ones",
          "type": "array",
          "items": {
            "description": "The way the builder works is that files in the install directory are hard-links to the cached files, so you're not allowed to modify them in-place. If you list a file in this then the hardlink will be broken and you can modify it. This is a workaround, ideally installing files should replace files, not modify existing ones",
            "type": "string"
          }
        },
        "only-arches": {
          "description": "If non-empty, only build the module on the arches listed",
          "type": "array",
          "items": {
            "description": "If non-empty, only build the module on the arches listed",
            "type": "string"
          }
        },
        "skip-arches": {
          "description": "Don't build on any of the arches listed",
          "type": "array",
          "items": {
            "description": "Don't build on any of the arches listed",
            "type": "string"
          }
        },
        "cleanup-platform": {
          "description": "Extra files to clean up in the platform",
          "type": "array",
          "items": {
            "description": "Extra file to clean up in the platform",
            "type": "string"
          }
        },
        "run-tests": {
          "description": "If true this will run the tests after installing",
          "type": "boolean"
        },
        "test-rule": {
          "description": "The target to build when running the tests. Defaults to 'check' for make and 'test' for ninja. Set to empty to disable",
          "type": "string"
        },
        "test-commands": {
          "description": "Array of commands to run during the tests",
          "type": "array",
          "items": {
            "description": "Command to run during the tests",
            "type": "string"
          }
        },
        "license-files": {
          "description": "Array of paths to LICENSE files of the module",
          "type": "array",
          "items": {
            "description": "LICENSE file of the module",
            "type": "string"
          }
        },
        "modules": {
          "description": "An array of objects specifying the modules to be built in order. String members in the array are interpreted as the name of a separate json or yaml file that contains a module",
          "type": "array",
          "items": {
            "if": {
              "type": "object"
            },
            "then": {
              "$ref": "#/definitions/module"
            },
            "else": {
              "type": "string",
              "description": "Name of a separate json or yaml file that contains a module"
            }
          }
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "required": ["name"],
      "additionalProperties": false
    },
    "source": {
      "description": "These contain a pointer to the source that will be extracted into the source directory before the build starts. They can be of several types, distinguished by the type property. Additionally, the sources list can contain a plain string, which is interpreted as the name of a separate json or yaml file that is read and inserted at this point. The file can contain a single source, or an array of sources",
      "type": "object",
      "if": {
        "properties": {
          "type": {
            "const": "extra-data"
          }
        }
      },
      "then": {
        "$ref": "#/definitions/source-extra-data"
      },
      "properties": {
        "only-arches": {
          "description": "If non-empty, only build the module on the arches listed",
          "type": "array",
          "items": {
            "description": "If non-empty, only build the module on the arches listed",
            "type": "string"
          }
        },
        "skip-arches": {
          "description": "Don't build on any of the arches listed",
          "type": "array",
          "items": {
            "description": "Don't build on this arch",
            "type": "string"
          }
        },
        "dest": {
          "description": "Directory inside the source dir where this source will be extracted",
          "type": "string"
        },
        "type": {
          "description": "Type of the source",
          "enum": [
            "archive",
            "git",
            "bzr",
            "svn",
            "dir",
            "file",
            "script",
            "inline",
            "shell",
            "patch",
            "extra-data"
          ]
        }
      },
      "required": ["type"],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "archive"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-archive"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "git"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-git"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "bzr"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-bzr"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "svn"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-svn"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "dir"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-dir"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "file"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-file"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "script"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-script"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "inline"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-inline"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "shell"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-shell"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "patch"
              }
            }
          },
          "then": {
            "$ref": "#/definitions/source-patch"
          }
        }
      ]
    },
    "source-archive": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "path": {
          "description": "The path of the archive",
          "type": "string"
        },
        "url": {
          "description": "The URL of a remote archive that will be downloaded. This overrides path if both are specified",
          "type": "string"
        },
        "mirror-urls": {
          "description": "A list of alternative urls that are used if the main url fails",
          "type": "array",
          "items": {
            "description": "Alternative url that is used if the main url fails",
            "type": "string"
          }
        },
        "referer": {
          "description": "Sets the HTTP \"Referer\" header when downloading the archive",
          "type": "string"
        },
        "disable-http-decompression": {
          "description": "Disables decompression of downloads over HTTP for misconfigured servers",
          "type": "boolean"
        },
        "archive-type": {
          "description": "The type of archive if it cannot be guessed from the path",
          "enum": [
            "rpm",
            "tar",
            "tar-gzip",
            "tar-compress",
            "tar-bzip2",
            "tar-lzip",
            "tar-lzma",
            "tar-lzop",
            "tar-xz",
            "tar-zst",
            "zip",
            "7z"
          ]
        },
        "git-init": {
          "description": "Whether to initialise the repository as a git repository",
          "type": "boolean"
        },
        "md5": {
          "description": "The md5 checksum of the file, verified after download. Note that md5 is no longer considered a safe checksum, we recommend you use at least sha256",
          "type": "string"
        },
        "sha1": {
          "description": "The sha1 checksum of the file, verified after download. Note that sha1 is no longer considered a safe checksum, we recommend you use at least sha256",
          "type": "string"
        },
        "sha256": {
          "description": "The sha256 checksum of the file, verified after download",
          "type": "string"
        },
        "sha512": {
          "description": "The sha512 checksum of the file, verified after download",
          "type": "string"
        },
        "strip-components": {
          "description": "The number of initial pathname components to strip during extraction. Defaults to 1",
          "type": "integer"
        },
        "dest-filename": {
          "description": "Filename to for the downloaded file, defaults to the basename of url",
          "type": "string"
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "oneOf": [
        {
          "required": ["url"]
        },
        {
          "required": ["path"]
        }
      ],
      "dependencies": {
        "url": {
          "anyOf": [
            {
              "required": ["sha256"],
              "properties": {
                "sha256": true
              }
            },
            {
              "required": ["sha512"],
              "properties": {
                "sha512": true
              }
            },
            {
              "required": ["sha1"],
              "properties": {
                "sha1": true
              }
            },
            {
              "required": ["md5"],
              "properties": {
                "md5": true
              }
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "source-git": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "path": {
          "description": "The path to a local checkout of the git repository. Due to how git-clone works, this will be much faster than specifying a URL of file:///",
          "type": "string"
        },
        "url": {
          "description": "URL of the git repository. This overrides path if both are specified. When using git via SSH, the correct syntax is ssh://user@domain/path/to/repo.git",
          "type": "string"
        },
        "branch": {
          "description": "The branch to use from the git repository",
          "type": "string"
        },
        "tag": {
          "description": "The tag to use from the git repository",
          "type": "string"
        },
        "commit": {
          "description": "The commit to use from the git repository. If branch is also specified, then it is verified that the branch/tag is at this specific commit. This is a readable way to document that you're using a particular tag, but verify that it does not change",
          "type": "string"
        },
        "disable-fsckobjects": {
          "description": "Don't use transfer.fsckObjects=1 to mirror git repository. This may be needed for some (broken) repositories",
          "type": "boolean"
        },
        "disable-shallow-clone": {
          "description": "Don't optimize by making a shallow clone when downloading the git repo",
          "type": "boolean"
        },
        "disable-submodules": {
          "description": "Don't checkout the git submodules when cloning the repository",
          "type": "boolean"
        },
        "disable-lfs": {
          "description": "Don't explicitly fetch or checkout LFS git objects",
          "type": "boolean"
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "oneOf": [
        {
          "required": ["url"]
        },
        {
          "required": ["path"]
        }
      ],
      "additionalProperties": false
    },
    "source-bzr": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "url": {
          "description": "URL of the bzr repository",
          "type": "string"
        },
        "branch": {
          "description": "A specific revision to use in the branch",
          "type": "string"
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "required": ["url"],
      "additionalProperties": false
    },
    "source-svn": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "url": {
          "description": "URL of the svn repository, including branch/tag part",
          "type": "string"
        },
        "revision": {
          "description": "A specific revision number to use",
          "type": "string"
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "required": ["url"],
      "additionalProperties": false
    },
    "source-dir": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "path": {
          "description": "The path of a local directory whose content will be copied into the source dir. Note that directory sources don't currently support caching, so they will be rebuilt each time",
          "type": "string"
        },
        "skip": {
          "description": "Source files to ignore in the directory",
          "type": "array",
          "items": {
            "description": "Source file to ignore in the directory",
            "type": "string"
          }
        }
      },
      "required": ["path"],
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "additionalProperties": false
    },
    "source-file": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "path": {
          "description": "The path of a local file that will be copied into the source dir",
          "type": "string"
        },
        "url": {
          "description": "The URL of a remote file that will be downloaded and copied into the source dir. This overrides path if both are specified",
          "type": "string"
        },
        "referer": {
          "description": "Sets the HTTP \"Referer\" header when downloading the file",
          "type": "string"
        },
        "disable-http-decompression": {
          "description": "Disables decompression of downloads over HTTP for misconfigured servers",
          "type": "boolean"
        },
        "mirror-urls": {
          "description": "A list of alternative urls that are used if the main url fails",
          "type": "array",
          "items": {
            "description": "Alternative url that is used if the main url fails",
            "type": "string"
          }
        },
        "md5": {
          "description": "The md5 checksum of the file, verified after download. Note that md5 is no longer considered a safe checksum, we recommend you use at least sha256",
          "type": "string"
        },
        "sha1": {
          "description": "The sha1 checksum of the file, verified after download. Note that sha1 is no longer considered a safe checksum, we recommend you use at least sha256",
          "type": "string"
        },
        "sha256": {
          "description": "The sha256 checksum of the file, verified after download",
          "type": "string"
        },
        "sha512": {
          "description": "The sha512 checksum of the file, verified after download",
          "type": "string"
        },
        "dest-filename": {
          "description": "Filename to for the downloaded file, defaults to the basename of url",
          "type": "string"
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "oneOf": [
        {
          "required": ["url"]
        },
        {
          "required": ["path"]
        }
      ],
      "dependencies": {
        "url": {
          "anyOf": [
            {
              "required": ["sha256"],
              "properties": {
                "sha256": true
              }
            },
            {
              "required": ["sha512"],
              "properties": {
                "sha512": true
              }
            },
            {
              "required": ["sha1"],
              "properties": {
                "sha1": true
              }
            },
            {
              "required": ["md5"],
              "properties": {
                "md5": true
              }
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "source-script": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "commands": {
          "description": "An array of shell commands that will be put in a shellscript file",
          "type": "array",
          "items": {
            "description": "Shell command that will be put in a shellscript file",
            "type": "string"
          }
        },
        "dest-filename": {
          "description": "Filename to use inside the source dir, default to autogen.sh",
          "type": "string"
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "required": ["commands"],
      "additionalProperties": false
    },
    "source-inline": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "dest-filename": {
          "description": "Filename to use inside the source dir",
          "type": "string"
        },
        "contents": {
          "description": "Text data that will be put in the file",
          "type": "string"
        },
        "base64": {
          "description": "Whether content is base64-encoded",
          "type": "boolean"
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "required": ["dest-filename"],
      "additionalProperties": false
    },
    "source-shell": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "commands": {
          "description": "An array of shell commands that will be run during source extraction",
          "type": "array",
          "items": {
            "description": "Shell command that will be run during source extraction",
            "type": "string"
          }
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "required": ["commands"],
      "additionalProperties": false
    },
    "source-patch": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "path": {
          "description": "The path of a patch file that will be applied in the source dir",
          "type": "string"
        },
        "paths": {
          "description": "An list of paths to patch files that will be applied in the source dir, in order",
          "type": "array",
          "items": {
            "description": "Path to a patch file that will be applied in the source dir",
            "type": "string"
          }
        },
        "strip-components": {
          "description": "The value of the -p argument to patch, defaults to 1",
          "type": "integer"
        },
        "use-git": {
          "description": "Whether to use 'git apply' rather than 'patch' to apply the patch, required when the patch file contains binary diffs",
          "type": "boolean"
        },
        "use-git-am": {
          "description": "Whether to use 'git am' rather than 'patch' to apply the patch, required when the patch file contains binary diffs. You cannot use this at the same time as use-git",
          "type": "boolean"
        },
        "options": {
          "description": "Extra options to pass to the patch command",
          "type": "array",
          "items": {
            "description": "Extra option to pass to the patch command",
            "type": "string"
          }
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "oneOf": [
        {
          "required": ["paths"]
        },
        {
          "required": ["path"]
        }
      ],
      "additionalProperties": false
    },
    "source-extra-data": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/source/properties/type"
        },
        "only-arches": {
          "$ref": "#/definitions/source/properties/only-arches"
        },
        "skip-arches": {
          "$ref": "#/definitions/source/properties/skip-arches"
        },
        "dest": {
          "$ref": "#/definitions/source/properties/dest"
        },
        "filename": {
          "description": "The name to use for the downloaded extra data",
          "type": "string"
        },
        "url": {
          "description": "The url to the extra data",
          "type": "string"
        },
        "sha256": {
          "description": "The sha256 of the extra data",
          "type": "string"
        },
        "size": {
          "description": "The size of the extra data",
          "type": "number"
        },
        "installed-size": {
          "description": "The extra installed size this adds to the app (optional)",
          "type": "number"
        }
      },
      "patternProperties": {
        "^x-.*": {
          "$ref": "#/definitions/ignored-prop-custom"
        },
        "^//.*": {
          "$ref": "#/definitions/ignored-prop-comment"
        }
      },
      "required": ["url", "sha256", "size", "filename"],
      "additionalProperties": false
    }
  },
  "properties": {
    "app-id": {
      "description": "A string defining the application id",
      "type": "string"
    },
    "id": {
      "description": "A string defining the application id",
      "type": "string"
    },
    "branch": {
      "description": "The branch to use when exporting the application. If this is unset the defaults come from the default-branch option",
      "type": "string"
    },
    "default-branch": {
      "description": "The default branch to use when exporting the application. Defaults to master. This key can be overridden by the --default-branch commandline option",
      "type": "string"
    },
    "collection-id": {
      "description": "The collection ID of the repository, defaults to being unset. Setting a globally unique collection ID allows the apps in the repository to be shared over peer to peer systems without needing further configuration. If building in an existing repository, the collection ID must match the existing configured collection ID for that repository",
      "type": "string"
    },
    "extension-tag": {
      "description": "If building an extension, the tag for the extension point to use. Since flatpak 0.11.4 a runtime may define multiple locations for the same extension point with the intention that different branches for the extension are mounted at each location. When building an extension it is necessary to know what extension point to install the extension to. This option resolves any ambiguity in which extension point to choose. If not specified, the default choice is to install into either the only location for the extension point or into the location for the untagged extension point. If there are multiple locations for the same extension point defined with different tags then an error will occur",
      "type": "string"
    },
    "runtime": {
      "description": "The name of the runtime that the application uses",
      "type": "string"
    },
    "runtime-version": {
      "description": "The version of the runtime that the application uses, defaults to master",
      "type": "string"
    },
    "sdk": {
      "description": "The name of the development runtime that the application builds with",
      "type": "string"
    },
    "var": {
      "description": "Initialize the (otherwise empty) writable /var in the build with a copy of this runtime",
      "type": "string"
    },
    "metadata": {
      "description": "Use this file as the base metadata file when finishing",
      "type": "string"
    },
    "command": {
      "description": "The filename or path to the main binary of the application. Note that this is really just a single file, not a commandline. If you want to pass arguments, install a shell script wrapper and use that as the command. Also note that the command is used when the application is run via flatpak run, and does not affect what gets executed when the application is run in other ways, e.g. via the desktop file or D-Bus activation",
      "type": "string"
    },
    "build-runtime": {
      "description": "Build a new runtime instead of an application",
      "type": "boolean"
    },
    "build-extension": {
      "description": "Build an extension",
      "type": "boolean"
    },
    "separate-locales": {
      "description": "Separate out locale files and translations to an extension runtime. Defaults to true",
      "type": "boolean"
    },
    "id-platform": {
      "description": "When building a runtime sdk, also create a platform based on it with this id",
      "type": "string"
    },
    "metadata-platform": {
      "description": "The metadata file to use for the platform we create",
      "type": "string"
    },
    "writable-sdk": {
      "description": "If true, use a writable copy of the sdk for /usr. Defaults to true if build-runtime is specified",
      "type": "boolean"
    },
    "appstream-compose": {
      "description": "Run appstream-compose during cleanup phase. Defaults to true",
      "type": "boolean"
    },
    "sdk-extensions": {
      "description": "Install these extra sdk extensions in /usr",
      "type": "array",
      "items": {
        "description": "Install this extra sdk extension in /usr",
        "type": "string"
      }
    },
    "platform-extensions": {
      "description": "Install these extra sdk extensions when creating the platform",
      "type": "array",
      "items": {
        "description": "Install this extra sdk extension when creating the platform",
        "type": "string"
      }
    },
    "base": {
      "description": "Start with the files from the specified application. This can be used to create applications that extend another application",
      "type": "string"
    },
    "base-version": {
      "description": "Use this specific version of the application specified in base. If unspecified, this uses the value specified in branch",
      "type": "string"
    },
    "base-extensions": {
      "description": "Install these extra extensions from the base application when initializing the application directory",
      "type": "array",
      "items": {
        "description": "Install this extra extension from the base application when initializing the application directory",
        "type": "string"
      }
    },
    "inherit-extensions": {
      "description": "Inherit these extra extension points from the base application or sdk when finishing the build",
      "type": "array",
      "items": {
        "description": "Inherit this extra extension point from the base application or sdk when finishing the build",
        "type": "string"
      }
    },
    "inherit-sdk-extensions": {
      "description": "Inherit these extra extension points from the base application or sdk when finishing the build, but do not inherit them into the platform",
      "type": "array",
      "items": {
        "description": "Inherit this extra extension point from the base application or sdk when finishing the build, but do not inherit into the platform",
        "type": "string"
      }
    },
    "tags": {
      "description": "Add these tags to the metadata file",
      "type": "array",
      "items": {
        "description": "Add this tag to the metadata file",
        "type": "string"
      }
    },
    "build-options": {
      "$ref": "#/definitions/build-options"
    },
    "modules": {
      "$ref": "#/definitions/module/properties/modules"
    },
    "add-extensions": {
      "description": "This is a dictionary of extension objects. The key is the name of the extension",
      "type": "object",
      "patternProperties": {
        ".*": {
          "$ref": "#/definitions/extension"
        }
      },
      "additionalProperties": false
    },
    "add-build-extensions": {
      "description": "This is a dictionary of extension objects similar to add-extensions. The main difference is that the extensions are added early and are available for use during the build",
      "type": "object",
      "patternProperties": {
        ".*": {
          "$ref": "#/definitions/extension"
        }
      },
      "additionalProperties": false
    },
    "cleanup": {
      "description": "An array of file patterns that should be removed at the end. Patterns starting with / are taken to be full pathnames (without the /app prefix), otherwise they just match the basename",
      "type": "array",
      "items": {
        "description": "File pattern that should be removed at the end. Patterns starting with / are taken to be full pathnames (without the /app prefix), otherwise they just match the basename",
        "type": "string"
      }
    },
    "cleanup-commands": {
      "description": "An array of commandlines that are run during the cleanup phase",
      "type": "array",
      "items": {
        "description": "Commandline that is run during the cleanup phase",
        "type": "string"
      }
    },
    "cleanup-platform": {
      "description": "Extra files to clean up in the platform",
      "type": "array",
      "items": {
        "description": "Extra file to clean up in the platform",
        "type": "string"
      }
    },
    "cleanup-platform-commands": {
      "description": "An array of commandlines that are run during the cleanup phase of the platform",
      "type": "array",
      "items": {
        "description": "Commandline that is run during the cleanup phase of the platform",
        "type": "string"
      }
    },
    "prepare-platform-commands": {
      "description": "An array of commandlines that are run after importing the base platform, but before applying the new files from the sdk. This is a good place to e.g. delete things from the base that may conflict with the files added in the sdk",
      "type": "array",
      "items": {
        "description": "Commandline that is run after importing the base platform, but before applying the new files from the sdk. This is a good place to e.g. delete things from the base that may conflict with the files added in the sdk",
        "type": "string"
      }
    },
    "finish-args": {
      "description": "An array of arguments passed to the flatpak build-finish command",
      "type": "array",
      "items": {
        "description": "Argument passed to the flatpak build-finish command",
        "type": "string"
      }
    },
    "rename-desktop-file": {
      "description": "Any desktop file with this name will be renamed to a name based on id during the cleanup phase",
      "type": "string"
    },
    "rename-appdata-file": {
      "description": "Any appdata (metainfo) file with this name will be renamed to a name based on id during the cleanup phase",
      "type": "string"
    },
    "rename-mime-file": {
      "description": "Any mimetypes file with this name will me renamed to a name based on id during the cleanup phase",
      "type": "string"
    },
    "rename-icon": {
      "description": "Any icon with this name will be renamed to a name based on id during the cleanup phase. Note that this is the icon name, not the full filenames, so it should not include a filename extension",
      "type": "string"
    },
    "rename-mime-icons": {
      "type": "array",
      "description": "Any mime icons with any of these names will be renamed to a name prefixed with id during the cleanup phase. Note that this is the icon name, not the full filenames, so it should not include a filename extension",
      "items": {
        "description": "Icon name to rename",
        "type": "string"
      }
    },
    "appdata-license": {
      "description": "Replace the appdata (metainfo) project_license field with this string. This is useful as the upstream license is typically only about the application itself, whereas the bundled app can contain other licenses too",
      "type": "string"
    },
    "copy-icon": {
      "description": "If rename-icon is set, keep a copy of the old icon file",
      "type": "boolean"
    },
    "desktop-file-name-prefix": {
      "description": "This string will be prefixed to the Name key in the main application desktop file",
      "type": "string"
    },
    "desktop-file-name-suffix": {
      "description": "This string will be suffixed to the Name key in the main application desktop file",
      "type": "string"
    }
  },
  "patternProperties": {
    "^x-.*": {
      "$ref": "#/definitions/ignored-prop-custom"
    },
    "^//.*": {
      "$ref": "#/definitions/ignored-prop-comment"
    },
    "^\\$schema$": {
      "$ref": "#/definitions/ignored-prop-schema"
    }
  },
  "required": ["runtime", "sdk"],
  "oneOf": [
    {
      "required": ["id"]
    },
    {
      "required": ["app-id"]
    }
  ],
  "additionalProperties": false
}
