{
  "$id": "https://json.schemastore.org/prometheus.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "additionalProperties": false,
  "definitions": {
    "auth": {
      "allOf": [
        {
          "if": {
            "not": {
              "properties": {
                "basic_auth": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "authorization": {
                "const": null
              },
              "bearer_token": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              },
              "oauth2": {
                "const": null
              },
              "sigv4": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "authorization": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "basic_auth": {
                "const": null
              },
              "bearer_token": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              },
              "oauth2": {
                "const": null
              },
              "sigv4": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "sigv4": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "authorization": {
                "const": null
              },
              "basic_auth": {
                "const": null
              },
              "bearer_token": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              },
              "oauth2": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "oauth2": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "authorization": {
                "const": null
              },
              "basic_auth": {
                "const": null
              },
              "bearer_token": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              },
              "sigv4": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "bearer_token": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "authorization": {
                "const": null
              },
              "basic_auth": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              },
              "oauth2": {
                "const": null
              },
              "sigv4": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "bearer_token_file": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "authorization": {
                "const": null
              },
              "basic_auth": {
                "const": null
              },
              "bearer_token": {
                "const": null
              },
              "oauth2": {
                "const": null
              },
              "sigv4": {
                "const": null
              }
            }
          }
        }
      ]
    },
    "authorization": {
      "additionalProperties": false,
      "description": "Sets the `Authorization` header on every scrape request with the configured credentials.",
      "oneOf": [
        {
          "required": ["credentials"]
        },
        {
          "required": ["credentials_file"]
        }
      ],
      "properties": {
        "credentials": {
          "description": "Sets the credentials of the request. It is mutually exclusive with `credentials_file`.",
          "type": ["string", "null"]
        },
        "credentials_file": {
          "$ref": "#/definitions/filepath",
          "description": "Sets the credentials of the request with the credentials read from the configured file. It is mutually exclusive with `credentials`."
        },
        "type": {
          "default": "Bearer",
          "description": "Sets the authentication type of the request.",
          "type": ["string", "null"]
        }
      },
      "type": ["object", "null"]
    },
    "azure_sd_configs": {
      "description": "List of Azure service discovery configurations.",
      "items": {
        "description": "The information to access the Azure API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "basic_auth": {
      "additionalProperties": false,
      "description": "Sets the `Authorization` header on every remote write request with the configured username and password. password and password_file are mutually exclusive.",
      "oneOf": [
        {
          "required": ["password"]
        },
        {
          "required": ["password_file"]
        }
      ],
      "properties": {
        "password": {
          "type": ["string", "null"]
        },
        "password_file": {
          "$ref": "#/definitions/filepath"
        },
        "username": {
          "type": "string"
        }
      },
      "required": ["username"],
      "type": ["object", "null"]
    },
    "bearer_token": {
      "description": "Sets the `Authorization` header on every scrape request with the configured bearer token. It is mutually exclusive with `bearer_token_file`.",
      "type": ["string", "null"]
    },
    "bearer_token_file": {
      "$ref": "#/definitions/filepath",
      "description": "Sets the `Authorization` header on every scrape request with the bearer token read from the configured file. It is mutually exclusive with `bearer_token`."
    },
    "consul_sd_configs": {
      "description": "List of Consul service discovery configurations.",
      "items": {
        "description": "The information to access the Consul API. It is to be defined as the Consul documentation requires.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "digitalocean_sd_configs": {
      "description": "List of DigitalOcean service discovery configurations.",
      "items": {
        "description": "The information to access the DigitalOcean API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "dns_sd_configs": {
      "description": "List of DNS service discovery configurations.",
      "items": {
        "additionalProperties": false,
        "description": "A DNS-based service discovery configuration allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from /etc/resolv.conf. This service discovery method only supports basic DNS A, AAAA and SRV record queries, but not the advanced DNS-SD approach specified in RFC6763. During the relabeling phase, the meta label __meta_dns_name is available on each target and is set to the record name that produced the discovered target.",
        "properties": {
          "names": {
            "description": "A list of DNS domain names to be queried.",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "type": "array"
          },
          "port": {
            "description": "The port number used if the query type is not SRV.",
            "type": ["integer", "null"]
          },
          "refresh_interval": {
            "$ref": "#/definitions/duration",
            "default": "30s",
            "description": "The time after which the provided names are refreshed."
          },
          "type": {
            "default": "SRV",
            "description": "The type of DNS query to perform. One of SRV, A, or AAAA.",
            "enum": ["SRV", "A", "AAAA"],
            "type": ["string", "null"]
          }
        },
        "required": ["names"],
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "docker_sd_configs": {
      "description": "List of Docker service discovery configurations.",
      "items": {
        "description": "Docker SD configurations allow retrieving scrape targets from Docker Engine hosts.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "dockerswarm_sd_configs": {
      "description": "List of Docker Swarm service discovery configurations.",
      "items": {
        "description": "Docker Swarm SD configurations allow retrieving scrape targets from Docker Swarm engine.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "duration": {
      "pattern": "^[0-9]+(ms|[smhdwy])$",
      "type": ["string", "null"]
    },
    "ec2_sd_configs": {
      "description": "List of EC2 service discovery configurations.",
      "items": {
        "description": "The information to access the EC2 API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "eureka_sd_configs": {
      "description": "List of Eureka service discovery configurations.",
      "items": {
        "description": "The information to access the Eureka API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "file_sd_configs": {
      "description": "List of file service discovery configurations.",
      "items": {
        "properties": {
          "files": {
            "description": "Patterns for files from which target groups are extracted. Where the pattern may be a path ending in .json, .yml or .yaml. The last path segment may contain a single * that matches any character sequence, e.g. my/path/tg_*.json.",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "type": "array"
          },
          "refresh_interval": {
            "$ref": "#/definitions/duration",
            "default": "5m",
            "description": "Refresh interval to re-read the files."
          }
        },
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "filepath": {
      "format": "uri-reference",
      "type": ["string", "null"]
    },
    "filepath_glob": {
      "type": "string"
    },
    "gce_sd_configs": {
      "description": "List of GCE service discovery configurations.",
      "items": {
        "description": "The information to access the GCE API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "hetzner_sd_configs": {
      "description": "List of Hetzner service discovery configurations.",
      "items": {
        "description": "The information to access the Hetzner API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "http_sd_configs": {
      "description": "List of HTTP service discovery configurations.",
      "items": {
        "additionalProperties": false,
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "description": "HTTP-based service discovery provides a more generic way to configure static targets and serves as an interface to plug in custom service discovery mechanisms.",
        "properties": {
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "follow_redirects": {
            "default": true,
            "description": "Configure whether HTTP requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"]
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "format": "uri-reference",
            "type": ["string", "null"]
          },
          "refresh_interval": {
            "$ref": "#/definitions/duration",
            "default": "60s",
            "description": "Refresh interval to re-query the endpoint."
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config",
            "description": "TLS configuration."
          },
          "url": {
            "description": "URL from which the targets are fetched.",
            "format": "uri-reference",
            "type": "string"
          }
        },
        "required": ["url"],
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "kubernetes_sd_configs": {
      "description": "List of Kubernetes service discovery configurations.",
      "items": {
        "additionalProperties": false,
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "description": "The information to access the Kubernetes API.",
        "properties": {
          "api_server": {
            "description": "The API server addresses. If left empty, Prometheus is assumed to run inside of the cluster and will discover API servers automatically and use the pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.",
            "format": "uri-reference",
            "type": ["string", "null"]
          },
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "follow_redirects": {
            "default": true,
            "description": "Configure whether scrape requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"]
          },
          "kubeconfig_file": {
            "$ref": "#/definitions/filepath"
          },
          "namespaces": {
            "additionalProperties": false,
            "description": "Optional namespace discovery. If omitted, all namespaces are used.",
            "properties": {
              "names": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "own_namespace": {
                "type": "boolean"
              }
            },
            "type": ["object", "null"]
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "format": "uri-reference",
            "type": ["string", "null"]
          },
          "role": {
            "description": "The Kubernetes role of entities that should be discovered. One of endpoints, service, pod, node, or ingress.",
            "enum": ["endpoints", "service", "pod", "node", "ingress"],
            "type": "string"
          },
          "selectors": {
            "description": "Optional label and field selectors to limit the discovery process to a subset of available resources.",
            "items": {
              "additionalProperties": false,
              "properties": {
                "field": {
                  "type": ["string", "null"]
                },
                "label": {
                  "type": ["string", "null"]
                },
                "role": {
                  "type": "string"
                }
              },
              "required": ["role"],
              "type": "object"
            },
            "type": ["array", "null"]
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config",
            "description": "TLS configuration."
          }
        },
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "kuma_sd_configs": {
      "description": "List of Kuma service discovery configurations.",
      "items": {
        "description": "The information to access the Kuma API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "label_name": {
      "pattern": "^[a-zA-Z_][a-zA-Z0-9_]*$",
      "type": "string"
    },
    "label_value": {
      "type": "string"
    },
    "labels": {
      "additionalProperties": false,
      "patternProperties": {
        "^[a-zA-Z_][a-zA-Z0-9_]*$": {
          "$ref": "#/definitions/label_value"
        }
      },
      "type": ["object", "null"]
    },
    "lightsail_sd_configs": {
      "description": "List of Lightsail service discovery configurations.",
      "items": {
        "description": "The information to access the Lightsail API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "linode_sd_configs": {
      "description": "List of Linode service discovery configurations.",
      "items": {
        "description": "The information to access the Linode API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "marathon_sd_configs": {
      "description": "List of Marathon service discovery configurations.",
      "items": {
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "nerve_sd_configs": {
      "description": "List of AirBnB's Nerve service discovery configurations.",
      "items": {
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "oauth2": {
      "additionalProperties": false,
      "description": "Optional OAuth 2.0 configuration. Cannot be used at the same time as basic_auth or authorization.",
      "oneOf": [
        {
          "required": ["client_secret"]
        },
        {
          "required": ["client_secret_file"]
        }
      ],
      "properties": {
        "client_id": {
          "type": ["string"]
        },
        "client_secret": {
          "type": ["string", "null"]
        },
        "client_secret_file": {
          "$ref": "#/definitions/filepath",
          "description": "Read the client secret from a file. It is mutually exclusive with `client_secret`."
        },
        "endpoint_params": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional parameters to append to the token URL.",
          "type": ["object", "null"]
        },
        "scopes": {
          "description": "Scopes for the token request.",
          "items": {
            "type": ["string", "null"]
          },
          "type": ["array", "null"]
        },
        "tls_config": {
          "$ref": "#/definitions/tls_config",
          "description": "Configures the token request's TLS settings."
        },
        "token_url": {
          "description": "The URL to fetch the token from.",
          "type": ["string"]
        }
      },
      "required": ["client_id", "token_url"],
      "type": ["object", "null"]
    },
    "openstack_sd_configs": {
      "description": "List of OpenStack service discovery configurations.",
      "items": {
        "description": "The information to access the OpenStack API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "puppetdb_sd_configs": {
      "description": "List of PuppetDB service discovery configurations.",
      "items": {
        "description": "The information to access the PuppetDB API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "relabel_configs": {
      "items": {
        "if": {
          "properties": {
            "action": {
              "const": "replace"
            }
          }
        },
        "properties": {
          "action": {
            "default": "replace",
            "description": "Action to perform based on regex matching.",
            "enum": [
              "replace",
              "keep",
              "drop",
              "hashmod",
              "labelmap",
              "labeldrop",
              "labelkeep"
            ],
            "type": "string"
          },
          "modulus": {
            "description": "Modulus to take of the hash of the source label values.",
            "type": "integer"
          },
          "regex": {
            "$comment": "https://github.com/prometheus/prometheus/blob/release-2.13/config/testdata/conf.good.yml#L111 has integer instead of string",
            "default": "(.*)",
            "description": "Regular expression against which the extracted value is matched."
          },
          "replacement": {
            "default": "$1",
            "description": "Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.",
            "type": "string"
          },
          "separator": {
            "default": ";",
            "description": "Separator placed between concatenated source label values.",
            "type": "string"
          },
          "source_labels": {
            "description": "The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.",
            "items": {
              "$ref": "#/definitions/label_name"
            },
            "type": "array"
          },
          "target_label": {
            "$comment": "https://github.com/prometheus/prometheus/blob/release-2.13/config/testdata/conf.good.yml#L146 has a regex capture group, violating vanilla label_name definition.",
            "description": "Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.",
            "type": "string"
          }
        },
        "then": {
          "required": ["target_label"]
        },
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "scaleway_sd_configs": {
      "description": "List of Scaleway service discovery configurations.",
      "items": {
        "description": "The information to access the Scaleway API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "scheme": {
      "enum": ["http", "https", null],
      "type": ["string", "null"]
    },
    "serverset_sd_configs": {
      "description": "List of Zookeeper Serverset service discovery configurations.",
      "items": {
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "sigv4": {
      "additionalProperties": false,
      "description": "Optionally configures AWS's Signature Verification 4 signing process to sign requests.",
      "properties": {
        "access_key": {
          "description": "The AWS API keys. If blank, the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` are used.",
          "type": ["string", "null"]
        },
        "profile": {
          "description": "Named AWS profile used to authenticate.",
          "type": ["string", "null"]
        },
        "region": {
          "description": "The AWS region. If blank, the region from the default credentials chain is used.",
          "type": ["string", "null"]
        },
        "role_arn": {
          "description": "AWS Role ARN, an alternative to using AWS API keys.",
          "type": ["string", "null"]
        },
        "secret_key": {
          "description": "The AWS API keys. If blank, the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` are used.",
          "type": ["string", "null"]
        }
      },
      "type": ["object", "null"]
    },
    "static_configs": {
      "description": "List of labeled statically configured targets for this job.",
      "items": {
        "properties": {
          "labels": {
            "$ref": "#/definitions/labels",
            "description": "Labels assigned to all metrics scraped from the targets."
          },
          "targets": {
            "description": "The targets specified by the static config.",
            "items": {
              "type": "string"
            },
            "type": ["array", "null"]
          }
        },
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "tls_config": {
      "additionalProperties": false,
      "properties": {
        "ca_file": {
          "$ref": "#/definitions/filepath",
          "description": "CA certificate to validate API server certificate with."
        },
        "cert_file": {
          "$ref": "#/definitions/filepath",
          "description": "Certificate file for client cert authentication to the server."
        },
        "insecure_skip_verify": {
          "description": "Disable validation of the server certificate.",
          "type": ["boolean", "null"]
        },
        "key_file": {
          "$ref": "#/definitions/filepath",
          "description": "Key file for client cert authentication to the server."
        },
        "server_name": {
          "description": "ServerName extension to indicate the name of the server.",
          "type": ["string", "null"]
        }
      },
      "type": ["object", "null"]
    },
    "triton_sd_configs": {
      "description": "List of Triton service discovery configurations.",
      "items": {
        "description": "The information to access the Triton discovery API.",
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "uyuni_sd_configs": {
      "description": "List of Uyuni service discovery configurations.",
      "items": {
        "description": "The information to access the Uyuni API.",
        "type": "object"
      },
      "type": ["array", "null"]
    }
  },
  "description": "Prometheus configuration file",
  "properties": {
    "alerting": {
      "description": "Alerting specifies settings related to the Alertmanager.",
      "properties": {
        "alert_relabel_configs": {
          "$ref": "#/definitions/relabel_configs"
        },
        "alertmanagers": {
          "items": {
            "allOf": [
              {
                "$ref": "#/definitions/auth"
              }
            ],
            "properties": {
              "api_version": {
                "default": "v2",
                "description": "The api version of Alertmanager.",
                "type": ["string", "null"]
              },
              "authorization": {
                "$ref": "#/definitions/authorization"
              },
              "azure_sd_configs": {
                "$ref": "#/definitions/azure_sd_configs"
              },
              "basic_auth": {
                "$ref": "#/definitions/basic_auth"
              },
              "bearer_token": {
                "$ref": "#/definitions/bearer_token"
              },
              "bearer_token_file": {
                "$ref": "#/definitions/bearer_token_file"
              },
              "consul_sd_configs": {
                "$ref": "#/definitions/consul_sd_configs"
              },
              "digitalocean_sd_configs": {
                "$ref": "#/definitions/digitalocean_sd_configs"
              },
              "dns_sd_configs": {
                "$ref": "#/definitions/dns_sd_configs"
              },
              "docker_sd_configs": {
                "$ref": "#/definitions/docker_sd_configs"
              },
              "dockerswarm_sd_configs": {
                "$ref": "#/definitions/dockerswarm_sd_configs"
              },
              "ec2_sd_configs": {
                "$ref": "#/definitions/ec2_sd_configs"
              },
              "eureka_sd_configs": {
                "$ref": "#/definitions/eureka_sd_configs"
              },
              "file_sd_configs": {
                "$ref": "#/definitions/file_sd_configs"
              },
              "follow_redirects": {
                "default": true,
                "description": "Configure whether HTTP requests follow HTTP 3xx redirects.",
                "type": ["boolean", "null"]
              },
              "gce_sd_configs": {
                "$ref": "#/definitions/gce_sd_configs"
              },
              "hetzner_sd_configs": {
                "$ref": "#/definitions/hetzner_sd_configs"
              },
              "http_sd_configs": {
                "$ref": "#/definitions/http_sd_configs"
              },
              "kubernetes_sd_configs": {
                "$ref": "#/definitions/kubernetes_sd_configs"
              },
              "kuma_sd_configs": {
                "$ref": "#/definitions/kuma_sd_configs"
              },
              "lightsail_sd_configs": {
                "$ref": "#/definitions/lightsail_sd_configs"
              },
              "linode_sd_configs": {
                "$ref": "#/definitions/linode_sd_configs"
              },
              "marathon_sd_configs": {
                "$ref": "#/definitions/marathon_sd_configs"
              },
              "nerve_sd_configs": {
                "$ref": "#/definitions/nerve_sd_configs"
              },
              "oauth2": {
                "$ref": "#/definitions/oauth2"
              },
              "openstack_sd_configs": {
                "$ref": "#/definitions/openstack_sd_configs"
              },
              "path_prefix": {
                "default": "/",
                "description": "Prefix for the HTTP path alerts are pushed to.",
                "type": ["string", "null"]
              },
              "proxy_url": {
                "description": "Optional proxy URL.",
                "format": "uri-reference",
                "type": ["string", "null"]
              },
              "puppetdb_sd_configs": {
                "$ref": "#/definitions/puppetdb_sd_configs"
              },
              "relabel_configs": {
                "$ref": "#/definitions/relabel_configs",
                "description": "List of Alertmanager relabel configurations."
              },
              "scaleway_sd_configs": {
                "$ref": "#/definitions/scaleway_sd_configs"
              },
              "scheme": {
                "$ref": "#/definitions/scheme",
                "default": "http",
                "description": "Configures the protocol scheme used for requests."
              },
              "serverset_sd_configs": {
                "$ref": "#/definitions/serverset_sd_configs"
              },
              "static_configs": {
                "$ref": "#/definitions/static_configs",
                "description": "List of labeled statically configured Alertmanagers."
              },
              "timeout": {
                "$ref": "#/definitions/duration",
                "default": "10s",
                "description": "Per-target Alertmanager timeout when pushing alerts."
              },
              "tls_config": {
                "$ref": "#/definitions/tls_config",
                "description": "Configures the scrape request's TLS settings."
              },
              "triton_sd_configs": {
                "$ref": "#/definitions/triton_sd_configs"
              },
              "uyuni_sd_configs": {
                "$ref": "#/definitions/uyuni_sd_configs"
              }
            },
            "type": "object"
          },
          "type": ["array", "null"]
        }
      },
      "type": ["object", "null"]
    },
    "global": {
      "additionalProperties": false,
      "description": "The global configuration specifies parameters that are valid in all other configuration contexts. They also serve as defaults for other configuration sections.",
      "properties": {
        "evaluation_interval": {
          "$ref": "#/definitions/duration",
          "default": "1m",
          "description": "How frequently to evaluate rules."
        },
        "external_labels": {
          "$ref": "#/definitions/labels",
          "description": "The labels to add to any time series or alerts when communicating with external systems (federation, remote storage, Alertmanager)."
        },
        "query_log_file": {
          "$ref": "#/definitions/filepath",
          "description": "File to which PromQL queries are logged. Reloading the configuration will reopen the file."
        },
        "scrape_interval": {
          "$ref": "#/definitions/duration",
          "default": "1m",
          "description": "How frequently to scrape targets by default."
        },
        "scrape_timeout": {
          "$ref": "#/definitions/duration",
          "default": "10s",
          "description": "How long until a scrape request times out."
        }
      },
      "type": ["object", "null"]
    },
    "remote_read": {
      "description": "Settings related to the remote read feature.",
      "items": {
        "additionalProperties": false,
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "properties": {
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "follow_redirects": {
            "default": true,
            "description": "Configure whether HTTP requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"]
          },
          "headers": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom HTTP headers to be sent along with each remote read request. Be aware that headers that are set by Prometheus itself can't be overwritten.",
            "type": ["object", "null"]
          },
          "name": {
            "description": "Name of the remote read config, which if specified must be unique among remote read configs. The name will be used in metrics and logging in place of a generated value to help users distinguish between remote read configs.",
            "type": ["string", "null"]
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "format": "uri-reference",
            "type": ["string", "null"]
          },
          "read_recent": {
            "default": false,
            "description": "Whether reads should be made for queries for time ranges that the local storage should have complete data for.",
            "type": ["boolean", "null"]
          },
          "remote_timeout": {
            "$ref": "#/definitions/duration",
            "default": "1m",
            "description": "Timeout for requests to the remote read endpoint."
          },
          "required_matchers": {
            "$ref": "#/definitions/labels",
            "description": "An optional list of equality matchers which have to be present in a selector to query the remote read endpoint."
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config"
          },
          "url": {
            "description": "The URL of the endpoint to query from.",
            "format": "uri-reference",
            "type": "string"
          }
        },
        "required": ["url"],
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "remote_write": {
      "description": "Settings related to the remote write feature.",
      "items": {
        "additionalProperties": false,
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "properties": {
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "follow_redirects": {
            "default": true,
            "description": "Configure whether HTTP requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"]
          },
          "headers": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom HTTP headers to be sent along with each remote write request. Be aware that headers that are set by Prometheus itself can't be overwritten.",
            "type": ["object", "null"]
          },
          "metadata_config": {
            "additionalProperties": false,
            "description": "Configures the sending of series metadata to remote storage.",
            "properties": {
              "max_samples_per_send": {
                "default": 500,
                "description": "Maximum number of samples per send.",
                "type": ["integer", "null"]
              },
              "send": {
                "default": true,
                "description": "Whether metric metadata is sent to remote storage or not.",
                "type": ["boolean", "null"]
              },
              "send_interval": {
                "$ref": "#/definitions/duration",
                "default": "1m",
                "description": "How frequently metric metadata is sent to remote storage."
              }
            },
            "type": ["object", "null"]
          },
          "name": {
            "description": "Name of the remote write config, which if specified must be unique among remote write configs. The name will be used in metrics and logging in place of a generated value to help users distinguish between remote write configs.",
            "type": ["string", "null"]
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "format": "uri-reference",
            "type": ["string", "null"]
          },
          "queue_config": {
            "additionalProperties": false,
            "description": "Configures the queue used to write to remote storage.",
            "properties": {
              "batch_send_deadline": {
                "$ref": "#/definitions/duration",
                "default": "5s",
                "description": "Maximum time a sample will wait in buffer."
              },
              "capacity": {
                "default": 2500,
                "description": "Number of samples to buffer per shard before we block reading of more samples from the WAL. It is recommended to have enough capacity in each shard to buffer several requests to keep throughput up while processing occasional slow remote requests.",
                "type": ["integer", "null"]
              },
              "max_backoff": {
                "$ref": "#/definitions/duration",
                "default": "5s",
                "description": "Maximum retry delay."
              },
              "max_samples_per_send": {
                "default": 500,
                "description": "Maximum number of samples per send.",
                "type": ["integer", "null"]
              },
              "max_shards": {
                "default": 200,
                "description": "Maximum number of shards, i.e. amount of concurrency.",
                "type": ["integer", "null"]
              },
              "min_backoff": {
                "$ref": "#/definitions/duration",
                "default": "30ms",
                "description": "Initial retry delay. Gets doubled for every retry."
              },
              "min_shards": {
                "default": 1,
                "description": "Minimum number of shards, i.e. amount of concurrency.",
                "type": ["integer", "null"]
              },
              "retry_on_http_429": {
                "default": false,
                "description": "Retry upon receiving a 429 status code from the remote-write storage.",
                "type": ["boolean", "null"]
              }
            },
            "type": ["object", "null"]
          },
          "remote_timeout": {
            "$ref": "#/definitions/duration",
            "default": "30s",
            "description": "Timeout for requests to the remote write endpoint."
          },
          "send_exemplars": {
            "default": false,
            "description": "Enables sending of exemplars over remote write. Note that exemplar storage itself must be enabled for exemplars to be scraped in the first place.",
            "type": ["boolean", "null"]
          },
          "sigv4": {
            "$ref": "#/definitions/sigv4"
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config",
            "description": "Configures the remote write request's TLS settings."
          },
          "url": {
            "description": "The URL of the endpoint to send samples to.",
            "format": "uri-reference",
            "type": "string"
          },
          "write_relabel_configs": {
            "$ref": "#/definitions/relabel_configs",
            "description": "List of remote write relabel configurations."
          }
        },
        "required": ["url"],
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "rule_files": {
      "description": "Rule files specifies a list of globs. Rules and alerts are read from all matching files.",
      "items": {
        "$ref": "#/definitions/filepath_glob"
      },
      "type": ["array", "null"]
    },
    "scrape_configs": {
      "description": "A list of scrape configurations.",
      "items": {
        "additionalProperties": false,
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "properties": {
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "azure_sd_configs": {
            "$ref": "#/definitions/azure_sd_configs"
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "body_size_limit": {
            "default": 0,
            "description": "An uncompressed response body larger than this many bytes will cause the scrape to fail. 0 means no limit. Example: 100MB.",
            "type": ["integer", "null"]
          },
          "consul_sd_configs": {
            "$ref": "#/definitions/consul_sd_configs"
          },
          "digitalocean_sd_configs": {
            "$ref": "#/definitions/digitalocean_sd_configs"
          },
          "dns_sd_configs": {
            "$ref": "#/definitions/dns_sd_configs"
          },
          "docker_sd_configs": {
            "$ref": "#/definitions/docker_sd_configs"
          },
          "dockerswarm_sd_configs": {
            "$ref": "#/definitions/dockerswarm_sd_configs"
          },
          "ec2_sd_configs": {
            "$ref": "#/definitions/ec2_sd_configs"
          },
          "eureka_sd_configs": {
            "$ref": "#/definitions/eureka_sd_configs"
          },
          "file_sd_configs": {
            "$ref": "#/definitions/file_sd_configs"
          },
          "follow_redirects": {
            "default": true,
            "description": "Configure whether scrape requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"]
          },
          "gce_sd_configs": {
            "$ref": "#/definitions/gce_sd_configs"
          },
          "hetzner_sd_configs": {
            "$ref": "#/definitions/hetzner_sd_configs"
          },
          "honor_labels": {
            "default": false,
            "description": "Controls how Prometheus handles conflicts between labels that are already present in scraped data and labels that Prometheus would attach server-side (\"job\" and \"instance\" labels, manually configured target labels, and labels generated by service discovery implementations).",
            "type": ["boolean", "null"]
          },
          "honor_timestamps": {
            "default": true,
            "description": "Controls whether Prometheus respects the timestamps present in scraped data.",
            "type": ["boolean", "null"]
          },
          "http_sd_configs": {
            "$ref": "#/definitions/http_sd_configs"
          },
          "job_name": {
            "description": "The job name assigned to scraped metrics by default. Must be unique across all scrape configurations.",
            "type": "string"
          },
          "kubernetes_sd_configs": {
            "$ref": "#/definitions/kubernetes_sd_configs"
          },
          "kuma_sd_configs": {
            "$ref": "#/definitions/kuma_sd_configs"
          },
          "label_limit": {
            "default": 0,
            "description": "Per-scrape limit on number of labels that will be accepted for a sample. If more than this number of labels are present post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit.",
            "type": ["integer", "null"]
          },
          "label_name_length_limit": {
            "default": 0,
            "description": "Per-scrape limit on length of labels name that will be accepted for a sample. If a label name is longer than this number post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit.",
            "type": ["integer", "null"]
          },
          "label_value_length_limit": {
            "default": 0,
            "description": "Per-scrape limit on length of labels value that will be accepted for a sample. If a label value is longer than this number post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit.",
            "type": ["integer", "null"]
          },
          "lightsail_sd_configs": {
            "$ref": "#/definitions/lightsail_sd_configs"
          },
          "linode_sd_configs": {
            "$ref": "#/definitions/linode_sd_configs"
          },
          "marathon_sd_configs": {
            "$ref": "#/definitions/marathon_sd_configs"
          },
          "metric_relabel_configs": {
            "$ref": "#/definitions/relabel_configs",
            "description": "List of metric relabel configurations."
          },
          "metrics_path": {
            "default": "/metrics",
            "description": "The HTTP resource path on which to fetch metrics from targets.",
            "type": ["string", "null"]
          },
          "nerve_sd_configs": {
            "$ref": "#/definitions/nerve_sd_configs"
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "openstack_sd_configs": {
            "$ref": "#/definitions/openstack_sd_configs"
          },
          "params": {
            "additionalProperties": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "description": "Optional HTTP URL parameters.",
            "type": ["object", "null"]
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "format": "uri-reference",
            "type": ["string", "null"]
          },
          "puppetdb_sd_configs": {
            "$ref": "#/definitions/puppetdb_sd_configs"
          },
          "relabel_configs": {
            "$ref": "#/definitions/relabel_configs",
            "description": "List of target relabel configurations."
          },
          "sample_limit": {
            "default": 0,
            "description": "Per-scrape limit on number of scraped samples that will be accepted. If more than this number of samples are present after metric relabelling the entire scrape will be treated as failed. 0 means no limit.",
            "type": ["integer", "null"]
          },
          "scaleway_sd_configs": {
            "$ref": "#/definitions/scaleway_sd_configs"
          },
          "scheme": {
            "$ref": "#/definitions/scheme",
            "default": "http",
            "description": "Configures the protocol scheme used for requests."
          },
          "scrape_interval": {
            "$ref": "#/definitions/duration",
            "description": "How frequently to scrape targets from this job. Defaults to `global.scrape_interval`."
          },
          "scrape_timeout": {
            "$ref": "#/definitions/duration",
            "description": "Per-scrape timeout when scraping this job. Defaults to `global.scrape_timeout`."
          },
          "serverset_sd_configs": {
            "$ref": "#/definitions/serverset_sd_configs"
          },
          "static_configs": {
            "$ref": "#/definitions/static_configs"
          },
          "target_limit": {
            "default": 0,
            "description": "Per-scrape config limit on number of unique targets that will be accepted. If more than this number of targets are present after target relabeling, Prometheus will mark the targets as failed without scraping them. 0 means no limit.",
            "type": ["integer", "null"]
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config",
            "description": "Configures the scrape request's TLS settings."
          },
          "triton_sd_configs": {
            "$ref": "#/definitions/triton_sd_configs"
          },
          "uyuni_sd_configs": {
            "$ref": "#/definitions/uyuni_sd_configs"
          }
        },
        "required": ["job_name"],
        "type": "object"
      },
      "type": ["array", "null"]
    },
    "storage": {
      "description": "Storage related settings that are runtime reloadable.",
      "items": {
        "additionalProperties": false,
        "properties": {
          "max_exemplars": {
            "default": 100000,
            "type": ["integer", "null"]
          }
        },
        "type": "object"
      },
      "type": ["array", "null"]
    }
  },
  "title": "Prometheus",
  "type": ["object", "null"]
}
