{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://json.schemastore.org/prometheus.json",
  "additionalProperties": false,
  "definitions": {
    "duration": {
      "type": ["string", "null"],
      "pattern": "^[0-9]+(ms|[smhdwy])$"
    },
    "label_name": {
      "type": "string",
      "pattern": "^[a-zA-Z_][a-zA-Z0-9_]*$"
    },
    "label_value": {
      "type": "string"
    },
    "labels": {
      "type": ["object", "null"],
      "patternProperties": {
        "^[a-zA-Z_][a-zA-Z0-9_]*$": {
          "$ref": "#/definitions/label_value"
        }
      },
      "additionalProperties": false
    },
    "filepath_glob": {
      "type": "string"
    },
    "filepath": {
      "type": ["string", "null"],
      "format": "uri-reference"
    },
    "basic_auth": {
      "description": "Sets the `Authorization` header on every remote write request with the configured username and password. password and password_file are mutually exclusive.",
      "type": ["object", "null"],
      "properties": {
        "username": {
          "type": "string"
        },
        "password": {
          "type": ["string", "null"]
        },
        "password_file": {
          "$ref": "#/definitions/filepath"
        }
      },
      "oneOf": [
        {
          "required": ["password"]
        },
        {
          "required": ["password_file"]
        }
      ],
      "additionalProperties": false,
      "required": ["username"]
    },
    "authorization": {
      "description": "Sets the `Authorization` header on every scrape request with the configured credentials.",
      "type": ["object", "null"],
      "properties": {
        "type": {
          "description": "Sets the authentication type of the request.",
          "type": ["string", "null"],
          "default": "Bearer"
        },
        "credentials": {
          "description": "Sets the credentials of the request. It is mutually exclusive with `credentials_file`.",
          "type": ["string", "null"]
        },
        "credentials_file": {
          "$ref": "#/definitions/filepath",
          "description": "Sets the credentials of the request with the credentials read from the configured file. It is mutually exclusive with `credentials`."
        }
      },
      "oneOf": [
        {
          "required": ["credentials"]
        },
        {
          "required": ["credentials_file"]
        }
      ],
      "additionalProperties": false
    },
    "sigv4": {
      "description": "Optionally configures AWS's Signature Verification 4 signing process to sign requests.",
      "type": ["object", "null"],
      "properties": {
        "region": {
          "description": "The AWS region. If blank, the region from the default credentials chain is used.",
          "type": ["string", "null"]
        },
        "access_key": {
          "description": "The AWS API keys. If blank, the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` are used.",
          "type": ["string", "null"]
        },
        "secret_key": {
          "description": "The AWS API keys. If blank, the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` are used.",
          "type": ["string", "null"]
        },
        "profile": {
          "description": "Named AWS profile used to authenticate.",
          "type": ["string", "null"]
        },
        "role_arn": {
          "description": "AWS Role ARN, an alternative to using AWS API keys.",
          "type": ["string", "null"]
        }
      },
      "additionalProperties": false
    },
    "azuread": {
      "description": "Optionally configure AzureAD.",
      "type": ["object", "null"],
      "properties": {
        "cloud": {
          "type": "string",
          "const": ["AzurePublic", "AzureChina", "AzureGovernment"],
          "default": "AzurePublic"
        },
        "managed_identity": {
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string"
            }
          }
        },
        "oauth2": {
          "type": "object",
          "properties": {
            "client_id": {
              "type": ["string"]
            },
            "client_secret": {
              "type": ["string", "null"]
            },
            "tenant_id": {
              "type": "string"
            }
          }
        },
        "sdk": {
          "properties": {
            "tenant_id": {
              "type": "string"
            }
          }
        }
      }
    },
    "google_iam": {
      "type": "object",
      "properties": {
        "credentials_file": {
          "type": "string"
        }
      }
    },
    "oauth2": {
      "description": "Optional OAuth 2.0 configuration. Cannot be used at the same time as basic_auth or authorization.",
      "type": ["object", "null"],
      "properties": {
        "client_id": {
          "type": ["string"]
        },
        "client_secret": {
          "type": ["string", "null"]
        },
        "client_secret_file": {
          "$ref": "#/definitions/filepath",
          "description": "Read the client secret from a file. It is mutually exclusive with `client_secret`."
        },
        "scopes": {
          "description": "Scopes for the token request.",
          "type": ["array", "null"],
          "items": {
            "type": ["string", "null"]
          }
        },
        "token_url": {
          "description": "The URL to fetch the token from.",
          "type": ["string"]
        },
        "endpoint_params": {
          "description": "Optional parameters to append to the token URL.",
          "type": ["object", "null"],
          "additionalProperties": {
            "type": "string"
          }
        },
        "tls_config": {
          "$ref": "#/definitions/tls_config",
          "description": "Configures the token request's TLS settings."
        }
      },
      "oneOf": [
        {
          "required": ["client_secret"]
        },
        {
          "required": ["client_secret_file"]
        }
      ],
      "additionalProperties": false,
      "required": ["client_id", "token_url"]
    },
    "bearer_token": {
      "description": "Sets the `Authorization` header on every scrape request with the configured bearer token. It is mutually exclusive with `bearer_token_file`.",
      "type": ["string", "null"]
    },
    "bearer_token_file": {
      "$ref": "#/definitions/filepath",
      "description": "Sets the `Authorization` header on every scrape request with the bearer token read from the configured file. It is mutually exclusive with `bearer_token`."
    },
    "auth": {
      "allOf": [
        {
          "if": {
            "not": {
              "properties": {
                "basic_auth": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "authorization": {
                "const": null
              },
              "sigv4": {
                "const": null
              },
              "oauth2": {
                "const": null
              },
              "bearer_token": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "authorization": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "basic_auth": {
                "const": null
              },
              "sigv4": {
                "const": null
              },
              "oauth2": {
                "const": null
              },
              "bearer_token": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "sigv4": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "basic_auth": {
                "const": null
              },
              "authorization": {
                "const": null
              },
              "oauth2": {
                "const": null
              },
              "bearer_token": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "oauth2": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "basic_auth": {
                "const": null
              },
              "authorization": {
                "const": null
              },
              "sigv4": {
                "const": null
              },
              "bearer_token": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "bearer_token": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "basic_auth": {
                "const": null
              },
              "authorization": {
                "const": null
              },
              "sigv4": {
                "const": null
              },
              "oauth2": {
                "const": null
              },
              "bearer_token_file": {
                "const": null
              }
            }
          }
        },
        {
          "if": {
            "not": {
              "properties": {
                "bearer_token_file": {
                  "const": null
                }
              }
            }
          },
          "then": {
            "properties": {
              "basic_auth": {
                "const": null
              },
              "authorization": {
                "const": null
              },
              "sigv4": {
                "const": null
              },
              "oauth2": {
                "const": null
              },
              "bearer_token": {
                "const": null
              }
            }
          }
        }
      ]
    },
    "relabel_configs": {
      "type": ["array", "null"],
      "items": {
        "type": "object",
        "properties": {
          "source_labels": {
            "description": "The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/label_name"
            }
          },
          "separator": {
            "description": "Separator placed between concatenated source label values.",
            "type": "string",
            "default": ";"
          },
          "target_label": {
            "$comment": "https://github.com/prometheus/prometheus/blob/release-2.13/config/testdata/conf.good.yml#L146 has a regex capture group, violating vanilla label_name definition.",
            "description": "Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.",
            "type": "string"
          },
          "regex": {
            "$comment": "https://github.com/prometheus/prometheus/blob/release-2.13/config/testdata/conf.good.yml#L111 has integer instead of string",
            "description": "Regular expression against which the extracted value is matched.",
            "default": "(.*)"
          },
          "modulus": {
            "description": "Modulus to take of the hash of the source label values.",
            "type": "integer"
          },
          "replacement": {
            "description": "Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.",
            "type": "string",
            "default": "$1"
          },
          "action": {
            "description": "Action to perform based on regex matching.",
            "type": "string",
            "enum": [
              "replace",
              "lowercase",
              "uppercase",
              "keep",
              "drop",
              "keepequal",
              "dropequal",
              "hashmod",
              "labelmap",
              "labeldrop",
              "labelkeep"
            ],
            "default": "replace"
          }
        },
        "if": {
          "properties": {
            "action": {
              "const": "replace"
            }
          }
        },
        "then": {
          "required": ["target_label"]
        }
      }
    },
    "tls_config": {
      "type": ["object", "null"],
      "properties": {
        "ca_file": {
          "$ref": "#/definitions/filepath",
          "description": "CA certificate to validate API server certificate with."
        },
        "cert_file": {
          "$ref": "#/definitions/filepath",
          "description": "Certificate file for client cert authentication to the server."
        },
        "key_file": {
          "$ref": "#/definitions/filepath",
          "description": "Key file for client cert authentication to the server."
        },
        "server_name": {
          "description": "ServerName extension to indicate the name of the server.",
          "type": ["string", "null"]
        },
        "insecure_skip_verify": {
          "description": "Disable validation of the server certificate.",
          "type": ["boolean", "null"]
        }
      },
      "additionalProperties": false
    },
    "scheme": {
      "type": ["string", "null"],
      "enum": ["http", "https", null]
    },
    "azure_sd_configs": {
      "description": "List of Azure service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Azure API.",
        "type": "object"
      }
    },
    "consul_sd_configs": {
      "description": "List of Consul service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Consul API. It is to be defined as the Consul documentation requires.",
        "type": "object"
      }
    },
    "digitalocean_sd_configs": {
      "description": "List of DigitalOcean service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the DigitalOcean API.",
        "type": "object"
      }
    },
    "docker_sd_configs": {
      "description": "List of Docker service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "Docker SD configurations allow retrieving scrape targets from Docker Engine hosts.",
        "type": "object"
      }
    },
    "dockerswarm_sd_configs": {
      "description": "List of Docker Swarm service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "Docker Swarm SD configurations allow retrieving scrape targets from Docker Swarm engine.",
        "type": "object"
      }
    },
    "dns_sd_configs": {
      "description": "List of DNS service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "A DNS-based service discovery configuration allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from /etc/resolv.conf. This service discovery method only supports basic DNS A, AAAA and SRV record queries, but not the advanced DNS-SD approach specified in RFC6763. During the relabeling phase, the meta label __meta_dns_name is available on each target and is set to the record name that produced the discovered target.",
        "type": "object",
        "properties": {
          "names": {
            "description": "A list of DNS domain names to be queried.",
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 1
          },
          "type": {
            "description": "The type of DNS query to perform. One of SRV, A, or AAAA.",
            "type": ["string", "null"],
            "enum": ["SRV", "A", "AAAA"],
            "default": "SRV"
          },
          "port": {
            "description": "The port number used if the query type is not SRV.",
            "type": ["integer", "null"]
          },
          "refresh_interval": {
            "$ref": "#/definitions/duration",
            "description": "The time after which the provided names are refreshed.",
            "default": "30s"
          }
        },
        "required": ["names"],
        "additionalProperties": false
      }
    },
    "ec2_sd_configs": {
      "description": "List of EC2 service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the EC2 API.",
        "type": "object"
      }
    },
    "eureka_sd_configs": {
      "description": "List of Eureka service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Eureka API.",
        "type": "object"
      }
    },
    "file_sd_configs": {
      "description": "List of file service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "type": "object",
        "properties": {
          "files": {
            "description": "Patterns for files from which target groups are extracted. Where the pattern may be a path ending in .json, .yml or .yaml. The last path segment may contain a single * that matches any character sequence, e.g. my/path/tg_*.json.",
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 1
          },
          "refresh_interval": {
            "$ref": "#/definitions/duration",
            "description": "Refresh interval to re-read the files.",
            "default": "5m"
          }
        }
      }
    },
    "gce_sd_configs": {
      "description": "List of GCE service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the GCE API.",
        "type": "object"
      }
    },
    "hetzner_sd_configs": {
      "description": "List of Hetzner service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Hetzner API.",
        "type": "object"
      }
    },
    "http_sd_configs": {
      "description": "List of HTTP service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "HTTP-based service discovery provides a more generic way to configure static targets and serves as an interface to plug in custom service discovery mechanisms.",
        "type": "object",
        "properties": {
          "url": {
            "description": "URL from which the targets are fetched.",
            "type": "string",
            "format": "uri-reference"
          },
          "refresh_interval": {
            "$ref": "#/definitions/duration",
            "description": "Refresh interval to re-query the endpoint.",
            "default": "60s"
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "type": ["string", "null"],
            "format": "uri-reference"
          },
          "follow_redirects": {
            "description": "Configure whether HTTP requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"],
            "default": true
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config",
            "description": "TLS configuration."
          }
        },
        "required": ["url"],
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "additionalProperties": false
      }
    },
    "kubernetes_sd_configs": {
      "description": "List of Kubernetes service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Kubernetes API.",
        "type": "object",
        "properties": {
          "api_server": {
            "description": "The API server addresses. If left empty, Prometheus is assumed to run inside of the cluster and will discover API servers automatically and use the pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.",
            "type": ["string", "null"],
            "format": "uri-reference"
          },
          "role": {
            "description": "The Kubernetes role of entities that should be discovered. One of endpoints, service, pod, node, or ingress.",
            "type": "string",
            "enum": ["endpoints", "service", "pod", "node", "ingress"]
          },
          "kubeconfig_file": {
            "$ref": "#/definitions/filepath"
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "type": ["string", "null"],
            "format": "uri-reference"
          },
          "follow_redirects": {
            "description": "Configure whether scrape requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"],
            "default": true
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config",
            "description": "TLS configuration."
          },
          "namespaces": {
            "description": "Optional namespace discovery. If omitted, all namespaces are used.",
            "type": ["object", "null"],
            "properties": {
              "own_namespace": {
                "type": "boolean"
              },
              "names": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          },
          "selectors": {
            "description": "Optional label and field selectors to limit the discovery process to a subset of available resources.",
            "type": ["array", "null"],
            "items": {
              "type": "object",
              "properties": {
                "role": {
                  "type": "string"
                },
                "label": {
                  "type": ["string", "null"]
                },
                "field": {
                  "type": ["string", "null"]
                }
              },
              "required": ["role"],
              "additionalProperties": false
            }
          }
        },
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "additionalProperties": false
      }
    },
    "kuma_sd_configs": {
      "description": "List of Kuma service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Kuma API.",
        "type": "object"
      }
    },
    "lightsail_sd_configs": {
      "description": "List of Lightsail service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Lightsail API.",
        "type": "object"
      }
    },
    "linode_sd_configs": {
      "description": "List of Linode service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Linode API.",
        "type": "object"
      }
    },
    "marathon_sd_configs": {
      "description": "List of Marathon service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "type": "object"
      }
    },
    "nerve_sd_configs": {
      "description": "List of AirBnB's Nerve service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "type": "object"
      }
    },
    "openstack_sd_configs": {
      "description": "List of OpenStack service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the OpenStack API.",
        "type": "object"
      }
    },
    "puppetdb_sd_configs": {
      "description": "List of PuppetDB service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the PuppetDB API.",
        "type": "object"
      }
    },
    "scaleway_sd_configs": {
      "description": "List of Scaleway service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Scaleway API.",
        "type": "object"
      }
    },
    "serverset_sd_configs": {
      "description": "List of Zookeeper Serverset service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "type": "object"
      }
    },
    "triton_sd_configs": {
      "description": "List of Triton service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Triton discovery API.",
        "type": "object"
      }
    },
    "uyuni_sd_configs": {
      "description": "List of Uyuni service discovery configurations.",
      "type": ["array", "null"],
      "items": {
        "description": "The information to access the Uyuni API.",
        "type": "object"
      }
    },
    "static_configs": {
      "description": "List of labeled statically configured targets for this job.",
      "type": ["array", "null"],
      "items": {
        "type": "object",
        "properties": {
          "targets": {
            "description": "The targets specified by the static config.",
            "type": ["array", "null"],
            "items": {
              "type": "string"
            }
          },
          "labels": {
            "$ref": "#/definitions/labels",
            "description": "Labels assigned to all metrics scraped from the targets."
          }
        }
      }
    }
  },
  "description": "Prometheus configuration file",
  "properties": {
    "global": {
      "description": "The global configuration specifies parameters that are valid in all other configuration contexts. They also serve as defaults for other configuration sections.",
      "type": ["object", "null"],
      "properties": {
        "scrape_interval": {
          "$ref": "#/definitions/duration",
          "description": "How frequently to scrape targets by default.",
          "default": "1m"
        },
        "scrape_timeout": {
          "$ref": "#/definitions/duration",
          "description": "How long until a scrape request times out.",
          "default": "10s"
        },
        "evaluation_interval": {
          "$ref": "#/definitions/duration",
          "description": "How frequently to evaluate rules.",
          "default": "1m"
        },
        "external_labels": {
          "$ref": "#/definitions/labels",
          "description": "The labels to add to any time series or alerts when communicating with external systems (federation, remote storage, Alertmanager)."
        },
        "query_log_file": {
          "$ref": "#/definitions/filepath",
          "description": "File to which PromQL queries are logged. Reloading the configuration will reopen the file."
        },
        "body_size_limit": {
          "description": "An uncompressed response body larger than this many bytes will cause the scrape to fail. 0 means no limit. Example: 100MB.",
          "type": ["string", "null"],
          "default": 0
        },
        "sample_limit": {
          "description": "Per-scrape limit on number of scraped samples that will be accepted. If more than this number of samples are present after metric relabelling the entire scrape will be treated as failed. 0 means no limit.",
          "type": ["integer", "null"],
          "default": 0
        },
        "label_limit": {
          "description": "Per-scrape limit on number of labels that will be accepted for a sample. If more than this number of labels are present post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit.",
          "type": ["integer", "null"],
          "default": 0
        },
        "label_name_length_limit": {
          "description": "Per-scrape limit on length of labels name that will be accepted for a sample. If a label name is longer than this number post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit.",
          "type": ["integer", "null"],
          "default": 0
        },
        "label_value_length_limit": {
          "description": "Per-scrape limit on length of labels value that will be accepted for a sample. If a label value is longer than this number post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit.",
          "type": ["integer", "null"],
          "default": 0
        },
        "target_limit": {
          "description": "Per-scrape config limit on number of unique targets that will be accepted. If more than this number of targets are present after target relabeling, Prometheus will mark the targets as failed without scraping them. 0 means no limit.",
          "type": ["integer", "null"],
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "rule_files": {
      "description": "Rule files specifies a list of globs. Rules and alerts are read from all matching files.",
      "type": ["array", "null"],
      "items": {
        "$ref": "#/definitions/filepath_glob"
      }
    },
    "remote_write": {
      "description": "Settings related to the remote write feature.",
      "type": ["array", "null"],
      "items": {
        "type": "object",
        "properties": {
          "url": {
            "description": "The URL of the endpoint to send samples to.",
            "type": "string",
            "format": "uri-reference"
          },
          "remote_timeout": {
            "$ref": "#/definitions/duration",
            "description": "Timeout for requests to the remote write endpoint.",
            "default": "30s"
          },
          "headers": {
            "description": "Custom HTTP headers to be sent along with each remote write request. Be aware that headers that are set by Prometheus itself can't be overwritten.",
            "type": ["object", "null"],
            "additionalProperties": {
              "type": "string"
            }
          },
          "write_relabel_configs": {
            "$ref": "#/definitions/relabel_configs",
            "description": "List of remote write relabel configurations."
          },
          "name": {
            "description": "Name of the remote write config, which if specified must be unique among remote write configs. The name will be used in metrics and logging in place of a generated value to help users distinguish between remote write configs.",
            "type": ["string", "null"]
          },
          "send_exemplars": {
            "description": "Enables sending of exemplars over remote write. Note that exemplar storage itself must be enabled for exemplars to be scraped in the first place.",
            "type": ["boolean", "null"],
            "default": false
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "sigv4": {
            "$ref": "#/definitions/sigv4"
          },
          "azuread": {
            "$ref": "#/definitions/azuread"
          },
          "google_iam": {
            "$ref": "#/definitions/google_iam"
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config",
            "description": "Configures the remote write request's TLS settings."
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "type": ["string", "null"],
            "format": "uri-reference"
          },
          "follow_redirects": {
            "description": "Configure whether HTTP requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"],
            "default": true
          },
          "queue_config": {
            "description": "Configures the queue used to write to remote storage.",
            "type": ["object", "null"],
            "properties": {
              "capacity": {
                "description": "Number of samples to buffer per shard before we block reading of more samples from the WAL. It is recommended to have enough capacity in each shard to buffer several requests to keep throughput up while processing occasional slow remote requests.",
                "type": ["integer", "null"],
                "default": 2500
              },
              "max_shards": {
                "description": "Maximum number of shards, i.e. amount of concurrency.",
                "type": ["integer", "null"],
                "default": 200
              },
              "min_shards": {
                "description": "Minimum number of shards, i.e. amount of concurrency.",
                "type": ["integer", "null"],
                "default": 1
              },
              "max_samples_per_send": {
                "description": "Maximum number of samples per send.",
                "type": ["integer", "null"],
                "default": 500
              },
              "batch_send_deadline": {
                "$ref": "#/definitions/duration",
                "description": "Maximum time a sample will wait in buffer.",
                "default": "5s"
              },
              "min_backoff": {
                "$ref": "#/definitions/duration",
                "description": "Initial retry delay. Gets doubled for every retry.",
                "default": "30ms"
              },
              "max_backoff": {
                "$ref": "#/definitions/duration",
                "description": "Maximum retry delay.",
                "default": "5s"
              },
              "retry_on_http_429": {
                "description": "Retry upon receiving a 429 status code from the remote-write storage.",
                "type": ["boolean", "null"],
                "default": false
              },
              "sample_age_limit": {
                "$ref": "#/definitions/duration",
                "description": "If set, any sample that is older than sample_age_limit will not be sent to the remote storage.",
                "default": "0s"
              }
            },
            "additionalProperties": false
          },
          "metadata_config": {
            "description": "Configures the sending of series metadata to remote storage.",
            "type": ["object", "null"],
            "properties": {
              "send": {
                "description": "Whether metric metadata is sent to remote storage or not.",
                "type": ["boolean", "null"],
                "default": true
              },
              "send_interval": {
                "$ref": "#/definitions/duration",
                "description": "How frequently metric metadata is sent to remote storage.",
                "default": "1m"
              },
              "max_samples_per_send": {
                "description": "Maximum number of samples per send.",
                "type": ["integer", "null"],
                "default": 500
              }
            },
            "additionalProperties": false
          }
        },
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "additionalProperties": false,
        "required": ["url"]
      }
    },
    "remote_read": {
      "description": "Settings related to the remote read feature.",
      "type": ["array", "null"],
      "items": {
        "type": "object",
        "properties": {
          "url": {
            "description": "The URL of the endpoint to query from.",
            "type": "string",
            "format": "uri-reference"
          },
          "name": {
            "description": "Name of the remote read config, which if specified must be unique among remote read configs. The name will be used in metrics and logging in place of a generated value to help users distinguish between remote read configs.",
            "type": ["string", "null"]
          },
          "required_matchers": {
            "$ref": "#/definitions/labels",
            "description": "An optional list of equality matchers which have to be present in a selector to query the remote read endpoint."
          },
          "remote_timeout": {
            "$ref": "#/definitions/duration",
            "description": "Timeout for requests to the remote read endpoint.",
            "default": "1m"
          },
          "headers": {
            "description": "Custom HTTP headers to be sent along with each remote read request. Be aware that headers that are set by Prometheus itself can't be overwritten.",
            "type": ["object", "null"],
            "additionalProperties": {
              "type": "string"
            }
          },
          "read_recent": {
            "description": "Whether reads should be made for queries for time ranges that the local storage should have complete data for.",
            "type": ["boolean", "null"],
            "default": false
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config"
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "type": ["string", "null"],
            "format": "uri-reference"
          },
          "follow_redirects": {
            "description": "Configure whether HTTP requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"],
            "default": true
          }
        },
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "additionalProperties": false,
        "required": ["url"]
      }
    },
    "scrape_config_files": {
      "description": "Scrape config files specifies a list of globs. Scrape configs are read from all matching files and appended to the list of scrape configs.",
      "type": ["array", "null"],
      "items": {
        "$ref": "#/definitions/filepath_glob"
      }
    },
    "scrape_configs": {
      "description": "A list of scrape configurations.",
      "type": ["array", "null"],
      "items": {
        "type": "object",
        "properties": {
          "job_name": {
            "description": "The job name assigned to scraped metrics by default. Must be unique across all scrape configurations.",
            "type": "string"
          },
          "scrape_interval": {
            "$ref": "#/definitions/duration",
            "description": "How frequently to scrape targets from this job. Defaults to `global.scrape_interval`."
          },
          "scrape_timeout": {
            "$ref": "#/definitions/duration",
            "description": "Per-scrape timeout when scraping this job. Defaults to `global.scrape_timeout`."
          },
          "fallback_scrape_protocol": {
            "description": "Fallback protocol to use if a scrape returns blank, unparsable, or otherwise invalid Content-Type.",
            "type": ["string", "null"],
            "enum": [
              "OpenMetricsText0.0.1",
              "OpenMetricsText1.0.0",
              "PrometheusProto",
              "PrometheusText0.0.4",
              "PrometheusText1.0.0"
            ]
          },
          "metrics_path": {
            "description": "The HTTP resource path on which to fetch metrics from targets.",
            "type": ["string", "null"],
            "default": "/metrics"
          },
          "honor_labels": {
            "description": "Controls how Prometheus handles conflicts between labels that are already present in scraped data and labels that Prometheus would attach server-side (\"job\" and \"instance\" labels, manually configured target labels, and labels generated by service discovery implementations).",
            "type": ["boolean", "null"],
            "default": false
          },
          "honor_timestamps": {
            "description": "Controls whether Prometheus respects the timestamps present in scraped data.",
            "type": ["boolean", "null"],
            "default": true
          },
          "scheme": {
            "$ref": "#/definitions/scheme",
            "description": "Configures the protocol scheme used for requests.",
            "default": "http"
          },
          "params": {
            "description": "Optional HTTP URL parameters.",
            "type": ["object", "null"],
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "basic_auth": {
            "$ref": "#/definitions/basic_auth"
          },
          "authorization": {
            "$ref": "#/definitions/authorization"
          },
          "oauth2": {
            "$ref": "#/definitions/oauth2"
          },
          "bearer_token": {
            "$ref": "#/definitions/bearer_token"
          },
          "bearer_token_file": {
            "$ref": "#/definitions/bearer_token_file"
          },
          "follow_redirects": {
            "description": "Configure whether scrape requests follow HTTP 3xx redirects.",
            "type": ["boolean", "null"],
            "default": true
          },
          "tls_config": {
            "$ref": "#/definitions/tls_config",
            "description": "Configures the scrape request's TLS settings."
          },
          "proxy_url": {
            "description": "Optional proxy URL.",
            "type": ["string", "null"],
            "format": "uri-reference"
          },
          "azure_sd_configs": {
            "$ref": "#/definitions/azure_sd_configs"
          },
          "consul_sd_configs": {
            "$ref": "#/definitions/consul_sd_configs"
          },
          "digitalocean_sd_configs": {
            "$ref": "#/definitions/digitalocean_sd_configs"
          },
          "docker_sd_configs": {
            "$ref": "#/definitions/docker_sd_configs"
          },
          "dockerswarm_sd_configs": {
            "$ref": "#/definitions/dockerswarm_sd_configs"
          },
          "dns_sd_configs": {
            "$ref": "#/definitions/dns_sd_configs"
          },
          "ec2_sd_configs": {
            "$ref": "#/definitions/ec2_sd_configs"
          },
          "eureka_sd_configs": {
            "$ref": "#/definitions/eureka_sd_configs"
          },
          "file_sd_configs": {
            "$ref": "#/definitions/file_sd_configs"
          },
          "gce_sd_configs": {
            "$ref": "#/definitions/gce_sd_configs"
          },
          "hetzner_sd_configs": {
            "$ref": "#/definitions/hetzner_sd_configs"
          },
          "http_sd_configs": {
            "$ref": "#/definitions/http_sd_configs"
          },
          "kubernetes_sd_configs": {
            "$ref": "#/definitions/kubernetes_sd_configs"
          },
          "kuma_sd_configs": {
            "$ref": "#/definitions/kuma_sd_configs"
          },
          "lightsail_sd_configs": {
            "$ref": "#/definitions/lightsail_sd_configs"
          },
          "linode_sd_configs": {
            "$ref": "#/definitions/linode_sd_configs"
          },
          "marathon_sd_configs": {
            "$ref": "#/definitions/marathon_sd_configs"
          },
          "nerve_sd_configs": {
            "$ref": "#/definitions/nerve_sd_configs"
          },
          "openstack_sd_configs": {
            "$ref": "#/definitions/openstack_sd_configs"
          },
          "puppetdb_sd_configs": {
            "$ref": "#/definitions/puppetdb_sd_configs"
          },
          "scaleway_sd_configs": {
            "$ref": "#/definitions/scaleway_sd_configs"
          },
          "serverset_sd_configs": {
            "$ref": "#/definitions/serverset_sd_configs"
          },
          "triton_sd_configs": {
            "$ref": "#/definitions/triton_sd_configs"
          },
          "uyuni_sd_configs": {
            "$ref": "#/definitions/uyuni_sd_configs"
          },
          "static_configs": {
            "$ref": "#/definitions/static_configs"
          },
          "relabel_configs": {
            "$ref": "#/definitions/relabel_configs",
            "description": "List of target relabel configurations."
          },
          "metric_relabel_configs": {
            "$ref": "#/definitions/relabel_configs",
            "description": "List of metric relabel configurations."
          },
          "body_size_limit": {
            "description": "An uncompressed response body larger than this many bytes will cause the scrape to fail. 0 means no limit. Example: 100MB.",
            "type": ["string", "null"],
            "default": 0
          },
          "sample_limit": {
            "description": "Per-scrape limit on number of scraped samples that will be accepted. If more than this number of samples are present after metric relabelling the entire scrape will be treated as failed. 0 means no limit.",
            "type": ["integer", "null"],
            "default": 0
          },
          "label_limit": {
            "description": "Per-scrape limit on number of labels that will be accepted for a sample. If more than this number of labels are present post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit.",
            "type": ["integer", "null"],
            "default": 0
          },
          "label_name_length_limit": {
            "description": "Per-scrape limit on length of labels name that will be accepted for a sample. If a label name is longer than this number post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit.",
            "type": ["integer", "null"],
            "default": 0
          },
          "label_value_length_limit": {
            "description": "Per-scrape limit on length of labels value that will be accepted for a sample. If a label value is longer than this number post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit.",
            "type": ["integer", "null"],
            "default": 0
          },
          "target_limit": {
            "description": "Per-scrape config limit on number of unique targets that will be accepted. If more than this number of targets are present after target relabeling, Prometheus will mark the targets as failed without scraping them. 0 means no limit.",
            "type": ["integer", "null"],
            "default": 0
          }
        },
        "allOf": [
          {
            "$ref": "#/definitions/auth"
          }
        ],
        "additionalProperties": false,
        "required": ["job_name"]
      }
    },
    "alerting": {
      "description": "Alerting specifies settings related to the Alertmanager.",
      "type": ["object", "null"],
      "properties": {
        "alert_relabel_configs": {
          "$ref": "#/definitions/relabel_configs"
        },
        "alertmanagers": {
          "type": ["array", "null"],
          "items": {
            "type": "object",
            "properties": {
              "timeout": {
                "$ref": "#/definitions/duration",
                "description": "Per-target Alertmanager timeout when pushing alerts.",
                "default": "10s"
              },
              "api_version": {
                "description": "The api version of Alertmanager.",
                "type": ["string", "null"],
                "default": "v2"
              },
              "path_prefix": {
                "description": "Prefix for the HTTP path alerts are pushed to.",
                "type": ["string", "null"],
                "default": "/"
              },
              "scheme": {
                "$ref": "#/definitions/scheme",
                "description": "Configures the protocol scheme used for requests.",
                "default": "http"
              },
              "basic_auth": {
                "$ref": "#/definitions/basic_auth"
              },
              "authorization": {
                "$ref": "#/definitions/authorization"
              },
              "oauth2": {
                "$ref": "#/definitions/oauth2"
              },
              "bearer_token": {
                "$ref": "#/definitions/bearer_token"
              },
              "bearer_token_file": {
                "$ref": "#/definitions/bearer_token_file"
              },
              "tls_config": {
                "$ref": "#/definitions/tls_config",
                "description": "Configures the scrape request's TLS settings."
              },
              "proxy_url": {
                "description": "Optional proxy URL.",
                "type": ["string", "null"],
                "format": "uri-reference"
              },
              "follow_redirects": {
                "description": "Configure whether HTTP requests follow HTTP 3xx redirects.",
                "type": ["boolean", "null"],
                "default": true
              },
              "azure_sd_configs": {
                "$ref": "#/definitions/azure_sd_configs"
              },
              "consul_sd_configs": {
                "$ref": "#/definitions/consul_sd_configs"
              },
              "digitalocean_sd_configs": {
                "$ref": "#/definitions/digitalocean_sd_configs"
              },
              "docker_sd_configs": {
                "$ref": "#/definitions/docker_sd_configs"
              },
              "dockerswarm_sd_configs": {
                "$ref": "#/definitions/dockerswarm_sd_configs"
              },
              "dns_sd_configs": {
                "$ref": "#/definitions/dns_sd_configs"
              },
              "ec2_sd_configs": {
                "$ref": "#/definitions/ec2_sd_configs"
              },
              "eureka_sd_configs": {
                "$ref": "#/definitions/eureka_sd_configs"
              },
              "file_sd_configs": {
                "$ref": "#/definitions/file_sd_configs"
              },
              "gce_sd_configs": {
                "$ref": "#/definitions/gce_sd_configs"
              },
              "hetzner_sd_configs": {
                "$ref": "#/definitions/hetzner_sd_configs"
              },
              "http_sd_configs": {
                "$ref": "#/definitions/http_sd_configs"
              },
              "kubernetes_sd_configs": {
                "$ref": "#/definitions/kubernetes_sd_configs"
              },
              "kuma_sd_configs": {
                "$ref": "#/definitions/kuma_sd_configs"
              },
              "lightsail_sd_configs": {
                "$ref": "#/definitions/lightsail_sd_configs"
              },
              "linode_sd_configs": {
                "$ref": "#/definitions/linode_sd_configs"
              },
              "marathon_sd_configs": {
                "$ref": "#/definitions/marathon_sd_configs"
              },
              "nerve_sd_configs": {
                "$ref": "#/definitions/nerve_sd_configs"
              },
              "openstack_sd_configs": {
                "$ref": "#/definitions/openstack_sd_configs"
              },
              "puppetdb_sd_configs": {
                "$ref": "#/definitions/puppetdb_sd_configs"
              },
              "scaleway_sd_configs": {
                "$ref": "#/definitions/scaleway_sd_configs"
              },
              "serverset_sd_configs": {
                "$ref": "#/definitions/serverset_sd_configs"
              },
              "triton_sd_configs": {
                "$ref": "#/definitions/triton_sd_configs"
              },
              "uyuni_sd_configs": {
                "$ref": "#/definitions/uyuni_sd_configs"
              },
              "static_configs": {
                "$ref": "#/definitions/static_configs",
                "description": "List of labeled statically configured Alertmanagers."
              },
              "relabel_configs": {
                "$ref": "#/definitions/relabel_configs",
                "description": "List of Alertmanager relabel configurations."
              }
            },
            "allOf": [
              {
                "$ref": "#/definitions/auth"
              }
            ]
          }
        }
      }
    },
    "storage": {
      "description": "Storage related settings that are runtime reloadable.",
      "type": ["object", "null"],
      "properties": {
        "tsdb": {
          "type": ["object", "null"],
          "properties": {
            "out_of_order_time_window": {
              "$ref": "#/definitions/duration",
              "description": "Configures how old an out-of-order/out-of-bounds sample can be w.r.t. the TSDB max time.",
              "default": "0s"
            }
          },
          "additionalProperties": false
        },
        "exemplars": {
          "type": ["object", "null"],
          "properties": {
            "max_exemplars": {
              "description": "Configures the maximum size of the circular buffer used to store exemplars for all series. Resizable during runtime.",
              "type": ["integer", "null"],
              "default": 100000
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    }
  },
  "title": "Prometheus",
  "type": ["object", "null"]
}
