{
  "$id": "https://json.schemastore.org/comet.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "PrimitiveType": {
      "type": "string",
      "oneOf": [
        {
          "const": "string",
          "description": ""
        },
        {
          "const": "long",
          "description": ""
        },
        {
          "const": "int",
          "description": ""
        },
        {
          "const": "short",
          "description": ""
        },
        {
          "const": "double",
          "description": ""
        },
        {
          "const": "boolean",
          "description": ""
        },
        {
          "const": "byte",
          "description": ""
        },
        {
          "const": "date",
          "description": ""
        },
        {
          "const": "timestamp",
          "description": ""
        },
        {
          "const": "decimal",
          "description": ""
        },
        {
          "const": "struct",
          "description": ""
        }
      ]
    },
    "IndexMapping": {
      "type": "string",
      "oneOf": [
        {
          "const": "text",
          "description": ""
        },
        {
          "const": "keyword",
          "description": ""
        },
        {
          "const": "long",
          "description": ""
        },
        {
          "const": "integer",
          "description": ""
        },
        {
          "const": "short",
          "description": ""
        },
        {
          "const": "byte",
          "description": ""
        },
        {
          "const": "double",
          "description": ""
        },
        {
          "const": "float",
          "description": ""
        },
        {
          "const": "half_float",
          "description": ""
        },
        {
          "const": "scaled_float",
          "description": ""
        },
        {
          "const": "date",
          "description": ""
        },
        {
          "const": "boolean",
          "description": ""
        },
        {
          "const": "binary",
          "description": ""
        },
        {
          "const": "integer_rang",
          "description": ""
        },
        {
          "const": "float_range",
          "description": ""
        },
        {
          "const": "long_range",
          "description": ""
        },
        {
          "const": "double_range",
          "description": ""
        },
        {
          "const": "date_range",
          "description": ""
        },
        {
          "const": "geo_point",
          "description": ""
        },
        {
          "const": "geo_shape",
          "description": ""
        },
        {
          "const": "ip",
          "description": ""
        },
        {
          "const": "completion",
          "description": ""
        },
        {
          "const": "token_count",
          "description": ""
        },
        {
          "const": "object",
          "description": ""
        },
        {
          "const": "array",
          "description": ""
        }
      ]
    },
    "WriteMode": {
      "description": "Append to or overwrite existing data",
      "type": "string",
      "oneOf": [
        {
          "const": "OVERWRITE",
          "description": ""
        },
        {
          "const": "APPEND",
          "description": ""
        },
        {
          "const": "ERROR_IF_EXISTS",
          "description": ""
        },
        {
          "const": "IGNORE",
          "description": ""
        }
      ]
    },
    "UserType": {
      "type": "string",
      "oneOf": [
        {
          "const": "SA",
          "description": ""
        },
        {
          "const": "USER",
          "description": ""
        },
        {
          "const": "GROUP",
          "description": ""
        }
      ]
    },
    "Trim": {
      "type": "string",
      "oneOf": [
        {
          "const": "LEFT",
          "description": ""
        },
        {
          "const": "RIGHT",
          "description": ""
        },
        {
          "const": "BOTH",
          "description": ""
        },
        {
          "const": "NONE",
          "description": ""
        }
      ]
    },
    "SinkType": {
      "description": "Where to sink the data",
      "type": "string",
      "oneOf": [
        {
          "const": "NONE",
          "description": "Don't sink. This is the default"
        },
        {
          "const": "JBDC",
          "description": "dataset will be sinked to a JDBC Database. See JdbcSink"
        },
        {
          "const": "BQ",
          "description": "Dataset is sinked to BigQuery. See BigQuerySink"
        },
        {
          "const": "ES",
          "description": "Dataset is indexed into Elasticsearch. See EsSink below"
        },
        {
          "const": "FS",
          "description": "Sink to Filesystem"
        },
        {
          "const": "KAFKA",
          "description": "Sink to Kafka"
        }
      ]
    },
    "TableDdl": {
      "description": "Partition columns, no partitioning by default",
      "type": "object",
      "properties": {
        "createSql": {
          "type": "string"
        },
        "pingSql": {
          "type": "string"
        }
      },
      "required": ["createSql"]
    },
    "TableType": {
      "type": "string",
      "oneOf": [
        {
          "const": "TABLE",
          "description": ""
        },
        {
          "const": "VIEW",
          "description": ""
        },
        {
          "const": "SYSTEM TABLE",
          "description": ""
        },
        {
          "const": "GLOBAL TEMPORARY",
          "description": ""
        },
        {
          "const": "LOCAL TEMPORARY",
          "description": ""
        },
        {
          "const": "ALIAS",
          "description": ""
        },
        {
          "const": "SYNONYM",
          "description": ""
        }
      ]
    },
    "Type": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "primitiveType": {
          "$ref": "#/definitions/PrimitiveType"
        },
        "pattern": {
          "type": "string"
        },
        "zone": {
          "type": "string",
          "description": "Useful for timestamp / dates"
        },
        "sample": {
          "type": "string"
        },
        "comment": {
          "type": "string"
        },
        "indexMapping": {
          "type": "string"
        },
        "ddlMapping": {
          "$ref": "#/definitions/MapString",
          "description": "Configure here the type mapping for each datawarehouse.\\nWill be used when inferring DDL from schema."
        }
      },
      "required": ["name", "pattern", "primitiveType"]
    },
    "Partition": {
      "description": "Partition columns, no partitioning by default",
      "type": "object",
      "properties": {
        "sampling": {
          "type": "number",
          "description": "0.0 means no sampling, > 0  && < 1 means sample dataset, >=1 absolute number of partitions."
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "string",
            "description": "Attributes used to partition de dataset."
          }
        }
      },
      "required": []
    },
    "Position": {
      "type": "object",
      "properties": {
        "first": {
          "type": "number"
        },
        "last": {
          "type": "number"
        }
      },
      "required": ["first", "last"]
    },
    "Connection": {
      "description": "Connection",
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "aka jdbc, bigquery, snowflake, redshift ..."
        },
        "sparkFormat": {
          "type": "string",
          "description": "Set only if you want to use the Spark engine"
        },
        "mode": {
          "$ref": "#/definitions/WriteMode",
          "description": "Write mode, APPEND by default"
        },
        "options": {
          "$ref": "#/definitions/MapString",
          "description": "Connection options"
        }
      },
      "required": ["type"]
    },
    "RowLevelSecurity": {
      "description": "Row level security policy to apply to the output data.",
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "This Row Level Security unique name"
        },
        "description": {
          "type": "string",
          "description": "Description for this access policy"
        },
        "predicate": {
          "type": "string",
          "description": "The condition that goes to the WHERE clause and limit the visible rows."
        },
        "grants": {
          "description": "user / groups / service accounts to which this security level is applied.\nex : user:me@mycompany.com,group:group@mycompany.com,serviceAccount:mysa@google-accounts.com",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": ["name", "grants"]
    },
    "AccessControlEntry": {
      "description": "Column level security policy to apply to the attribute.",
      "type": "object",
      "properties": {
        "role": {
          "type": "string",
          "description": "This role to give to the granted users"
        },
        "grants": {
          "description": "user / groups / service accounts to which this security level is applied.\nex : user:me@mycompany.com,group:group@mycompany.com,serviceAccount:mysa@google-accounts.com",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": ["role", "grants"]
    },
    "MergeOptions": {
      "type": "object",
      "properties": {
        "key": {
          "description": "list of attributes to join existing with incoming dataset. Use renamed columns here.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "delete": {
          "type": "string",
          "description": "Optional valid sql condition on the incoming dataset. Use renamed column here."
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp column used to identify last version, if not specified currently ingested row is considered the last"
        },
        "queryFilter": {
          "type": "string"
        }
      },
      "required": ["key"]
    },
    "Format": {
      "description": "DSV by default. Supported file formats are :\\n- DSV : Delimiter-separated values file. Delimiter value is specified in the \"separator\" field.\\n- POSITION : FIXED format file where values are located at an exact position in each line.\\n- SIMPLE_JSON : For optimisation purpose, we differentiate JSON with top level values from JSON\\n  with deep level fields. SIMPLE_JSON are JSON files with top level fields only.\\n- JSON :  Deep JSON file. Use only when your json documents contain subdocuments, otherwise prefer to\\n  use SIMPLE_JSON since it is much faster.\\n- XML : XML files",
      "type": "string",
      "oneOf": [
        {
          "const": "DSV",
          "description": ""
        },
        {
          "const": "POSITION",
          "description": ""
        },
        {
          "const": "JSON",
          "description": ""
        },
        {
          "const": "ARRAY_JSON",
          "description": ""
        },
        {
          "const": "SIMPLE_JSON",
          "description": "Simple Json is made of a single level attributes of simple types (no array or map or sub objects)"
        },
        {
          "const": "XML",
          "description": ""
        }
      ]
    },
    "MapString": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "MapConnection": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Connection"
      }
    },
    "MapJdbcEngine": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/JdbcEngine"
      }
    },
    "MapTableDdl": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/TableDdl"
      }
    },
    "JdbcEngine": {
      "type": "object",
      "properties": {
        "tables": {
          "description": "List of columns to extract. All columns by default.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/MapTableDdl"
          }
        }
      }
    },
    "Privacy": {
      "type": "object",
      "properties": {
        "options": {
          "description": "List of columns to extract. All columns by default.",
          "$ref": "#/definitions/MapString"
        }
      }
    },
    "Internal": {
      "type": "object",
      "properties": {
        "cacheStorageLevel": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        },
        "intermediateBigqueryFormat": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        },
        "temporaryGcsBucket": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        },
        "substituteVars": {
          "description": "List of columns to extract. All columns by default.",
          "type": "boolean"
        }
      }
    },
    "AccessPolicies": {
      "type": "object",
      "properties": {
        "apply": {
          "description": "List of columns to extract. All columns by default.",
          "type": "boolean"
        },
        "location": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        },
        "database": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        },
        "taxonomy": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        }
      }
    },
    "JobScheduling": {
      "type": "object",
      "properties": {
        "maxJobs": {
          "description": "List of columns to extract. All columns by default.",
          "type": "integer"
        },
        "poolName": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        },
        "mode": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        },
        "file": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        }
      }
    },
    "Expectations": {
      "type": "object",
      "properties": {
        "path": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        },
        "active": {
          "description": "List of columns to extract. All columns by default.",
          "type": "boolean"
        }
      }
    },
    "Metrics": {
      "type": "object",
      "properties": {
        "path": {
          "description": "List of columns to extract. All columns by default.",
          "type": "string"
        },
        "discreteMaxCardinality": {
          "description": "List of columns to extract. All columns by default.",
          "type": "integer"
        },
        "active": {
          "description": "List of columns to extract. All columns by default.",
          "type": "boolean"
        }
      }
    },
    "Sink": {
      "type": "object",
      "properties": {
        "options": {
          "$ref": "#/definitions/MapString",
          "description": "spark  options to use"
        },
        "id": {
          "type": "string",
          "description": "ES: Attribute to use as id of the document. Generated by Elasticsearch if not specified."
        },
        "timestamp": {
          "type": "string",
          "description": "ES or BQ: The timestamp column to use for table partitioning if any. No partitioning by default\\nES:Timestamp field format as expected by Elasticsearch (\"{beginTs|yyyy.MM.dd}\" for example)."
        },
        "location": {
          "type": "string",
          "description": "BQ: Database location (EU, US, ...)"
        },
        "clustering": {
          "description": "FS or BQ: List of attributes to use for clustering",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "days": {
          "type": "number",
          "description": "BQ: Number of days before this table is set as expired and deleted. Never by default."
        },
        "requirePartitionFilter": {
          "type": "boolean",
          "description": "BQ: Should be require a partition filter on every request ? No by default."
        },
        "materializedView": {
          "type": "boolean",
          "description": "BQ: Should we materialize as a table or as a view when saving the results ? false by default."
        },
        "enableRefresh": {
          "type": "boolean",
          "description": "BQ: Enable automatic refresh of materialized view ? false by default."
        },
        "refreshIntervalMs": {
          "type": "number",
          "description": "BQ: Refresh interval in milliseconds. Default to BigQuery default value"
        },
        "format": {
          "type": "string",
          "description": "FS: File format"
        },
        "extension": {
          "type": "string",
          "description": "FS: File extension"
        },
        "partition": {
          "$ref": "#/definitions/Partition",
          "description": "FS or BQ: List of partition attributes"
        },
        "connectionRef": {
          "type": "string",
          "description": "JDBC: Connection String"
        },
        "coalesce": {
          "type": "boolean",
          "description": "When outputting files, should we coalesce it to a single file. Useful when CSV is the output format."
        }
      }

    },
    "MapArrayOfString": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "Metadata": {
      "type": "object",
      "properties": {
        "format": {
          "$ref": "#/definitions/Format"
        },
        "encoding": {
          "type": "string",
          "description": "UTF-8 if not specified."
        },
        "multiline": {
          "type": "boolean",
          "description": "are json objects on a single line or multiple line ? Single by default.  false means single. false also means faster"
        },
        "array": {
          "type": "boolean",
          "description": "Is the json stored as a single object array ? false by default. This means that by default we have on json document per line."
        },
        "withHeader": {
          "type": "boolean",
          "description": "does the dataset has a header ? true bu default"
        },
        "separator": {
          "type": "string",
          "description": "the values delimiter,  ';' by default value may be a multichar string starting from Spark3"
        },
        "quote": {
          "type": "string",
          "description": "The String quote char, '\"' by default"
        },
        "escape": {
          "type": "string",
          "description": "escaping char '\\' by default"
        },
        "write": {
          "$ref": "#/definitions/WriteMode",
          "description": "Write mode, APPEND by default"
        },
        "partition": {
          "$ref": "#/definitions/Partition"
        },
        "sink": {
          "$ref": "#/definitions/Sink"
        },
        "ignore": {
          "type": "string",
          "description": "Pattern to ignore or UDF to apply to ignore some lines"
        },
        "xml": {
          "$ref": "#/definitions/MapString",
          "description": "com.databricks.spark.xml options to use (eq. rowTag)"
        },
        "directory": {
          "description": "Folder on the local filesystem where incoming files are stored.\n Typically, this folder will be scanned periodically to move the dataset to the cluster for ingestion.\n                     Files located in this folder are moved to the pending folder for ingestion by the \"import\" command.",
          "type": "string"
        },
        "extensions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "recognized filename extensions. json, csv, dsv, psv are recognized by default.\nOnly files with these extensions will be moved to the pending folder."
        },
        "ack": {
          "description": "Ack extension used for each file. \".ack\" if not specified.\nFiles are moved to the pending folder only once a file with the same name as the source file and with this extension is present.\nTo move a file without requiring an ack file to be present, set explicitly this property to the empty string value \"\".",
          "type": "string"
        },
        "options": {
          "$ref": "#/definitions/MapString",
          "description": "Options to add to the spark reader"
        },
        "validator": {
          "description": "Validator to use, 'spark' or 'native'. Default to 'spark' of SL_VALIDATOR env variable is set to 'native'",
          "type": "string"
        },
        "emptyIsNull": {
          "description": "Treat empty columns as null in DSV files. Default to false",
          "type": "boolean"
        },
        "nullValue": {
          "description": "Treat a specific input string as a null value indicator",
          "type": "string"
        },
        "freshness": {
          "description": "Configure freshness checks on this dataset",
          "$ref": "#/definitions/Freshness"
        },
        "schedule": {
          "type": "string",
          "description": "Cron expression to use for this domain/table"
        },
        "dagRef": {
          "type": "string",
          "description": "Cron expression to use for this domain/table"
        }
      }
    },
    "ExternalDomain": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Schema in SGBDR / Snoflake / Redshift or Dataset in BigQuery"
        },
        "tables": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Tables to scan in this domain"
        }
      }
    },
    "Airflow": {
      "type": "object",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "DAG reference"
        },
        "ingest": {
          "type": "string",
          "description": "Cron expression to use for this domain/table"
        }
      }
    },
    "External": {
      "type": "object",
      "properties": {
        "database": {
          "type": "string",
          "description": "Databse name of Project id in BigQuery"
        },
        "external": {
          "description": "List of domains to scan",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExternalDomain"
          }
        }
      }
    },
    "Area": {
      "type": "object",
      "properties": {
        "pending": {
          "type": "string",
          "description": "Databse name of Project id in BigQuery"
        },
        "unresolved": {
          "description": "List of domains to scan",
          "type": "string"
        },
        "archive": {
          "description": "List of domains to scan",
          "type": "string"
        },
        "ingesting": {
          "description": "List of domains to scan",
          "type": "string"
        },
        "accepted": {
          "description": "List of domains to scan",
          "type": "string"
        },
        "rejected": {
          "description": "List of domains to scan",
          "type": "string"
        },
        "replay": {
          "description": "List of domains to scan",
          "type": "string"
        },
        "business": {
          "description": "List of domains to scan",
          "type": "string"
        },
        "hiveDatabase": {
          "description": "List of domains to scan",
          "type": "string"
        }
      }

    },
    "Freshness": {
      "type": "object",
      "properties": {
        "warn": {
          "type": "string",
          "description": "How old may be teh data before a warning is raised. Use syntax like '3 day' or '2 hour' or '30 minute'"
        },
        "error": {
          "type": "string",
          "description": "How old may be teh data before an error is raised. Use syntax like '3 day' or '2 hour' or '30 minute'"
        }
      }
    },
    "Table": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Schema name, must be unique among all the schemas belonging to the same domain.\n  *                     Will become the hive table name On Premise or BigQuery Table name on GCP."
        },
        "rename": {
          "type": "string",
          "description": "If present, the table is renamed with this name. Useful when use in conjuntion with the 'extract' module"
        },
        "pattern": {
          "description": "filename pattern to which this schema must be applied.\n  *                     This instructs the framework to use this schema to parse any file with a filename that match this pattern.",
          "type": "string"
        },
        "attributes": {
          "description": "Attributes parsing rules.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Attribute"
          }
        },
        "metadata": {
          "$ref": "#/definitions/Metadata",
          "description": "Dataset metadata"
        },
        "merge": {
          "$ref": "#/definitions/MergeOptions"
        },
        "comment": {
          "type": "string",
          "description": "free text"
        },
        "presql": {
          "type": "array",
          "description": "Reserved for future use.",
          "items": {
            "type": "string"
          }
        },
        "postsql": {
          "type": "array",
          "description": "Reserved for future use.",
          "items": {
            "type": "string"
          }
        },
        "tags": {
          "description": "Set of string to attach to this Schema",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "rls": {
          "description": " Row level security on this schema.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RowLevelSecurity"
          }
        },
        "expectations": {
          "$ref": "#/definitions/MapString",
          "description": "Expectations to check after Load / Transform has succeeded"
        },
        "primaryKey": {
          "description": "List of columns that make up the primary key",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "acl": {
          "description": "Map of rolename -> List[Users].",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AccessControlEntry"
          }
        },
        "sample": {
          "description": "Store here a couple of records illustrating the table data.",
          "type": "string"
        },
        "filter": {
          "description": "remove all records that do not match this condition",
          "type": "string"
        },
        "patternSample": {
          "description": "Sample of filename matching this schema",
          "type": "string"
        }
      },
      "required": ["name", "pattern"]
    },
    "Attribute": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Attribute name as defined in the source dataset and as received in the file"
        },
        "type": {
          "type": "string",
          "description": "semantic type of the attribute"
        },
        "array": {
          "type": "boolean",
          "description": "Is it an array ?"
        },
        "required": {
          "type": "boolean",
          "description": "Should this attribute always be present in the source"
        },
        "privacy": {
          "type": "string",
          "description": "Should this attribute be applied a privacy transformation at ingestion time"
        },
        "comment": {
          "type": "string",
          "description": "free text for attribute description"
        },
        "rename": {
          "type": "string",
          "description": "If present, the attribute is renamed with this name"
        },
        "metricType": {
          "type": "string",
          "description": "If present, what kind of stat should be computed for this field"
        },
        "attributes": {
          "type": "array",
          "description": "List of sub-attributes (valid for JSON and XML files only)",
          "items": {
            "$ref": "#/definitions/Attribute"
          }
        },
        "position": {
          "$ref": "#/definitions/Position"
        },
        "default": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "tags": {
          "type": "array",
          "description": "Tags associated with this attribute",
          "items": {
            "type": "string"
          }
        },
        "trim": {
          "$ref": "#/definitions/Trim"
        },
        "script": {
          "type": "string",
          "description": "Scripted field : SQL request on renamed column"
        },
        "foreignKey": {
          "type": "string",
          "description": "If this attribute is a foreign key, reference to [domain.]table[.attribute]"
        },
        "ignore": {
          "type": "boolean",
          "description": "Should this attribute be ignored on ingestion. Default to false"
        },
        "accessPolicy": {
          "type": "string",
          "description": "Policy tag to assign to this attribute. Used for column level security"
        }
      },
      "required": ["name", "type"]
    },
    "AutoTaskDesc": {
      "type": "object",
      "properties": {
        "sql": {
          "type": "string",
          "description": "Main SQL request to execute (do not forget to prefix table names with the database name to avoid conflicts)"
        },
        "database": {
          "type": "string",
          "description": "Output Database (refer to a project id in BigQuery). Default to SL_DATABASE env var if set."
        },
        "domain": {
          "type": "string",
          "description": "Output domain in output Area (Will be the Database name in Hive or Dataset in BigQuery)"
        },
        "table": {
          "type": "string",
          "description": "Dataset Name in output Area (Will be the Table name in Hive & BigQuery)"
        },
        "write": {
          "$ref": "#/definitions/WriteMode"
        },
        "partition": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of columns used for partitioning the output."
        },
        "presql": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of SQL requests to executed before the main SQL request is run"
        },
        "postsql": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of SQL requests to executed after the main SQL request is run"
        },
        "sink": {
          "$ref": "#/definitions/Sink"
        },
        "rls": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RowLevelSecurity"
          }
        },
        "expectations": {
          "$ref": "#/definitions/MapString",
          "description": "Expectations to check after Load / Transform has succeeded"
        },
        "acl": {
          "description": "Map of rolename -> List[Users].",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AccessControlEntry"
          }
        },
        "comment": {
          "type": "string",
          "description": "Output table description"
        },
        "freshness": {
          "description": "Configure freshness checks on the output table",
          "$ref": "#/definitions/Freshness"
        },
        "attributesDesc": {
          "description": "Attributes comments and access policies",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AttributeDesc"
          }
        },
        "python": {
          "type": "string",
          "description": "Python script URI to execute instead of the SQL request"
        },
        "tags": {
          "description": "Set of string to attach to the output table",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "merge": {
          "$ref": "#/definitions/MergeOptions"
        },
        "schedule": {
          "type": "string",
          "description": "Cron expression to use for this task"
        },
        "dagRef": {
          "type": "string",
          "description": "Cron expression to use for this domain/table"
        }
      },
      "required": []
    },
    "Lock": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "Name of the lock"
        },
        "timeout": {
          "type": "integer",
          "description": "Name of the lock"
        },
        "pollTime": {
          "type": "string",
          "description": "Name of the lock"
        },
        "refreshTime": {
          "type": "string",
          "description": "Name of the lock"
        }
      }
    },
    "Audit": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "Main SQL request to execute (do not forget to prefix table names with the database name to avoid conflicts)"
        },
        "sink": {
          "$ref": "#/definitions/Sink",
          "description": "Output Database (refer to a project id in BigQuery). Default to SL_DATABASE env var if set."
        },
        "maxErrors": {
          "type": "string",
          "description": "Output domain in output Area (Will be the Database name in Hive or Dataset in BigQuery)"
        },
        "database": {
          "type": "string",
          "description": "Dataset Name in output Area (Will be the Table name in Hive & BigQuery)"
        },
        "domain": {
          "$ref": "#/definitions/WriteMode"
        },
        "active": {
          "type": "boolean",
          "description": "Output table description"
        }
      },
      "required": []
    },
    "AttributeDesc": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Column name"
        },
        "comment": {
          "type": "string",
          "description": "Column description"
        },
        "accessPolicy": {
          "type": "string",
          "description": "Access policy to apply to this column"
        }
      },
      "required": ["name", "comment"]
    },
    "Domain": {
      "type": "object",
      "description": "A schema in SGBD database or a folder in HDFS or a dataset in BigQuery.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Domain name. Make sure you use a name that may be used as a folder name on the target storage.\n                   - When using HDFS or Cloud Storage,  files once ingested are stored in a sub-directory named after the domain name.\n                   - When used with BigQuery, files are ingested and sorted in tables under a dataset named after the domain name."
        },
        "rename": {
          "type": "string",
          "description": "If present, the attribute is renamed with this name"
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        },
        "tables": {
          "type": "array",
          "description": "List of schemas for each dataset in this domain.\nA domain usually contains multiple schemas. Each schema defining how the contents of the input file should be parsed.\nSee Schema for more details.",
          "items": {
            "$ref": "#/definitions/Table"
          }
        },
        "comment": {
          "description": "Domain Description (free text)",
          "type": "string"
        },
        "database": {
          "description": "Output Database (refer to a project id in BigQuery). Default to SL_DATABASE env var if set.",
          "type": "string"
        },
        "tags": {
          "description": "Set of string to attach to this domain",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "AutoJobDesc": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Optional name. If not specified, the name of the file without the extension is used."
        },
        "default": {
          "$ref": "#/definitions/AutoTaskDesc",
          "description": "Default task properties to apply to all tasks defined in tasks section and in included files"
        },
        "tasks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AutoTaskDesc",
            "description": "List of transform tasks to execute"
          }
        }
      }
    },
    "JDBCTable": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "table name. Set to '*' to extract all tables"
        },
        "columns": {
          "description": "List of columns to extract. All columns by default.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "partitionColumn": {
          "type": "string"
        },
        "numPartitions": {
          "type": "integer"
        },
        "connectionOptions": {
          "type": "string"
        },
        "fetchSize": {
          "type": "integer"
        },
        "fullExport": {
          "type": "boolean"
        }
      },
      "required": ["name"]
    },
    "JDBCSchema": {
      "type": "object",
      "properties": {
        "catalog": {
          "type": "string",
          "description": "Optional catalog name in the source database"
        },
        "schema": {
          "type": "string",
          "description": "Database schema where source tables are located"
        },
        "write": {
          "$ref": "#/definitions/WriteMode"
        },
        "pattern": {
          "type": "string"
        },
        "numericTrim": {
          "$ref": "#/definitions/Trim"
        },
        "partitionColumn": {
          "type": "string"
        },
        "numPartitions": {
          "type": "integer"
        },
        "connectionOptions": {
          "type": "string"
        },
        "fetchSize": {
          "type": "integer"
        },
        "stringPartitionFunc": {
          "type": "string"
        },
        "fullExport": {
          "type": "boolean"
        },
        "tableRemarks": {
          "type": "string"
        },
        "columnRemarks": {
          "type": "string"
        },
        "template": {
          "type": "string",
          "description": "Metadata to use for the generated YAML file."
        },
        "tables": {
          "description": "List of tables to extract",
          "type": "array",
          "items": {
            "$ref": "#/definitions/JDBCTable"
          }
        },
        "tableTypes": {
          "description": "One or many of the predefined table types",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": ["tables"]
    },
    "JDBCSchemas": {
      "type": "object",
      "properties": {
        "jdbcSchemas": {
          "description": "List database connections to use to extract the data",
          "type": "array",
          "items": {
            "$ref": "#/definitions/JDBCSchema"
          }
        },
        "globalJdbcSchema": {
          "$ref": "#/definitions/JDBCSchema"
        },
        "fetchSize": {
          "type": "integer"
        },
        "connectionRef": {
          "type": "string",
          "description": "Connection name as defined in the connections section of the application.conf file"
        },
        "connection": {
          "$ref": "#/definitions/MapString",
          "description": "JDBC connection options: url, user, password ..."
        }
      }
    },
    "RefInput": {
      "description": "Input for ref object",
      "type": "object",
      "properties": {
        "database": {
          "type": "string",
          "description": "Database pattern to match, none if any database"
        },
        "domain": {
          "type": "string",
          "description": "Domain pattern to match, none if any domain matchy"
        },
        "table": {
          "type": "string",
          "description": "Table pattern to match"
        }
      },
      "required": ["table"]
    },
    "RefOutput": {
      "description": "Output for ref object",
      "type": "object",
      "properties": {
        "database": {
          "type": "string",
          "description": ""
        },
        "domain": {
          "type": "string",
          "description": ""
        },
        "table": {
          "type": "string",
          "description": ""
        }
      },
      "required": ["table", "domain", "database"]
    },
    "Ref": {
      "description": "Describe how to resolve a reference in a transform task",
      "type": "object",
      "properties": {
        "input": {
          "$ref": "#/definitions/RefInput",
          "description": "The input table to resolve"
        },
        "output": {
          "$ref": "#/definitions/RefOutput",
          "description": "The output table resolved with the domain and database"
        }
      },
      "required": ["input", "output"]
    },
    "Refs": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/Ref"
      }
    },
    "Application": {
      "type": "object",
      "properties": {
        "env": {
          "type": "string",
          "description": "Attribute name as defined in the source dataset and as received in the file"
        },
        "datasets": {
          "type": "string",
          "description": "semantic type of the attribute"
        },
        "dags": {
          "type": "string",
          "description": "Is it an array ?"
        },
        "metadata": {
          "type": "string",
          "description": "Should this attribute always be present in the source"
        },
        "metrics": {
          "$ref": "#/definitions/Metrics"
        },
        "validateOnLoad": {
          "type": "boolean",
          "description": "Should this attribute be applied a privacy transformation at ingestion time"
        },
        "audit": {
          "$ref": "#/definitions/Audit"
        },
        "archive": {
          "type": "boolean",
          "description": "free text for attribute description"
        },
        "sinkReplayToFile": {
          "type": "boolean",
          "description": "If present, the attribute is renamed with this name"
        },
        "lock": {
          "$ref": "#/definitions/Lock"
        },
        "defaultFormat": {
          "type": "string",
          "description": "If present, what kind of stat should be computed for this field"
        },
        "defaultRejectedWriteFormat": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "defaultAuditWriteFormat": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "csvOutput": {
          "type": "boolean",
          "description": "Default value for this attribute when it is not present."
        },
        "csvOutputExt": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "privacyOnly": {
          "type": "boolean",
          "description": "Default value for this attribute when it is not present."
        },
        "emptyIsNull": {
          "type": "boolean",
          "description": "Default value for this attribute when it is not present."
        },
        "validator": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "rowValidatorClass": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "treeValidatorClass": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "loadStrategyClass": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "analyze": {
          "type": "boolean",
          "description": "Default value for this attribute when it is not present."
        },
        "hive": {
          "type": "boolean",
          "description": "Default value for this attribute when it is not present."
        },
        "grouped": {
          "type": "boolean",
          "description": "Default value for this attribute when it is not present."
        },
        "groupedMax": {
          "type": "integer",
          "description": "Default value for this attribute when it is not present."
        },
        "mergeForceDistinct": {
          "type": "boolean",
          "description": "Default value for this attribute when it is not present."
        },
        "mergeOptimizePartitionWrite": {
          "type": "boolean",
          "description": "Default value for this attribute when it is not present."
        },
        "area": {
          "$ref": "#/definitions/Area",
          "description": "Default value for this attribute when it is not present."
        },
        "airflow": {
          "$ref": "#/definitions/Airflow",
          "description": "Default value for this attribute when it is not present."
        },
        "hadoop": {
          "$ref": "#/definitions/MapString",
          "description": "Default value for this attribute when it is not present."
        },
        "connections": {
          "$ref": "#/definitions/MapConnection",
          "description": "Default value for this attribute when it is not present."
        },
        "jdbcEngines": {
          "$ref": "#/definitions/MapJdbcEngine",
          "description": "Default value for this attribute when it is not present."
        },
        "privacy": {
          "$ref": "#/definitions/Privacy",
          "description": "Default value for this attribute when it is not present."
        },
        "root": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "internal": {
          "$ref": "#/definitions/Internal",
          "description": "Default value for this attribute when it is not present."
        },
        "accessPolicies": {
          "$ref": "#/definitions/AccessPolicies",
          "description": "Default value for this attribute when it is not present."
        },
        "scheduling": {
          "$ref": "#/definitions/JobScheduling",
          "description": "Default value for this attribute when it is not present."
        },
        "udfs": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "expectations": {
          "$ref": "#/definitions/Expectations",
          "description": "Default value for this attribute when it is not present."
        },
        "sqlParameterPattern": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "rejectAllOnError": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "rejectMaxRecords": {
          "type": "integer",
          "description": "Default value for this attribute when it is not present."
        },
        "maxParCopy": {
          "type": "integer",
          "description": "Default value for this attribute when it is not present."
        },
        "dsvOptions": {
          "$ref": "#/definitions/MapString",
          "description": "Default value for this attribute when it is not present."
        },
        "forceViewPattern": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "forceDomainPattern": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "forceTablePattern": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "forceJobPattern": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "forceTaskPattern": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "useLocalFileSystem": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "sessionDurationServe": {
          "type": "integer",
          "description": "Default value for this attribute when it is not present."
        },
        "database": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "tenant": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        },
        "connectionRef": {
          "type": "string",
          "description": "Default value for this attribute when it is not present."
        }
      },
      "required": ["name", "type"]
    }
  },
  "description": "JSON Schema for Starlake Data Pipeline",
  "oneOf": [
    {
      "required": ["extract"]
    },
    {
      "required": ["load"]
    },
    {
      "required": ["transform"]
    },
    {
      "required": ["expectations"]
    },
    {
      "required": ["env"]
    },
    {
      "required": ["types"]
    },
    {
      "required": ["tables"]
    },
    {
      "required": ["table"]
    },
    {
      "required": ["task"]
    },
    {
      "required": ["connections"]
    },
    {
      "required": ["external"]
    },
    {
      "required": ["application"]
    },
    {
      "required": ["refs"]
    }
  ],
  "properties": {
    "types": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/Type"
      }
    },
    "extract": {
      "$ref": "#/definitions/JDBCSchemas"
    },
    "load": {
      "$ref": "#/definitions/Domain"
    },
    "transform": {
      "$ref": "#/definitions/AutoJobDesc"
    },
    "task": {
      "$ref": "#/definitions/AutoTaskDesc"
    },
    "env": {
      "$ref": "#/definitions/MapString"
    },
    "expectations": {
      "$ref": "#/definitions/MapString",
      "description": "Expectations library defined as a map name(params) -> sql request that should return 0 record"
    },
    "table": {
      "$ref": "#/definitions/Table"
    },
    "external": {
      "$ref": "#/definitions/External"
    },
    "refs": {
      "$ref": "#/definitions/Refs"
    },
    "application": {
      "$ref": "#/definitions/Application"
    }
  },
  "title": "Starlake Data Pipeline",
  "type": "object"
}
