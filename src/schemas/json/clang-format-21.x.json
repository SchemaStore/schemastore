{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://json.schemastore.org/clang-format-21.x.json",
  "$defs": {},
  "additionalProperties": {},
  "description": "The .clang-format file is a YAML file defining formatting styles used by clang-format.\n\nsee https://clang.llvm.org/docs/ClangFormatStyleOptions.html",
  "patternProperties": {
    "^x-": {
      "$comment": "yaml marker for multiple documents in one single yaml file"
    }
  },
  "properties": {
    "BasedOnStyle": {
      "$comment": "clang-format ignores cases. For the sake of consistency, use one of following enums",
      "description": "The style used for all options not specifically set in the configuration.",
      "type": "string",
      "enum": [
        "Chromium",
        "Google",
        "LLVM",
        "Mozilla",
        "WebKit",
        "Microsoft",
        "GNU",
        "InheritParentConfig",
        "chromium",
        "google",
        "llvm",
        "mozilla",
        "webkit",
        "microsoft",
        "gnu",
        "inheritparentconfig"
      ]
    },
    "AccessModifierOffset": {
      "description": "clang-format 3.3\n\nThe extra indent or outdent of access modifiers, e.g. public:.",
      "type": "integer"
    },
    "AlignAfterOpenBracket": {
      "description": "clang-format 3.8\n\nThis applies to round brackets (parentheses), angle brackets and square brackets.",
      "type": "string",
      "enum": ["Align", "DontAlign", "AlwaysBreak", "BlockIndent"]
    },
    "AlignArrayOfStructures": {
      "description": "clang-format 13\n\nIf not None, when using initialization for an array of structs aligns the fields into columns.\n\nNOTE: As of clang-format 15 this option only applied to arrays with equal number of columns per row.",
      "type": "string",
      "enum": ["None", "Left", "Right"]
    },
    "AlignConsecutiveMacros": {
      "oneOf": [
        {
          "description": "clang-format 9\n\nStyle of aligning consecutive macros.",
          "type": "string",
          "enum": [
            "None",
            "Consecutive",
            "AcrossEmptyLines",
            "AcrossComments",
            "AcrossEmptyLinesAndComments"
          ]
        },
        {
          "description": "clang-format 15\n\nAlignment options.",
          "type": "object",
          "properties": {
            "Enabled": {
              "description": "Whether aligning is enabled.",
              "type": "boolean"
            },
            "AcrossEmptyLines": {
              "description": "Whether to align across empty lines.",
              "type": "boolean"
            },
            "AcrossComments": {
              "description": "Whether to align across comments.",
              "type": "boolean"
            }
          }
        }
      ]
    },
    "AlignConsecutiveAssignments": {
      "oneOf": [
        {
          "description": "clang-format 3.8\n\nStyle of aligning consecutive assignments.",
          "type": "string",
          "enum": [
            "None",
            "Consecutive",
            "AcrossEmptyLines",
            "AcrossComments",
            "AcrossEmptyLinesAndComments"
          ]
        },
        {
          "description": "clang-format 15\n\nAlignment options.",
          "type": "object",
          "properties": {
            "Enabled": {
              "description": "Whether aligning is enabled.",
              "type": "boolean"
            },
            "AcrossEmptyLines": {
              "description": "Whether to align across empty lines.",
              "type": "boolean"
            },
            "AcrossComments": {
              "description": "Whether to align across comments.",
              "type": "boolean"
            },
            "AlignCompound": {
              "description": "Whether compound assignments like += are aligned along with =.",
              "type": "boolean"
            },
            "PadOperators": {
              "description": "Whether short assignment operators are left-padded to the same length as long ones in order to put all assignment operators to the right of the left hand side.",
              "type": "boolean"
            }
          }
        }
      ]
    },
    "AlignConsecutiveBitFields": {
      "oneOf": [
        {
          "description": "clang-format 11\n\nStyle of aligning consecutive bit fields.",
          "type": "string",
          "enum": [
            "None",
            "Consecutive",
            "AcrossEmptyLines",
            "AcrossComments",
            "AcrossEmptyLinesAndComments"
          ]
        },
        {
          "description": "clang-format 15\n\nAlignment options.",
          "type": "object",
          "properties": {
            "Enabled": {
              "description": "Whether aligning is enabled.",
              "type": "boolean"
            },
            "AcrossEmptyLines": {
              "description": "Whether to align across empty lines.",
              "type": "boolean"
            },
            "AcrossComments": {
              "description": "Whether to align across comments.",
              "type": "boolean"
            }
          }
        }
      ]
    },
    "AlignConsecutiveDeclarations": {
      "oneOf": [
        {
          "description": "clang-format 3.8\n\nStyle of aligning consecutive declarations.",
          "type": "string",
          "enum": [
            "None",
            "Consecutive",
            "AcrossEmptyLines",
            "AcrossComments",
            "AcrossEmptyLinesAndComments"
          ]
        },
        {
          "description": "clang-format 15\n\nAlignment options.",
          "type": "object",
          "properties": {
            "Enabled": {
              "description": "Whether aligning is enabled.",
              "type": "boolean"
            },
            "AcrossEmptyLines": {
              "description": "Whether to align across empty lines.",
              "type": "boolean"
            },
            "AcrossComments": {
              "description": "Whether to align across comments.",
              "type": "boolean"
            },
            "AlignFunctionPointers": {
              "description": "Whether function pointers are aligned.",
              "type": "boolean"
            }
          }
        }
      ]
    },
    "AlignConsecutiveShortCaseStatements": {
      "description": "clang-format 17\n\nStyle of aligning consecutive short case labels.",
      "type": "object",
      "properties": {
        "Enabled": {
          "description": "Whether aligning is enabled.",
          "type": "boolean"
        },
        "AcrossEmptyLines": {
          "description": "Whether to align across empty lines.",
          "type": "boolean"
        },
        "AcrossComments": {
          "description": "Whether to align across comments.",
          "type": "boolean"
        },
        "AlignCaseColons": {
          "description": "Whether aligned case labels are aligned on the colon or on the tokens after the colon.",
          "type": "boolean"
        },
        "AlignCaseArrows": {
          "description": "Whether to align the case arrows when aligning short case expressions.",
          "type": "boolean"
        }
      }
    },
    "AlignEscapedNewlines": {
      "description": "clang-format 5\n\nOptions for aligning backslashes in escaped newlines.",
      "type": "string",
      "enum": ["Left", "Right", "DontAlign", "LeftWithLastLine"]
    },
    "AlignOperands": {
      "description": "clang-format 3.5\n\nIf true, horizontally align operands of binary and ternary expressions.",
      "type": "string",
      "enum": ["Align", "DontAlign", "AlignAfterOperator"]
    },
    "AlignTrailingComments": {
      "oneOf": [
        {
          "description": "clang-format 3.7\n\nControl of trailing comments.\n\nNOTE: In clang-format 16 this option is not a bool but can be set to the options. Conventional bool options still can be parsed as before.",
          "type": "boolean"
        },
        {
          "description": "clang-format 16\n\nAlignment options.",
          "type": "object",
          "properties": {
            "Kind": {
              "description": "Specifies the way to align trailing comments.",
              "enum": ["Leave", "Always", "Never"],
              "type": "string"
            },
            "OverEmptyLines": {
              "description": "How many empty lines to apply alignment.",
              "minimum": 0,
              "type": "integer"
            }
          }
        }
      ],
      "description": "Control of trailing comments."
    },
    "AllowAllArgumentsOnNextLine": {
      "description": "clang-format 9\n\nIf a function call or braced initializer list doesn't fit on a line, allow putting all arguments onto the next line, even if BinPackArguments is false.",
      "type": "boolean"
    },
    "AllowAllConstructorInitializersOnNextLine": {
      "description": "clang-format 9\n\nThis option is deprecated in clang-format 15. See NextLine of PackConstructorInitializers.\n\nIf a constructor definition with a member initializer list doesn't fit on a single line, allow putting all member initializers onto the next line, if `ConstructorInitializerAllOnOneLineOrOnePerLine` is true. Note that this parameter has no effect if `ConstructorInitializerAllOnOneLineOrOnePerLine` is false.",
      "type": "boolean"
    },
    "AllowAllParametersOfDeclarationOnNextLine": {
      "description": "clang-format 3.3\n\nIf the function declaration doesn't fit on a line, allow putting all parameters of a function declaration onto the next line even if BinPackParameters is false.",
      "type": "boolean"
    },
    "AllowBreakBeforeNoexceptSpecifier": {
      "description": "clang-format 18\n\nControls if there could be a line break before a noexcept specifier.",
      "type": "string",
      "enum": ["Never", "OnlyWithParen", "Always"]
    },
    "AllowShortEnumsOnASingleLine": {
      "description": "clang-format 11\n\nAllow short enums on a single line.",
      "type": "boolean"
    },
    "AllowShortBlocksOnASingleLine": {
      "description": "clang-format 3.5\n\nDependent on the value, while (true) { continue; } can be put on a single line.",
      "type": "string",
      "enum": ["Never", "Empty", "Always"]
    },
    "AllowShortCaseLabelsOnASingleLine": {
      "description": "clang-format 3.6\n\nIf true, short case labels will be contracted to a single line.",
      "type": "boolean"
    },
    "AllowShortCompoundRequirementOnASingleLine": {
      "description": "clang-format 18\n\nAllow short compound requirement on a single line.",
      "type": "boolean"
    },
    "AllowShortFunctionsOnASingleLine": {
      "description": "clang-format 3.5\n\nDependent on the value, int f() { return 0; } can be put on a single line.",
      "type": "string",
      "enum": ["All", "None", "Inline", "Empty", "InlineOnly"]
    },
    "AllowShortLambdasOnASingleLine": {
      "description": "clang-format 9\n\nDependent on the value, auto lambda []() { return 0; } can be put on a single line.",
      "type": "string",
      "enum": ["None", "Empty", "Inline", "All"]
    },
    "AllowShortIfStatementsOnASingleLine": {
      "description": "clang-format 3.3\n\nDependent on the value, if (a) return; can be put on a single line.",
      "type": "string",
      "enum": ["AllIfsAndElse", "Never", "WithoutElse", "OnlyFirstIf"]
    },
    "AllowShortLoopsOnASingleLine": {
      "description": "clang-format 3.7\n\nIf true, while (true) continue; can be put on a single line.",
      "type": "boolean"
    },
    "AlwaysBreakAfterDefinitionReturnType": {
      "description": "clang-format 3.7\n\nThis option is deprecated and is retained for backwards compatibility.\n\nThe function definition return type breaking style to use. This option is deprecated and is retained for backwards compatibility",
      "type": "string",
      "enum": ["None", "All", "TopLevel"]
    },
    "AlwaysBreakAfterReturnType": {
      "$ref": "#/properties/BreakAfterReturnType",
      "description": "clang-format 3.8\n\nDeprecated. This option is renamed to BreakAfterReturnType.\n\nThe function declaration return type breaking style to use."
    },
    "AlwaysBreakBeforeMultilineStrings": {
      "description": "clang-format 3.4\n\nIf true, always break before multiline string literals.",
      "type": "boolean"
    },
    "AlwaysBreakTemplateDeclarations": {
      "$ref": "#/properties/BreakTemplateDeclarations",
      "description": "clang-format 7\n\nDeprecated. This option is renamed to BreakTemplateDeclarations.\n\nThe template declaration breaking style to use."
    },
    "AttributeMacros": {
      "description": "clang-format 12\n\nA vector of strings that should be interpreted as attributes/qualifiers instead of identifiers. This can be useful for language extensions or static analyzer annotations.",
      "type": "array",
      "items": {
        "type": "string",
        "examples": ["__capability", "__output", "__ununsed"]
      }
    },
    "BinPackArguments": {
      "description": "clang-format 3.7\n\nIf false, a function call's arguments will either be all on the same line or will have one line each.",
      "type": "boolean"
    },
    "BinPackParameters": {
      "description": "clang-format 3.7\n\nThe bin pack parameters style to use.",
      "type": "string",
      "enum": ["BinPack", "OnePerLine", "AlwaysOnePerLine"]
    },
    "BitFieldColonSpacing": {
      "description": "clang-format 12\n\nThe BitFieldColonSpacingStyle to use for bitfields.",
      "type": "string",
      "enum": ["Both", "None", "Before", "After"]
    },
    "BraceWrapping": {
      "description": "clang-format 3.8\n\nControl of individual brace wrapping cases. If BreakBeforeBraces is set to Custom, use this to specify how each individual brace case should be handled. Otherwise, this is ignored.",
      "type": "object",
      "properties": {
        "AfterCaseLabel": {
          "description": "Wrap case labels.",
          "type": "boolean"
        },
        "AfterClass": {
          "description": "Wrap class definitions.",
          "type": "boolean"
        },
        "AfterControlStatement": {
          "description": "Wrap control statements (if/for/while/switch/...).",
          "type": "string",
          "enum": ["Never", "MultiLine", "Always"]
        },
        "AfterEnum": {
          "description": "Wrap enum definitions.",
          "type": "boolean"
        },
        "AfterFunction": {
          "description": "Wrap function definitions.",
          "type": "boolean"
        },
        "AfterNamespace": {
          "description": "Wrap namespace definitions.",
          "type": "boolean"
        },
        "AfterObjCDeclaration": {
          "description": "Wrap ObjC definitions (interfaces, implementations…). @autoreleasepool and @synchronized blocks are wrapped according to AfterControlStatement flag.",
          "type": "boolean"
        },
        "AfterStruct": {
          "description": "Wrap struct definitions.",
          "type": "boolean"
        },
        "AfterUnion": {
          "description": "Wrap union definitions.",
          "type": "boolean"
        },
        "AfterExternBlock": {
          "description": "Wrap extern blocks.",
          "type": "boolean"
        },
        "BeforeCatch": {
          "description": "Wrap before catch.",
          "type": "boolean"
        },
        "BeforeElse": {
          "description": "Wrap before else.",
          "type": "boolean"
        },
        "BeforeLambdaBody": {
          "description": "Wrap lambda block.",
          "type": "boolean"
        },
        "BeforeWhile": {
          "description": "Wrap before while.",
          "type": "boolean"
        },
        "IndentBraces": {
          "description": "Indent the wrapped braces themselves.",
          "type": "boolean"
        },
        "SplitEmptyFunction": {
          "description": "If false, empty function body can be put on a single line. This option is used only if the opening brace of the function has already been wrapped, i.e. the AfterFunction brace wrapping mode is set, and the function could/should not be put on a single line (as per AllowShortFunctionsOnASingleLine and constructor formatting options).",
          "type": "boolean"
        },
        "SplitEmptyRecord": {
          "description": "If false, empty record (e.g. class, struct or union) body can be put on a single line. This option is used only if the opening brace of the record has already been wrapped, i.e. the AfterClass (for classes) brace wrapping mode is set.",
          "type": "boolean"
        },
        "SplitEmptyNamespace": {
          "description": "If false, empty namespace body can be put on a single line. This option is used only if the opening brace of the namespace has already been wrapped, i.e. the AfterNamespace brace wrapping mode is set.",
          "type": "boolean"
        }
      }
    },
    "BracedInitializerIndentWidth": {
      "description": "clang-format 17\n\nThe number of columns to use to indent the contents of braced init lists. If unset or negative, ContinuationIndentWidth is used.",
      "type": "integer"
    },
    "BreakAdjacentStringLiterals": {
      "description": "clang-format 18\n\nBreak between adjacent string literals.",
      "type": "boolean"
    },
    "BreakAfterAttributes": {
      "description": "clang-format 16\n\nBreak after a group of C++11 attributes before a function declaration/definition name.",
      "type": "string",
      "enum": ["Always", "Leave", "Never"]
    },
    "BreakAfterJavaFieldAnnotations": {
      "description": "clang-format 3.8\n\nBreak after each annotation on a field in Java files.",
      "type": "boolean"
    },
    "BreakArrays": {
      "description": "clang-format 16\n\nIf true, clang-format will always break after a Json array [ otherwise it will scan until the closing ] to determine if it should add newlines between elements (prettier compatible).",
      "type": "boolean"
    },
    "BreakBeforeInlineASMColon": {
      "description": "clang-format 16\n\nThe inline ASM colon style to use..",
      "type": "string",
      "enum": ["Never", "OnlyMultiline", "Always"]
    },
    "BreakBeforeBinaryOperators": {
      "description": "clang-format 3.6\n\nThe way to wrap binary operators.",
      "type": "string",
      "enum": ["None", "NonAssignment", "All"]
    },
    "BreakBeforeBraces": {
      "description": "clang-format 3.7\n\nThe brace breaking style to use.",
      "type": "string",
      "enum": [
        "Attach",
        "Linux",
        "Mozilla",
        "Stroustrup",
        "Allman",
        "Whitesmiths",
        "GNU",
        "WebKit",
        "Custom"
      ]
    },
    "BreakBeforeConceptDeclarations": {
      "description": "clang-format 12\n\nThe concept declaration style to use.",
      "enum": ["Never", "Allowed", "Always"],
      "type": "string"
    },
    "BreakBeforeTernaryOperators": {
      "description": "clang-format 3.7\n\nIf true, ternary operators will be placed after line breaks.",
      "type": "boolean"
    },
    "BreakConstructorInitializers": {
      "description": "clang-format 5\n\nThe constructor initializers style to use.",
      "type": "string",
      "enum": ["BeforeColon", "BeforeComma", "AfterColon"]
    },
    "BreakInheritanceList": {
      "description": "clang-format 7\n\nThe inheritance list style to use.",
      "type": "string",
      "enum": ["BeforeColon", "BeforeComma", "AfterColon", "AfterComma"]
    },
    "BreakStringLiterals": {
      "description": "clang-format 3.9\n\nAllow breaking string literals when formatting.",
      "type": "boolean"
    },
    "ColumnLimit": {
      "description": "clang-format 3.7\n\nThe column limit.",
      "type": "integer",
      "minimum": 0
    },
    "CommentPragmas": {
      "description": "clang-format 3.7\n\nA regular expression that describes comments with special meaning, which should not be split into lines or otherwise changed.",
      "type": "string"
    },
    "CompactNamespaces": {
      "description": "clang-format 5\n\nIf true, consecutive namespace declarations will be on the same line. If false, each namespace is declared on a new line.",
      "type": "boolean"
    },
    "ConstructorInitializerAllOnOneLineOrOnePerLine": {
      "description": "clang-format 3.7\n\nThis option is deprecated. See CurrentLine of PackConstructorInitializers.",
      "type": "boolean"
    },
    "ConstructorInitializerIndentWidth": {
      "description": "clang-format 3.7\n\nThe number of characters to use for indentation of constructor initializer lists as well as inheritance lists.",
      "type": "integer",
      "minimum": 0
    },
    "ContinuationIndentWidth": {
      "description": "clang-format 3.7\n\nIndent width for line continuations.",
      "type": "integer",
      "minimum": 0
    },
    "Cpp11BracedListStyle": {
      "description": "clang-format 3.4\n\nIf true, format braced lists as best suited for C++11 braced lists.",
      "type": "boolean"
    },
    "DeriveLineEnding": {
      "description": "clang-format 10\n\nDeprecated. See DeriveLF and DeriveCRLF of LineEnding.",
      "type": "boolean"
    },
    "DerivePointerAlignment": {
      "description": "clang-format 3.7\n\nIf true, analyze the formatted file for the most common alignment of & and *. Pointer and reference alignment styles are going to be updated according to the preferences found in the file. PointerAlignment is then used only as fallback.",
      "type": "boolean"
    },
    "DisableFormat": {
      "description": "clang-format 3.7\n\nDisables formatting completely.",
      "type": "boolean"
    },
    "EmptyLineAfterAccessModifier": {
      "description": "clang-format 13\n\nDefines when to put an empty line after access modifiers. EmptyLineBeforeAccessModifier configuration handles the number of empty lines between two access modifiers.",
      "type": "string",
      "enum": ["Never", "Leave", "Always"]
    },
    "EmptyLineBeforeAccessModifier": {
      "description": "clang-format 12\n\nDefines in which cases to put empty line before access modifiers.",
      "type": "string",
      "enum": ["LogicalBlock", "Never", "Leave", "Always"]
    },
    "ExperimentalAutoDetectBinPacking": {
      "description": "clang-format 3.7\n\nIf true, clang-format detects whether function calls and definitions are formatted with one parameter per line.",
      "type": "boolean"
    },
    "FixNamespaceComments": {
      "description": "clang-format 5\n\nIf true, clang-format adds missing namespace end comments for namespaces and fixes invalid existing ones. This doesn't affect short namespaces, which are controlled by ShortNamespaceLines.",
      "type": "boolean"
    },
    "ForEachMacros": {
      "description": "clang-format 3.7\n\nA vector of macros that should be interpreted as foreach loops instead of as function calls.",
      "type": "array",
      "items": {
        "type": "string",
        "examples": ["foreach", "Q_FOREACH", "BOOST_FOREACH"]
      }
    },
    "IfMacros": {
      "description": "clang-format 13\n\nA vector of macros that should be interpreted as conditionals instead of as function calls.",
      "type": "array",
      "items": {
        "type": "string",
        "examples": ["KJ_IF_MAYBE"]
      }
    },
    "IncludeBlocks": {
      "description": "clang-format 6\n\nDependent on the value, multiple #include blocks can be sorted as one and divided based on category.",
      "type": "string",
      "enum": ["Regroup", "Preserve", "Merge"]
    },
    "IncludeCategories": {
      "description": "clang-format 3.8\n\nRegular expressions denoting the different #include categories used for ordering #includes.\n\nPOSIX extended regular expressions are supported.\n\nThese regular expressions are matched against the filename of an include (including the <> or \"\") in order. The value belonging to the first matching regular expression is assigned and #includes are sorted first according to increasing category number and then alphabetically within each category.\n\nIf none of the regular expressions match, INT_MAX is assigned as category.The main header for a source file automatically gets category 0. so that it is generally kept at the beginning of the #includes (https://llvm.org/docs/CodingStandards.html#include-style). However, you can also assign negative priorities if you have certain headers that always need to be first. \r There is a third and optional field SortPriority which can used while IncludeBlocks = IBS_Regroup to define the priority in which #includes should be ordered. The value of Priority defines the order of #include blocks and also allows the grouping of #includes of different priority. SortPriority is set to the value of Priority as default if it is not assigned.\n\nEach regular expression can be marked as case sensitive with the field CaseSensitive, per default it is not.",
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "Regex": {
            "type": "string"
          },
          "Priority": {
            "type": "integer"
          },
          "SortPriority": {
            "type": "integer"
          },
          "CaseSensitive": {
            "type": "boolean"
          }
        },
        "required": ["Regex", "Priority"]
      }
    },
    "IncludeIsMainRegex": {
      "description": "clang-format 3.9\n\nSpecify a regular expression of suffixes that are allowed in the file-to-main-include mapping.\rWhen guessing whether a #include is the \"main\" include (to assign category 0, see above), use this regex of allowed suffixes to the header stem. A partial match is done, so that: - \"\" means \"arbitrary suffix\" - \"$\" means \"no suffix\"\rFor example, if configured to \"(_test)?$\", then a header a.h would be seen as the \"main\" include in both a.cc and a_test.cc.",
      "type": "string"
    },
    "IncludeIsMainSourceRegex": {
      "description": "clang-format 10\n\nSpecify a regular expression for files being formatted that are allowed to be considered \"main\" in the file-to-main-include mapping.\rBy default, clang-format considers files as \"main\" only when they end with: .c, .cc, .cpp, .c++, .cxx, .m or .mm extensions. For these files a guessing of \"main\" include takes place (to assign category 0, see above). This config option allows for additional suffixes and extensions for files to be considered as \"main\".\rBy default, clang-format considers files as \"main\" only when they end with: .c, .cc, .cpp, .c++, .cxx, .m or .mm extensions. For these files a guessing of \"main\" include takes place (to assign category 0, see above). This config option allows for additional suffixes and extensions for files to be considered as \"main\". ",
      "type": "string"
    },
    "IndentAccessModifiers": {
      "description": "clang-format 13\n\nSpecify whether access modifiers should have their own indentation level.\rWhen false, access modifiers are indented (or outdented) relative to the record members, respecting the AccessModifierOffset. Record members are indented one level below the record. When true, access modifiers get their own indentation level. As a consequence, record members are always indented 2 levels below the record, regardless of the access modifier presence. Value of the AccessModifierOffset is ignored.",
      "type": "boolean"
    },
    "IndentCaseBlocks": {
      "description": "clang-format 11\n\nIndent case label blocks one level from the case label.\rWhen false, the block following the case label uses the same indentation level as for the case label, treating the case label the same as an if-statement. When true, the block gets indented as a scope block.",
      "type": "boolean"
    },
    "IndentCaseLabels": {
      "description": "clang-format 3.3\n\nIndent case labels one level from the switch statement.\rWhen false, use the same indentation level as for the switch statement. Switch statement body is always indented one level more than case labels (except the first block following the case label, which itself indents the code - unless IndentCaseBlocks is enabled).",
      "type": "boolean"
    },
    "IndentExternBlock": {
      "description": "clang-format 11\n\nIndentExternBlockStyle is the type of indenting of extern blocks.",
      "type": "string",
      "enum": ["AfterExternBlock", "NoIndent", "Indent"]
    },
    "IndentGotoLabels": {
      "description": "clang-format 10\n\nIndent goto labels.\rWhen false, goto labels are flushed left.",
      "type": "boolean"
    },
    "IndentPPDirectives": {
      "description": "clang-format 6\n\nThe preprocessor directive indenting style to use.",
      "type": "string",
      "enum": ["None", "AfterHash", "BeforeHash"]
    },
    "IndentRequiresClause": {
      "description": "clang-format 15\n\nIndent the requires clause in a template. This only applies when RequiresClausePosition is OwnLine, or WithFollowing.",
      "type": "boolean"
    },
    "IndentRequires": {
      "description": "clang-format 12-14\n\nIndent the requires clause in a template. This only applies when RequiresClausePosition is OwnLine, or WithFollowing. In clang-format 12, 13 and 14 it was named IndentRequires.",
      "type": "boolean"
    },
    "IndentWidth": {
      "description": "clang-format 3.7\n\nThe number of columns to use for indentation.",
      "type": "integer",
      "minimum": 0
    },
    "IndentWrappedFunctionNames": {
      "description": "clang-format 3.7\n\nIndent if a function definition or declaration is wrapped after the type.",
      "type": "boolean"
    },
    "InsertBraces": {
      "description": "clang-format 15\n\nInsert braces after control statements (if, else, for, do, and while) in C++ unless the control statements are inside macro definitions or the braces would enclose preprocessor directives.\n\nWarning: Setting this option to true could lead to incorrect code formatting due to clang-format's lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.",
      "type": "boolean"
    },
    "InsertNewlineAtEOF": {
      "description": "clang-format 16\n\nInsert a newline at end of file if missing.",
      "type": "boolean"
    },
    "InsertTrailingCommas": {
      "description": "clang-format 11\n\nIf set to TCS_Wrapped will insert trailing commas in container literals (arrays and objects) that wrap across multiple lines. It is currently only available for JavaScript and disabled by default TCS_None. InsertTrailingCommas cannot be used together with BinPackArguments as inserting the comma disables bin-packing.",
      "type": "string",
      "enum": ["None", "Wrapped"]
    },
    "IntegerLiteralSeparator": {
      "description": "clang-format 16\n\nFormat integer literal separators (' for C++ and _ for C#, Java, and JavaScript).\n\nSeparator format of integer literals of different bases. If negative, remove separators. If 0, leave the literal as is. If positive, insert separators between digits starting from the rightmost digit.\n\nYou can also specify a minimum number of digits (BinaryMinDigits, DecimalMinDigits, and HexMinDigits) the integer literal must have in order for the separators to be inserted.",
      "type": "object",
      "properties": {
        "Binary": {
          "description": "Format separators in binary literals.",
          "type": "integer"
        },
        "BinaryMinDigits": {
          "description": "Format separators in binary literals with a minimum number of digits.",
          "type": "integer"
        },
        "Decimal": {
          "description": "Format separators in decimal literals.",
          "type": "integer"
        },
        "DecimalMinDigits": {
          "description": "Format separators in decimal literals with a minimum number of digits.",
          "type": "integer"
        },
        "Hex": {
          "description": "Format separators in hexadecimal literals",
          "type": "integer"
        },
        "HexMinDigits": {
          "description": "Format separators in hexadecimal literals with a minimum number of digits.",
          "type": "integer"
        }
      }
    },
    "JavaScriptQuotes": {
      "description": "clang-format 3.9\n\nThe JavaScriptQuoteStyle to use for JavaScript strings.",
      "type": "string",
      "enum": ["Leave", "Single", "Double"]
    },
    "JavaScriptWrapImports": {
      "description": "clang-format 3.9\n\nWhether to wrap JavaScript import/export statements.",
      "type": "boolean"
    },
    "KeepEmptyLinesAtEOF": {
      "description": "clang-format 17\n\nThis option is deprecated. See AtEndOfFile of KeepEmptyLines.",
      "type": "boolean"
    },
    "KeepEmptyLinesAtTheStartOfBlocks": {
      "description": "clang-format 3.7\n\nThis option is deprecated. See AtStartOfBlock of KeepEmptyLines.",
      "type": "boolean"
    },
    "LambdaBodyIndentation": {
      "description": "clang-format 13\n\nThe indentation style of lambda bodies. Signature (the default) causes the lambda body to be indented one additional level relative to the indentation level of the signature. OuterScope forces the lambda body to be indented one additional level relative to the parent scope containing the lambda signature.",
      "type": "string",
      "enum": ["Signature", "OuterScope"]
    },
    "Language": {
      "description": "clang-format 3.5\n\nLanguage, this format style is targeted at.",
      "type": "string",
      "enum": [
        "None",
        "C",
        "Cpp",
        "CSharp",
        "Java",
        "JavaScript",
        "Json",
        "ObjC",
        "Proto",
        "TableGen",
        "TextProto",
        "Verilog"
      ]
    },
    "LineEnding": {
      "description": "clang-format 16\n\nLine ending style (\\n or \\r\\n) to use.",
      "type": "string",
      "enum": ["LF", "CRLF", "DeriveLF", "DeriveCRLF"]
    },
    "MacroBlockBegin": {
      "description": "clang-format 3.7\n\nA regular expression matching macros that start a block.",
      "type": "string",
      "examples": ["^NS_MAP_BEGIN|NS_TABLE_HEAD$"]
    },
    "MacroBlockEnd": {
      "description": "clang-format 3.7\n\nA regular expression matching macros that end a block.",
      "type": "string",
      "examples": ["^NS_MAP_END|NS_TABLE_.*_END$"]
    },
    "Macros": {
      "description": "clang-format 17\n\nA list of macros of the form <definition>=<expansion>.\n\nCode will be parsed with macros expanded, in order to determine how to interpret and format the macro arguments.",
      "type": "array",
      "items": {
        "type": "string",
        "examples": ["A=x", "A()=y", "A(z)=z"]
      }
    },
    "MaxEmptyLinesToKeep": {
      "description": "clang-format 3.7\n\nThe maximum number of consecutive empty lines to keep.",
      "type": "integer",
      "default": 1,
      "minimum": 0
    },
    "NamespaceIndentation": {
      "description": "clang-format 3.7\n\nThe indentation used for namespaces.",
      "type": "string",
      "enum": ["None", "Inner", "All"]
    },
    "NamespaceMacros": {
      "description": "clang-format 9\n\nA vector of macros which are used to open namespace blocks.",
      "type": "array",
      "items": {
        "type": "string",
        "examples": ["TESTSUITE"]
      }
    },
    "ObjCBinPackProtocolList": {
      "description": "clang-format 7\n\nControls bin-packing Objective-C protocol conformance list items into as few lines as possible when they go over ColumnLimit.If Auto (the default), delegates to the value in BinPackParameters. If that is true, bin-packs Objective-C protocol conformance list items into as few lines as possible whenever they go over ColumnLimit.\rIf Always, always bin-packs Objective-C protocol conformance list items into as few lines as possible whenever they go over ColumnLimit.\rIf Never, lays out Objective-C protocol conformance list items onto individual lines whenever they go over ColumnLimit.",
      "type": "string",
      "default": "Auto",
      "enum": ["Never", "Auto", "Always"]
    },
    "ObjCBlockIndentWidth": {
      "description": "clang-format 3.7\n\nThe number of characters to use for indentation of ObjC blocks.",
      "type": "integer",
      "minimum": 0
    },
    "ObjCBreakBeforeNestedBlockParam": {
      "description": "clang-format 11\n\nBreak parameters list into lines when there is nested block parameters in a function call.",
      "type": "boolean"
    },
    "ObjCPropertyAttributeOrder": {
      "description": "clang-format 18\n\nThe order in which ObjC property attributes should appear.\n\nAttributes in code will be sorted in the order specified. Any attributes encountered that are not mentioned in this array will be sorted last, in stable order. Comments between attributes will leave the attributes untouched.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "ObjCSpaceAfterProperty": {
      "description": "clang-format 3.7\n\nAdd a space after @property in Objective-C, i.e. use @property (readonly) instead of @property(readonly).",
      "type": "boolean"
    },
    "ObjCSpaceBeforeProtocolList": {
      "description": "clang-format 3.7\n\nAdd a space in front of an Objective-C protocol list, i.e. use Foo <Protocol> instead of Foo<Protocol>.",
      "type": "boolean"
    },
    "PPIndentWidth": {
      "description": "clang-format 13\n\nThe number of columns to use for indentation of preprocessor statements. When set to -1 (default) IndentWidth is used also for preprocessor statements.",
      "type": "integer",
      "default": -1
    },
    "PackConstructorInitializers": {
      "description": "clang-format 14\n\nThe pack constructor initializers style to use.",
      "type": "string",
      "enum": ["Never", "BinPack", "CurrentLine", "NextLine", "NextLineOnly"]
    },
    "PenaltyBreakAssignment": {
      "description": "clang-format 5\n\nThe penalty for breaking around an assignment operator.",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyBreakBeforeFirstCallParameter": {
      "description": "clang-format 3.7\n\nThe penalty for breaking a function call after call(.",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyBreakComment": {
      "description": "clang-format 3.7\n\nThe penalty for each line break introduced inside a comment.",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyBreakFirstLessLess": {
      "description": "clang-format 3.7\n\nThe penalty for breaking before the first <<.",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyBreakOpenParenthesis": {
      "description": "clang-format 14\n\nThe penalty for breaking after (.",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyBreakScopeResolution": {
      "description": "clang-format 18\n\nThe penalty for breaking after ::.",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyBreakString": {
      "description": "clang-format 3.7\n\nThe penalty for each line break introduced inside a string literal.",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyBreakTemplateDeclaration": {
      "description": "clang-format 7\n\nThe penalty for breaking after template declaration.",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyExcessCharacter": {
      "description": "clang-format 3.7\n\nThe penalty for each character outside of the column limit.",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyIndentedWhitespace": {
      "description": "clang-format 12\n\nPenalty for each character of whitespace indentation (counted relative to leading non-whitespace column).",
      "type": "integer",
      "minimum": 0
    },
    "PenaltyReturnTypeOnItsOwnLine": {
      "description": "clang-format 3.7\n\nPenalty for putting the return type of a function onto its own line.",
      "type": "integer",
      "minimum": 0
    },
    "PointerAlignment": {
      "description": "clang-format 3.7\n\nPointer and reference alignment style.",
      "type": "string",
      "enum": ["Left", "Right", "Middle"]
    },
    "QualifierAlignment": {
      "description": "clang-format 14\n\nDifferent ways to arrange specifiers and qualifiers (e.g. const/volatile).\n\nWarning: Setting QualifierAlignment to something other than Leave, COULD lead to incorrect code formatting due to incorrect decisions made due to clang-formats lack of complete semantic information. As such extra care should be taken to review code changes made by the use of this option.",
      "type": "string",
      "enum": ["Leave", "Left", "Right", "Custom"]
    },
    "QualifierOrder": {
      "description": "clang-format 14\n\nThe order in which the qualifiers appear. Order is an array that can contain any of the following. \n\nNote: it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and aligned in the order supplied. Items to the right of 'type' will be placed to the right of the type and aligned in the order supplied.",
      "type": "array",
      "contains": {
        "const": "type"
      },
      "items": {
        "type": "string",
        "enum": [
          "const",
          "inline",
          "static",
          "friend",
          "constexpr",
          "volatile",
          "restrict",
          "type"
        ]
      }
    },
    "RawStringFormats": {
      "description": "clang-format 6\n\nDefines hints for detecting supported languages code blocks in raw strings.",
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "Language": {
            "$ref": "#/properties/Language"
          },
          "Delimiters": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "CanonicalDelimiter": {
            "type": "string"
          },
          "BasedOnStyle": {
            "$ref": "#/properties/BasedOnStyle"
          },
          "EnclosingFunctions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "examples": [
          {
            "Language": "Cpp",
            "Delimiters": ["cc", "CC", "cpp", "Cpp", "CPP", "c++", "C++"],
            "CanonicalDelimiter": "",
            "BasedOnStyle": "google"
          },
          {
            "Language": "TextProto",
            "Delimiters": ["pb", "PB", "proto", "PROTO"],
            "CanonicalDelimiter": "pb",
            "BasedOnStyle": "google",
            "EnclosingFunctions": [
              "EqualsProto",
              "EquivToProto",
              "PARSE_PARTIAL_TEXT_PROTO",
              "PARSE_TEST_PROTO",
              "PARSE_TEXT_PROTO",
              "ParseTextOrDie",
              "ParseTextProtoOrDie",
              "ParseTestProto",
              "ParsePartialTestProto"
            ]
          }
        ]
      }
    },
    "ReferenceAlignment": {
      "description": "clang-format 13\n\nReference alignment style (overrides PointerAlignment for references).",
      "type": "string",
      "enum": ["Pointer", "Left", "Right", "Middle"]
    },
    "ReflowComments": {
      "description": "clang-format 3.8\n\nComment reformatting style.",
      "type": "string",
      "enum": ["Never", "IndentOnly", "Always"]
    },
    "RemoveSemicolon": {
      "description": "clang-format 16\n\nRemove semicolons after the closing brace of a non-empty function.\n\nWarning: Setting this option to true could lead to incorrect code formatting due to clang-format's lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.",
      "type": "boolean"
    },
    "RemoveBracesLLVM": {
      "description": "clang-format 14\n\nRemove optional braces of control statements (if, else, for, and while) in C++ according to the LLVM coding style. \n\nWarning: This option will be renamed and expanded to support other styles.\n\nSetting this option to true could lead to incorrect code formatting due to clang-format's lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.",
      "type": "boolean"
    },
    "RemoveParentheses": {
      "description": "clang-format 17\n\nRemove redundant parentheses.\n\nWarning: Setting this option to any value other than Leave could lead to incorrect code formatting due to clang-format’s lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.",
      "type": "string",
      "enum": ["Leave", "MultipleParentheses", "ReturnStatement"]
    },
    "RequiresClausePosition": {
      "description": "clang-format 15\n\nThe position of the requires clause.",
      "type": "string",
      "enum": [
        "OwnLine",
        "OwnLineWithBrace",
        "WithPreceding",
        "WithFollowing",
        "SingleLine"
      ]
    },
    "RequiresExpressionIndentation": {
      "description": "clang-format 16 \n\nThe indentation used for requires expression bodies.",
      "type": "string",
      "enum": ["OuterScope", "Keyword"]
    },
    "SeparateDefinitionBlocks": {
      "description": "clang-format 14\n\nSpecifies the use of empty lines to separate definition blocks, including classes, structs, enums, and functions.",
      "type": "string",
      "enum": ["Leave", "Always", "Never"]
    },
    "ShortNamespaceLines": {
      "description": "clang-format 13\n\nThe maximal number of unwrapped lines that a short namespace spans. Defaults to 1.",
      "type": "integer",
      "default": 1,
      "minimum": 0
    },
    "SkipMacroDefinitionBody": {
      "description": "clang-format 18\n\nDo not format macro definition body.",
      "type": "boolean"
    },
    "SortIncludes": {
      "description": "clang-format 3.8\n\nControls if and how clang-format will sort #includes.",
      "type": "object",
      "properties": {
        "Enabled": {
          "description": "If true, includes are sorted based on the other suboptions.",
          "type": "boolean"
        },
        "IgnoreCase": {
          "description": "Whether or not includes are sorted in a case-insensitive fashion.",
          "type": "boolean"
        }
      }
    },
    "SortJavaStaticImport": {
      "description": "clang-format 12\n\nWhen sorting Java imports, by default static imports are placed before non-static imports. If JavaStaticImportAfterImport is After, static imports are placed after non-static imports.",
      "type": "string",
      "enum": ["Before", "After"]
    },
    "SortUsingDeclarations": {
      "description": "clang-format 5\n\nControls if and how clang-format will sort using declarations.",
      "enum": ["Never", "Lexicographic", "LexicographicNumeric"],
      "type": "string"
    },
    "SpaceAfterCStyleCast": {
      "description": "clang-format 3.5\n\nIf true, a space is inserted after C style casts.",
      "type": "boolean"
    },
    "SpaceAfterLogicalNot": {
      "description": "clang-format 9\n\nIf true, a space is inserted after the logical not operator (!).",
      "type": "boolean"
    },
    "SpaceAfterTemplateKeyword": {
      "description": "clang-format 4\n\nIf true, a space will be inserted after the template keyword.",
      "type": "boolean"
    },
    "SpaceAroundPointerQualifiers": {
      "description": "clang-format 12\n\nDefines in which cases to put a space before or after pointer qualifiers",
      "type": "string",
      "enum": ["Default", "Before", "After", "Both"]
    },
    "SpaceBeforeAssignmentOperators": {
      "description": "clang-format 3.7\n\nIf false, spaces will be removed before assignment operators.",
      "type": "boolean"
    },
    "SpaceBeforeCaseColon": {
      "description": "clang-format 12\n\nIf false, spaces will be removed before case colon.",
      "type": "boolean"
    },
    "SpaceBeforeCpp11BracedList": {
      "description": "clang-format 7\n\nIf true, a space will be inserted before a C++11 braced list used to initialize an object (after the preceding identifier or type).",
      "type": "boolean"
    },
    "SpaceBeforeCtorInitializerColon": {
      "description": "clang-format 7\n\nIf false, spaces will be removed before constructor initializer colon.",
      "type": "boolean"
    },
    "SpaceBeforeInheritanceColon": {
      "description": "clang-format 7\n\nIf false, spaces will be removed before inheritance colon.",
      "type": "boolean"
    },
    "SpaceBeforeJsonColon": {
      "description": "clang-format 17\n\nIf true, a space will be added before a JSON colon. For other languages, e.g. JavaScript, use SpacesInContainerLiterals instead.",
      "type": "boolean"
    },
    "SpaceBeforeParens": {
      "description": "clang-format 3.5\n\nDefines in which cases to put a space before opening parentheses.",
      "type": "string",
      "enum": [
        "ControlStatements",
        "Never",
        "ControlStatementsExceptControlMacros",
        "NonEmptyParentheses",
        "Always",
        "Custom"
      ]
    },
    "SpaceBeforeParensOptions": {
      "description": "clang-format 14\n\nControl of individual space before parentheses.\n\nIf SpaceBeforeParens is set to Custom, use this to specify how each individual space before parentheses case should be handled. Otherwise, this is ignored.",
      "type": "object",
      "properties": {
        "AfterControlStatements": {
          "description": "If true, put space between control statement keywords (for/if/while…) and opening parentheses.",
          "type": "boolean"
        },
        "AfterForeachMacros": {
          "description": "If true, put space between foreach macros and opening parentheses.",
          "type": "boolean"
        },
        "AfterFunctionDeclarationName": {
          "description": "If true, put a space between function declaration name and opening parentheses.",
          "type": "boolean"
        },
        "AfterFunctionDefinitionName": {
          "description": "If true, put a space between function definition name and opening parentheses.",
          "type": "boolean"
        },
        "AfterIfMacros": {
          "description": "If true, put space between if macros and opening parentheses.",
          "type": "boolean"
        },
        "AfterOverloadedOperator": {
          "description": "If true, put a space between operator overloading and opening parentheses.",
          "type": "boolean"
        },
        "AfterPlacementOperator": {
          "description": "If true, put a space between operator new/delete and opening parenthesis.",
          "type": "boolean"
        },
        "AfterRequiresInClause": {
          "description": "If true, put space between requires keyword in a requires clause and opening parentheses, if there is one.",
          "type": "boolean"
        },
        "AfterRequiresInExpression": {
          "description": "If true, put space between requires keyword in a requires expression and opening parentheses.",
          "type": "boolean"
        },
        "BeforeNonEmptyParentheses": {
          "description": "If true, put a space before opening parentheses only if the parentheses are not empty.",
          "type": "boolean"
        },
        "AfterNot": {
          "description": "If true, put a space between alternative operator not and the opening parenthesis.",
          "type": "boolean"
        }
      }
    },
    "SpaceBeforeRangeBasedForLoopColon": {
      "description": "clang-format 7\n\nIf false, spaces will be removed before range-based for loop colon.",
      "type": "boolean"
    },
    "SpaceBeforeSquareBrackets": {
      "description": "clang-format 10\n\nIf true, spaces will be before [. Lambdas will not be affected. Only the first [ will get a space added.",
      "type": "boolean"
    },
    "SpaceInEmptyBlock": {
      "description": "clang-format 10\n\nIf true, spaces will be inserted into {}.",
      "type": "boolean"
    },
    "SpaceInEmptyParentheses": {
      "description": "clang-format 3.7\n\nIf true, spaces may be inserted into (). This option is deprecated in clang-format 17. See InEmptyParentheses of SpacesInParensOptions.",
      "type": "boolean"
    },
    "SpacesBeforeTrailingComments": {
      "description": "clang-format 3.7\n\nThe number of spaces before trailing line comments (// - comments).\n\nThis does not affect trailing block comments (/* - comments) as those commonly have different usage patterns and a number of special cases. In the case of Verilog, it doesn't affect a comment right after the opening parenthesis in the port or parameter list in a module header, because it is probably for the port on the following line instead of the parenthesis it follows.",
      "type": "integer",
      "minimum": 0
    },
    "SpacesInAngles": {
      "description": "clang-format 3.4\n\nThe SpacesInAnglesStyle to use for template argument lists.",
      "type": "string",
      "enum": ["Never", "Always", "Leave"]
    },
    "SpacesInCStyleCastParentheses": {
      "description": "clang-format 3.7\n\nIf true, spaces may be inserted into C style casts. This option is deprecated in clang-format 17. See InCStyleCasts of SpacesInParensOptions.",
      "type": "boolean"
    },
    "SpacesInConditionalStatement": {
      "description": "clang-format 10\n\nIf true, spaces will be inserted around if/for/switch/while conditions. This option is deprecated in clang-format 17. See InConditionalStatements of SpacesInParensOptions.",
      "type": "boolean"
    },
    "SpacesInContainerLiterals": {
      "description": "clang-format 3.7\n\nIf true, spaces are inserted inside container literals (e.g. ObjC and Javascript array and dict literals). For JSON, use SpaceBeforeJsonColon instead.",
      "type": "boolean"
    },
    "SpacesInLineCommentPrefix": {
      "description": "clang-format 13\n\nHow many spaces are allowed at the start of a line comment. To disable the maximum set it to -1, apart from that the maximum takes precedence over the minimum.\n\nIn clang-format 16, this option has only effect if ReflowComments is set to true.",
      "type": "object",
      "properties": {
        "Minimum": {
          "type": "integer",
          "default": 1
        },
        "Maximum": {
          "type": "integer",
          "default": 1
        }
      }
    },
    "SpacesInParens": {
      "description": "clang-format 17\n\nDefines in which cases spaces will be inserted after ( and before ).",
      "type": "string",
      "enum": ["Never", "Custom"]
    },
    "SpacesInParensOptions": {
      "description": "clang-format 17\n\nControl of individual spaces in parentheses.\n\nIf SpacesInParens is set to Custom, use this to specify how each individual space in parentheses case should be handled. Otherwise, this is ignored.",
      "type": "object",
      "properties": {
        "InConditionalStatements": {
          "type": "boolean"
        },
        "InCStyleCasts": {
          "type": "boolean"
        },
        "InEmptyParentheses": {
          "type": "boolean"
        },
        "Other": {
          "type": "boolean"
        },
        "ExceptDoubleParentheses": {
          "description": "Override any of the following options to prevent addition of space when both opening and closing parentheses use multiple parentheses.",
          "type": "boolean"
        }
      }
    },
    "SpacesInParentheses": {
      "description": "clang-format 3.7\n\nIf true, spaces will be inserted after ( and before ). This option is deprecated in clang-format 17. The previous behavior is preserved by using SpacesInParens with Custom and by setting all SpacesInParensOptions to true except for InCStyleCasts and InEmptyParentheses.",
      "type": "boolean"
    },
    "SpacesInSquareBrackets": {
      "description": "clang-format 3.7\n\nIf true, spaces will be inserted after [ and before ]. Lambdas without arguments or unspecified size array declarations will not be affected.",
      "type": "boolean"
    },
    "Standard": {
      "description": "clang-format 3.7\n\nParse and format C++ constructs compatible with this standard.",
      "type": "string",
      "enum": ["Auto", "Latest", "c++03", "c++11", "c++14", "c++17", "c++20"]
    },
    "StatementAttributeLikeMacros": {
      "description": "clang-format 12\n\nMacros which are ignored in front of a statement, as if they were an attribute. So that they are not parsed as identifier, for example for Qts emit.",
      "type": "array",
      "items": {
        "type": "string",
        "examples": ["Q_EMIT"]
      }
    },
    "StatementMacros": {
      "description": "clnag-format 8\n\nA vector of macros that should be interpreted as complete statements.\n\nTypical macros are expressions, and require a semi-colon to be added; sometimes this is not the case, and this allows to make clang-format aware of such cases.",
      "type": "array",
      "items": {
        "type": "string",
        "examples": ["Q_UNUSED", "QT_REQUIRE_VERSION"]
      }
    },
    "TabWidth": {
      "description": "clang-format 3.7\n\nThe number of columns used for tab stops.",
      "type": "integer",
      "minimum": 0
    },
    "TypeNames": {
      "description": "clang-format 17\n\nA vector of non-keyword identifiers that should be interpreted as type names.\n\nA *, &, or && between a type name and another non-keyword identifier is annotated as a pointer or reference token instead of a binary operator.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "TypenameMacros": {
      "description": "clang-format 9\n\nA vector of macros that should be interpreted as type declarations instead of as function calls.\n\nFor example: OpenSSL STACK_OF, BSD LIST_ENTRY.",
      "type": "array",
      "items": {
        "type": "string",
        "examples": ["STACK_OF", "LIST_ENTRY"]
      }
    },
    "UseCRLF": {
      "description": "clang-format 10\n\nUse \r\n instead of \n for line breaks. Also used as fallback if DeriveLineEnding is true.\n\nThis option is deprecated in clang-format 16. See LF and CRLF of LineEnding.",
      "type": "boolean"
    },
    "UseTab": {
      "description": "clang-format 3.7\n\nThe way to use tab characters in the resulting file.",
      "type": "string",
      "enum": [
        "Never",
        "ForIndentation",
        "ForContinuationAndIndentation",
        "AlignWithSpaces",
        "Always"
      ]
    },
    "VerilogBreakBetweenInstancePorts": {
      "description": "clang-format 17\n\nFor Verilog, put each port on its own line in module instantiations.",
      "type": "boolean"
    },
    "WhitespaceSensitiveMacros": {
      "description": "clang-format 11\n\nA vector of macros which are whitespace-sensitive and should not be touched.\n\nFor example: BOOST_PP_STRINGIZE",
      "type": "array",
      "items": {
        "type": "string",
        "examples": [
          "STRINGIZE",
          "PP_STRINGIZE",
          "BOOST_PP_STRINGIZE",
          "NS_SWIFT_NAME",
          "CF_SWIFT_NAME"
        ]
      }
    },
    "AlignConsecutiveTableGenBreakingDAGArgColons": {
      "description": "clang-format 19\n\nStyle of aligning consecutive TableGen DAGArg operator colons. If enabled, align the colon inside DAGArg which have line break inside. This works only when TableGenBreakInsideDAGArg is BreakElements or BreakAll and the DAGArg is not excepted by TableGenBreakingDAGArgOperators’s effect.",
      "oneOf": [
        {
          "enum": [
            "None",
            "Consecutive",
            "AcrossEmptyLines",
            "AcrossComments",
            "AcrossEmptyLinesAndComments"
          ],
          "type": "string"
        },
        {
          "properties": {
            "AcrossComments": {
              "description": "Whether to align across comments.",
              "type": "boolean"
            },
            "AcrossEmptyLines": {
              "description": "Whether to align across empty lines.",
              "type": "boolean"
            },
            "Enabled": {
              "description": "Whether aligning is enabled.",
              "type": "boolean"
            }
          },
          "type": "object"
        }
      ]
    },
    "AlignConsecutiveTableGenCondOperatorColons": {
      "description": "clang-format 19\n\nStyle of aligning consecutive TableGen cond operator colons. Align the colons of cases inside !cond operators.",
      "oneOf": [
        {
          "enum": [
            "None",
            "Consecutive",
            "AcrossEmptyLines",
            "AcrossComments",
            "AcrossEmptyLinesAndComments"
          ],
          "type": "string"
        },
        {
          "properties": {
            "AcrossComments": {
              "description": "Whether to align across comments.",
              "type": "boolean"
            },
            "AcrossEmptyLines": {
              "description": "Whether to align across empty lines.",
              "type": "boolean"
            },
            "Enabled": {
              "description": "Whether aligning is enabled.",
              "type": "boolean"
            }
          },
          "type": "object"
        }
      ]
    },
    "AlignConsecutiveTableGenDefinitionColons": {
      "description": "clang-format 19\n\nStyle of aligning consecutive TableGen definition colons. This aligns the inheritance colons of consecutive definitions.",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "None",
            "Consecutive",
            "AcrossEmptyLines",
            "AcrossComments",
            "AcrossEmptyLinesAndComments"
          ]
        },
        {
          "properties": {
            "AcrossComments": {
              "description": "Whether to align across comments.",
              "type": "boolean"
            },
            "AcrossEmptyLines": {
              "description": "Whether to align across empty lines.",
              "type": "boolean"
            },
            "Enabled": {
              "description": "Whether aligning is enabled.",
              "type": "boolean"
            }
          },
          "type": "object"
        }
      ]
    },
    "AllowShortCaseExpressionOnASingleLine": {
      "description": "clang-format 19\n\nWhether to merge a short switch labeled rule into a single line.",
      "type": "boolean"
    },
    "AllowShortNamespacesOnASingleLine": {
      "description": "clang-format 20\n\nIf true, namespace a { class b; } can be put on a single line.",
      "type": "boolean"
    },
    "BinPackLongBracedList": {
      "description": "clang-format 21\n\nIf BinPackLongBracedList is true it overrides BinPackArguments if there are 20 or more items in a braced initializer list.",
      "type": "boolean"
    },
    "BreakAfterReturnType": {
      "description": "clang-format 19\n\nThe function declaration return type breaking style to use.",
      "enum": [
        "Automatic",
        "ExceptShortType",
        "None",
        "All",
        "TopLevel",
        "AllDefinitions",
        "TopLevelDefinitions"
      ],
      "type": "string"
    },
    "BreakBeforeTemplateCloser": {
      "description": "clang-format 21\n\nIf true, break before a template closing bracket (>) when there is a line break after the matching opening bracket (<).",
      "type": "boolean"
    },
    "BreakBinaryOperations": {
      "description": "clang-format 20\n\nThe break binary operations style to use.",
      "enum": ["Never", "OnePerLine", "RespectPrecedence"],
      "type": "string"
    },
    "BreakFunctionDefinitionParameters": {
      "description": "clang-format 19\n\nIf true, clang-format will always break before function definition parameters.",
      "type": "boolean"
    },
    "BreakTemplateDeclarations": {
      "description": "clang-format 19\n\nThe template declaration breaking style to use.",
      "enum": ["Leave", "No", "MultiLine", "Yes"],
      "type": "string"
    },
    "EnumTrailingComma": {
      "description": "clang-format 21\n\nInsert a comma (if missing) or remove the comma at the end of an enum enumerator list.\n\nWarning: Setting this option to any value other than Leave could lead to incorrect code formatting due to clang-format’s lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.",
      "enum": ["Leave", "Insert", "Remove"],
      "type": "string"
    },
    "IndentExportBlock": {
      "description": "clang-format 20\n\nIf true, clang-format will indent the body of an export { ... } block. This doesn’t affect the formatting of anything else related to exported declarations.",
      "type": "boolean"
    },
    "JavaImportGroups": {
      "description": "clang-format 8\n\nA vector of prefixes ordered by the desired groups for Java imports.",
      "items": {
        "examples": ["com.example", "com", "org"],
        "type": "string"
      },
      "type": "array"
    },
    "KeepEmptyLines": {
      "description": "clang-format 19\n\nWhich empty lines are kept. See MaxEmptyLinesToKeep for how many consecutive empty lines are kept.",
      "properties": {
        "AtEndOfFile": {
          "description": "Keep empty lines at end of file.",
          "type": "boolean"
        },
        "AtStartOfBlock": {
          "description": "Keep empty lines at start of a block.",
          "type": "boolean"
        },
        "AtStartOfFile": {
          "description": "Keep empty lines at start of file.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "KeepFormFeed": {
      "description": "clang-format 20\n\nKeep the form feed character if it's immediately preceded and followed by a newline.",
      "type": "boolean"
    },
    "MacrosSkippedByRemoveParentheses": {
      "description": "clang-format 21\n\nA vector of function-like macros whose invocations should be skipped by RemoveParentheses.",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "MainIncludeChar": {
      "description": "clang-format 19\n\nWhen guessing whether a #include is the \"main\" include, only the include directives that use the specified character are considered.",
      "enum": ["Quote", "AngleBracket", "Any"],
      "type": "string"
    },
    "OneLineFormatOffRegex": {
      "description": "clang-format 21\n\nA regular expression that describes markers for turning formatting off for one line.",
      "examples": ["^(// NOLINT|logger$)"],
      "type": "string"
    },
    "PenaltyBreakBeforeMemberAccess": {
      "description": "clang-format 20\n\nThe penalty for breaking before a member access operator (., ->).",
      "minimum": 0,
      "type": "integer"
    },
    "RemoveEmptyLinesInUnwrappedLines": {
      "description": "clang-format 20\n\nRemove empty lines within unwrapped lines.",
      "type": "boolean"
    },
    "SpaceAfterOperatorKeyword": {
      "description": "clang-format 21\n\nIf true, a space will be inserted after the operator keyword.",
      "type": "boolean"
    },
    "TableGenBreakInsideDAGArg": {
      "description": "clang-format 19\n\nThe styles of the line break inside the DAGArg in TableGen.",
      "enum": ["DontBreak", "BreakElements", "BreakAll"],
      "type": "string"
    },
    "TableGenBreakingDAGArgOperators": {
      "description": "clang-format 19\n\nWorks only when TableGenBreakInsideDAGArg is not DontBreak. If any identifier is specified, this limits the line breaks by TableGenBreakInsideDAGArg option only on DAGArg values beginning with the specified identifiers.",
      "items": {
        "examples": ["ins", "outs"],
        "type": "string"
      },
      "type": "array"
    },
    "TemplateNames": {
      "description": "clang-format 20\n\nA vector of non-keyword identifiers that should be interpreted as template names.\n\nA < after a template name is annotated as a template opener instead of a binary operator.",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "VariableTemplates": {
      "description": "clang-format 20\n\nA vector of non-keyword identifiers that should be interpreted as variable template names.\n\nA ) after a variable template instantiation is not annotated as the closing parenthesis of C-style cast operator.",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "WrapNamespaceBodyWithEmptyLines": {
      "description": "clang-format 20\n\nWrap namespace body with empty lines.",
      "enum": ["Never", "Always", "Leave"],
      "type": "string"
    }
  },
  "title": ".clang-format config",
  "type": "object"
}
