{
  "description": "Auto-Generated JSON Schema for Ansible-stable 2.3 (https://github.com/shaded-enmity/ansible-schema-generator)",
  "title": "Ansible 2.3",
  "items": {
    "anyOf": [
      {
        "required": [
          "shell"
        ],
        "type": "object",
        "properties": {
          "shell": {
            "type": "string"
          },
          "args": {
            "type": "object",
            "properties": {
              "warn": {
                "type": "string",
                "description": "Default: True\n\nif command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false."
              },
              "creates": {
                "type": "string",
                "description": "a filename, when it already exists, this step will B(not) be run."
              },
              "executable": {
                "type": "string",
                "description": "change the shell used to execute the command. Should be an absolute path to the executable."
              },
              "chdir": {
                "type": "string",
                "description": "cd into this directory before running the command"
              },
              "removes": {
                "type": "string",
                "description": "a filename, when it does not exist, this step will B(not) be run."
              }
            }
          },
          "name": {
            "type": "string"
          }
        }
      },
      {
        "required": [
          "raw"
        ],
        "type": "object",
        "properties": {
          "raw": {
            "type": "string"
          },
          "args": {
            "type": "object",
            "properties": {
              "executable": {
                "type": "string",
                "description": "change the shell used to execute the command. Should be an absolute path to the executable.\nwhen using privilege escalation (C(become)), a default shell will be assigned if one is not provided as privilege escalation requires a shell."
              }
            }
          },
          "name": {
            "type": "string"
          }
        }
      },
      {
        "required": [
          "command"
        ],
        "type": "object",
        "properties": {
          "args": {
            "type": "object",
            "properties": {
              "warn": {
                "type": "string",
                "description": "Default: True\n\nif command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false."
              },
              "creates": {
                "type": "string",
                "description": "a filename or (since 2.0) glob pattern, when it already exists, this step will B(not) be run."
              },
              "executable": {
                "type": "string",
                "description": "change the shell used to execute the command. Should be an absolute path to the executable."
              },
              "chdir": {
                "type": "string",
                "description": "cd into this directory before running the command"
              },
              "removes": {
                "type": "string",
                "description": "a filename or (since 2.0) glob pattern, when it does not exist, this step will B(not) be run."
              }
            }
          },
          "command": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        }
      },
      {
        "required": [
          "script"
        ],
        "type": "object",
        "properties": {
          "args": {
            "type": "object",
            "properties": {
              "creates": {
                "type": "string",
                "description": "a filename, when it already exists, this step will B(not) be run."
              },
              "removes": {
                "type": "string",
                "description": "a filename, when it does not exist, this step will B(not) be run."
              }
            }
          },
          "name": {
            "type": "string"
          },
          "script": {
            "type": "string"
          }
        }
      },
      {
        "required": [
          "include"
        ],
        "include": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "properties": {}
      },
      {
        "properties": {
          "ignore_files": {
            "type": "array",
            "description": "List of file names to ignore."
          },
          "files_matching": {
            "type": "string",
            "description": "Limit the files that are loaded within any directory to this regular expression."
          },
          "depth": {
            "type": "string",
            "description": "When using C(dir), this module will, by default, recursively go through each sub directory and load up the variables. By explicitly setting the depth, this module will only go as deep as the depth."
          },
          "extensions": {
            "type": "array",
            "description": "Default: ['yaml', 'yml', 'json']\n\nList of file extensions to read when using C(dir)."
          },
          "file": {
            "type": "string",
            "description": "The file name from which variables should be loaded.\nIf the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook."
          },
          "dir": {
            "type": "string",
            "description": "The directory name from which the variables should be loaded.\nIf the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook."
          },
          "name": {
            "type": "string",
            "description": "The name of a variable into which assign the included vars, if omitted (null) they will be made top level vars."
          }
        },
        "required": [
          "include_vars"
        ],
        "name": {
          "type": "string"
        },
        "include_vars": {
          "type": "string"
        }
      },
      {
        "required": [
          "shell"
        ],
        "type": "object",
        "properties": {
          "shell": {
            "type": "string"
          },
          "args": {
            "type": "object",
            "properties": {
              "warn": {
                "type": "string",
                "description": "Default: True\n\nif command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false."
              },
              "creates": {
                "type": "string",
                "description": "a filename, when it already exists, this step will B(not) be run."
              },
              "executable": {
                "type": "string",
                "description": "change the shell used to execute the command. Should be an absolute path to the executable."
              },
              "chdir": {
                "type": "string",
                "description": "cd into this directory before running the command"
              },
              "removes": {
                "type": "string",
                "description": "a filename, when it does not exist, this step will B(not) be run."
              }
            }
          },
          "name": {
            "type": "string"
          }
        }
      },
      {
        "required": [
          "raw"
        ],
        "type": "object",
        "properties": {
          "raw": {
            "type": "string"
          },
          "args": {
            "type": "object",
            "properties": {
              "executable": {
                "type": "string",
                "description": "change the shell used to execute the command. Should be an absolute path to the executable.\nwhen using privilege escalation (C(become)), a default shell will be assigned if one is not provided as privilege escalation requires a shell."
              }
            }
          },
          "name": {
            "type": "string"
          }
        }
      },
      {
        "required": [
          "command"
        ],
        "type": "object",
        "properties": {
          "args": {
            "type": "object",
            "properties": {
              "warn": {
                "type": "string",
                "description": "Default: True\n\nif command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false."
              },
              "creates": {
                "type": "string",
                "description": "a filename or (since 2.0) glob pattern, when it already exists, this step will B(not) be run."
              },
              "executable": {
                "type": "string",
                "description": "change the shell used to execute the command. Should be an absolute path to the executable."
              },
              "chdir": {
                "type": "string",
                "description": "cd into this directory before running the command"
              },
              "removes": {
                "type": "string",
                "description": "a filename or (since 2.0) glob pattern, when it does not exist, this step will B(not) be run."
              }
            }
          },
          "command": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        }
      },
      {
        "required": [
          "script"
        ],
        "type": "object",
        "properties": {
          "args": {
            "type": "object",
            "properties": {
              "creates": {
                "type": "string",
                "description": "a filename, when it already exists, this step will B(not) be run."
              },
              "removes": {
                "type": "string",
                "description": "a filename, when it does not exist, this step will B(not) be run."
              }
            }
          },
          "name": {
            "type": "string"
          },
          "script": {
            "type": "string"
          }
        }
      },
      {
        "required": [
          "include"
        ],
        "include": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "properties": {}
      },
      {
        "properties": {
          "ignore_files": {
            "type": "array",
            "description": "List of file names to ignore. The defaults can not be overridden, but can be extended."
          },
          "files_matching": {
            "type": "string",
            "description": "Limit the variables that are loaded within any directory to this regular expression."
          },
          "depth": {
            "type": "string",
            "description": "By default, this module will recursively go through each sub directory and load up the variables. By explicitly setting the depth, this module will only go as deep as the depth."
          },
          "file": {
            "type": "string",
            "description": "The file name from which variables should be loaded.\nIf the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook."
          },
          "dir": {
            "type": "string",
            "description": "The directory name from which the variables should be loaded.\nIf the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook."
          },
          "name": {
            "type": "string",
            "description": "The name of a variable into which assign the included vars, if omitted (null) they will be made top level vars."
          }
        },
        "required": [
          "include_vars"
        ],
        "name": {
          "type": "string"
        },
        "include_vars": {
          "type": "string"
        }
      },
      {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "ecs_taskdefinition": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates or terminates task definitions",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "family": {
                "type": "string",
                "description": "A Name that would be given to the task definition"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "revision": {
                "description": "A revision number for the task definition",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "State whether the task definition should exist or be deleted"
              },
              "arn": {
                "type": "string",
                "description": "The arn of the task description to delete"
              },
              "volumes": {
                "description": "A list of names of volumes to be attached",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "containers": {
                "description": "A list of containers definitions",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "selinux": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "configfile",
                        "conf",
                        "file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Configures the SELinux mode and policy. A reboot may be required after usage. Ansible will not issue this reboot but will let you know when it is required.",
            "properties": {
              "policy": {
                "type": "string",
                "description": "name of the SELinux policy to use (example: C(targeted)) will be required if state is not C(disabled)"
              },
              "configfile": {
                "type": "string",
                "description": "Default: /etc/selinux/config\n\npath to the SELinux configuration file, if non-standard"
              },
              "file": {
                "type": "string",
                "description": "Default: /etc/selinux/config\n\npath to the SELinux configuration file, if non-standard"
              },
              "conf": {
                "type": "string",
                "description": "Default: /etc/selinux/config\n\npath to the SELinux configuration file, if non-standard"
              },
              "state": {
                "enum": [
                  "enforcing",
                  "permissive",
                  "disabled"
                ],
                "type": "string",
                "description": "The SELinux mode"
              }
            }
          },
          "consul": {
            "type": "object",
            "description": "Registers services and checks for an agent with a consul cluster. A service is some process running on the agent node that should be advertised by consul's discovery mechanism. It may optionally supply a check definition, a periodic service test to notify the consul cluster of service's health.\nChecks may also be registered per node e.g. disk usage, or cpu usage and notify the health of the entire node to the cluster. Service level checks do not require a check name or id as these are derived by Consul from the Service name and id respectively by appending 'service:' Node level checks require a check_name and optionally a check_id.\nCurrently, there is no complete way to retrieve the script, interval or ttl metadata for a registered check. Without this metadata it is  not possible to tell if the data supplied with ansible represents a change to a check. As a result this does not attempt to determine changes and will always report a changed occurred. An api method is planned to supply this metadata so at that stage change management will be added.\nSee http://consul.io for more details.",
            "properties": {
              "service_address": {
                "type": "string",
                "description": "Default: None\n\nthe address to advertise that the service will be listening on. This value will be passed as the I(Address) parameter to Consul's U(/v1/agent/service/register) API method, so refer to the Consul API documentation for further details."
              },
              "http": {
                "type": "string",
                "description": "Default: None\n\nchecks can be registered with an http endpoint. This means that consul will check that the http endpoint returns a successful http status. Interval must also be provided with this option."
              },
              "check_node": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "description": "Default: None\n\na list of tags that will be attached to the service registration.",
                "$ref": "#/definitions/ansible_array"
              },
              "check_name": {
                "type": "string",
                "description": "Default: None\n\na name for the service check, defaults to the check id. required if standalone, ignored if part of service definition."
              },
              "service_name": {
                "type": "string",
                "description": "Unique name for the service on a node, must be unique per node, required if registering a service. May be ommitted if registering a node level check"
              },
              "notes": {
                "type": "string",
                "description": "Default: None\n\nNotes to attach to check when registering it."
              },
              "script": {
                "type": "string",
                "description": "Default: None\n\nthe script/command that will be run periodically to check the health of the service. Scripts require an interval and vise versa"
              },
              "token": {
                "type": "string",
                "description": "Default: None\n\nthe token key indentifying an ACL rule set. May be required to register services."
              },
              "interval": {
                "type": "string",
                "description": "Default: None\n\nthe interval at which the service check will be run. This is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m. Required if the script param is specified."
              },
              "check_id": {
                "type": "string",
                "description": "Default: None\n\nan ID for the service check, defaults to the check name, ignored if part of a service definition."
              },
              "host": {
                "type": "string",
                "description": "Default: localhost\n\nhost of the consul agent defaults to localhost"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "register or deregister the consul service, defaults to present"
              },
              "service_port": {
                "description": "the port on which the service is listening required for registration of a service, i.e. if service_name or service_id is set",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "type": "string",
                "description": "Default: None\n\nA custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes, e.g. 15s or 1m."
              },
              "ttl": {
                "type": "string",
                "description": "Default: None\n\nchecks can be registered with a ttl instead of a script and interval this means that the service will check in with the agent before the ttl expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m"
              },
              "service_id": {
                "type": "string",
                "description": "Default: service_name if supplied\n\nthe ID for the service, must be unique per node, defaults to the service name if the service name is supplied"
              },
              "scheme": {
                "type": "string",
                "description": "Default: http\n\nthe protocol scheme on which the consul agent is running"
              },
              "validate_certs": {
                "description": "Default: True\n\nwhether to verify the tls certificate of the consul agent",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "Default: 8500\n\nthe port on which the consul agent is running",
                "$ref": "#/definitions/ansible_number"
              },
              "check_host": {
                "type": "string",
                "description": ""
              }
            }
          },
          "alternatives": {
            "required": [
              "path",
              "name"
            ],
            "type": "object",
            "description": "Manages symbolic links using the 'update-alternatives' tool\nUseful when multiple programs are installed but provide similar functionality (e.g. different editors).",
            "properties": {
              "priority": {
                "description": "Default: 50\n\nThe priority of the alternative",
                "$ref": "#/definitions/ansible_number"
              },
              "path": {
                "type": "string",
                "description": "The path to the real executable that the link should point to."
              },
              "link": {
                "type": "string",
                "description": "The path to the symbolic link that should point to the real executable.\nThis option is required on RHEL-based distributions"
              },
              "name": {
                "type": "string",
                "description": "The generic name of the link."
              }
            }
          },
          "set_stats": {
            "required": [
              "password"
            ],
            "type": "object",
            "description": "This module allows setting/accumulating stats on the current ansible run, either per host of for all hosts in the run.",
            "properties": {
              "timeout": {
                "type": "string",
                "description": ""
              },
              "ipv6": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "minutes": {
                "type": "string",
                "description": ""
              },
              "port": {
                "type": "string",
                "description": ""
              },
              "multi_key": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "gce_lb": {
            "type": "object",
            "description": "This module can create and destroy Google Compute Engine C(loadbalancer) and C(httphealthcheck) resources.  The primary LB resource is the C(load_balancer) resource and the health check parameters are all prefixed with I(httphealthcheck). The full documentation for Google Compute Engine load balancing is at U(https://developers.google.com/compute/docs/load-balancing/).  However, the ansible module simplifies the configuration by following the libcloud model. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.",
            "properties": {
              "httphealthcheck_host": {
                "type": "string",
                "description": "host header to pass through on HTTP check requests"
              },
              "httphealthcheck_name": {
                "type": "string",
                "description": "the name identifier for the HTTP health check"
              },
              "name": {
                "type": "string",
                "description": "name of the load-balancer resource"
              },
              "external_ip": {
                "type": "string",
                "description": "the external static IPv4 (or auto-assigned) address for the LB"
              },
              "service_account_email": {
                "type": "string",
                "description": "service account email"
              },
              "region": {
                "type": "string",
                "description": "the GCE region where the load-balancer is defined"
              },
              "httphealthcheck_unhealthy_count": {
                "type": "string",
                "description": "Default: 2\n\nnumber of consecutive failed checks before marking a node unhealthy"
              },
              "httphealthcheck_healthy_count": {
                "type": "string",
                "description": "Default: 2\n\nnumber of consecutive successful checks before marking a node healthy"
              },
              "pem_file": {
                "type": "string",
                "description": "path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'."
              },
              "httphealthcheck_path": {
                "type": "string",
                "description": "Default: /\n\nthe url path to use for HTTP health checking"
              },
              "port_range": {
                "type": "string",
                "description": "the port (range) to forward, e.g. 80 or 8000-8888 defaults to all ports"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\ndesired state of the LB"
              },
              "httphealthcheck_timeout": {
                "type": "string",
                "description": "Default: 5\n\nthe timeout in seconds before a request is considered a failed check"
              },
              "members": {
                "description": "a list of zone/nodename pairs, e.g ['us-central1-a/www-a', ...]",
                "$ref": "#/definitions/ansible_array"
              },
              "credentials_file": {
                "type": "string",
                "description": "path to the JSON file associated with the service account email"
              },
              "httphealthcheck_port": {
                "type": "string",
                "description": "Default: 80\n\nthe TCP port to use for HTTP health checking"
              },
              "protocol": {
                "type": "string",
                "description": "Default: tcp\n\nthe protocol used for the load-balancer packet forwarding, tcp or udp"
              },
              "project_id": {
                "type": "string",
                "description": "your GCE project ID"
              },
              "httphealthcheck_interval": {
                "type": "string",
                "description": "Default: 5\n\nthe duration in seconds between each health check request"
              }
            }
          },
          "ecs_cluster": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates or terminates ecs clusters.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "repeat": {
                "description": "The number of times to wait for the cluster to have an instance",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "The cluster name"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "delay": {
                "description": "Number of seconds to wait",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "has_instances"
                ],
                "type": "string",
                "description": "The desired state of the cluster"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "os_keystone_domain_facts": {
            "type": "object",
            "description": "Retrieve facts about a one or more OpenStack domains",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name or ID of the domain"
              },
              "filters": {
                "type": "string",
                "description": "Default: None\n\nA dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries."
              }
            }
          },
          "win_say": {
            "type": "object",
            "description": "Uses .NET libraries to convert text to speech and optionally play .wav sounds.  Audio Service needs to be running and some kind of speakers or headphones need to be attached to the windows target(s) for the speech to be audible.",
            "properties": {
              "start_sound_path": {
                "type": "string",
                "description": "Full path to a C(.wav) file containing a sound to play before the text is spoken.  Useful on conference calls to alert other speakers that ansible has something to say."
              },
              "msg_file": {
                "type": "string",
                "description": "Default: none\n\nFull path to a windows format text file containing the text to be spokend.  Use either msg or msg_file.  Optional so that you can use this module just to play sounds."
              },
              "end_sound_path": {
                "type": "string",
                "description": "Full path to a C(.wav) file containing a sound to play after the text has been spoken.  Useful on conference calls to alert other speakers that ansible has finished speaking."
              },
              "msg": {
                "type": "string",
                "description": "Default: none\n\nThe text to be spoken.  Use either msg or msg_file.  Optional so that you can use this module just to play sounds."
              },
              "voice": {
                "type": "string",
                "description": "Default: system default voice\n\nWhich voice to use. See notes for how to discover installed voices.  If the requested voice is not available the default voice will be used. Example voice names from Windows 10 are 'Microsoft Zira Desktop' and 'Microsoft Hazel Desktop'."
              },
              "speech_speed": {
                "type": "string",
                "description": "How fast or slow to speak the text.  Must be an integer value in the range -10 to 10.  -10 is slowest, 10 is fastest."
              }
            }
          },
          "os_recordset": {
            "type": "object",
            "description": "Manage OpenStack DNS recordsets. Recordsets can be created, deleted or updated. Only the I(records), I(description), and I(ttl) values can be updated.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the recordset"
              },
              "zone": {
                "type": "string",
                "description": "Zone managing the recordset"
              },
              "records": {
                "type": "string",
                "description": "List of recordset definitions"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "ttl": {
                "type": "string",
                "description": "Default: None\n\nTTL (Time To Live) value in seconds"
              },
              "recordset_type": {
                "type": "string",
                "description": "Recordset type"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nDescription of the recordset"
              }
            }
          },
          "junos_rpc": {
            "required": [
              "rpc"
            ],
            "type": "object",
            "description": "Sends a request to the remote device running JUNOS to execute the specified RPC using the NetConf transport.  The reply is then returned to the playbook in the c(xml) key.  If an alternate output format is requested, the reply is transformed to the requested output.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "args": {
                "type": "object",
                "description": "The C(args) argument provides a set of arguments for the RPC call and are encoded in the request message.  This argument accepts a set of key=value arguments."
              },
              "rpc": {
                "type": "string",
                "description": "The C(rpc) argument specifies the RPC call to send to the remote devices to be executed.  The RPC Reply message is parsed and the contents are returned to the playbook."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "output": {
                "enum": [
                  "xml",
                  "json",
                  "text"
                ],
                "type": "string",
                "description": "Default: xml\n\nThe C(output) argument specifies the desired output of the return data.  This argument accepts one of C(xml), C(text), or C(json).  For C(json), the JUNOS device must be running a version of software that supports native JSON output."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              }
            }
          },
          "pn_ospf": {
            "required": [
              "pn_vrouter_name",
              "pn_network_ip"
            ],
            "type": "object",
            "description": "Execute vrouter-ospf-add, vrouter-ospf-remove command.\nThis command adds/removes Open Shortest Path First(OSPF) routing protocol to a virtual router(vRouter) service.",
            "properties": {
              "pn_ospf_area": {
                "type": "string",
                "description": "Stub area number for the configuration. Required for vrouter-ospf-add."
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_vrouter_name": {
                "type": "string",
                "description": "Specify the name of the vRouter."
              },
              "pn_network_ip": {
                "type": "string",
                "description": "Specify the network IP (IPv4 or IPv6) address."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nAssert the state of the ospf. Use 'present' to add ospf and 'absent' to remove ospf."
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch to run the CLI on."
              }
            }
          },
          "htpasswd": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "username"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "dest",
                        "destfile"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "destfile"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add and remove username/password entries in a password file using htpasswd.\nThis is used by web servers such as Apache and Nginx for basic authentication.",
            "properties": {
              "username": {
                "type": "string",
                "description": "User name to add or remove"
              },
              "name": {
                "type": "string",
                "description": "User name to add or remove"
              },
              "dest": {
                "type": "string",
                "description": "Path to the file that contains the usernames and passwords"
              },
              "create": {
                "description": "Default: yes\n\nUsed with C(state=present). If specified, the file will be created if it does not already exist. If set to \"no\", will fail if the file does not exist",
                "$ref": "#/definitions/ansible_truth"
              },
              "destfile": {
                "type": "string",
                "description": "Path to the file that contains the usernames and passwords"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhether the user entry should be present or not"
              },
              "path": {
                "type": "string",
                "description": "Path to the file that contains the usernames and passwords"
              },
              "password": {
                "type": "string",
                "description": "Password associated with user.\nMust be specified if user does not exist yet."
              },
              "crypt_scheme": {
                "type": "string",
                "description": "Default: apr_md5_crypt\n\nEncryption scheme to be used.  As well as the four choices listed here, you can also use any other hash supported by passlib, such as md5_crypt and sha256_crypt, which are linux passwd hashes.  If you do so the password file will not be compatible with Apache or Nginx"
              }
            }
          },
          "gce_tag": {
            "required": [
              "instance_name"
            ],
            "type": "object",
            "description": "This module can add or remove tags U(https://cloud.google.com/compute/docs/instances/#tags) to/from GCE instance.",
            "properties": {
              "zone": {
                "type": "string",
                "description": "Default: us-central1-a\n\nthe zone of the disk specified by source"
              },
              "tags": {
                "description": "comma-separated list of tags to add or remove",
                "$ref": "#/definitions/ansible_array"
              },
              "service_account_email": {
                "type": "string",
                "description": "service account email"
              },
              "pem_file": {
                "type": "string",
                "description": "path to the pem file associated with the service account email"
              },
              "instance_name": {
                "type": "string",
                "description": "the name of the GCE instance to add/remove tags"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\ndesired state of the tags"
              },
              "project_id": {
                "type": "string",
                "description": "your GCE project ID"
              }
            }
          },
          "zabbix_maintenance": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "host_names",
                        "host_name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_url",
                        "url"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "server_url"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "url"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "host_groups",
                        "host_group"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module will let you create Zabbix maintenance windows.",
            "properties": {
              "http_login_password": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth password"
              },
              "name": {
                "type": "string",
                "description": "Unique name of maintenance window."
              },
              "url": {
                "type": "string",
                "description": "Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url)."
              },
              "login_user": {
                "type": "string",
                "description": "Zabbix user name."
              },
              "http_login_user": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth login"
              },
              "host_names": {
                "description": "Hosts to manage maintenance window for. Separate multiple hosts with commas. C(host_name) is an alias for C(host_names). B(Required) option when C(state) is I(present) and no C(host_groups) specified.",
                "$ref": "#/definitions/ansible_array"
              },
              "server_url": {
                "type": "string",
                "description": "Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url)."
              },
              "host_groups": {
                "description": "Host groups to manage maintenance window for. Separate multiple groups with commas. C(host_group) is an alias for C(host_groups). B(Required) option when C(state) is I(present) and no C(host_names) specified.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or remove a maintenance window."
              },
              "host_name": {
                "description": "Hosts to manage maintenance window for. Separate multiple hosts with commas. C(host_name) is an alias for C(host_names). B(Required) option when C(state) is I(present) and no C(host_groups) specified.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "Default: 10\n\nThe timeout of API request (seconds).",
                "$ref": "#/definitions/ansible_number"
              },
              "login_password": {
                "type": "string",
                "description": "Zabbix user password."
              },
              "collect_data": {
                "description": "Default: true\n\nType of maintenance. With data collection, or without.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host_group": {
                "description": "Host groups to manage maintenance window for. Separate multiple groups with commas. C(host_group) is an alias for C(host_groups). B(Required) option when C(state) is I(present) and no C(host_names) specified.",
                "$ref": "#/definitions/ansible_array"
              },
              "minutes": {
                "description": "Default: 10\n\nLength of maintenance window in minutes.",
                "$ref": "#/definitions/ansible_number"
              },
              "desc": {
                "type": "string",
                "description": "Default: Created by Ansible\n\nShort description of maintenance window."
              }
            }
          },
          "cl_img_install": {
            "required": [
              "src"
            ],
            "type": "object",
            "description": "install a different version of Cumulus Linux in the inactive slot. For more details go the Image Management User Guide at U(http://docs.cumulusnetworks.com/).",
            "properties": {
              "src": {
                "type": "string",
                "description": "The full path to the Cumulus Linux binary image. Can be a local path, http or https URL. If the code version is in the name of the file, the module will assume this is the version of code you wish to install."
              },
              "version": {
                "type": "string",
                "description": "Default: None\n\nInform the module of the exact version one is installing. This overrides the automatic check of version in the file name. For example, if the binary file name is called CumulusLinux-2.2.3.bin, and version is set to '2.5.0', then the module will assume it is installing '2.5.0' not '2.2.3'. If version is not included, then the module will assume '2.2.3' is the version to install."
              },
              "switch_slot": {
                "description": "Default: no\n\nSwitch slots after installing the image. To run the installed code, reboot the switch.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "panos_security_policy": {
            "required": [
              "ip_address",
              "rule_name"
            ],
            "type": "object",
            "description": "Security policies allow you to enforce rules and take action, and can be as general or specific as needed. The policy rules are compared against the incoming traffic in sequence, and because the first rule that matches the traffic is applied, the more specific rules must precede the more general ones.",
            "properties": {
              "wildfire_analysis": {
                "type": "string",
                "description": "Default: None\n\nName of the already defined wildfire_analysis profile."
              },
              "spyware": {
                "type": "string",
                "description": "Default: None\n\nName of the already defined spyware profile."
              },
              "hip_profiles": {
                "description": "Default: any\n\nIf you are using GlobalProtect with host information profile (HIP) enabled, you can also base the policy on information collected by GlobalProtect. For example, the user access level can be determined HIP that notifies the firewall about the user's local configuration.\n",
                "$ref": "#/definitions/ansible_array"
              },
              "file_blocking": {
                "type": "string",
                "description": "Default: None\n\nName of the already defined file_blocking profile."
              },
              "tag": {
                "type": "string",
                "description": "Default: None\n\nAdministrative tags that can be added to the rule. Note, tags must be already defined."
              },
              "log_start": {
                "description": "Whether to log at session start.",
                "$ref": "#/definitions/ansible_truth"
              },
              "data_filtering": {
                "type": "string",
                "description": "Default: None\n\nName of the already defined data_filtering profile."
              },
              "category": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "to_zone": {
                "description": "Default: any\n\nList of destination zones.",
                "$ref": "#/definitions/ansible_array"
              },
              "service": {
                "description": "Default: application-default\n\nList of services.",
                "$ref": "#/definitions/ansible_array"
              },
              "application": {
                "description": "Default: any\n\nList of applications.",
                "$ref": "#/definitions/ansible_array"
              },
              "destination": {
                "description": "Default: any\n\nList of destination addresses.",
                "$ref": "#/definitions/ansible_array"
              },
              "from_zone": {
                "description": "Default: any\n\nList of source zones.",
                "$ref": "#/definitions/ansible_array"
              },
              "source_user": {
                "description": "Default: any\n\nUse users to enforce policy for individual users or a group of users.",
                "$ref": "#/definitions/ansible_array"
              },
              "url_filtering": {
                "type": "string",
                "description": "Default: None\n\nName of the already defined url_filtering profile."
              },
              "group_profile": {
                "type": "string",
                "description": "Default: None\n\nSecurity profile group that is already defined in the system. This property supersedes antivirus, vulnerability, spyware, url_filtering, file_blocking, data_filtering, and wildfire_analysis properties.\n"
              },
              "api_key": {
                "type": "string",
                "description": "API key that can be used instead of I(username)/I(password) credentials."
              },
              "username": {
                "type": "string",
                "description": "Default: admin\n\nUsername credentials to use for auth unless I(api_key) is set."
              },
              "devicegroup": {
                "type": "string",
                "description": "Default: None\n\nDevice groups are used for the Panorama interaction with Firewall(s). The group must exists on Panorama. If device group is not define we assume that we are contacting Firewall.\n"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nDescription for the security rule."
              },
              "antivirus": {
                "type": "string",
                "description": "Default: None\n\nName of the already defined antivirus profile."
              },
              "rule_name": {
                "type": "string",
                "description": "Name of the security rule."
              },
              "password": {
                "type": "string",
                "description": "Password credentials to use for auth unless I(api_key) is set."
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device being configured."
              },
              "rule_type": {
                "type": "string",
                "description": "Default: universal\n\nType of security rule (version 6.1 of PanOS and above)."
              },
              "vulnerability": {
                "type": "string",
                "description": "Default: None\n\nName of the already defined vulnerability profile."
              },
              "source": {
                "description": "Default: any\n\nList of source addresses.",
                "$ref": "#/definitions/ansible_array"
              },
              "action": {
                "type": "string",
                "description": "Default: allow\n\nAction to apply once rules maches."
              },
              "commit": {
                "description": "Default: True\n\nCommit configuration if changed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "log_end": {
                "description": "Default: True\n\nWhether to log at session end.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "infini_pool": {
            "type": "object",
            "description": "This module to creates, deletes or modifies pools on Infinibox.",
            "properties": {
              "ssd_cache": {
                "type": "string",
                "description": "Default: True\n\nEnable/Disable SSD Cache on Pool"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nCreates/Modifies Pool when present or removes when absent"
              },
              "vsize": {
                "type": "string",
                "description": "Pool Virtual Capacity in MB, GB or TB units. If pool vsize is not set on pool creation, Virtual Capacity will be equal to Physical Capacity. See examples."
              },
              "name": {
                "type": "string",
                "description": "Pool Name"
              },
              "size": {
                "type": "string",
                "description": "Pool Physical Capacity in MB, GB or TB units. If pool size is not set on pool creation, size will be equal to 1TB. See examples."
              }
            }
          },
          "nxos_gir_profile_management": {
            "required": [
              "mode"
            ],
            "type": "object",
            "description": "Manage a maintenance-mode or normal-mode profile with configuration commands that can be applied during graceful removal or graceful insertion.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "commands": {
                "description": "List of commands to be included into the profile.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": "Specify the configuration string to be used for module operations."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify desired state of the resource."
              },
              "include_defaults": {
                "type": "string",
                "description": "Specify to retrieve or not the complete running configuration for module operations."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "mode": {
                "enum": [
                  "maintenance",
                  "normal"
                ],
                "type": "string",
                "description": "Configure the profile as Maintenance or Normal mode."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "kernel_blacklist": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Add or remove kernel modules from blacklist.",
            "properties": {
              "blacklist_file": {
                "type": "string",
                "description": "If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the module should be present in the blacklist or absent."
              },
              "name": {
                "type": "string",
                "description": "Name of kernel module to black- or whitelist."
              }
            }
          },
          "cs_snapshot_policy": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "interval_type",
                        "interval"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "time_zone",
                        "timezone"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "max_snaps",
                        "max"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, update and delete volume snapshot policies.",
            "properties": {
              "project": {
                "type": "string",
                "description": "Name of the project the volume is related to."
              },
              "account": {
                "type": "string",
                "description": "Account the volume is related to."
              },
              "interval": {
                "enum": [
                  "hourly",
                  "daily",
                  "weekly",
                  "monthly"
                ],
                "type": "string",
                "description": "Default: daily\n\nInterval of the snapshot."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "schedule": {
                "type": "string",
                "description": "Time the snapshot is scheduled. Required if C(state=present).\nFormat for C(interval_type=HOURLY): C(MM)\nFormat for C(interval_type=DAILY): C(MM:HH)\nFormat for C(interval_type=WEEKLY): C(MM:HH:DD (1-7))\nFormat for C(interval_type=MONTHLY): C(MM:HH:DD (1-28))"
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "interval_type": {
                "enum": [
                  "hourly",
                  "daily",
                  "weekly",
                  "monthly"
                ],
                "type": "string",
                "description": "Default: daily\n\nInterval of the snapshot."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "time_zone": {
                "type": "string",
                "description": "Default: UTC\n\nSpecifies a timezone for this command."
              },
              "volume": {
                "type": "string",
                "description": "Name of the volume."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the snapshot policy."
              },
              "domain": {
                "type": "string",
                "description": "Domain the volume is related to."
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "max_snaps": {
                "description": "Default: 8\n\nMax number of snapshots.",
                "$ref": "#/definitions/ansible_number"
              },
              "timezone": {
                "type": "string",
                "description": "Default: UTC\n\nSpecifies a timezone for this command."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "max": {
                "description": "Default: 8\n\nMax number of snapshots.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "nxos_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends an arbitrary command to an NXOS node and returns the results read from the device.  This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should by tried before it is considered failed.  The command is run on the target device every retry and evaluated against the I(wait_for) conditionals.",
                "$ref": "#/definitions/ansible_number"
              },
              "commands": {
                "description": "The commands to send to the remote NXOS device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.\nThe I(commands) argument also accepts an alternative form that allows for complex values that specify the command to run and the output format to return.   This can be done on a command by command basis.  The complex argument supports the keywords C(command) and C(output) where C(command) is the command to run and C(output) is one of 'text' or 'json'.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command.  If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_for": {
                "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "match": {
                "enum": [
                  "any",
                  "all"
                ],
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "waitfor": {
                "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "virt_pool": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pool"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage I(libvirt) storage pools.",
            "properties": {
              "xml": {
                "type": "string",
                "description": "XML document used with the define command."
              },
              "name": {
                "type": "string",
                "description": "name of the storage pool being managed. Note that pool must be previously defined with xml."
              },
              "uri": {
                "type": "string",
                "description": "Default: qemu:///system\n\nI(libvirt) connection uri."
              },
              "state": {
                "enum": [
                  "active",
                  "inactive",
                  "present",
                  "absent",
                  "undefined",
                  "deleted"
                ],
                "type": "string",
                "description": "specify which state you want a storage pool to be in. If 'active', pool will be started. If 'present', ensure that pool is present but do not change its state; if it's missing, you need to specify xml argument. If 'inactive', pool will be stopped. If 'undefined' or 'absent', pool will be removed from I(libvirt) configuration. If 'deleted', pool contents will be deleted and then pool undefined."
              },
              "command": {
                "enum": [
                  "create",
                  "status",
                  "start",
                  "stop",
                  "build",
                  "delete",
                  "undefine",
                  "destroy",
                  "get_xml",
                  "define",
                  "refresh",
                  "list_pools",
                  "facts",
                  "info"
                ],
                "type": "string",
                "description": "in addition to state management, various non-idempotent commands are available. See examples."
              },
              "mode": {
                "enum": [
                  "new",
                  "repair",
                  "resize",
                  "no_overwrite",
                  "overwrite",
                  "normal",
                  "zeroed"
                ],
                "type": "string",
                "description": "Pass additional parameters to 'build' or 'delete' commands."
              },
              "autostart": {
                "description": "Specify if a given storage pool should be started automatically on system boot.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pool": {
                "type": "string",
                "description": "name of the storage pool being managed. Note that pool must be previously defined with xml."
              }
            }
          },
          "infini_export_client": {
            "type": "object",
            "description": "This module creates, deletes or modifys NFS client(s) for existing exports on Infinibox.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nCreates/Modifies client when present and removes when absent."
              },
              "access_mode": {
                "type": "string",
                "description": "Default: RW\n\nRead Write or Read Only Access."
              },
              "export": {
                "type": "string",
                "description": "Name of the export."
              },
              "no_root_squash": {
                "type": "string",
                "description": "Don't squash root user to anonymous. Will be set to \"no\" on creation if not specified explicitly."
              },
              "client": {
                "type": "string",
                "description": "Client IP or Range. Ranges can be defined as follows 192.168.0.1-192.168.0.254."
              }
            }
          },
          "netapp_e_amg_sync": {
            "required": [
              "api_url",
              "api_password",
              "name",
              "state",
              "api_username",
              "ssid"
            ],
            "type": "object",
            "description": "Allows for the initialization, suspension and resumption of an asynchronous mirror group's synchronization for NetApp E-series storage arrays.",
            "properties": {
              "ssid": {
                "type": "string",
                "description": "The ID of the storage array containing the AMG you wish to target"
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "state": {
                "enum": [
                  "running",
                  "suspended"
                ],
                "type": "string",
                "description": "The synchronization action you'd like to take.\nIf C(running) then it will begin syncing if there is no active sync or will resume a suspended sync. If there is already a sync in progress, it will return with an OK status.\nIf C(suspended) it will suspend any ongoing sync action, but return OK if there is no active sync or if the sync is already suspended"
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "delete_recovery_point": {
                "description": "Indicates whether the failures point can be deleted on the secondary if necessary to achieve the synchronization.\nIf true, and if the amount of unsynchronized data exceeds the CoW repository capacity on the secondary for any member volume, the last failures point will be deleted and synchronization will continue.\nIf false, the synchronization will be suspended if the amount of unsynchronized data exceeds the CoW Repository capacity on the secondary and the failures point will be preserved.\nNOTE: This only has impact for newly launched syncs.",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name of the async mirror group you wish to target"
              }
            }
          },
          "rabbitmq_parameter": {
            "required": [
              "name",
              "component"
            ],
            "type": "object",
            "description": "Manage dynamic, cluster-wide parameters for RabbitMQ",
            "properties": {
              "node": {
                "type": "string",
                "description": "Default: rabbit\n\nerlang node name of the rabbit we wish to configure"
              },
              "name": {
                "type": "string",
                "description": "Name of the parameter being set"
              },
              "component": {
                "type": "string",
                "description": "Name of the component of which the parameter is being set"
              },
              "value": {
                "type": "string",
                "description": "Value of the parameter, as a JSON term"
              },
              "vhost": {
                "type": "string",
                "description": "Default: /\n\nvhost to apply access privileges."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify if user is to be added or removed"
              }
            }
          },
          "logentries": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "logtype",
                        "type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends logs to LogEntries in realtime",
            "properties": {
              "logtype": {
                "type": "string",
                "description": "type of the log"
              },
              "state": {
                "enum": [
                  "present",
                  "followed",
                  "absent",
                  "unfollowed"
                ],
                "type": "string",
                "description": "Default: present\n\nfollowing state of the log"
              },
              "type": {
                "type": "string",
                "description": "type of the log"
              },
              "name": {
                "type": "string",
                "description": "name of the log"
              },
              "path": {
                "type": "string",
                "description": "path to a log file"
              }
            }
          },
          "openwrt_init": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "service"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "service"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Controls OpenWrt services on remote hosts.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "If the service does not respond to the 'running' command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a 'running' result.  If the string is found, the service will be assumed to be running."
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "restarted",
                  "reloaded"
                ],
                "type": "string",
                "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. C(restarted) will always bounce the service. C(reloaded) will always reload."
              },
              "enabled": {
                "description": "Whether the service should start on boot. B(At least one of state and enabled are required.)",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the service."
              },
              "service": {
                "type": "string",
                "description": "Name of the service."
              }
            }
          },
          "smartos_image_facts": {
            "type": "object",
            "description": "Retrieve facts about all installed images on SmartOS. Facts will be inserted to the ansible_facts key.",
            "properties": {
              "filters": {
                "type": "string",
                "description": "Default: None\n\nCriteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More informaton can be found at U(https://smartos.org/man/1m/imgadm) under 'imgadm list'."
              }
            }
          },
          "bigip_pool_member": {
            "type": "object",
            "description": "Manages F5 BIG-IP LTM pool members via iControl SOAP API",
            "properties": {
              "session_state": {
                "type": "string",
                "description": "Set new session availability status for pool member"
              },
              "ratio": {
                "type": "string",
                "description": "Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overriden with this value -- default to 1."
              },
              "description": {
                "type": "string",
                "description": "Pool member description"
              },
              "monitor_state": {
                "type": "string",
                "description": "Set monitor availability status for pool member"
              },
              "partition": {
                "type": "string",
                "description": "Default: Common\n\nPartition"
              },
              "connection_limit": {
                "type": "string",
                "description": "Pool member connection limit. Setting this to 0 disables the limit."
              },
              "host": {
                "type": "string",
                "description": "Pool member IP"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nPool member state"
              },
              "preserve_node": {
                "type": "string",
                "description": "Default: no\n\nWhen state is absent and the pool member is no longer referenced in other pools, the default behavior removes the unused node o bject. Setting this to 'yes' disables this behavior."
              },
              "rate_limit": {
                "type": "string",
                "description": "Pool member rate limit (connections-per-second). Setting this to 0 disables the limit."
              },
              "port": {
                "type": "string",
                "description": "Pool member port"
              },
              "pool": {
                "type": "string",
                "description": "Pool name. This pool must exist."
              }
            }
          },
          "win_ping": {
            "type": "object",
            "description": "Checks management connectivity of a windows host",
            "properties": {
              "data": {
                "type": "string",
                "description": "Default: pong\n\nAlternate data to return instead of 'pong'"
              }
            }
          },
          "avi_api_session": {
            "required": [
              "http_method",
              "path"
            ],
            "type": "object",
            "description": "This module can be used for calling any resources defined in Avi REST API. U(https://avinetworks.com/)\nThis module is useful for invoking HTTP Patch methods and accessing resources that do not have an REST object associated with them.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "http_method": {
                "enum": [
                  "get",
                  "put",
                  "post",
                  "patch",
                  "delete"
                ],
                "type": "string",
                "description": "Allowed HTTP methods for RESTful services and are supported by Avi Controller."
              },
              "params": {
                "type": "object",
                "description": "Query parameters passed to the HTTP API."
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "Timeout (in seconds) for Avi API calls.",
                "$ref": "#/definitions/ansible_number"
              },
              "path": {
                "type": "string",
                "description": "Path for Avi API resource. For example, C(path: virtualservice) will translate to C(api/virtualserivce)."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "data": {
                "type": "string",
                "description": "HTTP body in YAML or JSON format."
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              }
            }
          },
          "avi_networkprofile": {
            "required": [
              "profile",
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure NetworkProfile object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "profile": {
                "type": "object",
                "description": "Networkprofileunion settings for networkprofile."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "uuid": {
                "type": "string",
                "description": "Uuid of the network profile."
              },
              "description": {
                "type": "string",
                "description": "User defined description for the object."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the network profile."
              }
            }
          },
          "nginx_status_facts": {
            "required": [
              "url"
            ],
            "type": "object",
            "description": "Gathers facts from nginx from an URL having C(stub_status) enabled.",
            "properties": {
              "url": {
                "type": "string",
                "description": "URL of the nginx status."
              },
              "timeout": {
                "description": "Default: 10\n\nHTTP connection timeout in seconds.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "win_feature": {
            "type": "object",
            "description": "Installs or uninstalls Windows Roles or Features on Windows Server. This module uses the Add/Remove-WindowsFeature Cmdlets on Windows 2008 and Install/Uninstall-WindowsFeature Cmdlets on Windows 2012, which are not available on client os machines.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Names of roles or features to install as a single feature or a comma-separated list of features"
              },
              "include_management_tools": {
                "type": "string",
                "description": "Adds the corresponding management tools to the specified feature.\nNot supported in Windows 2008. If present when using Windows 2008 this option will be ignored."
              },
              "include_sub_features": {
                "type": "string",
                "description": "Adds all subfeatures of the specified feature"
              },
              "source": {
                "type": "string",
                "description": "Specify a source to install the feature from.\nNot supported in Windows 2008. If present when using Windows 2008 this option will be ignored."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nState of the features or roles on the system"
              },
              "restart": {
                "type": "string",
                "description": "Restarts the computer automatically when installation is complete, if restarting is required by the roles or features installed."
              }
            }
          },
          "win_service": {
            "type": "object",
            "description": "Manages Windows services",
            "properties": {
              "username": {
                "type": "string",
                "description": "The username to set the service to start as.\nThis and the C(password) argument must be supplied together."
              },
              "display_name": {
                "type": "string",
                "description": "The display name to set for the service."
              },
              "description": {
                "type": "string",
                "description": "The description to set for the service."
              },
              "force_dependent_services": {
                "type": "string",
                "description": "If True, stopping or restarting a service with dependent services will force the dependent services to stop or restart also.\nIf False, stopping or restarting a service with dependent services may fail."
              },
              "dependency_action": {
                "type": "string",
                "description": "Default: set\n\nUsed in conjunction with C(dependency) to either add the dependencies to the existing service dependencies.\nRemove the dependencies to the existing dependencies.\nSet the dependencies to only the values in the list replacing the existing dependencies."
              },
              "name": {
                "type": "string",
                "description": "Name of the service"
              },
              "start_mode": {
                "type": "string",
                "description": "Set the startup type for the service.\nC(delayed) added in Ansible 2.3"
              },
              "state": {
                "type": "string",
                "description": "C(started)/C(stopped)/C(absent) are idempotent actions that will not run commands unless necessary.\nC(restarted) will always bounce the service.\nC(absent) added in Ansible 2.3"
              },
              "dependencies": {
                "type": "string",
                "description": "A list of service dependencies to set for this particular service.\nThis should be a list of service names and not the display name of the service.\nThis works by C(dependency_action) to either add/remove or set the services in this list."
              },
              "path": {
                "type": "string",
                "description": "The path to the executable to set for the service."
              },
              "password": {
                "type": "string",
                "description": "The password to set the service to start as.\nThis and the C(username) argument must be supplied together.\nIf specifying LocalSystem, NetworkService or LocalService this field must be an empty string and not null."
              },
              "desktop_interact": {
                "type": "string",
                "description": "Whether to allow the service user to interact with the desktop.\nThis should only be set to true when using the LocalSystem username."
              }
            }
          },
          "ec2_elb": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module de-registers or registers an AWS EC2 instance from the ELBs that it belongs to.\nReturns fact \"ec2_elbs\" which is a list of elbs attached to the instance if state=absent is passed as an argument.\nWill be marked changed when called only if there are ELBs found to operate on.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_elbs": {
                "description": "Default: None\n\nList of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.",
                "$ref": "#/definitions/ansible_array"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: True\n\nWait for instance registration or deregistration to complete successfully before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "instance_id": {
                "type": "string",
                "description": "EC2 Instance ID"
              },
              "state": {
                "type": "string",
                "description": "register or deregister the instance"
              },
              "wait_timeout": {
                "description": "Number of seconds to wait for an instance to change state. If 0 then this module may return an error if a transient error occurs. If non-zero then any transient errors are ignored until the timeout is reached. Ignored when wait=no.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "Default: yes\n\nWhen set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
                "$ref": "#/definitions/ansible_truth"
              },
              "enable_availability_zone": {
                "description": "Default: True\n\nWhether to enable the availability zone of the instance on the target ELB if the availability zone has not already been enabled. If set to no, the task will fail if the availability zone is not enabled on the ELB.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "win_tempfile": {
            "type": "object",
            "description": "Creates temporary files and directories.",
            "properties": {
              "path": {
                "type": "string",
                "description": "Default: %TEMP%\n\nLocation where temporary file or directory should be created.\nIf path is not specified default system temporary directory (%TEMP%) will be used."
              },
              "state": {
                "type": "string",
                "description": "Default: file\n\nWhether to create file or directory."
              },
              "prefix": {
                "type": "string",
                "description": "Default: ansible.\n\nPrefix of file/directory name created by module."
              },
              "suffix": {
                "type": "string",
                "description": "Suffix of file/directory name created by module."
              }
            }
          },
          "git_config": {
            "type": "object",
            "description": "The M(git_config) module changes git configuration by invoking 'git config'. This is needed if you don't want to use M(template) for the entire git config file (e.g. because you need to change just C(user.email) in /etc/.git/config).  Solutions involving M(command) are cumbersone or don't work correctly in check mode.",
            "properties": {
              "repo": {
                "type": "string",
                "description": "Path to a git repository for reading and writing values from a specific repo."
              },
              "scope": {
                "enum": [
                  "local",
                  "global",
                  "system"
                ],
                "type": "string",
                "description": "Specify which scope to read/set values from. This is required when setting config values. If this is set to local, you must also specify the repo parameter. It defaults to system only when not using I(list_all)=yes."
              },
              "list_all": {
                "description": "List all settings (optionally limited to a given I(scope))",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name of the setting. If no value is supplied, the value will be read from the config if it has been set."
              },
              "value": {
                "type": "string",
                "description": "When specifying the name of a single setting, supply a value to set that setting to the given value."
              }
            }
          },
          "rax_identity": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Verifies Rackspace Cloud credentials and returns identity information",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ovirt_templates_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt templates.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search template X from datacenter Y use following pattern: name=X and datacenter=Y"
              }
            }
          },
          "cs_portforward": {
            "required": [
              "private_port",
              "ip_address",
              "public_port"
            ],
            "type": "object",
            "description": "Create, update and remove port forwarding rules.",
            "properties": {
              "open_firewall": {
                "description": "Whether the firewall rule for public port should be created, while creating the new rule.\nUse M(cs_firewall) for managing firewall rules.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vm_guest_ip": {
                "type": "string",
                "description": "VM guest NIC secondary IP address for the port forwarding rule."
              },
              "domain": {
                "type": "string",
                "description": "Domain the C(vm) is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "protocol": {
                "enum": [
                  "tcp",
                  "udp"
                ],
                "type": "string",
                "description": "Default: tcp\n\nProtocol of the port forwarding rule."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "public_port": {
                "description": "Start public port for this rule.",
                "$ref": "#/definitions/ansible_number"
              },
              "vm": {
                "type": "string",
                "description": "Name of virtual machine which we make the port forwarding rule for.\nRequired if C(state=present)."
              },
              "public_end_port": {
                "description": "End public port for this rule.\nIf not specified equal C(public_port).",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the C(vm) is located in."
              },
              "private_port": {
                "description": "Start private port for this rule.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the port forwarding rule."
              },
              "private_end_port": {
                "description": "End private port for this rule.\nIf not specified equal C(private_port).",
                "$ref": "#/definitions/ansible_number"
              },
              "account": {
                "type": "string",
                "description": "Account the C(vm) is related to."
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the virtual machine is in.\nIf not set, default zone is used."
              },
              "ip_address": {
                "type": "string",
                "description": "Public IP address the rule is assigned to."
              }
            }
          },
          "iam_policy": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Allows uploading or removing IAM policies for IAM users, groups or roles.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "policy_document": {
                "type": "string",
                "description": "The path to the properly json formatted policy file (mutually exclusive with C(policy_json))"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "iam_name": {
                "type": "string",
                "description": "Name of IAM resource you wish to target for policy actions. In other words, the user name, group name or role name."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "iam_type": {
                "enum": [
                  "user",
                  "group",
                  "role"
                ],
                "type": "string",
                "description": "Type of IAM resource"
              },
              "policy_name": {
                "type": "string",
                "description": "The name label for the policy to create or remove."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether to create or delete the IAM policy."
              },
              "policy_json": {
                "type": "string",
                "description": "A properly json formatted policy as string (mutually exclusive with C(policy_document), see https://github.com/ansible/ansible/issues/7005#issuecomment-42894813 on how to use it properly)"
              },
              "skip_duplicates": {
                "description": "Default: /\n\nBy default the module looks for any policies that match the document you pass in, if there is a match it will not make a new policy object with the same rules. You can override this by specifying false which would allow for two policy objects with different names but same rules.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "win_reboot": {
            "type": "object",
            "description": "Reboot a Windows machine, wait for it to go down, come back up, and respond to commands.",
            "properties": {
              "connect_timeout_sec": {
                "type": "string",
                "description": "Default: 5\n\nMaximum seconds to wait for a single successful TCP connection to the WinRM endpoint before trying again"
              },
              "reboot_timeout_sec": {
                "type": "string",
                "description": "Default: 600\n\nMaximum seconds to wait for machine to re-appear on the network and respond to a test command\nThis timeout is evaluated separately for both network appearance and test command success (so maximum clock time is actually twice this value)"
              },
              "test_command": {
                "type": "string",
                "description": "Default: whoami\n\nCommand to expect success for to determine the machine is ready for management"
              },
              "pre_reboot_delay_sec": {
                "type": "string",
                "description": "Default: 2\n\nSeconds for shutdown to wait before requesting reboot"
              },
              "msg": {
                "type": "string",
                "description": "Default: Reboot initiated by Ansible\n\nMessage to display to users"
              },
              "shutdown_timeout_sec": {
                "type": "string",
                "description": "Default: 600\n\nMaximum seconds to wait for shutdown to occur\nIncrease this timeout for very slow hardware, large update applications, etc"
              }
            }
          },
          "rax_files_objects": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Upload, download, and delete objects in Rackspace Cloud Files",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "Source from which to upload files.  Used to specify a remote object as a source for an operation, i.e. a file name, \"file1\", or a comma-separated list of remote objects, \"file1,file2,file17\".  src and dest are mutually exclusive on remote-only object operations"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "container": {
                "type": "string",
                "description": "The container to use for file object operations."
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "expires": {
                "description": "Used to set an expiration on a file or folder uploaded to Cloud Files. Requires an integer, specifying expiration in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "dest": {
                "type": "string",
                "description": "The destination of a \"get\" operation; i.e. a local directory, \"/home/user/myfolder\". Used to specify the destination of an operation on a remote object; i.e. a file name, \"file1\", or a comma-separated list of remote objects, \"file1,file2,file17\""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "clear_meta": {
                "description": "Default: no\n\nOptionally clear existing metadata when applying metadata to existing objects. Selecting this option is only appropriate when setting type=meta",
                "$ref": "#/definitions/ansible_truth"
              },
              "meta": {
                "type": "object",
                "description": "A hash of items to set as metadata values on an uploaded file or folder"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "type": {
                "enum": [
                  "file",
                  "meta"
                ],
                "type": "string",
                "description": "Default: file\n\nType of object to do work on\nMetadata object or a file object"
              },
              "method": {
                "enum": [
                  "get",
                  "put",
                  "delete"
                ],
                "type": "string",
                "description": "Default: get\n\nThe method of operation to be performed.  For example, put to upload files to Cloud Files, get to download files from Cloud Files or delete to delete remote objects in Cloud Files"
              },
              "structure": {
                "description": "Default: yes\n\nUsed to specify whether to maintain nested directory structure when downloading objects from Cloud Files.  Setting to false downloads the contents of a container to a single, flat directory",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "elasticache_parameter_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage cache security groups in Amazon Elasticache.\nReturns information about the specified cache cluster.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "A user-specified description for the cache parameter group."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "A user-specified name for the cache parameter group."
              },
              "group_family": {
                "enum": [
                  "memcached1.4",
                  "redis2.6",
                  "redis2.8",
                  "redis3.2"
                ],
                "type": "string",
                "description": "The name of the cache parameter group family that the cache parameter group can be used with."
              },
              "state": {
                "type": "string",
                "description": "Idempotent actions that will create/modify, destroy, or reset a cache parameter group as needed."
              },
              "values": {
                "type": "object",
                "description": "Default: None\n\nA user-specified list of parameters to reset or modify for the cache parameter group."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "postgresql_schema": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "schema",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "schema"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove PostgreSQL schema from a remote host.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the schema to add or remove."
              },
              "database": {
                "type": "string",
                "description": "Default: postgres\n\nName of the database to connect to."
              },
              "login_user": {
                "type": "string",
                "description": "The username used to authenticate with."
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nHost running the database."
              },
              "login_unix_socket": {
                "type": "string",
                "description": "Path to a Unix domain socket for local connections."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe schema state."
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with."
              },
              "owner": {
                "type": "string",
                "description": "Name of the role to set as owner of the schema."
              },
              "port": {
                "type": "string",
                "description": "Default: 5432\n\nDatabase port to connect to."
              },
              "schema": {
                "type": "string",
                "description": "Name of the schema to add or remove."
              }
            }
          },
          "jenkins_plugin": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Ansible module which helps to manage Jenkins plugins.",
            "properties": {
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "owner": {
                "type": "string",
                "description": "Default: jenkins\n\nName of the Jenkins user on the OS."
              },
              "client_key": {
                "type": "string",
                "description": ""
              },
              "group": {
                "type": "string",
                "description": "Default: jenkins\n\nName of the Jenkins group on the OS."
              },
              "use_proxy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "updates_url": {
                "type": "string",
                "description": "Default: https://updates.jenkins-ci.org\n\nURL of the Update Centre.\nUsed as the base URL to download the plugins and the I(update-center.json) JSON file."
              },
              "state": {
                "enum": [
                  "absent",
                  "present",
                  "pinned",
                  "unpinned",
                  "enabled",
                  "disabled",
                  "latest"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired plugin state.\nIf the C(latest) is set, the check for new version will be performed every time. This is suitable to keep the plugin up-to-date."
              },
              "version": {
                "type": "string",
                "description": "Plugin version number.\nIf this option is specified, all plugin dependencies must be installed manually.\nIt might take longer to verify that the correct version is installed. This is especially true if a specific version number is specified."
              },
              "updates_expiration": {
                "description": "Default: 86400\n\nNumber of seconds after which a new copy of the I(update-center.json) file is downloaded. This is used to avoid the need to download the plugin to calculate its checksum when C(latest) is specified.\nSet it to C(0) if no cache file should be used. In that case, the plugin file will always be downloaded to calculate its checksum when C(latest) is specified.",
                "$ref": "#/definitions/ansible_number"
              },
              "params": {
                "type": "object",
                "description": "Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to C(null)."
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "Default: 30\n\nServer connection timeout in secs.",
                "$ref": "#/definitions/ansible_number"
              },
              "force_basic_auth": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "jenkins_home": {
                "type": "string",
                "description": "Default: /var/lib/jenkins\n\nHome directory of the Jenkins user."
              },
              "url_password": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Plugin name."
              },
              "url": {
                "type": "string",
                "description": "Default: http://localhost:8080\n\nURL of the Jenkins server."
              },
              "with_dependencies": {
                "description": "Default: yes\n\nDefines whether to install plugin dependencies.",
                "$ref": "#/definitions/ansible_truth"
              },
              "mode": {
                "type": "string",
                "description": "Default: 0664\n\nFile mode applied on versioned plugins."
              },
              "url_username": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "win_acl": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove rights/permissions for a given user or group for the specified src file or folder.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify whether to add C(present) or remove C(absent) the specified access rule"
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_groups": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "authz_name",
                        "domain"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "authz_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "domain"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage groups in oVirt",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Authorization provider of the group. In previous versions of oVirt known as domain."
              },
              "name": {
                "type": "string",
                "description": "Name of the the group to manage."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the group be present/absent."
              },
              "namespace": {
                "type": "string",
                "description": "Namespace of the authorization provider, where group resides."
              },
              "authz_name": {
                "type": "string",
                "description": "Authorization provider of the group. In previous versions of oVirt known as domain."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "supervisorctl": {
            "required": [
              "state",
              "name"
            ],
            "type": "object",
            "description": "Manage the state of a program or group of programs running via supervisord",
            "properties": {
              "username": {
                "type": "string",
                "description": "username to use for authentication"
              },
              "supervisorctl_path": {
                "type": "string",
                "description": "path to supervisorctl executable"
              },
              "name": {
                "type": "string",
                "description": "The name of the supervisord program or group to manage.\nThe name will be taken as group name when it ends with a colon I(:)\nGroup support is only available in Ansible version 1.6 or later."
              },
              "server_url": {
                "type": "string",
                "description": "URL on which supervisord server is listening"
              },
              "state": {
                "enum": [
                  "present",
                  "started",
                  "stopped",
                  "restarted",
                  "absent"
                ],
                "type": "string",
                "description": "The desired state of program/group."
              },
              "password": {
                "type": "string",
                "description": "password to use for authentication"
              },
              "config": {
                "type": "string",
                "description": "The supervisor configuration file path"
              }
            }
          },
          "infini_vol": {
            "type": "object",
            "description": "This module creates, deletes or modifies volume on Infinibox.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nCreates/Modifies volume when present or removes when absent"
              },
              "name": {
                "type": "string",
                "description": "Volume Name"
              },
              "pool": {
                "type": "string",
                "description": "Pool that volume will reside on"
              },
              "size": {
                "type": "string",
                "description": "Volume size in MB, GB or TB units. See examples."
              }
            }
          },
          "rax_cbs_attachments": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manipulate Rackspace Cloud Block Storage Volume Attachments",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "server": {
                "type": "string",
                "description": "Name or id of the server to attach/detach"
              },
              "volume": {
                "type": "string",
                "description": "Name or id of the volume to attach/detach"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "wait_timeout": {
                "description": "Default: 300\n\nhow long before wait gives up, in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "device": {
                "type": "string",
                "description": "The device path to attach the volume to, e.g. /dev/xvde"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: no\n\nwait for the volume to be in 'in-use'/'available' state before returning",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "mysql_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "user",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Adds or removes a user from a MySQL database.",
            "properties": {
              "ssl_key": {
                "type": "string",
                "description": ""
              },
              "update_password": {
                "enum": [
                  "always",
                  "on_create"
                ],
                "type": "string",
                "description": "Default: always\n\nC(always) will update passwords if they differ.  C(on_create) will only set the password for newly created users."
              },
              "login_user": {
                "type": "string",
                "description": ""
              },
              "host_all": {
                "description": "Default: no\n\noverride the host option, making ansible apply changes to all hostnames for a given user.  This option cannot be used when creating users",
                "$ref": "#/definitions/ansible_truth"
              },
              "priv": {
                "type": "string",
                "description": "MySQL privileges string in the format: C(db.table:priv1,priv2).\nMultiple privileges can be specified by separating each one using a forward slash: C(db.table:priv/db.table:priv).\nThe format is based on MySQL C(GRANT) statement.\nDatabase and table names can be quoted, MySQL-style.\nIf column privileges are used, the C(priv1,priv2) part must be exactly as returned by a C(SHOW GRANT) statement. If not followed, the module will always report changes. It includes grouping columns by permission (C(SELECT(col1,col2)) instead of C(SELECT(col1),SELECT(col2)))."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the user should exist.  When C(absent), removes the user."
              },
              "sql_log_bin": {
                "description": "Default: yes\n\nWhether binary logging should be enabled or disabled for the connection.",
                "$ref": "#/definitions/ansible_truth"
              },
              "encrypted": {
                "description": "Default: no\n\nIndicate that the 'password' field is a `mysql_native_password` hash",
                "$ref": "#/definitions/ansible_truth"
              },
              "connect_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "config_file": {
                "type": "string",
                "description": ""
              },
              "login_host": {
                "type": "string",
                "description": ""
              },
              "append_privs": {
                "description": "Default: no\n\nAppend the privileges defined by priv to the existing ones for this user instead of overwriting existing ones.",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": "Default: localhost\n\nthe 'host' part of the MySQL username"
              },
              "user": {
                "type": "string",
                "description": "name of the user (role) to add or remove"
              },
              "login_password": {
                "type": "string",
                "description": ""
              },
              "check_implicit_admin": {
                "description": "Default: no\n\nCheck if mysql allows login as root/nopassword before trying supplied credentials.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "set the user's password."
              },
              "login_port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "ssl_cert": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "name of the user (role) to add or remove"
              },
              "ssl_ca": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ec2_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "maintains ec2 security groups. This module has a dependency on python-boto >= 2.5",
            "properties": {
              "rules_egress": {
                "description": "List of firewall outbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no outbound rules will be enabled.",
                "$ref": "#/definitions/ansible_array"
              },
              "purge_rules": {
                "description": "Default: true\n\nPurge existing rules on security group that are not found in rules",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete a security group"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Description of the security group. Required when C(state) is C(present)."
              },
              "rules": {
                "description": "List of firewall inbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no inbound rules will be enabled. Rules list may include its own name in `group_name`. This allows idempotent loopback additions (e.g. allow group to acccess itself).",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "purge_rules_egress": {
                "description": "Default: true\n\nPurge existing rules_egress on security group that are not found in rules_egress",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the security group."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "vpc_id": {
                "type": "string",
                "description": "ID of the VPC to create the group in."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "panos_nat_policy": {
            "required": [
              "rule_name",
              "password",
              "ip_address",
              "to_zone",
              "from_zone"
            ],
            "type": "object",
            "description": "Create a policy nat rule. Keep in mind that we can either end up configuring source NAT, destination NAT, or both. Instead of splitting it into two we will make a fair attempt to determine which one the user wants.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "dnat_address": {
                "type": "string",
                "description": "Default: None\n\ndnat translated address"
              },
              "snat_bidirectional": {
                "type": "string",
                "description": "Default: false\n\nbidirectional flag"
              },
              "to_zone": {
                "type": "string",
                "description": "destination zone"
              },
              "service": {
                "type": "string",
                "description": "Default: any\n\nservice"
              },
              "snat_type": {
                "type": "string",
                "description": "Default: None\n\ntype of source translation"
              },
              "source": {
                "description": "Default: ['any']\n\nlist of source addresses",
                "$ref": "#/definitions/ansible_array"
              },
              "from_zone": {
                "description": "list of source zones",
                "$ref": "#/definitions/ansible_array"
              },
              "destination": {
                "description": "Default: ['any']\n\nlist of destination addresses",
                "$ref": "#/definitions/ansible_array"
              },
              "dnat_port": {
                "type": "string",
                "description": "Default: None\n\ndnat translated port"
              },
              "snat_interface_address": {
                "type": "string",
                "description": "Default: None\n\nsnat interface address"
              },
              "rule_name": {
                "type": "string",
                "description": "name of the SNAT rule"
              },
              "override": {
                "description": "Default: false\n\nattempt to override rule if one with the same name already exists",
                "$ref": "#/definitions/ansible_truth"
              },
              "commit": {
                "description": "Default: True\n\ncommit if changed",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              },
              "snat_address": {
                "type": "string",
                "description": "Default: None\n\nsnat translated address"
              },
              "snat_interface": {
                "type": "string",
                "description": "Default: None\n\nsnat interface"
              }
            }
          },
          "cnos_portchannel": {
            "type": "object",
            "description": "This module allows you to work with port aggregation related configurations. The operators used are overloaded to ensure control over switch port aggregation configurations. Apart from the regular device connection related attributes, there are five LAG arguments which are overloaded variables that will perform further configurations. They are interfaceArg1, interfaceArg2, interfaceArg3, interfaceArg4, and interfaceArg5. For more details on how to use these arguments, see [Overloaded Variables]. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_portchannel.html)",
            "properties": {
              "interfaceRange": {
                "type": "string",
                "description": "This specifies the interface range in which the port aggregation is envisaged"
              },
              "interfaceArg4": {
                "type": "string",
                "description": "This is an overloaded Port Channel fourth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg5": {
                "type": "string",
                "description": "This is an overloaded Port Channel fifth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg6": {
                "type": "string",
                "description": "This is an overloaded Port Channel sixth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg7": {
                "type": "string",
                "description": "This is an overloaded Port Channel seventh argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg1": {
                "type": "string",
                "description": "This is an overloaded Port Channel first argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg2": {
                "type": "string",
                "description": "This is an overloaded Port Channel second argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg3": {
                "type": "string",
                "description": "This is an overloaded Port Channel third argument. Usage of this argument can be found is the User Guide referenced above."
              }
            }
          },
          "cnos_rollback": {
            "type": "object",
            "description": "This module allows you to work with switch configurations. It provides a way to roll back configurations of a switch from a remote server. This is achieved by using startup or running configurations of the target device that were previously backed up to a remote server using FTP, SFTP, TFTP, or SCP. The first step is to create a directory from where the remote server can be reached. The next step is to provide the full file path of the backup configuration’s location. Authentication details required by the remote server must be provided as well. By default, this method overwrites the switch’s configuration file with the newly downloaded file. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_rollback.html)",
            "properties": {
              "serverpassword": {
                "type": "string",
                "description": "Specify the password for the server relating to the protocol used."
              },
              "protocol": {
                "type": "string",
                "description": "This refers to the protocol used by the network device to interact with the remote server from where to download the backup configuration. The choices are FTP, SFTP, TFTP, or SCP. Any other protocols will result in error. If this parameter is not specified, there is no default value to be used."
              },
              "configType": {
                "type": "string",
                "description": "This refers to the type of configuration which will be used for the rolling back process. The choices are the running or startup configurations. There is no default value, so it will result in an error if the input is incorrect."
              },
              "serverusername": {
                "type": "string",
                "description": "Specify the username for the server relating to the protocol used."
              },
              "rcserverip": {
                "type": "string",
                "description": "This specifies the IP Address of the remote server from where the backup configuration will be downloaded."
              },
              "rcpath": {
                "type": "string",
                "description": "This specifies the full file path of the configuration file located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified."
              }
            }
          },
          "setup": {
            "type": "object",
            "description": "This module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks. It can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host. Ansible provides many I(facts) about the system, automatically.",
            "properties": {
              "filter": {
                "type": "string",
                "description": "Default: *\n\nif supplied, only return facts that match this shell-style (fnmatch) wildcard."
              },
              "gather_subset": {
                "description": "Default: all\n\nif supplied, restrict the additional facts collected to the given subset. Possible values: all, hardware, network, virtual, ohai, and facter Can specify a list of values to specify a larger subset. Values can also be used with an initial C(!) to specify that that specific subset should not be collected.  For instance: !hardware, !network, !virtual, !ohai, !facter.  Note that a few facts are always collected.  Use the filter parameter if you do not want to display those.",
                "$ref": "#/definitions/ansible_array"
              },
              "fact_path": {
                "type": "string",
                "description": "Default: /etc/ansible/facts.d\n\npath used for local ansible facts (*.fact) - files in this dir will be run (if executable) and their results be added to ansible_local facts if a file is not executable it is read. Check notes for Windows options. (from 2.1 on) File/results format can be json or ini-format"
              },
              "gather_timeout": {
                "description": "Default: 10\n\nSet the default timeout in seconds for individual fact gathering",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "glance_image": {
            "required": [
              "login_password",
              "name"
            ],
            "type": "object",
            "description": "Add or Remove images from the glance repository.",
            "properties": {
              "login_tenant_name": {
                "type": "string",
                "description": "Default: yes\n\nThe tenant name of the login user"
              },
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nName of the region"
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "container_format": {
                "enum": [
                  "aki",
                  "ari",
                  "bare",
                  "ovf"
                ],
                "type": "string",
                "description": "Default: bare\n\nThe format of the container"
              },
              "min_ram": {
                "type": "string",
                "description": "Default: None\n\nThe minimum ram required to deploy this image"
              },
              "disk_format": {
                "enum": [
                  "aki",
                  "vhd",
                  "vmdk",
                  "raw",
                  "qcow2",
                  "vdi",
                  "iso"
                ],
                "type": "string",
                "description": "Default: qcow2\n\nThe format of the disk that is getting uploaded"
              },
              "timeout": {
                "type": "string",
                "description": "Default: 180\n\nThe time to wait for the image process to complete in seconds"
              },
              "copy_from": {
                "type": "string",
                "description": "Default: None\n\nA url from where the image can be downloaded, mutually exclusive with file parameter"
              },
              "owner": {
                "type": "string",
                "description": "Default: None\n\nThe owner of the image"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "endpoint_type": {
                "enum": [
                  "publicURL",
                  "internalURL"
                ],
                "type": "string",
                "description": "Default: publicURL\n\nThe name of the glance service's endpoint URL type"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone url for authentication"
              },
              "file": {
                "type": "string",
                "description": "Default: None\n\nThe path to the file which has to be uploaded, mutually exclusive with copy_from"
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\nPassword of login user"
              },
              "min_disk": {
                "type": "string",
                "description": "Default: None\n\nThe minimum disk space required to deploy this image"
              },
              "is_public": {
                "type": "string",
                "description": "Default: yes\n\nWhether the image can be accessed publicly"
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nName that has to be given to the image"
              }
            }
          },
          "consul_session": {
            "type": "object",
            "description": "allows the addition, modification and deletion of sessions in a consul cluster. These sessions can then be used in conjunction with key value pairs to implement distributed locks. In depth documentation for working with sessions can be found here http://www.consul.io/docs/internals/sessions.html",
            "properties": {
              "node": {
                "type": "string",
                "description": "Default: None\n\nthe name of the node that with which the session will be associated. by default this is the name of the agent."
              },
              "datacenter": {
                "type": "string",
                "description": "Default: None\n\nname of the datacenter in which the session exists or should be created."
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nthe name that should be associated with the session. This is opaque to Consul and not required."
              },
              "host": {
                "type": "string",
                "description": "Default: localhost\n\nhost of the consul agent defaults to localhost"
              },
              "port": {
                "type": "string",
                "description": "Default: 8500\n\nthe port on which the consul agent is running"
              },
              "delay": {
                "type": "string",
                "description": "Default: 15\n\nthe optional lock delay that can be attached to the session when it is created. Locks for invalidated sessions ar blocked from being acquired until this delay has expired. Durations are in seconds"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nwhether the session should be present i.e. created if it doesn't exist, or absent, removed if present. If created, the ID for the session is returned in the output. If absent, the name or ID is required to remove the session. Info for a single session, all the sessions for a node or all available sessions can be retrieved by specifying info, node or list for the state; for node or info, the node name or session id is required as parameter."
              },
              "behavior": {
                "type": "string",
                "description": "Default: release\n\nthe optional behavior that can be attached to the session when it is created. This can be set to either ‘release’ or ‘delete’. This controls the behavior when a session is invalidated."
              },
              "scheme": {
                "type": "string",
                "description": "Default: http\n\nthe protocol scheme on which the consul agent is running"
              },
              "validate_certs": {
                "type": "string",
                "description": "Default: True\n\nwhether to verify the tls certificate of the consul agent"
              },
              "checks": {
                "type": "string",
                "description": "Default: None\n\na list of checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired."
              }
            }
          },
          "ec2_group_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about ec2 security groups in AWS.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See       U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html) for       possible filters. Filter names and values are case sensitive. You can also use underscores (_)       instead of dashes (-) in the filter keys, which will take precedence in case of conflict."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "parted": {
            "required": [
              "device"
            ],
            "type": "object",
            "description": "This module allows configuring block device partition using the C(parted) command line tool. For a full description of the fields and the options check the GNU parted manual.",
            "properties": {
              "part_start": {
                "type": "string",
                "description": "Default: 0%\n\nWhere the partition will start as offset from the beginning of the disk, that is, the \"distance\" from the start of the disk. The distance can be specified with all the units supported by parted (except compat) and it is case sensitive. E.g. C(10GiB), C(15%)."
              },
              "part_end": {
                "type": "string",
                "description": "Default: 100%\n\nWhere the partition will end as offset from the beginning of the disk, that is, the \"distance\" from the start of the disk. The distance can be specified with all the units supported by parted (except compat) and it is case sensitive. E.g. C(10GiB), C(15%)."
              },
              "name": {
                "type": "string",
                "description": "Sets the name for the partition number (GPT, Mac, MIPS and PC98 only)."
              },
              "align": {
                "enum": [
                  "none",
                  "cylinder",
                  "minimal",
                  "optimal"
                ],
                "type": "string",
                "description": "Default: optimal\n\nSet alignment for newly created partitions."
              },
              "number": {
                "description": "The number of the partition to work with or the number of the partition that will be created. Required when performing any action on the disk, except fetching information.",
                "$ref": "#/definitions/ansible_number"
              },
              "label": {
                "enum": [
                  "aix",
                  "amiga",
                  "bsd",
                  "dvh",
                  "gpt",
                  "loop",
                  "mac",
                  "msdos",
                  "pc98",
                  "sun",
                  ""
                ],
                "type": "string",
                "description": "Default: msdos\n\nCreates a new disk label."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "info"
                ],
                "type": "string",
                "description": "Default: info\n\nIf to create or delete a partition. If set to C(info) the module will only return the device information."
              },
              "part_type": {
                "enum": [
                  "primary",
                  "extended",
                  "logical"
                ],
                "type": "string",
                "description": "Is one of 'primary', 'extended' or 'logical' and may be specified only with 'msdos' or 'dvh' partition tables. A name must be specified for a 'gpt' partition table. Neither part-type nor name may be used with a 'sun' partition table."
              },
              "flags": {
                "description": "A list of the flags that has to be set on the partition.",
                "$ref": "#/definitions/ansible_array"
              },
              "device": {
                "type": "string",
                "description": "The block device (disk) where to operate."
              },
              "unit": {
                "enum": [
                  "s",
                  "B",
                  "KB",
                  "KiB",
                  "MB",
                  "MiB",
                  "GB",
                  "GiB",
                  "TB",
                  "TiB",
                  "%",
                  "cyl",
                  "chs",
                  "compact"
                ],
                "type": "string",
                "description": "Default: KiB\n\nSelects the current default unit that Parted will use to display locations and capacities on the disk and to interpret those given by the user if they are not suffixed by an unit. When fetching information about a disk, it is always recommended to specify a unit."
              }
            }
          },
          "ec2_win_password": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gets the default administrator password from any EC2 Windows instance.  The instance is referenced by its id (e.g. i-XXXXXXX). This module has a dependency on python-boto.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: no\n\nWhether or not to wait for the password to be available before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "instance_id": {
                "type": "string",
                "description": "The instance id to get the password data from."
              },
              "key_passphrase": {
                "type": "string",
                "description": "The passphrase for the instance key pair. The key must use DES or 3DES encryption for this module to decrypt it. You can use openssl to convert your password protected keys if they do not use DES or 3DES. ex) openssl rsa -in current_key -out new_key -des3."
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 120\n\nNumber of seconds to wait before giving up."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "key_file": {
                "type": "string",
                "description": "Path to the file containing the key pair used on the instance."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ec2_vpc_vgw": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tags",
                        "resource_tags"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates AWS VPN Virtual Gateways\nDeletes AWS VPN Virtual Gateways\nAttaches Virtual Gateways to VPCs\nDetaches Virtual Gateways from VPCs",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "vpn_gateway_id": {
                "type": "string",
                "description": "vpn gateway id of an existing virtual gateway"
              },
              "name": {
                "type": "string",
                "description": "name of the vgw to be created or deleted"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "dictionary of resource tags"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "vpc_id": {
                "type": "string",
                "description": "the vpc-id of a vpc to attach or detach"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\npresent to ensure resource is created.\nabsent to remove resource"
              },
              "wait_timeout": {
                "description": "Default: 320\n\nnumber of seconds to wait for status during vpc attach and detach",
                "$ref": "#/definitions/ansible_number"
              },
              "resource_tags": {
                "type": "object",
                "description": "dictionary of resource tags"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "type": {
                "enum": [
                  "ipsec.1"
                ],
                "type": "string",
                "description": "type of the virtual gateway to be created"
              }
            }
          },
          "win_domain_controller": {
            "type": "object",
            "description": "Ensure that a Windows Server 2012+ host is configured as a domain controller or demoted to member server. This module may require subsequent use of the M(win_reboot) action if changes are made.",
            "properties": {
              "domain_admin_user": {
                "type": "string",
                "description": "username of a domain admin for the target domain (necessary to promote or demote a domain controller)"
              },
              "dns_domain_name": {
                "type": "string",
                "description": "when C(state) is C(domain_controller), the DNS name of the domain for which the targeted Windows host should be a DC"
              },
              "safe_mode_password": {
                "type": "string",
                "description": "safe mode password for the domain controller (required when C(state) is C(domain_controller))"
              },
              "domain_admin_password": {
                "type": "string",
                "description": "password for the specified C(domain_admin_user)"
              },
              "state": {
                "type": "string",
                "description": "whether the target host should be a domain controller or a member server"
              },
              "local_admin_password": {
                "type": "string",
                "description": "password to be assigned to the local C(Administrator) user (required when C(state) is C(member_server))"
              }
            }
          },
          "vmware_maintenancemode": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Place an ESXI host into maintenance mode\nSupport for VSAN compliant maintenance mode when selected",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "Specify a timeout for the operation",
                "$ref": "#/definitions/ansible_number"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "evacuate": {
                "description": "If True, evacuate all powered off VMs",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nEnter or exit maintenance mode"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "esxi_hostname": {
                "type": "string",
                "description": "Name of the host as defined in vCenter"
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "vsan": {
                "enum": [
                  "ensureObjectAccessibility",
                  "evacuateAllData",
                  "noAction"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "jenkins_job": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manage Jenkins jobs by using Jenkins REST API.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the Jenkins job."
              },
              "url": {
                "type": "string",
                "description": "Default: http://localhost:8080\n\nUrl where the Jenkins server is accessible."
              },
              "enabled": {
                "description": "Whether the job should be enabled or disabled.\nMututally exclusive with C(config).\nConsidered if C(state=present).",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nAttribute that specifies if the job has to be created or deleted."
              },
              "token": {
                "type": "string",
                "description": "API token used to authenticate alternatively to password."
              },
              "user": {
                "type": "string",
                "description": "User to authenticate with the Jenkins server."
              },
              "password": {
                "type": "string",
                "description": "Password to authenticate with the Jenkins server."
              },
              "config": {
                "type": "string",
                "description": "config in XML format.\nRequired if job does not yet exist.\nMututally exclusive with C(enabled).\nConsidered if C(state=present)."
              }
            }
          },
          "netapp_e_storage_system": {
            "required": [
              "state",
              "ssid"
            ],
            "type": "object",
            "description": "Manage the arrays accessible via a NetApp Web Services Proxy for NetApp E-series storage arrays.",
            "properties": {
              "ssid": {
                "type": "string",
                "description": "The ID of the array to manage. This value must be unique for each array."
              },
              "meta_tags": {
                "description": "Default: None\n\nOptional meta tags to associate to this storage system",
                "$ref": "#/definitions/ansible_array"
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "array_wwn": {
                "type": "string",
                "description": "The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host.  Mutually exclusive of controller_addresses parameter."
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "array_status_timeout_sec": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified array should be configured on the Web Services Proxy or not."
              },
              "array_password": {
                "type": "string",
                "description": "The management password of the array to manage, if set."
              },
              "enable_trace": {
                "description": "Enable trace logging for SYMbol calls to the storage system.",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "controller_addresses": {
                "description": "The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "cron": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "job",
                        "value"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "day",
                        "dom"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "weekday",
                        "dow"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Use this module to manage crontab and environment variables entries. This module allows you to create environment variables and named crontab entries, update, or delete them.\nWhen crontab jobs are managed: the module includes one line with the description of the crontab entry C(\"#Ansible: <name>\") corresponding to the \"name\" passed to the module, which is used by future ansible/module calls to find/check the state. The \"name\" parameter should be unique, and changing the \"name\" value will result in a new cron task being created (or a different one being removed).\nWhen environment variables are managed: no comment line is added, but, when the module needs to find/check the state, it uses the \"name\" parameter to find the environment variable definition line.\nWhen using symbols such as %, they must be properly escaped.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to ensure the job or environment variable is present or absent."
              },
              "name": {
                "type": "string",
                "description": "Description of a crontab entry or, if env is set, the name of environment variable. Required if state=absent. Note that if name is not set and state=present, then a new crontab entry will always be created, regardless of existing ones."
              },
              "insertbefore": {
                "type": "string",
                "description": "Used with C(state=present) and C(env). If specified, the environment variable will be inserted before the declaration of specified environment variable."
              },
              "dom": {
                "type": "string",
                "description": "Default: *\n\nDay of the month the job should run ( 1-31, *, */2, etc )"
              },
              "hour": {
                "type": "string",
                "description": "Default: *\n\nHour when the job should run ( 0-23, *, */2, etc )"
              },
              "dow": {
                "type": "string",
                "description": "Default: *\n\nDay of the week that the job should run ( 0-6 for Sunday-Saturday, *, etc )"
              },
              "cron_file": {
                "type": "string",
                "description": "If specified, uses this file instead of an individual user's crontab. If this is a relative path, it is interpreted with respect to /etc/cron.d. (If it is absolute, it will typically be /etc/crontab). To use the C(cron_file) parameter you must specify the C(user) as well."
              },
              "reboot": {
                "description": "Default: no\n\nIf the job should be run at reboot. This option is deprecated. Users should use special_time.",
                "$ref": "#/definitions/ansible_truth"
              },
              "value": {
                "type": "string",
                "description": "The command to execute or, if env is set, the value of environment variable. Required if state=present."
              },
              "month": {
                "type": "string",
                "description": "Default: *\n\nMonth of the year the job should run ( 1-12, *, */2, etc )"
              },
              "disabled": {
                "description": "If the job should be disabled (commented out) in the crontab. Only has effect if state=present",
                "$ref": "#/definitions/ansible_truth"
              },
              "job": {
                "type": "string",
                "description": "The command to execute or, if env is set, the value of environment variable. Required if state=present."
              },
              "special_time": {
                "enum": [
                  "reboot",
                  "yearly",
                  "annually",
                  "monthly",
                  "weekly",
                  "daily",
                  "hourly"
                ],
                "type": "string",
                "description": "Special time specification nickname."
              },
              "user": {
                "type": "string",
                "description": "Default: root\n\nThe specific user whose crontab should be modified."
              },
              "env": {
                "description": "Default: no\n\nIf set, manages a crontab's environment variable. New variables are added on top of crontab. \"name\" and \"value\" parameters are the name and the value of environment variable.",
                "$ref": "#/definitions/ansible_truth"
              },
              "insertafter": {
                "type": "string",
                "description": "Used with C(state=present) and C(env). If specified, the environment variable will be inserted after the declaration of specified environment variable."
              },
              "backup": {
                "description": "If set, create a backup of the crontab before it is modified. The location of the backup is returned in the C(backup_file) variable by this module.",
                "$ref": "#/definitions/ansible_truth"
              },
              "day": {
                "type": "string",
                "description": "Default: *\n\nDay of the month the job should run ( 1-31, *, */2, etc )"
              },
              "minute": {
                "type": "string",
                "description": "Default: *\n\nMinute when the job should run ( 0-59, *, */2, etc )"
              },
              "weekday": {
                "type": "string",
                "description": "Default: *\n\nDay of the week that the job should run ( 0-6 for Sunday-Saturday, *, etc )"
              }
            }
          },
          "os_stack": {
            "type": "object",
            "description": "Add or Remove a Stack to an OpenStack Heat",
            "properties": {
              "rollback": {
                "type": "string",
                "description": "Rollback stack creation"
              },
              "name": {
                "type": "string",
                "description": "Name of the stack that should be created, name could be char and digit, no space"
              },
              "parameters": {
                "type": "string",
                "description": "Default: None\n\nDictionary of parameters for the stack creation"
              },
              "environment": {
                "type": "string",
                "description": "Default: None\n\nList of environment files that should be used for the stack creation"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "timeout": {
                "type": "string",
                "description": "Default: 3600\n\nMaximum number of seconds to wait for the stack creation"
              },
              "template": {
                "type": "string",
                "description": "Default: None\n\nPath of the template file to use for the stack creation"
              }
            }
          },
          "ios_facts": {
            "type": "object",
            "description": "Collects a base set of device facts from a remote device that is running IOS.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "s3_website": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Configure an s3 bucket as a website",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "suffix": {
                "type": "string",
                "description": "Default: index.html\n\nSuffix that is appended to a request that is for a directory on the website endpoint (e.g. if the suffix is index.html and you make a request to samplebucket/images/ the data that is returned will be for the object with the key name images/index.html). The suffix must not include a slash character."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the s3 bucket"
              },
              "region": {
                "type": "string",
                "description": "AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard."
              },
              "redirect_all_requests": {
                "type": "string",
                "description": "Describes the redirect behavior for every request to this s3 bucket website endpoint"
              },
              "aws_region": {
                "type": "string",
                "description": "AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard."
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "error_key": {
                "type": "string",
                "description": "The object key name to use when a 4XX class error occurs. To remove an error key, set to None."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nAdd or remove s3 website configuration"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": "AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard."
              }
            }
          },
          "ec2_vpc_peer": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Read the AWS documentation for VPC Peering Connections U(http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-peering.html)",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "peering_id": {
                "type": "string",
                "description": "Peering connection id."
              },
              "tags": {
                "type": "object",
                "description": "Dictionary of tags to look for and apply when creating a Peering Connection."
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "peer_owner_id": {
                "type": "string",
                "description": "The AWS account number for cross account peering."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "accept",
                  "reject"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate, delete, accept, reject a peering connection."
              },
              "vpc_id": {
                "type": "string",
                "description": "VPC id of the requesting VPC."
              },
              "peer_vpc_id": {
                "type": "string",
                "description": "VPC id of the accepting VPC."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ec2_vpc_subnet_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about ec2 VPC subnets in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ovirt_storage_domains_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt storage domains.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search storage domain X from datacenter Y use following pattern: name=X and datacenter=Y"
              }
            }
          },
          "airbrake_deployment": {
            "required": [
              "environment",
              "token"
            ],
            "type": "object",
            "description": "Notify airbrake about app deployments (see http://help.airbrake.io/kb/api-2/deploy-tracking)",
            "properties": {
              "repo": {
                "type": "string",
                "description": "URL of the project repository"
              },
              "url": {
                "type": "string",
                "description": "Default: https://airbrake.io/deploys.txt\n\nOptional URL to submit the notification to. Use to send notifications to Airbrake-compliant tools like Errbit."
              },
              "environment": {
                "type": "string",
                "description": "The airbrake environment name, typically 'production', 'staging', etc."
              },
              "token": {
                "type": "string",
                "description": "API token."
              },
              "user": {
                "type": "string",
                "description": "The username of the person doing the deployment"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "revision": {
                "type": "string",
                "description": "A hash, number, tag, or other identifier showing what revision was deployed"
              }
            }
          },
          "pacemaker_cluster": {
            "type": "object",
            "description": "This module can manage a pacemaker cluster and nodes from Ansible using the pacemaker cli.",
            "properties": {
              "node": {
                "type": "string",
                "description": "Default: None\n\nSpecify which node of the cluster you want to manage. None == the cluster status itself, 'all' == check the status of all nodes."
              },
              "state": {
                "type": "string",
                "description": "Indicate desired state of the cluster"
              },
              "force": {
                "type": "string",
                "description": "Default: True\n\nForce the change of the cluster state"
              },
              "timeout": {
                "type": "string",
                "description": "Default: 300\n\nTimeout when the module should considered that the action has failed"
              }
            }
          },
          "digital_ocean_block_storage": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_token",
                        "API_TOKEN"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create/destroy Block Storage volume in DigitalOcean, or attach/detach Block Storage volume to a droplet.",
            "properties": {
              "droplet_id": {
                "description": "The droplet id you want to operate on. Required when command=attach.",
                "$ref": "#/definitions/ansible_number"
              },
              "description": {
                "type": "string",
                "description": "Description of the Block Storage volume."
              },
              "API_TOKEN": {
                "type": "string",
                "description": "DigitalOcean api token."
              },
              "region": {
                "type": "string",
                "description": "The slug of the region where your Block Storage volume should be located in."
              },
              "api_token": {
                "type": "string",
                "description": "DigitalOcean api token."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Indicate desired state of the target."
              },
              "command": {
                "enum": [
                  "create",
                  "attach"
                ],
                "type": "string",
                "description": "Which operation do you want to perform."
              },
              "timeout": {
                "description": "Default: 10\n\nThe timeout in seconds used for polling DigitalOcean's API.",
                "$ref": "#/definitions/ansible_number"
              },
              "volume_name": {
                "type": "string",
                "description": "The name of the Block Storage volume."
              },
              "block_size": {
                "description": "The size of the Block Storage volume in gigabytes. Required when command=create and state=present.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "nxos_switchport": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "trunk_vlans",
                        "trunk_add_vlans"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages Layer 2 interfaces",
            "properties": {
              "native_vlan": {
                "type": "string",
                "description": "If C(mode=trunk), used as the trunk native VLAN ID."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "access_vlan": {
                "type": "string",
                "description": "If C(mode=access), used as the access VLAN ID."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "unconfigured"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "trunk_allowed_vlans": {
                "type": "string",
                "description": "if C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. \"2-10,15\"."
              },
              "trunk_vlans": {
                "type": "string",
                "description": "If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk."
              },
              "trunk_add_vlans": {
                "type": "string",
                "description": "If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Full name of the interface, i.e. Ethernet1/1."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "mode": {
                "enum": [
                  "access",
                  "trunk"
                ],
                "type": "string",
                "description": "Mode for the Layer 2 port."
              }
            }
          },
          "iso_extract": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "image",
                        "path",
                        "src"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "image"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "src"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module mounts an iso image in a temporary directory and extracts files from there to a given destination.",
            "properties": {
              "files": {
                "description": "A list of files to extract from the image.\nExtracting directories does not work.",
                "$ref": "#/definitions/ansible_array"
              },
              "dest": {
                "type": "string",
                "description": "The destination directory to extract files to."
              },
              "image": {
                "type": "string",
                "description": "The ISO image to extract files from."
              },
              "src": {
                "type": "string",
                "description": "The ISO image to extract files from."
              },
              "path": {
                "type": "string",
                "description": "The ISO image to extract files from."
              }
            }
          },
          "os_server_facts": {
            "type": "object",
            "description": "Retrieve facts about server instances from OpenStack.",
            "properties": {
              "detailed": {
                "type": "string",
                "description": "when true, return additional detail about servers at the expense of additional API calls."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "server": {
                "type": "string",
                "description": "Default: None\n\nrestrict results to servers with names or UUID matching this glob expression (e.g., C<web*>)."
              }
            }
          },
          "ovirt_vmpools_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt vmpools.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search vmpool X: name=X"
              }
            }
          },
          "find": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "paths",
                        "name",
                        "path"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "paths"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "patterns",
                        "pattern"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Return a list of files based on specific criteria. Multiple criteria are AND'd together.",
            "properties": {
              "paths": {
                "description": "List of paths of directories to search. All paths must be fully qualified.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "description": "List of paths of directories to search. All paths must be fully qualified.",
                "$ref": "#/definitions/ansible_array"
              },
              "file_type": {
                "enum": [
                  "file",
                  "directory",
                  "link",
                  "any"
                ],
                "type": "string",
                "description": "Default: file\n\nType of file to select\nThe 'link' and 'any' choices were added in version 2.3"
              },
              "pattern": {
                "description": "Default: *\n\nOne or more (shell or regex) patterns, which type is controlled by C(use_regex) option.\nThe patterns restrict the list of files to be returned to those whose basenames match at least one of the patterns specified. Multiple patterns can be specified using a list.",
                "$ref": "#/definitions/ansible_array"
              },
              "age": {
                "type": "string",
                "description": "Select files whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days, or weeks by specifying the first letter of any of those words (e.g., \"1w\")."
              },
              "contains": {
                "type": "string",
                "description": "One or more regex patterns which should be matched against the file content"
              },
              "recurse": {
                "description": "Default: no\n\nIf target is a directory, recursively descend into the directory looking for files.",
                "$ref": "#/definitions/ansible_truth"
              },
              "age_stamp": {
                "enum": [
                  "atime",
                  "mtime",
                  "ctime"
                ],
                "type": "string",
                "description": "Default: mtime\n\nChoose the file property against which we compare age. Default is mtime."
              },
              "patterns": {
                "description": "Default: *\n\nOne or more (shell or regex) patterns, which type is controlled by C(use_regex) option.\nThe patterns restrict the list of files to be returned to those whose basenames match at least one of the patterns specified. Multiple patterns can be specified using a list.",
                "$ref": "#/definitions/ansible_array"
              },
              "get_checksum": {
                "description": "Default: False\n\nSet this to true to retrieve a file's sha1 checksum",
                "$ref": "#/definitions/ansible_truth"
              },
              "follow": {
                "description": "Default: False\n\nSet this to true to follow symlinks in path for systems with python 2.6+",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_regex": {
                "description": "Default: False\n\nIf false the patterns are file globs (shell) if true they are python regexes",
                "$ref": "#/definitions/ansible_truth"
              },
              "path": {
                "description": "List of paths of directories to search. All paths must be fully qualified.",
                "$ref": "#/definitions/ansible_array"
              },
              "hidden": {
                "description": "Default: False\n\nSet this to true to include hidden files, otherwise they'll be ignored.",
                "$ref": "#/definitions/ansible_truth"
              },
              "size": {
                "type": "string",
                "description": "Select files whose size is equal to or greater than the specified size. Use a negative size to find files equal to or less than the specified size. Unqualified values are in bytes, but b, k, m, g, and t can be appended to specify bytes, kilobytes, megabytes, gigabytes, and terabytes, respectively. Size is not evaluated for directories."
              }
            }
          },
          "jboss": {
            "required": [
              "deployment"
            ],
            "type": "object",
            "description": "Deploy applications to JBoss standalone using the filesystem",
            "properties": {
              "src": {
                "type": "string",
                "description": "The remote path of the application ear or war to deploy"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the application should be deployed or undeployed"
              },
              "deploy_path": {
                "type": "string",
                "description": "Default: /var/lib/jbossas/standalone/deployments\n\nThe location in the filesystem where the deployment scanner listens"
              },
              "deployment": {
                "type": "string",
                "description": "The name of the deployment"
              }
            }
          },
          "ovirt_host_pm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "host"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "host"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "encrypt_options",
                        "encrypt"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage power management of hosts in oVirt.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username to be used to connect to power management interface."
              },
              "slot": {
                "type": "string",
                "description": "Power management slot."
              },
              "encrypt_options": {
                "description": "If (true) options will be encrypted when send to agent.",
                "$ref": "#/definitions/ansible_truth"
              },
              "encrypt": {
                "description": "If (true) options will be encrypted when send to agent.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the the host to manage."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the host be present/absent."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": "Name of the the host to manage."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "options": {
                "type": "object",
                "description": "Dictionary of additional fence agent options.\nAdditional information about options can be found at U(https://fedorahosted.org/cluster/wiki/FenceArguments)."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "address": {
                "type": "string",
                "description": "Address of the power management interface."
              },
              "password": {
                "type": "string",
                "description": "Password of the user specified in C(username) parameter."
              },
              "type": {
                "type": "string",
                "description": "Type of the power management. oVirt predefined values are I(drac5), I(ipmilan), I(rsa), I(bladecenter), I(alom), I(apc), I(apc_snmp), I(eps), I(wti), I(rsb), I(cisco_ucs), I(drac7), I(hpblade), I(ilo), I(ilo2), I(ilo3), I(ilo4), I(ilo_ssh), but user can have defined custom type."
              },
              "port": {
                "description": "Power management interface port.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "avi_systemconfiguration": {
            "type": "object",
            "description": "This module is used to configure SystemConfiguration object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "docker_mode": {
                "description": "Boolean flag to set docker_mode.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "proxy_configuration": {
                "type": "object",
                "description": "Proxyconfiguration settings for systemconfiguration."
              },
              "ssh_hmacs": {
                "description": "Allowed hmac list for ssh to the management interface on the controller and service engines.\nIf this is not specified, all the default hmacs are allowed.\nSsh -q mac provides the list of default hmacs supported.",
                "$ref": "#/definitions/ansible_array"
              },
              "portal_configuration": {
                "type": "object",
                "description": "Portalconfiguration settings for systemconfiguration."
              },
              "uuid": {
                "type": "string",
                "description": "Unique object identifier of the object."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "ntp_configuration": {
                "type": "object",
                "description": "Ntpconfiguration settings for systemconfiguration."
              },
              "ssh_ciphers": {
                "description": "Allowed ciphers list for ssh to the management interface on the controller and service engines.\nIf this is not specified, all the default ciphers are allowed.\nSsh -q cipher provides the list of default ciphers supported.",
                "$ref": "#/definitions/ansible_array"
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "global_tenant_config": {
                "type": "object",
                "description": "Tenantconfiguration settings for systemconfiguration."
              },
              "dns_configuration": {
                "type": "object",
                "description": "Dnsconfiguration settings for systemconfiguration."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "email_configuration": {
                "type": "object",
                "description": "Emailconfiguration settings for systemconfiguration."
              },
              "dns_virtualservice_refs": {
                "description": "Dns virtualservices hosting fqdn records for applications across avi vantage.\nIf no virtualservices are provided, avi vantage will provide dns services for configured applications.\nSwitching back to avi vantage from dns virtualservices is not allowed.\nIt is a reference to an object of type virtualservice.",
                "$ref": "#/definitions/ansible_array"
              },
              "tech_support_uploader_configuration": {
                "type": "object",
                "description": "Techsupportuploaderconfiguration settings for systemconfiguration."
              },
              "linux_configuration": {
                "type": "object",
                "description": "Linuxconfiguration settings for systemconfiguration."
              },
              "snmp_configuration": {
                "type": "object",
                "description": "Snmpconfiguration settings for systemconfiguration."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "admin_auth_configuration": {
                "type": "object",
                "description": "Adminauthconfiguration settings for systemconfiguration."
              },
              "mgmt_ip_access_control": {
                "type": "object",
                "description": "Configure ip access control for controller to restrict open access."
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              }
            }
          },
          "yum_repository": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Add or remove YUM repositories in RPM-based Linux distributions.",
            "properties": {
              "ip_resolve": {
                "enum": [
                  "4",
                  "6",
                  "IPv4",
                  "IPv6",
                  "whatever"
                ],
                "type": "string",
                "description": "Default: whatever\n\nDetermines how yum resolves host names.\nC(4) or C(IPv4) - resolve to IPv4 addresses only.\nC(6) or C(IPv6) - resolve to IPv6 addresses only."
              },
              "enabled": {
                "description": "Default: yes\n\nThis tells yum whether or not use this repository.",
                "$ref": "#/definitions/ansible_truth"
              },
              "proxy_password": {
                "type": "string",
                "description": "Username to use for proxy."
              },
              "bandwidth": {
                "type": "string",
                "description": "Maximum available network bandwidth in bytes/second. Used with the I(throttle) option.\nIf I(throttle) is a percentage and bandwidth is C(0) then bandwidth throttling will be disabled. If I(throttle) is expressed as a data rate (bytes/sec) then this option is ignored. Default is C(0) (no bandwidth throttling)."
              },
              "cost": {
                "type": "string",
                "description": "Default: 1000\n\nRelative cost of accessing this repository. Useful for weighing one repo's packages as greater/less than any other."
              },
              "file": {
                "type": "string",
                "description": "File to use to save the repo in. Defaults to the value of I(name)."
              },
              "mirrorlist_expire": {
                "type": "string",
                "description": "Default: 21600\n\nTime (in seconds) after which the mirrorlist locally cached will expire.\nDefault value is 6 hours."
              },
              "exclude": {
                "type": "string",
                "description": "List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.\nThe list can also be a regular YAML array."
              },
              "keepalive": {
                "description": "Default: no\n\nThis tells yum whether or not HTTP/1.1 keepalive should be used with this repository. This can improve transfer speeds by using one connection when downloading multiple files from a repository.",
                "$ref": "#/definitions/ansible_truth"
              },
              "repo_gpgcheck": {
                "description": "Default: no\n\nThis tells yum whether or not it should perform a GPG signature check on the repodata from this repository.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sslverify": {
                "description": "Default: yes\n\nDefines whether yum should verify SSL certificates/hosts at all.",
                "$ref": "#/definitions/ansible_truth"
              },
              "failovermethod": {
                "enum": [
                  "roundrobin",
                  "priority"
                ],
                "type": "string",
                "description": "Default: roundrobin\n\nC(roundrobin) randomly selects a URL out of the list of URLs to start with and proceeds through each of them as it encounters a failure contacting the host.\nC(priority) starts from the first I(baseurl) listed and reads through them sequentially."
              },
              "deltarpm_metadata_percentage": {
                "type": "string",
                "description": "Default: 100\n\nWhen the relative size of deltarpm metadata vs pkgs is larger than this, deltarpm metadata is not downloaded from the repo. Note that you can give values over C(100), so C(200) means that the metadata is required to be half the size of the packages. Use C(0) to turn off this check, and always download metadata."
              },
              "gpgkey": {
                "type": "string",
                "description": "A URL pointing to the ASCII-armored GPG key file for the repository."
              },
              "http_caching": {
                "enum": [
                  "all",
                  "packages",
                  "none"
                ],
                "type": "string",
                "description": "Default: all\n\nDetermines how upstream HTTP caches are instructed to handle any HTTP downloads that Yum does.\nC(all) means that all HTTP downloads should be cached.\nC(packages) means that only RPM package downloads should be cached (but not repository metadata downloads).\nC(none) means that no HTTP downloads should be cached."
              },
              "priority": {
                "type": "string",
                "description": "Default: 99\n\nEnforce ordered protection of repositories. The value is an integer from 1 to 99.\nThis option only works if the YUM Priorities plugin is installed."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the repo file."
              },
              "mirrorlist": {
                "type": "string",
                "description": "Specifies a URL to a file containing a list of baseurls.\nThis or the I(baseurl) parameter is required if I(state) is set to C(present)."
              },
              "params": {
                "type": "object",
                "description": "Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to C(null)."
              },
              "gpgcheck": {
                "description": "Default: no\n\nTells yum whether or not it should perform a GPG signature check on packages.",
                "$ref": "#/definitions/ansible_truth"
              },
              "include": {
                "type": "string",
                "description": "Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected."
              },
              "proxy_username": {
                "type": "string",
                "description": "Password for this proxy."
              },
              "username": {
                "type": "string",
                "description": "Username to use for basic authentication to a repo or really any url."
              },
              "metadata_expire": {
                "type": "string",
                "description": "Default: 21600\n\nTime (in seconds) after which the metadata will expire.\nDefault value is 6 hours."
              },
              "description": {
                "type": "string",
                "description": "A human readable string describing the repository.\nThis parameter is only required if I(state) is set to C(present)."
              },
              "retries": {
                "type": "string",
                "description": "Default: 10\n\nSet the number of times any attempt to retrieve a file should retry before returning an error. Setting this to C(0) makes yum try forever."
              },
              "sslclientcert": {
                "type": "string",
                "description": "Path to the SSL client certificate yum should use to connect to repos/remote sites."
              },
              "gpgcakey": {
                "type": "string",
                "description": "A URL pointing to the ASCII-armored CA key file for the repository."
              },
              "baseurl": {
                "type": "string",
                "description": "URL to the directory where the yum repository's 'repodata' directory lives.\nThis or the I(mirrorlist) parameter is required if I(state) is set to C(present)."
              },
              "s3_enabled": {
                "description": "Default: no\n\nEnables support for S3 repositories.\nThis option only works if the YUM S3 plugin is installed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "includepkgs": {
                "type": "string",
                "description": "List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.\nThe list can also be a regular YAML array."
              },
              "async": {
                "description": "Default: yes\n\nIf set to C(yes) Yum will download packages and metadata from this repo in parallel, if possible.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "Password to use with the username for basic authentication."
              },
              "ui_repoid_vars": {
                "type": "string",
                "description": "Default: releasever basearch\n\nWhen a repository id is displayed, append these yum variables to the string if they are used in the I(baseurl)/etc. Variables are appended in the order listed (and found)."
              },
              "protect": {
                "description": "Default: no\n\nProtect packages from updates from other repositories.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssl_check_cert_permissions": {
                "description": "Default: no\n\nWhether yum should check the permissions on the paths for the certificates on the repository (both remote and local).\nIf we can't read any of the files then yum will force I(skip_if_unavailable) to be C(yes). This is most useful for non-root processes which use yum on repos that have client cert files which are readable only by root.",
                "$ref": "#/definitions/ansible_truth"
              },
              "throttle": {
                "type": "string",
                "description": "Enable bandwidth throttling for downloads.\nThis option can be expressed as a absolute data rate in bytes/sec. An SI prefix (k, M or G) may be appended to the bandwidth value."
              },
              "name": {
                "type": "string",
                "description": "Unique repository ID.\nThis parameter is only required if I(state) is set to C(present) or C(absent)."
              },
              "deltarpm_percentage": {
                "type": "string",
                "description": "Default: 75\n\nWhen the relative size of delta vs pkg is larger than this, delta is not used. Use C(0) to turn off delta rpm processing. Local repositories (with file:// I(baseurl)) have delta rpms turned off by default."
              },
              "sslclientkey": {
                "type": "string",
                "description": "Path to the SSL client key yum should use to connect to repos/remote sites."
              },
              "metalink": {
                "type": "string",
                "description": "Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl)."
              },
              "reposdir": {
                "type": "string",
                "description": "Default: /etc/yum.repos.d\n\nDirectory where the C(.repo) files will be stored."
              },
              "skip_if_unavailable": {
                "description": "Default: no\n\nIf set to C(yes) yum will continue running if this repository cannot be contacted for any reason. This should be set carefully as all repos are consulted for any given command.",
                "$ref": "#/definitions/ansible_truth"
              },
              "keepcache": {
                "enum": [
                  "0",
                  "1"
                ],
                "type": "string",
                "description": "Default: 1\n\nEither C(1) or C(0). Determines whether or not yum keeps the cache of headers and packages after successful installation."
              },
              "sslcacert": {
                "type": "string",
                "description": "Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates."
              },
              "timeout": {
                "type": "string",
                "description": "Default: 30\n\nNumber of seconds to wait for a connection before timing out."
              },
              "enablegroups": {
                "description": "Default: yes\n\nDetermines whether yum will allow the use of package groups for this repository.",
                "$ref": "#/definitions/ansible_truth"
              },
              "metadata_expire_filter": {
                "enum": [
                  "never",
                  "read-only:past",
                  "read-only:present",
                  "read-only:future"
                ],
                "type": "string",
                "description": "Default: read-only:present\n\nFilter the I(metadata_expire) time, allowing a trade of speed for accuracy if a command doesn't require it. Each yum command can specify that it requires a certain level of timeliness quality from the remote repos. from \"I'm about to install/upgrade, so this better be current\" to \"Anything that's available is good enough\".\nC(never) - Nothing is filtered, always obey I(metadata_expire).\nC(read-only:past) - Commands that only care about past information are filtered from metadata expiring. Eg. I(yum history) info (if history needs to lookup anything about a previous transaction, then by definition the remote package was available in the past).\nC(read-only:present) - Commands that are balanced between past and future. Eg. I(yum list yum).\nC(read-only:future) - Commands that are likely to result in running other commands which will require the latest metadata. Eg. I(yum check-update).\nNote that this option does not override \"yum clean expire-cache\"."
              },
              "proxy": {
                "type": "string",
                "description": "URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting."
              }
            }
          },
          "template": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "dest",
                        "destfile",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "destfile"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "line",
                        "value"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Templates are processed by the Jinja2 templating language (U(http://jinja.pocoo.org/docs/)) - documentation on the template formatting can be found in the Template Designer Documentation (U(http://jinja.pocoo.org/docs/templates/)).\nSix additional variables can be used in templates: C(ansible_managed) (configurable via the C(defaults) section of C(ansible.cfg)) contains a string which can be used to describe the template name, host, modification time of the template file and the owner uid. C(template_host) contains the node name of the template's machine. C(template_uid) the numeric user id of the owner. C(template_path) the path of the template. C(template_fullpath) is the absolute path of the template. C(template_run_date) is the date that the template was rendered.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Location to render the template to on the remote machine."
              },
              "insertbefore": {
                "type": "string",
                "description": ""
              },
              "dest": {
                "type": "string",
                "description": "Location to render the template to on the remote machine."
              },
              "create": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "destfile": {
                "type": "string",
                "description": "Location to render the template to on the remote machine."
              },
              "backrefs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": ""
              },
              "value": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": "Location to render the template to on the remote machine."
              },
              "insertafter": {
                "type": "string",
                "description": ""
              },
              "regexp": {
                "type": "string",
                "description": ""
              },
              "validate": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              },
              "line": {
                "type": "string",
                "description": ""
              }
            }
          },
          "tower_inventory": {
            "required": [
              "organization",
              "name"
            ],
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower inventories. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "variables": {
                "type": "string",
                "description": "Inventory variables. Use '@' to get from file."
              },
              "description": {
                "type": "string",
                "description": "The description to use for the inventory."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "organization": {
                "type": "string",
                "description": "Organization the inventory belongs to."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name to use for the inventory."
              }
            }
          },
          "bigmon_policy": {
            "required": [
              "name",
              "controller"
            ],
            "type": "object",
            "description": "Create and remove a bigmon out-of-band policy.",
            "properties": {
              "policy_description": {
                "type": "string",
                "description": "Description of policy."
              },
              "name": {
                "type": "string",
                "description": "The name of the policy."
              },
              "access_token": {
                "type": "string",
                "description": "Bigmon access token. If this isn't set the the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used."
              },
              "start_time": {
                "type": "string",
                "description": "Default: ansible_date_time.iso8601\n\nDate the policy becomes active"
              },
              "controller": {
                "type": "string",
                "description": "The controller address."
              },
              "priority": {
                "description": "Default: 100\n\nA priority associated with this policy. The higher priority policy takes precedence over a lower priority.",
                "$ref": "#/definitions/ansible_number"
              },
              "action": {
                "enum": [
                  "forward",
                  "drop",
                  "capture",
                  "flow-gen"
                ],
                "type": "string",
                "description": "Default: forward\n\nForward matching packets to delivery interfaces, Drop is for measure rate of matching packets, but do not forward to delivery interfaces, capture packets and write to a PCAP file, or enable NetFlow generation."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the policy should be present or absent."
              },
              "duration": {
                "description": "Run policy for duration duration or until delivery_packet_count packets are delivered, whichever comes first.",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "Default: True\n\nIf C(false), SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "delivery_packet_count": {
                "description": "Run policy until delivery_packet_count packets are delivered.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "cl_license": {
            "required": [
              "src"
            ],
            "type": "object",
            "description": "Installs a Cumulus Linux license. The module reports no change of status when a license is installed. For more details go the Cumulus Linux License Documentation at U(http://docs.cumulusnetwork.com) and the Licensing KB Site at U(https://support.cumulusnetworks.com/hc/en-us/sections/200507688)",
            "properties": {
              "src": {
                "type": "string",
                "description": "The full path to the license. Can be local path or HTTP URL."
              },
              "force": {
                "description": "Force installation of a license. Typically not needed. It is recommended to manually run this command via the ansible command. A reload of switchd is not required. Running the force option in a playbook will break the idempotent state machine of the module and cause the switchd notification to kick in all the time, causing a disruption.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "aos_template": {
            "required": [
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS Template module let you manage your Template easily. You can create create and delete Template by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "content": {
                "type": "string",
                "description": "Datastructure of the Template to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the Template (present or not)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "id": {
                "type": "string",
                "description": "AOS Id of the Template to manage (can't be used to create a new Template), Only one of I(name), I(id) or I(src) can be set."
              },
              "name": {
                "type": "string",
                "description": "Name of the Template to manage. Only one of I(name), I(id) or I(src) can be set."
              }
            }
          },
          "ec2_ami_find": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ami_tags",
                        "search_tags",
                        "image_tags"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Returns list of matching AMIs with AMI ID, along with other useful information\nCan search AMIs with different owners\nCan search by matching tag(s), by AMI name and/or other criteria\nResults can be sorted and sliced",
            "properties": {
              "no_result_action": {
                "enum": [
                  "success",
                  "fail"
                ],
                "type": "string",
                "description": "Default: success\n\nWhat to do when no results are found.\n'success' reports success and returns an empty array\n'fail' causes the module to report failure"
              },
              "sort_order": {
                "enum": [
                  "ascending",
                  "descending"
                ],
                "type": "string",
                "description": "Default: ascending\n\nOrder in which to sort results.\nOnly used when the 'sort' parameter is specified."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "owner": {
                "type": "string",
                "description": "Search AMIs owned by the specified owner\nCan specify an AWS account ID, or one of the special IDs 'self', 'amazon' or 'aws-marketplace'\nIf not specified, all EC2 AMIs in the specified region will be searched.\nYou can include wildcards in many of the search options. An asterisk (*) matches zero or more characters, and a question mark (?) matches exactly one character. You can escape special characters using a backslash (\\) before the character. For example, a value of \\*amazon\\?\\ searches for the literal string *amazon?\\."
              },
              "product_code": {
                "type": "string",
                "description": "Marketplace product code to match."
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "image_tags": {
                "type": "object",
                "description": "A hash/dictionary of tags to match for the AMI."
              },
              "platform": {
                "type": "string",
                "description": "Platform type to match."
              },
              "state": {
                "type": "string",
                "description": "Default: available\n\nAMI state to match."
              },
              "sort_start": {
                "type": "string",
                "description": "Which result to start with (when sorting).\nCorresponds to Python slice notation."
              },
              "virtualization_type": {
                "type": "string",
                "description": "Virtualization type to match (e.g. hvm)."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "sort_end": {
                "type": "string",
                "description": "Which result to end with (when sorting).\nCorresponds to Python slice notation."
              },
              "search_tags": {
                "type": "object",
                "description": "A hash/dictionary of tags to match for the AMI."
              },
              "aws_region": {
                "type": "string",
                "description": "The AWS region to use."
              },
              "sort": {
                "enum": [
                  "name",
                  "description",
                  "tag",
                  "architecture",
                  "block_device_mapping",
                  "creationDate",
                  "hypervisor",
                  "is_public",
                  "location",
                  "owner_id",
                  "platform",
                  "root_device_name",
                  "root_device_type",
                  "state",
                  "virtualization_type"
                ],
                "type": "string",
                "description": "Optional attribute which with to sort the results.\nIf specifying 'tag', the 'tag_name' parameter is required.\nStarting at version 2.1, additional sort choices of architecture, block_device_mapping, creationDate, hypervisor, is_public, location, owner_id, platform, root_device_name, root_device_type, state, and virtualization_type are supported."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": "The AWS region to use."
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "ami_id": {
                "type": "string",
                "description": "An AMI ID to match."
              },
              "name": {
                "type": "string",
                "description": "An AMI name to match."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "hypervisor": {
                "type": "string",
                "description": "A hypervisor type type to match (e.g. xen)."
              },
              "region": {
                "type": "string",
                "description": "The AWS region to use."
              },
              "is_public": {
                "description": "Whether or not the image(s) are public.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ami_tags": {
                "type": "object",
                "description": "A hash/dictionary of tags to match for the AMI."
              },
              "architecture": {
                "type": "string",
                "description": "An architecture type to match (e.g. x86_64)."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "sort_tag": {
                "type": "string",
                "description": "Tag name with which to sort results.\nRequired when specifying 'sort=tag'."
              }
            }
          },
          "zfs_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "ds",
                        "dataset"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "ds"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dataset"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts from ZFS dataset properties.",
            "properties": {
              "properties": {
                "type": "string",
                "description": "Default: all\n\nSpecifies which dataset properties should be queried in comma-separated format. For more information about dataset properties, check zfs(1M) man page."
              },
              "name": {
                "type": "string",
                "description": "ZFS dataset name."
              },
              "recurse": {
                "description": "Specifies if properties for any children should be recursively displayed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dataset": {
                "type": "string",
                "description": "ZFS dataset name."
              },
              "parsable": {
                "description": "Specifies if property values should be displayed in machine friendly format.",
                "$ref": "#/definitions/ansible_truth"
              },
              "depth": {
                "description": "Default: None\n\nSpecifiies recurion depth.",
                "$ref": "#/definitions/ansible_number"
              },
              "type": {
                "enum": [
                  "all",
                  "filesystem",
                  "volume",
                  "snapshot",
                  "bookmark"
                ],
                "type": "string",
                "description": "Default: all\n\nSpecifies which datasets types to display. Multiple values have to be provided in comma-separated form."
              },
              "ds": {
                "type": "string",
                "description": "ZFS dataset name."
              }
            }
          },
          "cs_cluster": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, update and remove clusters.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username for the cluster."
              },
              "ovm3_cluster": {
                "type": "string",
                "description": "Ovm3 native OCFS2 clustering enabled for cluster."
              },
              "ovm3_pool": {
                "type": "string",
                "description": "Ovm3 native pooling enabled for cluster."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "pod": {
                "type": "string",
                "description": "Name of the pod in which the cluster belongs to."
              },
              "public_vswitch_type": {
                "enum": [
                  "vmwaresvs",
                  "vmwaredvs"
                ],
                "type": "string",
                "description": "Type of virtual switch used for public traffic in the cluster.\nAllowed values are, vmwaresvs (for VMware standard vSwitch) and vmwaredvs (for VMware distributed vSwitch)"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the cluster belongs to.\nIf not set, default zone is used."
              },
              "cluster_type": {
                "enum": [
                  "CloudManaged",
                  "ExternalManaged"
                ],
                "type": "string",
                "description": "Type of the cluster.\nRequired if C(state=present)"
              },
              "ovm3_vip": {
                "type": "string",
                "description": "Ovm3 vip to use for pool (and cluster)."
              },
              "vms_ip_address": {
                "type": "string",
                "description": "IP address of the VSM associated with this cluster."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "disabled",
                  "enabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the cluster."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "guest_vswitch_type": {
                "enum": [
                  "vmwaresvs",
                  "vmwaredvs"
                ],
                "type": "string",
                "description": "Type of virtual switch used for guest traffic in the cluster.\nAllowed values are, vmwaresvs (for VMware standard vSwitch) and vmwaredvs (for VMware distributed vSwitch)"
              },
              "guest_vswitch_name": {
                "type": "string",
                "description": "Name of virtual switch used for guest traffic in the cluster.\nThis would override zone wide traffic label setting."
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": "Password for the cluster."
              },
              "vms_username": {
                "type": "string",
                "description": "Username for the VSM associated with this cluster."
              },
              "name": {
                "type": "string",
                "description": "name of the cluster."
              },
              "url": {
                "type": "string",
                "description": "URL for the cluster"
              },
              "hypervisor": {
                "enum": [
                  "KVM",
                  "kvm",
                  "VMware",
                  "vmware",
                  "BareMetal",
                  "baremetal",
                  "XenServer",
                  "xenserver",
                  "LXC",
                  "lxc",
                  "HyperV",
                  "hyperv",
                  "UCS",
                  "ucs",
                  "OVM",
                  "ovm",
                  "Simulator",
                  "simulator"
                ],
                "type": "string",
                "description": "Default: none\n\nName the hypervisor to be used.\nRequired if C(state=present)."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "public_vswitch_name": {
                "type": "string",
                "description": "Name of virtual switch used for public traffic in the cluster.\nThis would override zone wide traffic label setting."
              },
              "vms_password": {
                "type": "string",
                "description": "Password for the VSM associated with this cluster."
              }
            }
          },
          "nxos_snmp_community": {
            "required": [
              "community"
            ],
            "type": "object",
            "description": "Manages SNMP community configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "group": {
                "type": "string",
                "description": "Group to which the community belongs."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "community": {
                "type": "string",
                "description": "Case-sensitive community string."
              },
              "acl": {
                "type": "string",
                "description": "Default: 1\n\nACL name to filter snmp requests."
              },
              "access": {
                "enum": [
                  "ro",
                  "rw"
                ],
                "type": "string",
                "description": "Access type for community."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "ovirt_tags": {
            "required": [
              "name",
              "auth"
            ],
            "type": "object",
            "description": "This module manage tags in oVirt. It can also manage assignments of those tags to entities.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the the tag to manage."
              },
              "parent": {
                "type": "string",
                "description": "Name of the parent tag."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the tag be present or absent."
              },
              "hosts": {
                "description": "List of the hosts names, which should have assigned this tag.",
                "$ref": "#/definitions/ansible_array"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "vms": {
                "description": "List of the VMs names, which should have assigned this tag.",
                "$ref": "#/definitions/ansible_array"
              },
              "description": {
                "type": "string",
                "description": "Description of the the tag to manage."
              }
            }
          },
          "ec2_ami_search": {
            "required": [
              "release",
              "distro"
            ],
            "type": "object",
            "description": "Look up the most recent AMI on AWS for a given operating system.\nReturns C(ami), C(aki), C(ari), C(serial), C(tag)\nIf there is no AKI or ARI associated with an image, these will be C(null).\nOnly supports images from cloud-images.ubuntu.com\nExample output: C({\"ami\": \"ami-69f5a900\", \"changed\": false, \"aki\": \"aki-88aa75e1\", \"tag\": \"release\", \"ari\": null, \"serial\": \"20131024\"})",
            "properties": {
              "stream": {
                "enum": [
                  "server",
                  "desktop"
                ],
                "type": "string",
                "description": "Default: server\n\nType of release."
              },
              "virt": {
                "enum": [
                  "paravirtual",
                  "hvm"
                ],
                "type": "string",
                "description": "Default: paravirtual\n\nvirutalization type"
              },
              "region": {
                "enum": [
                  "ap-northeast-1",
                  "ap-southeast-1",
                  "ap-northeast-2",
                  "ap-southeast-2",
                  "ap-south-1",
                  "ca-central-1",
                  "eu-central-1",
                  "eu-west-1",
                  "eu-west-2",
                  "sa-east-1",
                  "us-east-1",
                  "us-east-2",
                  "us-west-1",
                  "us-west-2",
                  "us-gov-west-1"
                ],
                "type": "string",
                "description": "Default: us-east-1\n\nEC2 region"
              },
              "release": {
                "type": "string",
                "description": "short name of the release (e.g., C(precise))"
              },
              "arch": {
                "enum": [
                  "i386",
                  "amd64"
                ],
                "type": "string",
                "description": "Default: amd64\n\nCPU architecture"
              },
              "store": {
                "enum": [
                  "ebs",
                  "ebs-io1",
                  "ebs-ssd",
                  "instance-store"
                ],
                "type": "string",
                "description": "Default: ebs\n\nBack-end store for instance"
              },
              "distro": {
                "enum": [
                  "ubuntu"
                ],
                "type": "string",
                "description": "Linux distribution (e.g., C(ubuntu))"
              }
            }
          },
          "sl_vm": {
            "type": "object",
            "description": "Creates or cancels SoftLayer instances. When created, optionally waits for it to be 'running'.",
            "properties": {
              "dedicated": {
                "description": "Falg to determine if the instance should be deployed in dedicated space",
                "$ref": "#/definitions/ansible_truth"
              },
              "cpus": {
                "description": "Count of cpus to be assigned to new virtual instance",
                "$ref": "#/definitions/ansible_number"
              },
              "private": {
                "description": "Flag to determine if the instance should be private only",
                "$ref": "#/definitions/ansible_truth"
              },
              "domain": {
                "type": "string",
                "description": "Domain name to be provided to a virtual instance"
              },
              "private_vlan": {
                "type": "string",
                "description": "VLAN by its Id to be assigned to the private NIC"
              },
              "hourly": {
                "description": "Default: True\n\nFlag to determine if the instance should be hourly billed",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keys": {
                "description": "List of ssh keys by their Id to be assigned to a virtual instance",
                "$ref": "#/definitions/ansible_array"
              },
              "hostname": {
                "type": "string",
                "description": "Hostname to be provided to a virtual instance"
              },
              "os_code": {
                "type": "string",
                "description": "OS Code to be used for new virtual instance"
              },
              "wait_time": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate, or cancel a virtual instance. Specify \"present\" for create, \"absent\" to cancel."
              },
              "post_uri": {
                "type": "string",
                "description": "URL of a post provisioning script ot be loaded and exectued on virtual instance"
              },
              "memory": {
                "description": "Amount of memory to be assigned to new virtual instance",
                "$ref": "#/definitions/ansible_number"
              },
              "tags": {
                "type": "string",
                "description": "Tag or list of tags to be provided to a virtual instance"
              },
              "image_id": {
                "type": "string",
                "description": "Image Template to be used for new virtual instance"
              },
              "nic_speed": {
                "description": "Default: 10\n\nNIC Speed to be assigned to new virtual instance",
                "$ref": "#/definitions/ansible_number"
              },
              "public_vlan": {
                "type": "string",
                "description": "VLAN by its Id to be assigned to the public NIC"
              },
              "wait": {
                "description": "Default: True\n\nFlag used to wait for active status before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "datacenter": {
                "enum": [
                  "ams01",
                  "ams03",
                  "che01",
                  "dal01",
                  "dal05",
                  "dal06",
                  "dal09",
                  "dal10",
                  "fra02",
                  "hkg02",
                  "hou02",
                  "lon02",
                  "mel01",
                  "mex01",
                  "mil01",
                  "mon01",
                  "osl01",
                  "par01",
                  "sjc01",
                  "sjc03",
                  "sao01",
                  "sea01",
                  "sng01",
                  "syd01",
                  "tok02",
                  "tor01",
                  "wdc01",
                  "wdc04"
                ],
                "type": "string",
                "description": "Datacenter for the virtual instance to be deployed"
              },
              "disks": {
                "description": "Default: [25]\n\nList of disk sizes to be assigned to new virtual instance",
                "$ref": "#/definitions/ansible_array"
              },
              "instance_id": {
                "type": "string",
                "description": "Instance Id of the virtual instance to perform action option"
              },
              "local_disk": {
                "description": "Default: True\n\nFlag to determine if local disk should be used for the new instance",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "na_cdot_qtree": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or destroy Qtrees.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the Qtree to manage."
              },
              "flexvol_name": {
                "type": "string",
                "description": "The name of the FlexVol the Qtree should exist on. Required when C(state=present)."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "vserver": {
                "type": "string",
                "description": "The name of the vserver to use."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified Qtree should exist or not."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              }
            }
          },
          "wait_for": {
            "type": "object",
            "description": "You can wait for a set amount of time C(timeout), this is the default if nothing is specified.\nWaiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers. It is also useful when starting guests with the M(virt) module and needing to pause until they are ready.\nThis module can also be used to wait for a regex match a string to be present in a file.\nIn 1.6 and later, this module can also be used to wait for a file to be available or absent on the filesystem.\nIn 1.8 and later, this module can also be used to wait for active connections to be closed before continuing, useful if a node is being rotated out of a load balancer pool.",
            "properties": {
              "active_connection_states": {
                "description": "Default: ['ESTABLISHED', 'SYN_SENT', 'SYN_RECV', 'FIN_WAIT1', 'FIN_WAIT2', 'TIME_WAIT']\n\nThe list of tcp connection states which are counted as active connections",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": "Default: 127.0.0.1\n\nA resolvable hostname or IP address to wait for"
              },
              "connect_timeout": {
                "description": "Default: 5\n\nmaximum number of seconds to wait for a connection to happen before closing and retrying",
                "$ref": "#/definitions/ansible_number"
              },
              "delay": {
                "description": "number of seconds to wait before starting to poll",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "started",
                  "stopped",
                  "absent",
                  "drained"
                ],
                "type": "string",
                "description": "Default: started\n\neither C(present), C(started), or C(stopped), C(absent), or C(drained)\nWhen checking a port C(started) will ensure the port is open, C(stopped) will check that it is closed, C(drained) will check for active connections\nWhen checking for a file or a search string C(present) or C(started) will ensure that the file or string is present before continuing, C(absent) will check that file is absent or removed"
              },
              "sleep": {
                "description": "Default: 1\n\nNumber of seconds to sleep between checks, before 2.3 this was hardcoded to 1 second.",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "Default: 300\n\nmaximum number of seconds to wait for",
                "$ref": "#/definitions/ansible_number"
              },
              "exclude_hosts": {
                "description": "list of hosts or IPs to ignore when looking for active TCP connections for C(drained) state",
                "$ref": "#/definitions/ansible_array"
              },
              "search_regex": {
                "type": "string",
                "description": "Can be used to match a string in either a file or a socket connection. Defaults to a multiline regex."
              },
              "path": {
                "type": "string",
                "description": "path to a file on the filesytem that must exist before continuing"
              },
              "port": {
                "description": "port number to poll",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "rds_param_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "params",
                        "parameters"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, modifies, and deletes RDS parameter groups. This module has a dependency on python-boto >= 2.5.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Database parameter group description. Only set when a new group is added."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "immediate": {
                "description": "Whether to apply the changes immediately, or after the next reboot of any associated instances.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Database parameter group identifier."
              },
              "engine": {
                "enum": [
                  "aurora5.6",
                  "mariadb10.0",
                  "mariadb10.1",
                  "mysql5.1",
                  "mysql5.5",
                  "mysql5.6",
                  "mysql5.7",
                  "oracle-ee-11.2",
                  "oracle-ee-12.1",
                  "oracle-se-11.2",
                  "oracle-se-12.1",
                  "oracle-se1-11.2",
                  "oracle-se1-12.1",
                  "postgres9.3",
                  "postgres9.4",
                  "postgres9.5",
                  "postgres9.6",
                  "sqlserver-ee-10.5",
                  "sqlserver-ee-11.0",
                  "sqlserver-ex-10.5",
                  "sqlserver-ex-11.0",
                  "sqlserver-ex-12.0",
                  "sqlserver-se-10.5",
                  "sqlserver-se-11.0",
                  "sqlserver-se-12.0",
                  "sqlserver-web-10.5",
                  "sqlserver-web-11.0",
                  "sqlserver-web-12.0"
                ],
                "type": "string",
                "description": "The type of database for this group. Required for state=present."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecifies whether the group should be present or absent."
              },
              "params": {
                "type": "object",
                "description": "Map of parameter names and values. Numeric values may be represented as K for kilo (1024), M for mega (1024^2), G for giga (1024^3), or T for tera (1024^4), and these values will be expanded into the appropriate number before being set in the parameter group."
              },
              "parameters": {
                "type": "object",
                "description": "Map of parameter names and values. Numeric values may be represented as K for kilo (1024), M for mega (1024^2), G for giga (1024^3), or T for tera (1024^4), and these values will be expanded into the appropriate number before being set in the parameter group."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "xenserver_facts": {
            "type": "object",
            "description": "Reads data out of XenAPI, can be used instead of multiple xe commands.",
            "properties": {}
          },
          "elasticache_subnet_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, modifies, and deletes Elasticache subnet groups. This module has a dependency on python-boto >= 2.5.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Elasticache subnet group description. Only set when a new group is added."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "subnets": {
                "description": "List of subnet IDs that make up the Elasticache subnet group.",
                "$ref": "#/definitions/ansible_array"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Database subnet group identifier."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecifies whether the subnet should be present or absent."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "logstash_plugin": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manages Logstash plugins.",
            "properties": {
              "plugin_bin": {
                "type": "string",
                "description": "Default: /usr/share/logstash/bin/logstash-plugin\n\nSpecify logstash-plugin to use for plugin management."
              },
              "proxy_host": {
                "type": "string",
                "description": "Default: None\n\nProxy host to use during plugin installation."
              },
              "proxy_port": {
                "type": "string",
                "description": "Default: None\n\nProxy port to use during plugin installation."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nApply plugin state."
              },
              "version": {
                "type": "string",
                "description": "Default: None\n\nSpecify plugin Version of the plugin to install. If plugin exists with previous version, it will NOT be updated."
              },
              "name": {
                "type": "string",
                "description": "Install plugin with that name."
              }
            }
          },
          "vertica_configuration": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "parameter",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "parameter"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Updates Vertica configuration parameters.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the parameter to update."
              },
              "login_user": {
                "type": "string",
                "description": "Default: dbadmin\n\nThe username used to authenticate with."
              },
              "db": {
                "type": "string",
                "description": "Name of the Vertica database."
              },
              "value": {
                "type": "string",
                "description": "Value of the parameter to be set."
              },
              "cluster": {
                "type": "string",
                "description": "Default: localhost\n\nName of the Vertica cluster."
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with."
              },
              "parameter": {
                "type": "string",
                "description": "Name of the parameter to update."
              },
              "port": {
                "type": "string",
                "description": "Default: 5433\n\nVertica cluster port to connect to."
              }
            }
          },
          "gce_instance_template": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "base_name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates or destroy Google instance templates of Compute Engine of Google Cloud Platform.",
            "properties": {
              "automatic_restart": {
                "description": "Defines whether the instance should be automatically restarted when it is terminated by Compute Engine.",
                "$ref": "#/definitions/ansible_truth"
              },
              "image": {
                "type": "string",
                "description": "The image to use to create the instance. Cannot specify both both I(image) and I(source)."
              },
              "service_account_permissions": {
                "description": "service account permissions (see U(https://cloud.google.com/sdk/gcloud/reference/compute/instances/create), --scopes section for detailed information)",
                "$ref": "#/definitions/ansible_array"
              },
              "pem_file": {
                "type": "string",
                "description": "path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'."
              },
              "size": {
                "type": "string",
                "description": "Default: f1-micro\n\nThe desired machine type for the instance template."
              },
              "network": {
                "type": "string",
                "description": "Default: default\n\nThe network to associate with the instance."
              },
              "service_account_email": {
                "type": "string",
                "description": "service account email"
              },
              "nic_gce_struct": {
                "description": "Support passing in the GCE-specific formatted networkInterfaces[] structure.",
                "$ref": "#/definitions/ansible_array"
              },
              "disk_auto_delete": {
                "description": "Default: True\n\nIndicate that the boot disk should be deleted when the Node is deleted.",
                "$ref": "#/definitions/ansible_truth"
              },
              "source": {
                "type": "string",
                "description": "A source disk to attach to the instance. Cannot specify both I(image) and I(source)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe desired state for the instance template."
              },
              "project_id": {
                "type": "string",
                "description": "your GCE project ID"
              },
              "image_family": {
                "type": "string",
                "description": "The image family to use to create the instance. If I(image) has been used I(image_family) is ignored. Cannot specify both I(image) and I(source)."
              },
              "metadata": {
                "type": "string",
                "description": "a hash/dictionary of custom data for the instance; '{\"key\":\"value\", ...}'"
              },
              "description": {
                "type": "string",
                "description": "description of instance template"
              },
              "tags": {
                "description": "a comma-separated list of tags to associate with the instance",
                "$ref": "#/definitions/ansible_array"
              },
              "preemptible": {
                "description": "Defines whether the instance is preemptible.",
                "$ref": "#/definitions/ansible_truth"
              },
              "can_ip_forward": {
                "description": "Set to True to allow instance to send/receive non-matching src/dst packets.",
                "$ref": "#/definitions/ansible_truth"
              },
              "disk_type": {
                "enum": [
                  "pd-standard",
                  "pd-ssd"
                ],
                "type": "string",
                "description": "Default: pd-standard\n\nSpecify a C(pd-standard) disk or C(pd-ssd) for an SSD disk."
              },
              "name": {
                "type": "string",
                "description": "The name of the GCE instance template."
              },
              "base_name": {
                "type": "string",
                "description": "The name of the GCE instance template."
              },
              "external_ip": {
                "type": "string",
                "description": "Default: ephemeral\n\nThe external IP address to use. If C(ephemeral), a new non-static address will be used.  If C(None), then no external address will be used.  To use an existing static IP address specify adress name."
              },
              "disks": {
                "description": "a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).",
                "$ref": "#/definitions/ansible_array"
              },
              "credentials_file": {
                "type": "string",
                "description": "path to the JSON file associated with the service account email"
              },
              "subnetwork": {
                "type": "string",
                "description": "The Subnetwork resource name for this instance."
              }
            }
          },
          "vmware_host": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module can be used to add/remove an ESXi host to/from vCenter",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "datacenter_name": {
                "type": "string",
                "description": "Name of the datacenter to add the host"
              },
              "esxi_hostname": {
                "type": "string",
                "description": "ESXi hostname to manage"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "esxi_username": {
                "type": "string",
                "description": "ESXi username"
              },
              "cluster_name": {
                "type": "string",
                "description": "Name of the cluster to add the host"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nAdd or remove the host"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "esxi_password": {
                "type": "string",
                "description": "ESXi password"
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              }
            }
          },
          "openvswitch_db": {
            "required": [
              "key",
              "value",
              "record",
              "table",
              "col"
            ],
            "type": "object",
            "description": "Set column values in record in database table.",
            "properties": {
              "key": {
                "type": "string",
                "description": "Identifies the key in the record column"
              },
              "value": {
                "type": "string",
                "description": "Expected value for the table, record, column and key."
              },
              "record": {
                "type": "string",
                "description": "Identifies the recoard in the table."
              },
              "timeout": {
                "description": "Default: 5\n\nHow long to wait for ovs-vswitchd to respond",
                "$ref": "#/definitions/ansible_number"
              },
              "table": {
                "type": "string",
                "description": "Identifies the table in the database."
              },
              "col": {
                "type": "string",
                "description": ""
              }
            }
          },
          "webfaction_domain": {
            "required": [
              "login_password",
              "login_name",
              "name"
            ],
            "type": "object",
            "description": "Add or remove domains or subdomains on a Webfaction host. Further documentation at http://github.com/quentinsf/ansible-webfaction.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the domain should exist"
              },
              "subdomains": {
                "type": "string",
                "description": "Any subdomains to create."
              },
              "login_name": {
                "type": "string",
                "description": "The webfaction account to use"
              },
              "name": {
                "type": "string",
                "description": "The name of the domain"
              },
              "login_password": {
                "type": "string",
                "description": "The webfaction password to use"
              }
            }
          },
          "aix_inittab": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "service"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "service"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages the inittab on AIX.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the inittab entry."
              },
              "service": {
                "type": "string",
                "description": "Name of the inittab entry."
              },
              "action": {
                "enum": [
                  "respawn",
                  "wait",
                  "once",
                  "boot",
                  "bootwait",
                  "powerfail",
                  "powerwait",
                  "off",
                  "hold",
                  "ondemand",
                  "initdefault",
                  "sysinit"
                ],
                "type": "string",
                "description": "Action what the init has to do with this entry."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the entry should be present or absent in the inittab file"
              },
              "command": {
                "type": "string",
                "description": "What command has to run."
              },
              "runlevel": {
                "type": "string",
                "description": "Runlevel of the entry."
              },
              "insertafter": {
                "type": "string",
                "description": "After which inittabline should the new entry inserted."
              }
            }
          },
          "rds": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "zone",
                        "aws_zone",
                        "ec2_zone"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_type",
                        "type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, deletes, or modifies rds instances.  When creating an instance it can be either a new instance or a read-only replica of an existing instance. This module has a dependency on python-boto >= 2.5. The 'promote' command requires boto >= 2.18.0. Certain features such as tags rely on boto.rds2 (boto >= 2.26.0)",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "db_engine": {
                "enum": [
                  "mariadb",
                  "MySQL",
                  "oracle-se1",
                  "oracle-se",
                  "oracle-ee",
                  "sqlserver-ee",
                  "sqlserver-se",
                  "sqlserver-ex",
                  "sqlserver-web",
                  "postgres",
                  "aurora"
                ],
                "type": "string",
                "description": "The type of database.  Used only when command=create.\nmariadb was added in version 2.2"
              },
              "force_failover": {
                "description": "Default: no\n\nUsed only when command=reboot.  If enabled, the reboot is done using a MultiAZ failover.",
                "$ref": "#/definitions/ansible_truth"
              },
              "iops": {
                "type": "string",
                "description": "Specifies the number of IOPS for the instance.  Used only when command=create or command=modify. Must be an integer greater than 1000."
              },
              "backup_window": {
                "type": "string",
                "description": "Backup window in format of hh24:mi-hh24:mi.  If not specified then a random backup window is assigned. Used only when command=create or command=modify."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "backup_retention": {
                "type": "string",
                "description": "Number of days backups are retained.  Set to 0 to disable backups.  Default is 1 day.  Valid range: 0-35. Used only when command=create or command=modify."
              },
              "port": {
                "type": "string",
                "description": "Default: 3306 for mysql, 1521 for Oracle, 1433 for SQL Server, 5432 for PostgreSQL.\n\nPort number that the DB instance uses for connections. Used only when command=create or command=replicate.\nPrior to 2.0 it always defaults to null and the API would use 3306, it had to be set to other DB default values when not using MySql. Starting at 2.0 it automatically defaults to what is expected for each c(db_engine)."
              },
              "security_groups": {
                "type": "string",
                "description": "Comma separated list of one or more security groups.  Used only when command=create or command=modify."
              },
              "size": {
                "type": "string",
                "description": "Size in gigabytes of the initial storage for the DB instance. Used only when command=create or command=modify."
              },
              "aws_secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "subnet": {
                "type": "string",
                "description": "VPC subnet group.  If specified then a VPC instance is created. Used only when command=create."
              },
              "vpc_security_groups": {
                "description": "Comma separated list of one or more vpc security group ids. Also requires `subnet` to be specified. Used only when command=create or command=modify.",
                "$ref": "#/definitions/ansible_array"
              },
              "upgrade": {
                "description": "Indicates that minor version upgrades should be applied automatically. Used only when command=create or command=replicate.",
                "$ref": "#/definitions/ansible_truth"
              },
              "zone": {
                "type": "string",
                "description": "availability zone in which to launch the instance. Used only when command=create, command=replicate or command=restore."
              },
              "source_instance": {
                "type": "string",
                "description": "Name of the database to replicate. Used only when command=replicate."
              },
              "parameter_group": {
                "type": "string",
                "description": "Name of the DB parameter group to associate with this instance.  If omitted then the RDS default DBParameterGroup will be used. Used only when command=create or command=modify."
              },
              "snapshot": {
                "type": "string",
                "description": "Name of snapshot to take. When command=delete, if no snapshot name is provided then no snapshot is taken. If used with command=delete with no instance_name, the snapshot is deleted. Used with command=facts, command=delete or command=snapshot."
              },
              "multi_zone": {
                "description": "Specifies if this is a Multi-availability-zone deployment. Can not be used in conjunction with zone parameter. Used only when command=create or command=modify.",
                "$ref": "#/definitions/ansible_truth"
              },
              "new_instance_name": {
                "type": "string",
                "description": "Name to rename an instance to. Used only when command=modify."
              },
              "type": {
                "type": "string",
                "description": "The instance type of the database.  Must be specified when command=create. Optional when command=replicate, command=modify or command=restore. If not specified then the replica inherits the same instance type as the source instance."
              },
              "username": {
                "type": "string",
                "description": "Master database username. Used only when command=create."
              },
              "access_key": {
                "type": "string",
                "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "tags": {
                "type": "object",
                "description": "tags dict to apply to a resource. Used with command=create, command=replicate, command=restore. Requires boto >= 2.26.0"
              },
              "character_set_name": {
                "type": "string",
                "description": "Associate the DB instance with a specified character set. Used with command=create."
              },
              "aws_region": {
                "type": "string",
                "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used."
              },
              "wait_timeout": {
                "description": "Default: 300\n\nhow long before wait gives up, in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "license_model": {
                "enum": [
                  "license-included",
                  "bring-your-own-license",
                  "general-public-license",
                  "postgresql-license"
                ],
                "type": "string",
                "description": "The license model for this DB instance. Used only when command=create or command=restore."
              },
              "ec2_access_key": {
                "type": "string",
                "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "ec2_secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "apply_immediately": {
                "description": "Used only when command=modify.  If enabled, the modifications will be applied as soon as possible rather than waiting for the next preferred maintenance window.",
                "$ref": "#/definitions/ansible_truth"
              },
              "wait": {
                "description": "Default: no\n\nWhen command=create, replicate, modify or restore then wait for the database to enter the 'available' state.  When command=delete wait for the database to be terminated.",
                "$ref": "#/definitions/ansible_truth"
              },
              "aws_zone": {
                "type": "string",
                "description": "availability zone in which to launch the instance. Used only when command=create, command=replicate or command=restore."
              },
              "aws_access_key": {
                "type": "string",
                "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "ec2_region": {
                "type": "string",
                "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used."
              },
              "option_group": {
                "type": "string",
                "description": "The name of the option group to use.  If not specified then the default option group is used. Used only when command=create."
              },
              "engine_version": {
                "type": "string",
                "description": "Version number of the database engine to use. Used only when command=create. If not specified then the current Amazon RDS default engine version is used."
              },
              "ec2_zone": {
                "type": "string",
                "description": "availability zone in which to launch the instance. Used only when command=create, command=replicate or command=restore."
              },
              "instance_name": {
                "type": "string",
                "description": "Database instance identifier. Required except when using command=facts or command=delete on just a snapshot"
              },
              "instance_type": {
                "type": "string",
                "description": "The instance type of the database.  Must be specified when command=create. Optional when command=replicate, command=modify or command=restore. If not specified then the replica inherits the same instance type as the source instance."
              },
              "password": {
                "type": "string",
                "description": "Password for the master database username. Used only when command=create or command=modify."
              },
              "db_name": {
                "type": "string",
                "description": "Name of a database to create within the instance.  If not specified then no database is created. Used only when command=create."
              },
              "command": {
                "enum": [
                  "create",
                  "replicate",
                  "delete",
                  "facts",
                  "modify",
                  "promote",
                  "snapshot",
                  "reboot",
                  "restore"
                ],
                "type": "string",
                "description": "Specifies the action to take. The 'reboot' option is available starting at version 2.0"
              },
              "publicly_accessible": {
                "type": "string",
                "description": "explicitly set whether the resource should be publicly accessible or not. Used with command=create, command=replicate. Requires boto >= 2.26.0"
              },
              "secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "maint_window": {
                "type": "string",
                "description": "Maintenance window in format of ddd:hh24:mi-ddd:hh24:mi.  (Example: Mon:22:00-Mon:23:15) If not specified then a random maintenance window is assigned. Used only when command=create or command=modify."
              }
            }
          },
          "os_nova_flavor": {
            "type": "object",
            "description": "Add or remove flavors from OpenStack.",
            "properties": {
              "flavorid": {
                "type": "string",
                "description": "Default: auto\n\nID for the flavor. This is optional as a unique UUID will be assigned if a value is not specified."
              },
              "name": {
                "type": "string",
                "description": "Flavor name."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "ram": {
                "type": "string",
                "description": "Amount of memory, in MB."
              },
              "ephemeral": {
                "type": "string",
                "description": "Ephemeral space size, in GB."
              },
              "vcpus": {
                "type": "string",
                "description": "Number of virtual CPUs."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource. When I(state) is 'present', then I(ram), I(vcpus), and I(disk) are all required. There are no default values for those parameters."
              },
              "extra_specs": {
                "type": "string",
                "description": "Default: None\n\nMetadata dictionary"
              },
              "swap": {
                "type": "string",
                "description": "Swap space size, in MB."
              },
              "rxtx_factor": {
                "type": "string",
                "description": "Default: 1.0\n\nRX/TX factor."
              },
              "is_public": {
                "type": "string",
                "description": "Default: True\n\nMake flavor accessible to the public."
              },
              "disk": {
                "type": "string",
                "description": "Size of local disk, in GB."
              }
            }
          },
          "nxos_ntp": {
            "type": "object",
            "description": "Manages core NTP configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "source_addr": {
                "type": "string",
                "description": "Local source address from which NTP messages are sent."
              },
              "key_id": {
                "type": "string",
                "description": "Authentication key identifier to use with given NTP server or peer."
              },
              "prefer": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Makes given NTP server or peer the preferred NTP server or peer for the device."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "server": {
                "type": "string",
                "description": "Network address of NTP server."
              },
              "source_int": {
                "type": "string",
                "description": "Local source interface from which NTP messages are sent. Must be fully qualified interface name."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "vrf_name": {
                "type": "string",
                "description": "Makes the device communicate with the given NTP server or peer over a specific VRF."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "peer": {
                "type": "string",
                "description": "Network address of NTP peer."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "consul_kv": {
            "type": "object",
            "description": "Allows the addition, modification and deletion of key/value entries in a consul cluster via the agent. The entire contents of the record, including the indices, flags and session are returned as 'value'.\nIf the key represents a prefix then Note that when a value is removed, the existing value if any is returned as part of the results.\nSee http://www.consul.io/docs/agent/http.html#kv for more details.",
            "properties": {
              "cas": {
                "type": "string",
                "description": "Default: None\n\nused when acquiring a lock with a session. If the cas is 0, then Consul will only put the key if it does not already exist. If the cas value is non-zero, then the key is only set if the index matches the ModifyIndex of that key."
              },
              "recurse": {
                "type": "string",
                "description": "if the key represents a prefix, each entry with the prefix can be retrieved by setting this to true."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nthe action to take with the supplied key and value. If the state is 'present', the key contents will be set to the value supplied, 'changed' will be set to true only if the value was different to the current contents. The state 'absent' will remove the key/value pair, again 'changed' will be set to true only if the key actually existed prior to the removal. An attempt can be made to obtain or free the lock associated with a key/value pair with the states 'acquire' or 'release' respectively. a valid session must be supplied to make the attempt changed will be true if the attempt is successful, false otherwise."
              },
              "value": {
                "type": "string",
                "description": "the value should be associated with the given key, required if state is present"
              },
              "token": {
                "type": "string",
                "description": "Default: None\n\nthe token key indentifying an ACL rule set that controls access to the key value pair"
              },
              "session": {
                "type": "string",
                "description": "Default: None\n\nthe session that should be used to acquire or release a lock associated with a key/value pair"
              },
              "flags": {
                "type": "string",
                "description": "Default: None\n\nopaque integer value that can be passed when setting a value."
              },
              "key": {
                "type": "string",
                "description": "the key at which the value should be stored."
              },
              "host": {
                "type": "string",
                "description": "Default: localhost\n\nhost of the consul agent defaults to localhost"
              },
              "scheme": {
                "type": "string",
                "description": "Default: http\n\nthe protocol scheme on which the consul agent is running"
              },
              "validate_certs": {
                "type": "string",
                "description": "Default: True\n\nwhether to verify the tls certificate of the consul agent"
              },
              "port": {
                "type": "string",
                "description": "Default: 8500\n\nthe port on which the consul agent is running"
              }
            }
          },
          "win_psexec": {
            "type": "object",
            "description": "Run commands (remotely) through the PsExec service\nRun commands as another (domain) user (with elevated privileges)",
            "properties": {
              "username": {
                "type": "string",
                "description": "The (remote) user to run the command as.\nIf not provided, the current user is used."
              },
              "limited": {
                "type": "string",
                "description": "Run the command as limited user (strips the Administrators group and allows only privileges assigned to the Users group)."
              },
              "executable": {
                "type": "string",
                "description": "Default: psexec.exe\n\nThe location of the PsExec utility (in case it is not located in your PATH)."
              },
              "chdir": {
                "type": "string",
                "description": "Run the command from this (remote) directory."
              },
              "noprofile": {
                "type": "string",
                "description": "Run the command without loading the account's profile."
              },
              "system": {
                "type": "string",
                "description": "Run the remote command in the System account."
              },
              "elevated": {
                "type": "string",
                "description": "Run the command with elevated privileges."
              },
              "priority": {
                "type": "string",
                "description": "Used to run the command at a different priority."
              },
              "hostnames": {
                "type": "string",
                "description": "The hostnames to run the command.\nIf not provided, the command is run locally."
              },
              "command": {
                "type": "string",
                "description": "The command line to run through PsExec (limited to 260 characters)."
              },
              "timeout": {
                "type": "string",
                "description": "The connection timeout in seconds"
              },
              "wait": {
                "type": "string",
                "description": "Default: True\n\nWait for the application to terminate.\nOnly use for non-interactive applications."
              },
              "password": {
                "type": "string",
                "description": "The password for the (remote) user to run the command as.\nThis is mandatory in order authenticate yourself."
              },
              "interactive": {
                "type": "string",
                "description": "Run the program so that it interacts with the desktop on the remote system."
              }
            }
          },
          "ejabberd_user": {
            "type": "object",
            "description": "This module provides user management for ejabberd servers",
            "properties": {
              "username": {
                "type": "string",
                "description": "the name of the user to manage"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\ndescribe the desired state of the user to be managed"
              },
              "password": {
                "type": "string",
                "description": "the password to assign to the username"
              },
              "logging": {
                "description": "enables or disables the local syslog facility for this module",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": "the ejabberd host associated with this username"
              }
            }
          },
          "vmware_guest_snapshot": {
            "required": [
              "datacenter",
              "name"
            ],
            "type": "object",
            "description": "Create virtual machines snapshots",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "datacenter": {
                "type": "string",
                "description": "Destination datacenter for the deploy operation"
              },
              "description": {
                "type": "string",
                "description": "Define an arbitrary description to attach to snapshot."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the VM to work with"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "revert",
                  "remove_all"
                ],
                "type": "string",
                "description": "Manage snapshots attached to a specific virtual machine."
              },
              "snapshot_name": {
                "type": "string",
                "description": "Sets the snapshot name to manage.\nThis param is required only if state is not C(remove_all)"
              },
              "name_match": {
                "type": "string",
                "description": "Default: first\n\nIf multiple VMs matching the name, use the first or last found"
              },
              "folder": {
                "type": "string",
                "description": "Define instance folder location."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "uuid": {
                "type": "string",
                "description": "UUID of the instance to manage if known, this is VMware's unique identifier.\nThis is required if name is not supplied."
              }
            }
          },
          "ecs_service_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Lists or describes services in ecs.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "service": {
                "type": "string",
                "description": "The service to get details for (required if details is true)"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "cluster": {
                "type": "string",
                "description": "Default: default\n\nThe cluster ARNS in which to list the services."
              },
              "details": {
                "description": "Default: false\n\nSet this to true if you want detailed information about the services.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "hpilo_boot": {
            "required": [
              "host"
            ],
            "type": "object",
            "description": "This module boots a system through its HP iLO interface. The boot media can be one of: cdrom, floppy, hdd, network or usb.\nThis module requires the hpilo python module.",
            "properties": {
              "force": {
                "description": "Whether to force a reboot (even when the system is already booted).\nAs a safeguard, without force, hpilo_boot will refuse to reboot a server that is already running.",
                "$ref": "#/definitions/ansible_truth"
              },
              "media": {
                "enum": [
                  "cdrom",
                  "floppy",
                  "rbsu",
                  "hdd",
                  "network",
                  "normal",
                  "usb"
                ],
                "type": "string",
                "description": "Default: network\n\nThe boot media to boot the system from"
              },
              "image": {
                "type": "string",
                "description": "The URL of a cdrom, floppy or usb boot media image. protocol://username:password@hostname:port/filename\nprotocol is either 'http' or 'https'\nusername:password is optional\nport is optional"
              },
              "state": {
                "enum": [
                  "boot_always",
                  "boot_once",
                  "connect",
                  "disconnect",
                  "no_boot",
                  "poweroff"
                ],
                "type": "string",
                "description": "Default: boot_once\n\nThe state of the boot media.\nno_boot: Do not boot from the device\nboot_once: Boot from the device once and then notthereafter\nboot_always: Boot from the device each time the serveris rebooted\nconnect: Connect the virtual media device and set to boot_always\ndisconnect: Disconnects the virtual media device and set to no_boot\npoweroff: Power off the server"
              },
              "host": {
                "type": "string",
                "description": "The HP iLO hostname/address that is linked to the physical system."
              },
              "login": {
                "type": "string",
                "description": "Default: Administrator\n\nThe login name to authenticate to the HP iLO interface."
              },
              "password": {
                "type": "string",
                "description": "Default: admin\n\nThe password to authenticate to the HP iLO interface."
              }
            }
          },
          "webfaction_mailbox": {
            "required": [
              "mailbox_password",
              "login_name",
              "mailbox_name",
              "login_password"
            ],
            "type": "object",
            "description": "Add or remove mailboxes on a Webfaction account. Further documentation at http://github.com/quentinsf/ansible-webfaction.",
            "properties": {
              "mailbox_password": {
                "type": "string",
                "description": "The password for the mailbox"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the mailbox should exist"
              },
              "login_name": {
                "type": "string",
                "description": "The webfaction account to use"
              },
              "mailbox_name": {
                "type": "string",
                "description": "The name of the mailbox"
              },
              "login_password": {
                "type": "string",
                "description": "The webfaction password to use"
              }
            }
          },
          "nxos_install_os": {
            "required": [
              "system_image_file"
            ],
            "type": "object",
            "description": "Install an operating system by setting the boot options like boot image and kickstart image.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "system_image_file": {
                "type": "string",
                "description": "Name of the system (or combined) image file on flash."
              },
              "kickstart_image_file": {
                "type": "string",
                "description": "Name of the kickstart image file on flash."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "sf_account_manager": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, destroy, or update accounts on SolidFire",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "status": {
                "type": "string",
                "description": "Status of the account."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "account_id": {
                "description": "Default: None\n\nThe ID of the account to manage or update.",
                "$ref": "#/definitions/ansible_number"
              },
              "new_name": {
                "type": "string",
                "description": "Default: None\n\nNew name for the user account."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "initiator_secret": {
                "type": "string",
                "description": "CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.\nThe CHAP initiator secrets must be unique and cannot be the same as the target CHAP secret.\nIf not specified, a random secret is created."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified account should exist or not."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "attributes": {
                "type": "object",
                "description": "List of Name/Value pairs in JSON object format."
              },
              "target_secret": {
                "type": "string",
                "description": "CHAP secret to use for the target (mutual CHAP authentication).\nShould be 12-16 characters long and impenetrable.\nThe CHAP target secrets must be unique and cannot be the same as the initiator CHAP secret.\nIf not specified, a random secret is created."
              },
              "name": {
                "type": "string",
                "description": "Unique username for this account. (May be 1 to 64 characters in length)."
              }
            }
          },
          "nxos_pim": {
            "required": [
              "ssm_range"
            ],
            "type": "object",
            "description": "Manages configuration of a Protocol Independent Multicast (PIM) instance.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "m_facts": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "ssm_range": {
                "type": "string",
                "description": "Configure group ranges for Source Specific Multicast (SSM). Valid values are multicast addresses or the keyword 'none'."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "nxos_snmp_location": {
            "required": [
              "location"
            ],
            "type": "object",
            "description": "Manages SNMP location configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "location": {
                "type": "string",
                "description": "Location information."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "sns_topic": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "The M(sns_topic) module allows you to create, delete, and manage subscriptions for AWS SNS topics.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "display_name": {
                "type": "string",
                "description": "Default: None\n\nDisplay name of the topic"
              },
              "name": {
                "type": "string",
                "description": "The name or ARN of the SNS topic to converge"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "subscriptions": {
                "description": "List of subscriptions to apply to the topic. Note that AWS requires subscriptions to be confirmed, so you will need to confirm any new subscriptions.",
                "$ref": "#/definitions/ansible_array"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to create or destroy an SNS topic"
              },
              "purge_subscriptions": {
                "description": "Default: True\n\nWhether to purge any subscriptions not listed here. NOTE: AWS does not allow you to purge any PendingConfirmation subscriptions, so if any exist and would be purged, they are silently skipped. This means that somebody could come back later and confirm the subscription. Sorry. Blame Amazon.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "policy": {
                "type": "object",
                "description": "Default: None\n\nPolicy to apply to the SNS topic"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "delivery_policy": {
                "type": "object",
                "description": "Default: None\n\nDelivery policy to apply to the SNS topic"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "bigip_gtm_datacenter": {
            "type": "object",
            "description": "Manage BIG-IP data center configuration. A data center defines the location where the physical network components reside, such as the server and link objects that share the same subnet on the network. This module is able to manipulate the data center definitions in a BIG-IP",
            "properties": {
              "description": {
                "type": "string",
                "description": "The description of the data center."
              },
              "enabled": {
                "type": "string",
                "description": "Whether the data center should be enabled. At least one of C(state) and C(enabled) are required."
              },
              "state": {
                "type": "string",
                "description": "The state of the datacenter on the BIG-IP. When C(present), guarantees that the data center exists. When C(absent) removes the data center from the BIG-IP. C(enabled) will enable the data center and C(disabled) will ensure the data center is disabled. At least one of state and enabled are required."
              },
              "contact": {
                "type": "string",
                "description": "The name of the contact for the data center."
              },
              "location": {
                "type": "string",
                "description": "The location of the data center."
              },
              "name": {
                "type": "string",
                "description": "The name of the data center."
              }
            }
          },
          "win_iis_website": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, Removes and configures a IIS Web site",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "State of the web site"
              },
              "names": {
                "type": "string",
                "description": "Names of web site"
              },
              "name": {
                "type": "string",
                "description": "Names of web site"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "win_dotnet_ngen": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "After .NET framework is installed/updated, Windows will probably want to recompile things to optimise for the host.\nThis happens via scheduled task, usually at some inopportune time.\nThis module allows you to run this task on your own schedule, so you incur the CPU hit at some more convenient and controlled time.\nhttp://blogs.msdn.com/b/dotnet/archive/2013/08/06/wondering-why-mscorsvw-exe-has-high-cpu-usage-you-can-speed-it-up.aspx",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": ""
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cloudformation": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Launches or updates an AWS CloudFormation stack and waits for it complete.",
            "properties": {
              "template_format": {
                "enum": [
                  "json",
                  "yaml"
                ],
                "type": "string",
                "description": "Default: json\n\n(deprecated) For local templates, allows specification of json or yaml format. Templates are now passed raw to CloudFormation regardless of format. This parameter is ignored since Ansible 2.3."
              },
              "stack_name": {
                "type": "string",
                "description": "name of the cloudformation stack"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "role_arn": {
                "type": "string",
                "description": "The role that AWS CloudFormation assumes to create the stack. See the AWS CloudFormation Service Role docs U(http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-servicerole.html)"
              },
              "stack_policy": {
                "type": "string",
                "description": "the path of the cloudformation stack policy. A policy cannot be removed once placed, but it can be modified. (for instance, [allow all updates](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html#d0e9051)"
              },
              "template_parameters": {
                "type": "object",
                "description": "a list of hashes of all the template variables for the stack"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "If state is \"present\", stack will be created.  If state is \"present\" and if stack exists and template has changed, it will be updated. If state is \"absent\", stack will be removed."
              },
              "template": {
                "type": "string",
                "description": "The local path of the cloudformation template.\nThis must be the full path to the file, relative to the working directory. If using roles this may look like \"roles/cloudformation/files/cloudformation-example.json\".\nIf 'state' is 'present' and the stack does not exist yet, either 'template' or 'template_url' must be specified (but not both). If 'state' is present, the stack does exist, and neither 'template' nor 'template_url' are specified, the previous template will be reused."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "disable_rollback": {
                "description": "Default: false\n\nIf a stacks fails to form, rollback will remove the stack",
                "$ref": "#/definitions/ansible_truth"
              },
              "notification_arns": {
                "type": "string",
                "description": "The Simple Notification Service (SNS) topic ARNs to publish stack related events."
              },
              "tags": {
                "type": "object",
                "description": "Dictionary of tags to associate with stack and its resources during stack creation. Can be updated later, updating tags removes previous entries."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "template_url": {
                "type": "string",
                "description": "Location of file containing the template body. The URL must point to a template (max size 307,200 bytes) located in an S3 bucket in the same region as the stack.\nIf 'state' is 'present' and the stack does not exist yet, either 'template' or 'template_url' must be specified (but not both). If 'state' is present, the stack does exist, and neither 'template' nor 'template_url' are specified, the previous template will be reused."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "os_user_facts": {
            "type": "object",
            "description": "Retrieve facts about a one or more OpenStack users",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Default: None\n\nName or ID of the domain containing the user if the cloud supports domains"
              },
              "name": {
                "type": "string",
                "description": "Name or ID of the user"
              },
              "filters": {
                "type": "string",
                "description": "Default: None\n\nA dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries."
              }
            }
          },
          "apk": {
            "type": "object",
            "description": "Manages I(apk) packages for Alpine Linux.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "absent",
                  "removed",
                  "latest"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicates the desired package(s) state.\nC(present) ensures the package(s) is/are present.\nC(absent) ensures the package(s) is/are absent.\nC(latest) ensures the package(s) is/are present and the latest version(s)."
              },
              "upgrade": {
                "description": "Upgrade all installed packages to their latest version.",
                "$ref": "#/definitions/ansible_truth"
              },
              "update_cache": {
                "description": "Update repository indexes. Can be run with other steps or on it's own.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "A package name, like C(foo), or mutliple packages, like C(foo, bar).",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "bigpanda": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "component",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "component"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "hosts",
                        "host"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Notify BigPanda when deployments start and end (successfully or not). Returns a deployment object containing all the parameters for future module calls.",
            "properties": {
              "description": {
                "type": "string",
                "description": "Free text description of the deployment."
              },
              "url": {
                "type": "string",
                "description": "Default: https://api.bigpanda.io\n\nBase URL of the API server."
              },
              "component": {
                "type": "string",
                "description": "The name of the component being deployed. Ex: billing"
              },
              "token": {
                "type": "string",
                "description": "API token."
              },
              "owner": {
                "type": "string",
                "description": "The person responsible for the deployment."
              },
              "source_system": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "started",
                  "finished",
                  "failed"
                ],
                "type": "string",
                "description": "State of the deployment."
              },
              "version": {
                "type": "string",
                "description": "The deployment version."
              },
              "hosts": {
                "type": "string",
                "description": "Default: machine's hostname\n\nName of affected host name. Can be a list."
              },
              "env": {
                "type": "string",
                "description": "The environment name, typically 'production', 'staging', etc."
              },
              "host": {
                "type": "string",
                "description": "Default: machine's hostname\n\nName of affected host name. Can be a list."
              },
              "message": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name of the component being deployed. Ex: billing"
              }
            }
          },
          "win_iis_webapplication": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, Removes and configures a IIS Web applications",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "State of the web application"
              },
              "names": {
                "type": "string",
                "description": "Name of the Web applicatio"
              },
              "name": {
                "type": "string",
                "description": "Name of the Web applicatio"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "composer": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "no_scripts",
                        "no-scripts"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "no_plugins",
                        "no-plugins"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "optimize_autoloader",
                        "optimize-autoloader"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "working_dir",
                        "working-dir"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "working_dir"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "working-dir"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ignore_platform_reqs",
                        "ignore-platform-reqs"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "no_dev",
                        "no-dev"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "prefer_dist",
                        "prefer-dist"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "prefer_source",
                        "prefer-source"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Composer is a tool for dependency management in PHP. It allows you to declare the dependent libraries your project needs and it will install them in your project for you",
            "properties": {
              "prefer_dist": {
                "description": "Default: no\n\nForces installation from package dist even for dev versions ( see --prefer-dist )",
                "$ref": "#/definitions/ansible_truth"
              },
              "ignore-platform-reqs": {
                "description": "Default: no\n\nIgnore php, hhvm, lib-* and ext-* requirements and force the installation even if the local machine does not fulfill these.",
                "$ref": "#/definitions/ansible_truth"
              },
              "prefer-source": {
                "description": "Default: no\n\nForces installation from package sources when possible ( see --prefer-source )",
                "$ref": "#/definitions/ansible_truth"
              },
              "no-plugins": {
                "description": "Default: no\n\nDisables all plugins ( see --no-plugins )",
                "$ref": "#/definitions/ansible_truth"
              },
              "prefer_source": {
                "description": "Default: no\n\nForces installation from package sources when possible ( see --prefer-source )",
                "$ref": "#/definitions/ansible_truth"
              },
              "no_scripts": {
                "description": "Default: no\n\nSkips the execution of all scripts defined in composer.json ( see --no-scripts )",
                "$ref": "#/definitions/ansible_truth"
              },
              "working-dir": {
                "type": "string",
                "description": "Directory of your project ( see --working-dir )"
              },
              "optimize-autoloader": {
                "description": "Default: yes\n\nOptimize autoloader during autoloader dump ( see --optimize-autoloader ). Convert PSR-0/4 autoloading to classmap to get a faster autoloader. This is recommended especially for production, but can take a bit of time to run so it is currently not done by default.",
                "$ref": "#/definitions/ansible_truth"
              },
              "working_dir": {
                "type": "string",
                "description": "Directory of your project ( see --working-dir )"
              },
              "ignore_platform_reqs": {
                "description": "Default: no\n\nIgnore php, hhvm, lib-* and ext-* requirements and force the installation even if the local machine does not fulfill these.",
                "$ref": "#/definitions/ansible_truth"
              },
              "arguments": {
                "type": "string",
                "description": "Composer arguments like required package, version and so on"
              },
              "no-dev": {
                "description": "Default: yes\n\nDisables installation of require-dev packages ( see --no-dev )",
                "$ref": "#/definitions/ansible_truth"
              },
              "prefer-dist": {
                "description": "Default: no\n\nForces installation from package dist even for dev versions ( see --prefer-dist )",
                "$ref": "#/definitions/ansible_truth"
              },
              "command": {
                "type": "string",
                "description": "Default: install\n\nComposer command like \"install\", \"update\" and so on"
              },
              "no_dev": {
                "description": "Default: yes\n\nDisables installation of require-dev packages ( see --no-dev )",
                "$ref": "#/definitions/ansible_truth"
              },
              "no-scripts": {
                "description": "Default: no\n\nSkips the execution of all scripts defined in composer.json ( see --no-scripts )",
                "$ref": "#/definitions/ansible_truth"
              },
              "no_plugins": {
                "description": "Default: no\n\nDisables all plugins ( see --no-plugins )",
                "$ref": "#/definitions/ansible_truth"
              },
              "optimize_autoloader": {
                "description": "Default: yes\n\nOptimize autoloader during autoloader dump ( see --optimize-autoloader ). Convert PSR-0/4 autoloading to classmap to get a faster autoloader. This is recommended especially for production, but can take a bit of time to run so it is currently not done by default.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "deploy_helper": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "dest"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "The Deploy Helper manages some of the steps common in deploying software. It creates a folder structure, manages a symlink for the current release and cleans up old releases.\nRunning it with the C(state=query) or C(state=present) will return the C(deploy_helper) fact. C(project_path), whatever you set in the path parameter, C(current_path), the path to the symlink that points to the active release, C(releases_path), the path to the folder to keep releases in, C(shared_path), the path to the folder to keep shared resources in, C(unfinished_filename), the file to check for to recognize unfinished builds, C(previous_release), the release the 'current' symlink is pointing to, C(previous_release_path), the full path to the 'current' symlink target, C(new_release), either the 'release' parameter or a generated timestamp, C(new_release_path), the path to the new release folder (not created by the module).",
            "properties": {
              "unfinished_filename": {
                "type": "string",
                "description": "Default: DEPLOY_UNFINISHED\n\nthe name of the file that indicates a deploy has not finished. All folders in the releases_path that contain this file will be deleted on C(state=finalize) with clean=True, or C(state=clean). This file is automatically deleted from the I(new_release_path) during C(state=finalize)."
              },
              "keep_releases": {
                "description": "Default: 5\n\nthe number of old releases to keep when cleaning. Used in C(finalize) and C(clean). Any unfinished builds will be deleted first, so only correct releases will count. The current version will not count.",
                "$ref": "#/definitions/ansible_number"
              },
              "dest": {
                "type": "string",
                "description": "the root path of the project. Alias I(dest). Returned in the C(deploy_helper.project_path) fact."
              },
              "current_path": {
                "type": "string",
                "description": "Default: current\n\nthe name of the symlink that is created when the deploy is finalized. Used in C(finalize) and C(clean). Returned in the C(deploy_helper.current_path) fact."
              },
              "state": {
                "enum": [
                  "present",
                  "finalize",
                  "absent",
                  "clean",
                  "query"
                ],
                "type": "string",
                "description": "Default: present\n\nthe state of the project. C(query) will only gather facts, C(present) will create the project I(root) folder, and in it the I(releases) and I(shared) folders, C(finalize) will remove the unfinished_filename file, create a symlink to the newly deployed release and optionally clean old releases, C(clean) will remove failed & old releases, C(absent) will remove the project folder (synonymous to the M(file) module with C(state=absent))"
              },
              "shared_path": {
                "type": "string",
                "description": "Default: shared\n\nthe name of the folder that will hold the shared resources. This can be relative to C(path) or absolute. If this is set to an empty string, no shared folder will be created. Returned in the C(deploy_helper.shared_path) fact."
              },
              "releases_path": {
                "type": "string",
                "description": "Default: releases\n\nthe name of the folder that will hold the releases. This can be relative to C(path) or absolute. Returned in the C(deploy_helper.releases_path) fact."
              },
              "clean": {
                "description": "Default: True\n\nWhether to run the clean procedure in case of C(state=finalize).",
                "$ref": "#/definitions/ansible_truth"
              },
              "release": {
                "type": "string",
                "description": "Default: None\n\nthe release version that is being deployed. Defaults to a timestamp format %Y%m%d%H%M%S (i.e. '20141119223359'). This parameter is optional during C(state=present), but needs to be set explicitly for C(state=finalize). You can use the generated fact C(release={{ deploy_helper.new_release }})."
              },
              "path": {
                "type": "string",
                "description": "the root path of the project. Alias I(dest). Returned in the C(deploy_helper.project_path) fact."
              }
            }
          },
          "rpm_key": {
            "required": [
              "key"
            ],
            "type": "object",
            "description": "Adds or removes (rpm --import) a gpg key to your rpm database.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIf the key will be imported or removed from the rpm db."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no) and the C(key) is a url starting with https, SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "key": {
                "type": "string",
                "description": "Key that will be modified. Can be a url, a file, or a keyid if the key already exists in the database."
              }
            }
          },
          "avi_applicationpersistenceprofile": {
            "required": [
              "name",
              "persistence_type"
            ],
            "type": "object",
            "description": "This module is used to configure ApplicationPersistenceProfile object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "uuid": {
                "type": "string",
                "description": "Uuid of the persistence profile."
              },
              "app_cookie_persistence_profile": {
                "type": "object",
                "description": "Specifies the application cookie persistence profile parameters."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "description": {
                "type": "string",
                "description": "User defined description for the object."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "server_hm_down_recovery": {
                "type": "string",
                "description": "Specifies behavior when a persistent server has been marked down by a health monitor.\nDefault value when not specified in API or module is interpreted by Avi Controller as HM_DOWN_PICK_NEW_SERVER."
              },
              "http_cookie_persistence_profile": {
                "type": "object",
                "description": "Specifies the http cookie persistence profile parameters."
              },
              "persistence_type": {
                "type": "string",
                "description": "Method used to persist clients to the same server for a duration of time or a session.\nDefault value when not specified in API or module is interpreted by Avi Controller as PERSISTENCE_TYPE_CLIENT_IP_ADDRESS."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "ip_persistence_profile": {
                "type": "object",
                "description": "Specifies the client ip persistence profile parameters."
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "hdr_persistence_profile": {
                "type": "object",
                "description": "Specifies the custom http header persistence profile parameters."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "A user-friendly name for the persistence profile."
              }
            }
          },
          "hipchat": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "msg_from",
                        "from"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Send a message to hipchat",
            "properties": {
              "msg_from": {
                "type": "string",
                "description": "Default: Ansible\n\nName the message will appear be sent from. max 15 characters. Over 15, will be shorten."
              },
              "from": {
                "type": "string",
                "description": "Default: Ansible\n\nName the message will appear be sent from. max 15 characters. Over 15, will be shorten."
              },
              "room": {
                "type": "string",
                "description": "ID or name of the room."
              },
              "color": {
                "enum": [
                  "yellow",
                  "red",
                  "green",
                  "purple",
                  "gray",
                  "random"
                ],
                "type": "string",
                "description": "Default: yellow\n\nBackground color for the message. Default is yellow."
              },
              "msg_format": {
                "enum": [
                  "text",
                  "html"
                ],
                "type": "string",
                "description": "Default: text\n\nmessage format. html or text. Default is text."
              },
              "token": {
                "type": "string",
                "description": "API token."
              },
              "api": {
                "type": "string",
                "description": "Default: https://api.hipchat.com/v1\n\nAPI url if using a self-hosted hipchat server. For hipchat api version 2 use C(/v2) path in URI"
              },
              "notify": {
                "description": "Default: yes\n\nnotify or not (change the tab color, play a sound, etc)",
                "$ref": "#/definitions/ansible_truth"
              },
              "msg": {
                "type": "string",
                "description": "The message body."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "pubnub_blocks": {
            "required": [
              "keyset",
              "application",
              "name"
            ],
            "type": "object",
            "description": "This module allows Ansible to interface with the PubNub BLOCKS infrastructure by providing the following operations: create / remove, start / stop and rename for blocks and create / modify / remove for event handlers",
            "properties": {
              "description": {
                "type": "string",
                "description": "Default: New block\n\nShort block description which will be later visible on admin.pubnub.com. Used only if block doesn't exists and won't change description for existing block."
              },
              "application": {
                "type": "string",
                "description": "Name of target PubNub application for which blocks configuration on specific C(keyset) will be done."
              },
              "validate_certs": {
                "description": "Default: True\n\nThis key allow to try skip certificates check when performing REST API calls. Sometimes host may have issues with certificates on it and this will cause problems to call PubNub REST API.\nIf check should be ignored C(False) should be passed to this parameter.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cache": {
                "type": "object",
                "description": "In case if single play use blocks management module few times it is preferred to enabled 'caching' by making previous module to share gathered artifacts and pass them to this parameter.\n"
              },
              "keyset": {
                "type": "string",
                "description": "Name of application's keys set which is bound to managed blocks."
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: started\n\nIntended block state after event handlers creation / update process will be completed."
              },
              "password": {
                "type": "string",
                "description": "Password which match to account to which specified C(email) belong.\nNot required if C(cache) contains result of previous module call (in same play)."
              },
              "changes": {
                "type": "object",
                "description": "List of fields which should be changed by block itself (doesn't affect any event handlers).\nPossible options for change is: C(name)."
              },
              "email": {
                "type": "string",
                "description": "Email from account for which new session should be started.\nNot required if C(cache) contains result of previous module call (in same play)."
              },
              "event_handlers": {
                "description": "List of event handlers which should be updated for specified block C(name).\nEach entry for new event handler should contain: C(name), C(src), C(channels), C(event). C(name) used as event handler name which can be used later to make changes to it.\nC(src) is full path to file with event handler code.\nC(channels) is name of channel from which event handler is waiting for events.\nC(event) is type of event which is able to trigger event handler: I(js-before-publish), I(js-after-publish), I(js-after-presence).\nEach entry for existing handlers should contain C(name) (so target handler can be identified). Rest parameters (C(src), C(channels) and C(event)) can be added if changes required for them.\nIt is possible to rename event handler by adding C(changes) key to event handler payload and pass dictionary, which will contain single key C(name), where new name should be passed.\nTo remove particular event handler it is possible to set C(state) for it to C(absent) and it will be removed.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Name of managed block which will be later visible on admin.pubnub.com."
              }
            }
          },
          "win_robocopy": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Synchronizes the contents of two directories on the remote machine. Under the hood this just calls out to RoboCopy, since that should be available on most modern Windows Systems.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": ""
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "dnf": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Installs, upgrade, removes, and lists packages and groups with the I(dnf) package manager.",
            "properties": {
              "name": {
                "description": "Package name, or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file.",
                "$ref": "#/definitions/ansible_array"
              },
              "list": {
                "type": "string",
                "description": "Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. See examples."
              },
              "disable_gpg_check": {
                "description": "Default: no\n\nWhether to disable the GPG checking of signatures of packages being installed. Has an effect only if state is I(present) or I(latest).",
                "$ref": "#/definitions/ansible_truth"
              },
              "conf_file": {
                "type": "string",
                "description": "The remote dnf configuration file to use for the transaction."
              },
              "state": {
                "enum": [
                  "absent",
                  "present",
                  "installed",
                  "removed",
                  "latest"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to install (C(present), C(latest)), or remove (C(absent)) a package."
              },
              "disablerepo": {
                "description": "I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\".",
                "$ref": "#/definitions/ansible_array"
              },
              "pkg": {
                "description": "Package name, or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file.",
                "$ref": "#/definitions/ansible_array"
              },
              "enablerepo": {
                "description": "I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\".",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "win_nssm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "nssm is a service helper which doesn't suck. See https://nssm.cc/ for more information.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: started\n\nState of the service on the system\nNote that NSSM actions like \"pause\", \"continue\", \"rotate\" do not fit the declarative style of ansible, so these should be implemented via the ansible command module"
              },
              "names": {
                "type": "string",
                "description": "Name of the service to operate on"
              },
              "name": {
                "type": "string",
                "description": "Name of the service to operate on"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "bundler": {
            "type": "object",
            "description": "Manage installation and Gem version dependencies for Ruby using the Bundler gem",
            "properties": {
              "executable": {
                "type": "string",
                "description": "The path to the bundler executable"
              },
              "chdir": {
                "type": "string",
                "description": "Default: temporary working directory\n\nThe directory to execute the bundler commands from. This directoy needs to contain a valid Gemfile or .bundle/ directory"
              },
              "gemfile": {
                "type": "string",
                "description": "Default: Gemfile in current directory\n\nOnly applies if state is C(present). The path to the gemfile to use to install gems."
              },
              "clean": {
                "description": "Default: no\n\nOnly applies if state is C(present). If set removes any gems on the target host that are not in the gemfile",
                "$ref": "#/definitions/ansible_truth"
              },
              "user_install": {
                "description": "Default: yes\n\nOnly applies if state is C(present). Installs gems in the local user's cache or for all users",
                "$ref": "#/definitions/ansible_truth"
              },
              "extra_args": {
                "type": "string",
                "description": "A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information"
              },
              "state": {
                "enum": [
                  "present",
                  "latest"
                ],
                "type": "string",
                "description": "Default: present\n\nThe desired state of the Gem bundle. C(latest) updates gems to the most recent, acceptable version"
              },
              "deployment_mode": {
                "description": "Default: no\n\nOnly applies if state is C(present). If set it will only install gems that are in the default or production groups. Requires a Gemfile.lock file to have been created prior",
                "$ref": "#/definitions/ansible_truth"
              },
              "binstub_directory": {
                "type": "string",
                "description": "Only applies if state is C(present). Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If C(chdir) is set then this path is relative to C(chdir)"
              },
              "exclude_groups": {
                "description": "A list of Gemfile groups to exclude during operations. This only applies when state is C(present). Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if C(exclude_groups) is not set",
                "$ref": "#/definitions/ansible_array"
              },
              "local": {
                "description": "Default: no\n\nIf set only installs gems from the cache on the target host",
                "$ref": "#/definitions/ansible_truth"
              },
              "gem_path": {
                "type": "string",
                "description": "Default: RubyGems gem paths\n\nOnly applies if state is C(present). Specifies the directory to install the gems into. If C(chdir) is set then this path is relative to C(chdir)"
              }
            }
          },
          "os_nova_host_aggregate": {
            "type": "object",
            "description": "Create, update, or delete OpenStack host aggregates. If a aggregate with the supplied name already exists, it will be updated with the new name, new availability zone, new metadata and new list of hosts.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "availability_zone": {
                "type": "string",
                "description": "Default: None\n\nAvailability zone to create aggregate into."
              },
              "hosts": {
                "type": "string",
                "description": "Default: None\n\nList of hosts to set for an aggregate."
              },
              "name": {
                "type": "string",
                "description": "Name of the aggregate."
              },
              "metadata": {
                "type": "string",
                "description": "Default: None\n\nMetadata dict."
              }
            }
          },
          "nxos_file_copy": {
            "type": "object",
            "description": "Copy a file to the flash (or bootflash) remote network device on NXOS devices.",
            "properties": {
              "remote_file": {
                "type": "string",
                "description": "Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used."
              },
              "local_file": {
                "type": "string",
                "description": "Path to local file. Local directory must exist."
              },
              "file_system": {
                "type": "string",
                "description": "The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values."
              }
            }
          },
          "udm_group": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module allows to manage user groups on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.",
            "properties": {
              "description": {
                "type": "string",
                "description": "Group description."
              },
              "subpath": {
                "type": "string",
                "description": "Subpath inside the OU, e.g. C(cn=classes,cn=students,cn=groups)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the group is present or not."
              },
              "position": {
                "type": "string",
                "description": "define the whole ldap position of the group, e.g. C(cn=g123m-1A,cn=classes,cn=schueler,cn=groups,ou=schule,dc=example,dc=com)."
              },
              "ou": {
                "type": "string",
                "description": "LDAP OU, e.g. school for LDAP OU C(ou=school,dc=example,dc=com)."
              },
              "name": {
                "type": "string",
                "description": "Name of the posix group."
              }
            }
          },
          "nxos_vrf": {
            "required": [
              "vrf"
            ],
            "type": "object",
            "description": "Manages global VRF configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Description of the VRF."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManages desired state of the resource."
              },
              "vni": {
                "type": "string",
                "description": "Specify virtual network identifier. Valid values are Integer or keyword 'default'."
              },
              "rd": {
                "type": "string",
                "description": ""
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "admin_state": {
                "enum": [
                  "up",
                  "down"
                ],
                "type": "string",
                "description": "Default: up\n\nAdministrative state of the VRF."
              },
              "vrf": {
                "type": "string",
                "description": "Name of VRF to be managed."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "logicmonitor": {
            "required": [
              "company",
              "user",
              "password",
              "target",
              "action"
            ],
            "type": "object",
            "description": "LogicMonitor is a hosted, full-stack, infrastructure monitoring platform.\nThis module manages hosts, host groups, and collectors within your LogicMonitor account.",
            "properties": {
              "displayname": {
                "type": "string",
                "description": "Default: hostname -f\n\nThe display name of a host in your LogicMonitor account or the desired display name of a device to manage.\nOptional for managing hosts (target=host)."
              },
              "description": {
                "type": "string",
                "description": "The long text description of the object in your LogicMonitor account.\nOptional for managing hosts and host groups (target=host or target=hostgroup; action=add or action=update)."
              },
              "company": {
                "type": "string",
                "description": "The LogicMonitor account company name. If you would log in to your account at \"superheroes.logicmonitor.com\" you would use \"superheroes.\""
              },
              "hostname": {
                "type": "string",
                "description": "Default: hostname -f\n\nThe hostname of a host in your LogicMonitor account, or the desired hostname of a device to manage.\nOptional for managing hosts (target=host)."
              },
              "fullpath": {
                "type": "string",
                "description": "The fullpath of the host group object you would like to manage.\nRecommend running on a single Ansible host.\nRequired for management of LogicMonitor host groups (target=hostgroup)."
              },
              "properties": {
                "type": "object",
                "description": "A dictionary of properties to set on the LogicMonitor host or host group.\nOptional for managing hosts and host groups (target=host or target=hostgroup; action=add or action=update).\nThis parameter will add or update existing properties in your LogicMonitor account."
              },
              "action": {
                "enum": [
                  "add",
                  "remove",
                  "update",
                  "sdt"
                ],
                "type": "string",
                "description": "The action you wish to perform on target.\nAdd: Add an object to your LogicMonitor account.\nRemove: Remove an object from your LogicMonitor account.\nUpdate: Update properties, description, or groups (target=host) for an object in your LogicMonitor account.\nSDT: Schedule downtime for an object in your LogicMonitor account."
              },
              "user": {
                "type": "string",
                "description": "A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user."
              },
              "groups": {
                "description": "A list of groups that the host should be a member of.\nOptional for managing hosts (target=host; action=add or action=update).",
                "$ref": "#/definitions/ansible_array"
              },
              "duration": {
                "type": "string",
                "description": "Default: 30\n\nThe duration (minutes) of the Scheduled Down Time (SDT).\nOptional for putting an object into SDT (action=sdt)."
              },
              "alertenable": {
                "enum": [
                  0,
                  "on",
                  "f",
                  "false",
                  1,
                  "no",
                  "n",
                  "1",
                  "0",
                  "t",
                  "y",
                  "off",
                  "yes",
                  "true"
                ],
                "type": "string",
                "description": "Default: True\n\nA boolean flag to turn alerting on or off for an object.\nOptional for managing all hosts (action=add or action=update)."
              },
              "starttime": {
                "type": "string",
                "description": "Default: Now\n\nThe time that the Scheduled Down Time (SDT) should begin.\nOptional for managing SDT (action=sdt).\nY-m-d H:M"
              },
              "password": {
                "type": "string",
                "description": "The password of the specified LogicMonitor user"
              },
              "collector": {
                "type": "string",
                "description": "The fully qualified domain name of a collector in your LogicMonitor account.\nThis is required for the creation of a LogicMonitor host (target=host action=add).\nThis is required for updating, removing or scheduling downtime for hosts if 'displayname' isn't specified (target=host action=update action=remove action=sdt)."
              },
              "id": {
                "type": "string",
                "description": "ID of the datasource to target.\nRequired for management of LogicMonitor datasources (target=datasource)."
              },
              "target": {
                "enum": [
                  "collector",
                  "host",
                  "datasource",
                  "hostgroup"
                ],
                "type": "string",
                "description": "The type of LogicMonitor object you wish to manage.\nCollector: Perform actions on a LogicMonitor collector.\nNOTE You should use Ansible service modules such as M(service) or M(supervisorctl) for managing the Collector 'logicmonitor-agent' and 'logicmonitor-watchdog' services. Specifically, you'll probably want to start these services after a Collector add and stop these services before a Collector remove.\nHost: Perform actions on a host device.\nHostgroup: Perform actions on a LogicMonitor host group.\nNOTE Host and Hostgroup tasks should always be performed via local_action. There are no benefits to running these tasks on the remote host and doing so will typically cause problems."
              }
            }
          },
          "os_security_group_rule": {
            "type": "object",
            "description": "Add or Remove rule from an existing security group",
            "properties": {
              "direction": {
                "type": "string",
                "description": "Default: ingress\n\nThe direction in which the security group rule is applied. Not all providers support egress."
              },
              "protocol": {
                "type": "string",
                "description": "Default: None\n\nIP protocols TCP UDP ICMP 112 (VRRP)"
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "remote_ip_prefix": {
                "type": "string",
                "description": "Source IP address(es) in CIDR notation (exclusive with remote_group)"
              },
              "port_range_max": {
                "type": "string",
                "description": "Default: None\n\nEnding port"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "port_range_min": {
                "type": "string",
                "description": "Default: None\n\nStarting port"
              },
              "ethertype": {
                "type": "string",
                "description": "Default: IPv4\n\nMust be IPv4 or IPv6, and addresses represented in CIDR must match the ingress or egress rules. Not all providers support IPv6."
              },
              "security_group": {
                "type": "string",
                "description": "Name or ID of the security group"
              },
              "remote_group": {
                "type": "string",
                "description": "Name or ID of the Security group to link (exclusive with remote_ip_prefix)"
              }
            }
          },
          "azure_rm_storageaccount_facts": {
            "type": "object",
            "description": "Get facts for one storage account or all storage accounts within a resource group.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Only show results for a specific account."
              },
              "resource_group": {
                "type": "string",
                "description": "Limit results to a resource group. Required when filtering by name."
              },
              "tags": {
                "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
                "$ref": "#/definitions/ansible_array"
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "swupd": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "bundle"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "manifest",
                        "release",
                        "version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages updates and bundles with the swupd bundle manager, which is used by the Clear Linux Project for Intel Architecture.",
            "properties": {
              "contenturl": {
                "type": "string",
                "description": "URL pointing to the contents of available bundles. If not specified, the contents are retrieved from clearlinux.org."
              },
              "name": {
                "type": "string",
                "description": "Name of the (I)bundle to install or remove."
              },
              "format": {
                "type": "string",
                "description": "The format suffix for version file downloads. For example [1,2,3,staging,etc]. If not specified, the default format is used."
              },
              "url": {
                "type": "string",
                "description": "Overrides both I(contenturl) and I(versionurl)."
              },
              "verify": {
                "description": "Verify content for OS version.",
                "$ref": "#/definitions/ansible_truth"
              },
              "update": {
                "description": "Updates the OS to the latest version.",
                "$ref": "#/definitions/ansible_truth"
              },
              "bundle": {
                "type": "string",
                "description": "Name of the (I)bundle to install or remove."
              },
              "manifest": {
                "description": "The manifest contains information about the bundles at certaion version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicates the desired (I)bundle state. C(present) ensures the bundle is installed while C(absent) ensures the (I)bundle is not installed."
              },
              "version": {
                "description": "The manifest contains information about the bundles at certaion version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version.",
                "$ref": "#/definitions/ansible_number"
              },
              "release": {
                "description": "The manifest contains information about the bundles at certaion version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version.",
                "$ref": "#/definitions/ansible_number"
              },
              "versionurl": {
                "type": "string",
                "description": "URL for version string download."
              }
            }
          },
          "docker_login": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cacert_path",
                        "tls_ca_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "config_path",
                        "self.config_path",
                        "dockercfg_path"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "registry_url",
                        "registry",
                        "url"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "docker_host",
                        "docker_url"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "key_path",
                        "tls_client_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cert_path",
                        "tls_client_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_version",
                        "docker_api_version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "reauthorize",
                        "reauth"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Provides functionality similar to the \"docker login\" command.\nAuthenticate with a docker registry and add the credentials to your local Docker config file. Adding the credentials to the config files allows future connections to the registry using tools such as Ansible's Docker modules, the Docker CLI and docker-py without needing to provide credentials.\nRunning in check mode will perform the authentication without updating the config file.",
            "properties": {
              "docker_host": {
                "type": "string",
                "description": ""
              },
              "tls_verify": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "tls_client_key": {
                "type": "string",
                "description": ""
              },
              "filter_logger": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config_path": {
                "type": "string",
                "description": "Default: ~/.docker/config.json\n\nCustom path to the Docker CLI configuration file."
              },
              "docker_url": {
                "type": "string",
                "description": ""
              },
              "tls_ca_cert": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThis controls the current state of the user. C(present) will login in a user, C(absent) will log him out.\nTo logout you only need the registry server, which defaults to DockerHub.\nBefore 2.1 you could ONLY log in.\ndocker does not support 'logout' with a custom config file."
              },
              "tls_client_cert": {
                "type": "string",
                "description": ""
              },
              "key_path": {
                "type": "string",
                "description": ""
              },
              "self.config_path": {
                "type": "string",
                "description": "Default: ~/.docker/config.json\n\nCustom path to the Docker CLI configuration file."
              },
              "email": {
                "type": "string",
                "description": "Default: None\n\nThe email address for the registry account. NOTE: private registries may not require this, but Docker Hub requires it."
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "reauthorize": {
                "description": "Refresh exiting authentication found in the configuration file.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": "The username for the registry account"
              },
              "cacert_path": {
                "type": "string",
                "description": ""
              },
              "dockercfg_path": {
                "type": "string",
                "description": "Default: ~/.docker/config.json\n\nCustom path to the Docker CLI configuration file."
              },
              "reauth": {
                "description": "Refresh exiting authentication found in the configuration file.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tls_hostname": {
                "type": "string",
                "description": ""
              },
              "registry": {
                "type": "string",
                "description": "Default: https://index.docker.io/v1/\n\nThe registry URL."
              },
              "cert_path": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": "The plaintext password for the registry account"
              },
              "tls": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "url": {
                "type": "string",
                "description": "Default: https://index.docker.io/v1/\n\nThe registry URL."
              },
              "ssl_version": {
                "type": "string",
                "description": ""
              },
              "docker_api_version": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "registry_url": {
                "type": "string",
                "description": "Default: https://index.docker.io/v1/\n\nThe registry URL."
              }
            }
          },
          "vmware_vm_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Return basic facts pertaining to a vSphere virtual machine guest",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "gitlab_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "validate_certs",
                        "verify_ssl"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "When the user does not exists in Gitlab, it will be created.\nWhen the user does exists and state=absent, the user will be deleted.\nWhen changes are made to user, the user will be updated.",
            "properties": {
              "username": {
                "type": "string",
                "description": "The username of the user."
              },
              "verify_ssl": {
                "description": "Default: True\n\nWhen using https if SSL certificate needs to be verified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "group": {
                "type": "string",
                "description": "Add user as an member to this group."
              },
              "name": {
                "type": "string",
                "description": "Name of the user you want to create"
              },
              "sshkey_file": {
                "type": "string",
                "description": "The ssh key itself."
              },
              "sshkey_name": {
                "type": "string",
                "description": "The name of the sshkey"
              },
              "login_user": {
                "type": "string",
                "description": "Gitlab user name."
              },
              "login_token": {
                "type": "string",
                "description": "Gitlab token for logging in."
              },
              "server_url": {
                "type": "string",
                "description": "Url of Gitlab server, with protocol (http or https)."
              },
              "access_level": {
                "enum": [
                  "guest",
                  "reporter",
                  "developer",
                  "master",
                  "owner"
                ],
                "type": "string",
                "description": "The access level to the group. One of the following can be used.\nguest\nreporter\ndeveloper\nmaster\nowner"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\ncreate or delete group.\nPossible values are present and absent."
              },
              "login_password": {
                "type": "string",
                "description": "Gitlab password for login_user"
              },
              "password": {
                "type": "string",
                "description": "The password of the user."
              },
              "validate_certs": {
                "description": "Default: True\n\nWhen using https if SSL certificate needs to be verified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "email": {
                "type": "string",
                "description": "The email that belongs to the user."
              }
            }
          },
          "avi_pool": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure Pool object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "lb_algorithm": {
                "type": "string",
                "description": "The load balancing algorithm will pick a server within the pool's list of available servers.\nDefault value when not specified in API or module is interpreted by Avi Controller as LB_ALGORITHM_LEAST_CONNECTIONS."
              },
              "use_service_port": {
                "description": "Do not translate the client's destination port when sending the connection to the server.\nThe pool or servers specified service port will still be used for health monitoring.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "server_auto_scale": {
                "description": "Server autoscale.\nNot used anymore.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host_check_enabled": {
                "description": "Enable common name check for server certificate.\nIf enabled and no explicit domain name is specified, avi will use the incoming host header to do the match.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "enabled": {
                "description": "Enable or disable the pool.\nDisabling will terminate all open connections and pause health monitors.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "rewrite_host_header_to_sni": {
                "description": "If sni server name is specified, rewrite incoming host header to the sni server name.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "capacity_estimation": {
                "description": "Inline estimation of capacity of servers.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "max_conn_rate_per_server": {
                "type": "object",
                "description": "Rate limit connections to each server."
              },
              "servers": {
                "description": "The pool directs load balanced traffic to this list of destination servers.\nThe servers can be configured by ip address, name, network or via ip address group.",
                "$ref": "#/definitions/ansible_array"
              },
              "fewest_tasks_feedback_delay": {
                "description": "Periodicity of feedback for fewest tasks server selection algorithm.\nDefault value when not specified in API or module is interpreted by Avi Controller as 10.",
                "$ref": "#/definitions/ansible_number"
              },
              "rewrite_host_header_to_server_name": {
                "description": "Rewrite incoming host header to server name of the server to which the request is proxied.\nEnabling this feature rewrites host header for requests to all servers in the pool.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "created_by": {
                "type": "string",
                "description": "Creator name."
              },
              "capacity_estimation_ttfb_thresh": {
                "description": "The maximum time-to-first-byte of a server.\nDefault value when not specified in API or module is interpreted by Avi Controller as 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "ab_pool": {
                "type": "object",
                "description": "A/b pool configuration."
              },
              "fail_action": {
                "type": "object",
                "description": "Enable an action - close connection, http redirect, local http response, or backup pool - when a pool failure happens.\nBy default, a connection will be closed, in case the pool experiences a failure."
              },
              "apic_epg_name": {
                "type": "string",
                "description": "Synchronize cisco apic epg members with pool servers."
              },
              "networks": {
                "description": "(internal-use) networks designated as containing servers for this pool.\nThe servers may be further narrowed down by a filter.\nThis field is used internally by avi, not editable by the user.",
                "$ref": "#/definitions/ansible_array"
              },
              "lb_algorithm_hash": {
                "type": "string",
                "description": "Criteria used as a key for determining the hash between the client and  server.\nDefault value when not specified in API or module is interpreted by Avi Controller as LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS."
              },
              "uuid": {
                "type": "string",
                "description": "Uuid of the pool."
              },
              "server_name": {
                "type": "string",
                "description": "Fully qualified dns hostname which will be used in the tls sni extension in server connections if sni is enabled.\nIf no value is specified, avi will use the incoming host header instead."
              },
              "health_monitor_refs": {
                "description": "Verify server health by applying one or more health monitors.\nActive monitors generate synthetic traffic from each service engine and mark a server up or down based on the response.\nThe passive monitor listens only to client to server communication.\nIt raises or lowers the ratio of traffic destined to a server based on successful responses.\nIt is a reference to an object of type healthmonitor.",
                "$ref": "#/definitions/ansible_array"
              },
              "cloud_ref": {
                "type": "string",
                "description": "It is a reference to an object of type cloud."
              },
              "domain_name": {
                "description": "Comma separated list of domain names which will be used to verify the common names or subject alternative names presented by server certificates.\nIt is performed only when common name check host_check_enabled is enabled.",
                "$ref": "#/definitions/ansible_array"
              },
              "autoscale_policy_ref": {
                "type": "string",
                "description": "Reference to server autoscale policy.\nIt is a reference to an object of type serverautoscalepolicy."
              },
              "ssl_profile_ref": {
                "type": "string",
                "description": "When enabled, avi re-encrypts traffic to the backend servers.\nThe specific ssl profile defines which ciphers and ssl versions will be supported.\nIt is a reference to an object of type sslprofile."
              },
              "ipaddrgroup_ref": {
                "type": "string",
                "description": "Use list of servers from ip address group.\nIt is a reference to an object of type ipaddrgroup."
              },
              "placement_networks": {
                "description": "Manually select the networks and subnets used to provide reachability to the pool's servers.\nSpecify the subnet using the following syntax  10-1-1-0/24.\nUse static routes in vrf configuration when pool servers are not directly connected butroutable from the service engine.",
                "$ref": "#/definitions/ansible_array"
              },
              "graceful_disable_timeout": {
                "description": "Used to gracefully disable a server.\nVirtual service waits for the specified time before terminating the existing connections  to the servers that are disabled.\nDefault value when not specified in API or module is interpreted by Avi Controller as 1.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "a_pool": {
                "type": "string",
                "description": "Name of container cloud application that constitutes a pool in a a-b pool configuration, if different from vs app."
              },
              "pki_profile_ref": {
                "type": "string",
                "description": "Avi will validate the ssl certificate present by a server against the selected pki profile.\nIt is a reference to an object of type pkiprofile."
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "east_west": {
                "description": "Inherited config from virtualservice.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "application_persistence_profile_ref": {
                "type": "string",
                "description": "Persistence will ensure the same user sticks to the same server for a desired duration of time.\nIt is a reference to an object of type applicationpersistenceprofile."
              },
              "inline_health_monitor": {
                "description": "The passive monitor will monitor client to server connections and requests and adjust traffic load to servers based on successful responses.\nThis may alter the expected behavior of the lb method, such as round robin.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "default_server_port": {
                "description": "Traffic sent to servers will use this destination server port unless overridden by the server's specific port attribute.\nThe ssl checkbox enables avi to server encryption.\nDefault value when not specified in API or module is interpreted by Avi Controller as 80.",
                "$ref": "#/definitions/ansible_number"
              },
              "description": {
                "type": "string",
                "description": "A description of the pool."
              },
              "request_queue_depth": {
                "description": "Minimum number of requests to be queued when pool is full.\nDefault value when not specified in API or module is interpreted by Avi Controller as 128.",
                "$ref": "#/definitions/ansible_number"
              },
              "server_reselect": {
                "type": "object",
                "description": "Server reselect configuration for http requests."
              },
              "ab_priority": {
                "description": "Priority of this pool in a a-b pool pair.\nInternally used.",
                "$ref": "#/definitions/ansible_number"
              },
              "connection_ramp_duration": {
                "description": "Duration for which new connections will be gradually ramped up to a server recently brought online.\nUseful for lb algorithms that are least connection based.\nDefault value when not specified in API or module is interpreted by Avi Controller as 10.",
                "$ref": "#/definitions/ansible_number"
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "server_count": {
                "description": "Number of server_count.\nDefault value when not specified in API or module is interpreted by Avi Controller as 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "sni_enabled": {
                "description": "Enable tls sni for server connections.\nIf disabled, avi will not send the sni extension as part of the handshake.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "request_queue_enabled": {
                "description": "Enable request queue when pool is full.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name of the pool."
              },
              "max_concurrent_connections_per_server": {
                "description": "The maximum number of concurrent connections allowed to each server within the pool.\nDefault value when not specified in API or module is interpreted by Avi Controller as 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "autoscale_launch_config_ref": {
                "type": "string",
                "description": "Reference to the launch configuration profile.\nIt is a reference to an object of type autoscalelaunchconfig."
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "autoscale_networks": {
                "description": "Network ids for the launch configuration.",
                "$ref": "#/definitions/ansible_array"
              },
              "lb_algorithm_consistent_hash_hdr": {
                "type": "string",
                "description": "Http header name to be used for the hash key."
              },
              "ssl_key_and_certificate_ref": {
                "type": "string",
                "description": "Service engines will present a client ssl certificate to the server.\nIt is a reference to an object of type sslkeyandcertificate."
              },
              "cloud_config_cksum": {
                "type": "string",
                "description": "Checksum of cloud configuration for pool.\nInternally set by cloud connector."
              },
              "vrf_ref": {
                "type": "string",
                "description": "Virtual routing context that the pool is bound to.\nThis is used to provide the isolation of the set of networks the pool is attached to.\nThe pool inherits the virtual routing conext of the virtual service, and this field is used only internally, and is set by pb-transform.\nIt is a reference to an object of type vrfcontext."
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "prst_hdr_name": {
                "type": "string",
                "description": "Header name for custom header persistence."
              }
            }
          },
          "cs_router": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Start, restart, stop and destroy routers.\nC(state=present) is not able to create routers, use M(cs_network) instead.",
            "properties": {
              "account": {
                "type": "string",
                "description": "Account the router is related to."
              },
              "poll_async": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the router is related to."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "started",
                  "stopped",
                  "restarted"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the router."
              },
              "domain": {
                "type": "string",
                "description": "Domain the router is related to."
              },
              "service_offering": {
                "type": "string",
                "description": "Name or id of the service offering of the router."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the router."
              }
            }
          },
          "os_keystone_role": {
            "type": "object",
            "description": "Manage OpenStack Identity Roles.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "name": {
                "type": "string",
                "description": "Role Name"
              }
            }
          },
          "vmware_cluster": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create VMware vSphere Cluster",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "enable_ha": {
                "description": "If set to True will enable HA when the cluster is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "enable_vsan": {
                "description": "If set to True will enable vSAN when the cluster is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "datacenter_name": {
                "type": "string",
                "description": "The name of the datacenter the cluster will be created in."
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "cluster_name": {
                "type": "string",
                "description": "The name of the cluster that will be created"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "enable_drs": {
                "description": "If set to True will enable DRS when the cluster is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ec2_remote_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about ec2 instances in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "os_keypair": {
            "type": "object",
            "description": "Add or Remove key pair from OpenStack",
            "properties": {
              "public_key": {
                "type": "string",
                "description": "Default: None\n\nThe public key that would be uploaded to nova and injected into VMs upon creation."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "public_key_file": {
                "type": "string",
                "description": "Default: None\n\nPath to local file containing ssh public key. Mutually exclusive with public_key."
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nName that has to be given to the key pair"
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              }
            }
          },
          "quantum_subnet": {
            "required": [
              "login_password",
              "cidr",
              "network_name",
              "name"
            ],
            "type": "object",
            "description": "Add/remove subnet from a network",
            "properties": {
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nName of the region"
              },
              "enable_dhcp": {
                "description": "Default: True\n\nWhether DHCP should be enabled for this subnet.",
                "$ref": "#/definitions/ansible_truth"
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the tenant for whom the subnet should be created"
              },
              "dns_nameservers": {
                "type": "string",
                "description": "Default: None\n\nDNS nameservers for this subnet, comma-separated"
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: True\n\nThe tenant name of the login user"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "allocation_pool_start": {
                "type": "string",
                "description": "Default: None\n\nFrom the subnet pool the starting address from which the IP should be allocated"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone URL for authentication"
              },
              "login_password": {
                "type": "string",
                "description": "Default: True\n\nPassword of login user"
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "gateway_ip": {
                "type": "string",
                "description": "Default: None\n\nThe ip that would be assigned to the gateway for this subnet"
              },
              "cidr": {
                "type": "string",
                "description": "Default: None\n\nThe CIDR representation of the subnet that should be assigned to the subnet"
              },
              "network_name": {
                "type": "string",
                "description": "Default: None\n\nName of the network to which the subnet should be attached"
              },
              "ip_version": {
                "enum": [
                  "4",
                  "6"
                ],
                "type": "string",
                "description": "Default: 4\n\nThe IP version of the subnet 4 or 6"
              },
              "allocation_pool_end": {
                "type": "string",
                "description": "Default: None\n\nFrom the subnet pool the last IP that should be assigned to the virtual machines"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the subnet that should be created"
              }
            }
          },
          "ec2_vpc_route_table_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about ec2 VPC route tables in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "eos_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Arista EOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with eos configuration sections in a deterministic way.  This module works with either CLI or eAPI transports.",
            "properties": {
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "force": {
                "description": "The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.\nNote this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release.",
                "$ref": "#/definitions/ansible_truth"
              },
              "replace": {
                "enum": [
                  "line",
                  "block",
                  "config"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "eapi"
                ],
                "type": "string",
                "description": ""
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "The C(save) argument instructs the module to save the running-config to startup-config.  This operation is performed after any changes are made to the current running config.  If no changes are made, the configuration is still saved to the startup config.  This option will always cause the module to return changed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "defaults": {
                "description": "The I(defaults) argument will influence how the running-config is collected from the device.  When the value is set to true, the command used to collect the running-config is append with the all keyword.  When the value is set to false, the command is issued without the all keyword",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "eos_template": {
            "required": [
              "src"
            ],
            "type": "object",
            "description": "Manages network device configurations over SSH or eos_local.  This module allows implementers to work with the device running-config.  It provides a way to push a set of commands onto a network device by evaluating the current running-config and only pushing configuration commands that are not already configured.  The config source can be a set of commands or a template.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.",
                "$ref": "#/definitions/ansible_truth"
              },
              "backup": {
                "description": "When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "src": {
                "type": "string",
                "description": "The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will search for the source file in role or playbook root folder in templates directory."
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "replace": {
                "description": "This argument will cause the provided configuration to be replaced on the destination node.   The use of the replace argument will always cause the task to set changed to true and will implies C(force=true).  This argument is only valid with C(transport=eos_local).",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "description": "By default when the M(eos_template) connects to the remote device to retrieve the configuration it will issue the C(show running-config) command.  If this option is set to True then the issued command will be C(show running-config all).",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "eapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "tower_role": {
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower roles. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "credential": {
                "type": "string",
                "description": "Credential the role acts on."
              },
              "job_template": {
                "type": "string",
                "description": "The job_template the role acts on."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "team": {
                "type": "string",
                "description": "Team that receives the permissions specified by the role."
              },
              "project": {
                "type": "string",
                "description": "Project the role acts on."
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "role": {
                "enum": [
                  "admin",
                  "read",
                  "member",
                  "execute",
                  "adhoc",
                  "update",
                  "use",
                  "auditor"
                ],
                "type": "string",
                "description": "The role type to grant/revoke."
              },
              "inventory": {
                "type": "string",
                "description": "Inventory the role acts on."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "organization": {
                "type": "string",
                "description": "Organiation the role acts on."
              },
              "target_team": {
                "type": "string",
                "description": "Team that the role acts on."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "user": {
                "type": "string",
                "description": "User that receives the permissions specified by the role."
              }
            }
          },
          "known_hosts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "host"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "host"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "The M(known_hosts) module lets you add or remove a host keys from the C(known_hosts) file.\nStarting at Ansible 2.2, multiple entries per host are allowed, but only one for each key type supported by ssh. This is useful if you're going to want to use the M(git) module over ssh, for example.\nIf you have a very large number of host keys to manage, you will find the M(template) module more useful.",
            "properties": {
              "host": {
                "type": "string",
                "description": "The host to add or remove (must match a host specified in key)"
              },
              "path": {
                "type": "string",
                "description": "Default: (homedir)+/.ssh/known_hosts\n\nThe known_hosts file to edit"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nI(present) to add the host key, I(absent) to remove it."
              },
              "name": {
                "type": "string",
                "description": "The host to add or remove (must match a host specified in key)"
              },
              "key": {
                "type": "string",
                "description": "The SSH public host key, as a string (required if state=present, optional when state=absent, in which case all keys for the host are removed). The key must be in the right format for ssh (see sshd(1), section \"SSH_KNOWN_HOSTS FILE FORMAT\")"
              }
            }
          },
          "ec2_scaling_policy": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Can create or delete scaling policies for autoscaling groups\nReferenced autoscaling groups must already exist",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Unique name for the scaling policy"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "asg_name": {
                "type": "string",
                "description": "Name of the associated autoscaling group"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "min_adjustment_step": {
                "description": "Minimum amount of adjustment when policy is triggered",
                "$ref": "#/definitions/ansible_number"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "adjustment_type": {
                "enum": [
                  "ChangeInCapacity",
                  "ExactCapacity",
                  "PercentChangeInCapacity"
                ],
                "type": "string",
                "description": "The type of change in capacity of the autoscaling group"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "scaling_adjustment": {
                "description": "The amount by which the autoscaling group is adjusted by the policy",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "register or deregister the policy"
              },
              "cooldown": {
                "description": "The minimum period of time between which autoscaling actions can take place",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "snmp_facts": {
            "required": [
              "host",
              "version"
            ],
            "type": "object",
            "description": "Retrieve facts for a device using SNMP, the facts will be inserted to the ansible_facts key.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username for SNMPv3, required if version is v3"
              },
              "privacy": {
                "enum": [
                  "des",
                  "aes"
                ],
                "type": "string",
                "description": "Encryption algoritm, required if level is authPriv"
              },
              "level": {
                "enum": [
                  "authPriv",
                  "authNoPriv"
                ],
                "type": "string",
                "description": "Authentication level, required if version is v3"
              },
              "community": {
                "type": "string",
                "description": "The SNMP community string, required if version is v2/v2c"
              },
              "authkey": {
                "type": "string",
                "description": "Authentication key, required if version is v3"
              },
              "host": {
                "type": "string",
                "description": "Set to target snmp server (normally {{inventory_hostname}})"
              },
              "version": {
                "enum": [
                  "v2",
                  "v2c",
                  "v3"
                ],
                "type": "string",
                "description": "SNMP Version to use, v2/v2c or v3"
              },
              "integrity": {
                "enum": [
                  "md5",
                  "sha"
                ],
                "type": "string",
                "description": "Hashing algoritm, required if version is v3"
              },
              "removeplaceholder": {
                "type": "string",
                "description": ""
              },
              "privkey": {
                "type": "string",
                "description": "Encryption key, required if version is authPriv"
              }
            }
          },
          "tower_job_launch": {
            "type": "object",
            "description": "Launch an Ansible Tower jobs. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "credential": {
                "type": "string",
                "description": "Credential to use for job, only used if prompt for credential is set."
              },
              "use_job_endpoint": {
                "type": "string",
                "description": "Disable launching jobs from job template."
              },
              "job_template": {
                "type": "string",
                "description": "Name of the job_template to use."
              },
              "tags": {
                "type": "string",
                "description": "Specific tags to use for from playbook."
              },
              "extra_vars": {
                "type": "string",
                "description": "Extra_vars to use for the job_template. Use '@' for a file."
              },
              "job_explanation": {
                "type": "string",
                "description": "Job explanation field."
              },
              "job_type": {
                "type": "string",
                "description": "Job_type to use for the job, only used if prompt for job_type is set."
              },
              "limit": {
                "type": "string",
                "description": "Limit to use for the job_template."
              },
              "inventory": {
                "type": "string",
                "description": "Inventory to use for the job, only used if prompt for inventory is set."
              }
            }
          },
          "os_group": {
            "type": "object",
            "description": "Manage OpenStack Identity Groups. Groups can be created, deleted or updated. Only the I(description) value can be updated.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "name": {
                "type": "string",
                "description": "Group name"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nGroup description"
              }
            }
          },
          "cs_instance": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "networks",
                        "network"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_groups",
                        "security_group"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "affinity_groups",
                        "affinity_group"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "template_filter",
                        "iso_filter"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tags",
                        "tag"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ip_to_networks",
                        "ip_to_network"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Deploy, start, update, scale, restart, restore, stop and destroy instances.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain the instance is related to."
              },
              "force": {
                "description": "Force stop/start the instance if required to apply changes, otherwise a running instance will not be changed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "disk_offering": {
                "type": "string",
                "description": "Name of the disk offering to be used."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "cpu_speed": {
                "description": "The clock speed/shares allocated to the instance, used with custom service offerings",
                "$ref": "#/definitions/ansible_number"
              },
              "user_data": {
                "type": "string",
                "description": "Optional data (ASCII) that can be sent to the instance upon a successful deployment.\nThe data will be automatically base64 encoded.\nConsider switching to HTTP_POST by using C(CLOUDSTACK_METHOD=post) to increase the HTTP_GET size limit of 2KB to 32 KB."
              },
              "root_disk_size": {
                "description": "Root disk size in GByte required if deploying instance with KVM hypervisor and want resize the root disk size at startup (need CloudStack >= 4.4, cloud-initramfs-growroot installed and enabled in the template)",
                "$ref": "#/definitions/ansible_number"
              },
              "iso_filter": {
                "enum": [
                  "featured",
                  "self",
                  "selfexecutable",
                  "sharedexecutable",
                  "executable",
                  "community"
                ],
                "type": "string",
                "description": "Default: executable\n\nName of the filter used to search for the template or iso.\nUsed for params C(iso) or C(template) on C(state=present)."
              },
              "tag": {
                "description": "List of tags. Tags are a list of dictionaries having keys C(key) and C(value).\nIf you want to delete all tags, set a empty list e.g. C(tags: []).",
                "$ref": "#/definitions/ansible_array"
              },
              "keyboard": {
                "enum": [
                  "de",
                  "de-ch",
                  "es",
                  "fi",
                  "fr",
                  "fr-be",
                  "fr-ch",
                  "is",
                  "it",
                  "jp",
                  "nl-be",
                  "no",
                  "pt",
                  "uk",
                  "us"
                ],
                "type": "string",
                "description": "Keyboard device type for the instance."
              },
              "ip6_address": {
                "type": "string",
                "description": "IPv6 address for default instance's network."
              },
              "networks": {
                "description": "List of networks to use for the new instance.",
                "$ref": "#/definitions/ansible_array"
              },
              "security_groups": {
                "description": "List of security groups the instance to be applied to.",
                "$ref": "#/definitions/ansible_array"
              },
              "group": {
                "type": "string",
                "description": "Group in where the new instance should be in."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the instance shoud be deployed.\nIf not set, default zone is used."
              },
              "state": {
                "enum": [
                  "deployed",
                  "started",
                  "stopped",
                  "restarted",
                  "restored",
                  "destroyed",
                  "expunged",
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the instance."
              },
              "template": {
                "type": "string",
                "description": "Name or id of the template to be used for creating the new instance.\nRequired when using C(state=present).\nMutually exclusive with C(ISO) option."
              },
              "memory": {
                "description": "The memory allocated to the instance, used with custom service offerings",
                "$ref": "#/definitions/ansible_number"
              },
              "iso": {
                "type": "string",
                "description": "Name or id of the ISO to be used for creating the new instance.\nRequired when using C(state=present).\nMutually exclusive with C(template) option."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "template_filter": {
                "enum": [
                  "featured",
                  "self",
                  "selfexecutable",
                  "sharedexecutable",
                  "executable",
                  "community"
                ],
                "type": "string",
                "description": "Default: executable\n\nName of the filter used to search for the template or iso.\nUsed for params C(iso) or C(template) on C(state=present)."
              },
              "ip_to_network": {
                "description": "List of mappings in the form {'network': NetworkName, 'ip': 1.2.3.4}\nMutually exclusive with C(networks) option.",
                "$ref": "#/definitions/ansible_array"
              },
              "tags": {
                "description": "List of tags. Tags are a list of dictionaries having keys C(key) and C(value).\nIf you want to delete all tags, set a empty list e.g. C(tags: []).",
                "$ref": "#/definitions/ansible_array"
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "ssh_key": {
                "type": "string",
                "description": "Name of the SSH key to be deployed on the new instance."
              },
              "display_name": {
                "type": "string",
                "description": "Custom display name of the instances.\nDisplay name will be set to C(name) if not specified.\nEither C(name) or C(display_name) is required."
              },
              "affinity_group": {
                "description": "Affinity groups names to be applied to the new instance.",
                "$ref": "#/definitions/ansible_array"
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "service_offering": {
                "type": "string",
                "description": "Name or id of the service offering of the new instance.\nIf not set, first found service offering is used."
              },
              "ip_address": {
                "type": "string",
                "description": "IPv4 address for default instance's network during creation."
              },
              "network": {
                "description": "List of networks to use for the new instance.",
                "$ref": "#/definitions/ansible_array"
              },
              "account": {
                "type": "string",
                "description": "Account the instance is related to."
              },
              "disk_size": {
                "description": "Disk size in GByte required if deploying instance from ISO.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Host name of the instance. C(name) can only contain ASCII letters.\nName will be generated (UUID) by CloudStack if not specified and can not be changed afterwards.\nEither C(name) or C(display_name) is required."
              },
              "hypervisor": {
                "enum": [
                  "KVM",
                  "kvm",
                  "VMware",
                  "vmware",
                  "BareMetal",
                  "baremetal",
                  "XenServer",
                  "xenserver",
                  "LXC",
                  "lxc",
                  "HyperV",
                  "hyperv",
                  "UCS",
                  "ucs",
                  "OVM",
                  "ovm",
                  "Simulator",
                  "simulator"
                ],
                "type": "string",
                "description": "Name the hypervisor to be used for creating the new instance.\nRelevant when using C(state=present), but only considered if not set on ISO/template.\nIf not set or found on ISO/template, first found hypervisor will be used."
              },
              "ip_to_networks": {
                "description": "List of mappings in the form {'network': NetworkName, 'ip': 1.2.3.4}\nMutually exclusive with C(networks) option.",
                "$ref": "#/definitions/ansible_array"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the instance to be deployed in."
              },
              "affinity_groups": {
                "description": "Affinity groups names to be applied to the new instance.",
                "$ref": "#/definitions/ansible_array"
              },
              "security_group": {
                "description": "List of security groups the instance to be applied to.",
                "$ref": "#/definitions/ansible_array"
              },
              "cpu": {
                "description": "The number of CPUs to allocate to the instance, used with custom service offerings",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "win_file_version": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Get DLL or EXE file build version\nchange state alway be false",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": ""
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "eos_banner": {
            "required": [
              "banner"
            ],
            "type": "object",
            "description": "This will configure both login and motd banners on remote devices running Arista EOS.  It allows playbooks to add or remote banner text from the active running configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "text": {
                "type": "string",
                "description": "The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string. Requires I(state=present)."
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecifies whether or not the configuration is present in the current devices active running configuration."
              },
              "banner": {
                "enum": [
                  "login",
                  "motd"
                ],
                "type": "string",
                "description": "Specifies which banner that should be configured on the remote device."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "eapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "ec2_vpc_nat_gateway_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gets various details related to AWS VPC Managed Nat Gateways",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "nat_gateway_ids": {
                "description": "Default: None\n\nGet details of specific nat gateway IDs",
                "$ref": "#/definitions/ansible_array"
              },
              "filters": {
                "type": "object",
                "description": "Default: None\n\nA dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "sorcery": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update_codex"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "spell"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages \"spells\" on Source Mage GNU/Linux using I(sorcery) toolchain",
            "properties": {
              "update_codex": {
                "description": "Default: no\n\nWhether or not to update grimoire collection before casting spells",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "Name of the spell\nmultiple names can be given, separated by commas\nspecial value '*' in conjunction with states C(latest) or C(rebuild) will update or rebuild the whole system respectively",
                "$ref": "#/definitions/ansible_array"
              },
              "spell": {
                "description": "Name of the spell\nmultiple names can be given, separated by commas\nspecial value '*' in conjunction with states C(latest) or C(rebuild) will update or rebuild the whole system respectively",
                "$ref": "#/definitions/ansible_array"
              },
              "depends": {
                "type": "string",
                "description": "Comma-separated list of _optional_ dependencies to build a spell (or make sure it is built) with; use +/- in front of dependency to turn it on/off ('+' is optional though)\nthis option is ignored if C(name) parameter is equal to '*' or contains more than one spell\nproviders must be supplied in the form recognized by Sorcery, e.g. 'openssl(SSL)'"
              },
              "update": {
                "description": "Default: no\n\nWhether or not to update sorcery scripts at the very first stage",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "latest",
                  "absent",
                  "cast",
                  "dispelled",
                  "rebuild"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to cast, dispel or rebuild a package\nstate C(cast) is an equivalent of C(present), not C(latest)\nstate C(latest) always triggers C(update_cache=yes)\nstate C(rebuild) implies cast of all specified spells, not only those existed before"
              },
              "update_cache": {
                "description": "Default: no\n\nWhether or not to update grimoire collection before casting spells",
                "$ref": "#/definitions/ansible_truth"
              },
              "cache_valid_time": {
                "description": "Time in seconds to invalidate grimoire collection on update\nespecially useful for SCM and rsync grimoires\nmakes sense only in pair with C(update_cache)",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "dellos6_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends arbitrary commands to a Dell OS6 node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.\nThis module does not support running commands in configuration mode. Please use M(dellos6_config) to configure Dell OS6 devices.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.",
                "$ref": "#/definitions/ansible_number"
              },
              "commands": {
                "description": "List of commands to send to the remote dellos6 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) as expired.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "wait_for": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "all",
                  "any"
                ],
                "type": "string",
                "description": ""
              },
              "waitfor": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "get_url": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Downloads files from HTTP, HTTPS, or FTP to the remote server. The remote server I(must) have direct access to the remote resource.\nBy default, if an environment variable C(<protocol>_proxy) is set on the target host, requests will be sent through that proxy. This behaviour can be overridden by setting a variable for this task (see `setting the environment <http://docs.ansible.com/playbooks_environment.html>`_), or by using the use_proxy option.\nHTTP redirects can redirect from HTTP to HTTPS so you should be sure that your proxy environment for both protocols is correct.",
            "properties": {
              "url_password": {
                "type": "string",
                "description": "The password for use in HTTP basic authentication. If the C(url_username) parameter is not specified, the C(url_password) parameter will not be used."
              },
              "force": {
                "description": "Default: no\n\nIf C(yes) and C(dest) is not a directory, will download the file every time and replace the file if the contents change. If C(no), the file will only be downloaded if the destination does not exist. Generally should be C(yes) only for small local files. Prior to 0.6, this module behaved as if C(yes) was the default.",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_proxy": {
                "description": "Default: yes\n\nif C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "Default: no\n\nIf C(yes) and C(dest) is not a directory, will download the file every time and replace the file if the contents change. If C(no), the file will only be downloaded if the destination does not exist. Generally should be C(yes) only for small local files. Prior to 0.6, this module behaved as if C(yes) was the default.",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "url": {
                "type": "string",
                "description": "HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path"
              },
              "checksum": {
                "type": "string",
                "description": "If a checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. Format: <algorithm>:<checksum>, e.g.: checksum=\"sha256:D98291AC[...]B6DC7B97\" If you worry about portability, only the sha1 algorithm is available on all platforms and python versions.  The third party hashlib library can be installed for access to additional algorithms. Additionally, if a checksum is passed to this parameter, and the file exist under the C(dest) location, the destination_checksum would be calculated, and if checksum equals destination_checksum, the file download would be skipped (unless C(force) is true). "
              },
              "force_basic_auth": {
                "description": "Default: no\n\nhttplib2, the library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sha256sum": {
                "type": "string",
                "description": "If a SHA-256 checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. This option is deprecated. Use 'checksum'."
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "headers": {
                "type": "string",
                "description": "Add custom HTTP headers to a request in the format \"key:value,key:value\""
              },
              "timeout": {
                "description": "Default: 10\n\nTimeout in seconds for URL request",
                "$ref": "#/definitions/ansible_number"
              },
              "dest": {
                "type": "string",
                "description": "absolute path of where to download the file to.\nIf C(dest) is a directory, either the server provided filename or, if none provided, the base name of the URL on the remote server will be used. If a directory, C(force) has no effect. If C(dest) is a directory, the file will always be downloaded (regardless of the force option), but replaced only if the contents changed."
              },
              "url_username": {
                "type": "string",
                "description": "The username for use in HTTP basic authentication. This parameter can be used without C(url_password) for sites that allow empty passwords."
              },
              "backup": {
                "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "tmp_dest": {
                "type": "string",
                "description": "absolute path of where temporary file is downloaded to.\nDefaults to TMPDIR, TEMP or TMP env variables or a platform specific value\nhttps://docs.python.org/2/library/tempfile.html#tempfile.tempdir"
              },
              "client_key": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ec2_tag": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, removes and lists tags from any EC2 resource.  The resource is referenced by its resource id (e.g. an instance being i-XXXXXXX). It is designed to be used with complex args (tags), see the examples.  This module has a dependency on python-boto.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "resource": {
                "type": "string",
                "description": "The EC2 resource id."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "a hash/dictionary of tags to add to the resource; '{\"key\":\"value\"}' and '{\"key\":\"value\",\"key\":\"value\"}'"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "list"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the tags should be present or absent on the resource. Use list to interrogate the tags of an instance."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "rds_subnet_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, modifies, and deletes RDS database subnet groups. This module has a dependency on python-boto >= 2.5.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Database subnet group description. Only set when a new group is added."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "subnets": {
                "description": "List of subnet IDs that make up the database subnet group.",
                "$ref": "#/definitions/ansible_array"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Database subnet group identifier."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecifies whether the subnet should be present or absent."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "fetch": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module works like M(copy), but in reverse. It is used for fetching files from remote machines and storing them locally in a file tree, organized by hostname. Note that this module is written to transfer log files that might not be present, so a missing remote file won't be an error unless fail_on_missing is set to 'yes'.",
            "properties": {
              "name": {
                "type": "string",
                "description": ""
              },
              "value": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "read",
                  "present",
                  "all",
                  "keys",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "key": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": ""
              },
              "follow": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "pushbullet": {
            "required": [
              "title",
              "api_key"
            ],
            "type": "object",
            "description": "This module sends push notifications via Pushbullet to channels or devices.",
            "properties": {
              "body": {
                "type": "string",
                "description": "Body of the notification, e.g. Details of the fault you're alerting."
              },
              "title": {
                "type": "string",
                "description": "Title of the notification."
              },
              "url": {
                "type": "string",
                "description": ""
              },
              "push_type": {
                "enum": [
                  "note",
                  "link"
                ],
                "type": "string",
                "description": "Default: note\n\nThing you wish to push."
              },
              "device": {
                "type": "string",
                "description": "The device NAME you wish to send a push notification, as seen on the Pushbullet main page."
              },
              "api_key": {
                "type": "string",
                "description": "Push bullet API token"
              },
              "channel": {
                "type": "string",
                "description": "The channel TAG you wish to broadcast a push notification, as seen on the \"My Channels\" > \"Edit your channel\" at Pushbullet page."
              }
            }
          },
          "github_release": {
            "required": [
              "action",
              "repo",
              "token",
              "user"
            ],
            "type": "object",
            "description": "Fetch metadata about Github Releases",
            "properties": {
              "action": {
                "enum": [
                  "latest_release"
                ],
                "type": "string",
                "description": "Action to perform"
              },
              "repo": {
                "type": "string",
                "description": "Repository name"
              },
              "token": {
                "type": "string",
                "description": "Github Personal Access Token for authenticating"
              },
              "user": {
                "type": "string",
                "description": "The GitHub account that owns the repository"
              }
            }
          },
          "zpool_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pool",
                        "zpool"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts from ZFS pool properties.",
            "properties": {
              "parsable": {
                "description": "Specifies if property values should be displayed in machine friendly format.",
                "$ref": "#/definitions/ansible_truth"
              },
              "zpool": {
                "type": "string",
                "description": "ZFS pool name."
              },
              "properties": {
                "type": "string",
                "description": "Default: all\n\nSpecifies which dataset properties should be queried in comma-separated format. For more information about dataset properties, check zpool(1M) man page."
              },
              "pool": {
                "type": "string",
                "description": "ZFS pool name."
              },
              "name": {
                "type": "string",
                "description": "ZFS pool name."
              }
            }
          },
          "panos_check": {
            "required": [
              "password",
              "ip_address"
            ],
            "type": "object",
            "description": "Check if PAN-OS device is ready for being configured (no pending jobs).\nThe check could be done once or multiple times until the device is ready.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              },
              "timeout": {
                "description": "Default: 0\n\ntimeout of API calls",
                "$ref": "#/definitions/ansible_number"
              },
              "interval": {
                "description": "Default: 0\n\ntime waited between checks",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "cloudtrail": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates or deletes CloudTrail configuration. Ensures logging is also enabled.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "aws_access_key": {
                "type": "string",
                "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "name": {
                "type": "string",
                "description": "name for given CloudTrail configuration.\nThis is a primary key and is used to identify the configuration."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used."
              },
              "include_global_events": {
                "description": "record API calls from global services such as IAM and STS?",
                "$ref": "#/definitions/ansible_truth"
              },
              "aws_region": {
                "type": "string",
                "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used."
              },
              "access_key": {
                "type": "string",
                "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "s3_bucket_name": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "add or remove CloudTrail configuration."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "ec2_secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "s3_key_prefix": {
                "type": "string",
                "description": "prefix to keys in bucket. A trailing slash is not necessary and will be removed."
              },
              "ec2_region": {
                "type": "string",
                "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used."
              }
            }
          },
          "aos_blueprint_virtnet": {
            "required": [
              "blueprint",
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS Blueprint Virtual Network module let you manage your Virtual Network easily. You can create access, define and delete Virtual Network by name or by using a JSON / Yaml file. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "content": {
                "type": "string",
                "description": "Datastructure of the Virtual Network to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value)."
              },
              "blueprint": {
                "type": "string",
                "description": "Blueprint Name or Id as defined in AOS."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the Virtual Network (present or not)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "name": {
                "type": "string",
                "description": "Name of Virtual Network as part of the Blueprint."
              }
            }
          },
          "netapp_e_volume_copy": {
            "required": [
              "status",
              "api_url",
              "ssid"
            ],
            "type": "object",
            "description": "Create and delete snapshots images on volume groups for NetApp E-series storage arrays.",
            "properties": {
              "status": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "create_copy_pair_if_does_not_exist": {
                "description": "Default: True\n\nDefines if a copy pair will be created if it does not exist.\nIf set to True destination_volume_id and source_volume_id are required.",
                "$ref": "#/definitions/ansible_truth"
              },
              "search_volume_id": {
                "type": "string",
                "description": "Searches for all valid potential target and source volumes that could be used in a copy_pair\nMutually exclusive with volume_copy_pair_id, destination_volume_id and source_volume_id"
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "volume_copy_pair_id": {
                "type": "string",
                "description": "The the id of a given volume copy pair\nMutually exclusive with destination_volume_id, source_volume_id, and search_volume_id\nCan use to delete or check presence of volume pairs\nMust specify this or (destination_volume_id and source_volume_id)"
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "source_volume_id": {
                "type": "string",
                "description": "The the id of the volume copy source.\nIf used, must be paired with destination_volume_id\nMutually exclusive with volume_copy_pair_id, and search_volume_id"
              },
              "destination_volume_id": {
                "type": "string",
                "description": "The the id of the volume copy destination.\nIf used, must be paired with source_volume_id\nMutually exclusive with volume_copy_pair_id, and search_volume_id"
              },
              "copy_priority": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "onlineCopy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "start_stop_copy": {
                "enum": [
                  "start",
                  "stop"
                ],
                "type": "string",
                "description": "starts a re-copy or stops a copy in progress\nNote: If you stop the initial file copy before it it done the copy pair will be destroyed\nRequires volume_copy_pair_id"
              },
              "validate_certs": {
                "type": "string",
                "description": "Default: True\n\nShould https certificates be validated?"
              },
              "targetWriteProtected": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssid": {
                "type": "string",
                "description": ""
              }
            }
          },
          "os_ironic": {
            "type": "object",
            "description": "Create or Remove Ironic nodes from OpenStack.",
            "properties": {
              "uuid": {
                "type": "string",
                "description": "Default: None\n\nglobally unique identifier (UUID) to be given to the resource. Will be auto-generated if not specified, and name is specified.\nDefinition of a UUID will always take precedence to a name value."
              },
              "driver_info": {
                "type": "string",
                "description": "Information for this server's driver. Will vary based on which driver is in use. Any sub-field which is populated will be validated during creation."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "nics": {
                "type": "string",
                "description": "A list of network interface cards, eg, \" - mac: aa:bb:cc:aa:bb:cc\""
              },
              "driver": {
                "type": "string",
                "description": "Default: None\n\nThe name of the Ironic Driver to use with this node."
              },
              "ironic_url": {
                "type": "string",
                "description": "Default: None\n\nIf noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with \"auth\" and \"auth_type\" settings set to None."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicates desired state of the resource"
              },
              "chassis_uuid": {
                "type": "string",
                "description": "Default: None\n\nAssociate the node with a pre-defined chassis."
              },
              "skip_update_of_driver_password": {
                "type": "string",
                "description": "Allows the code that would assert changes to nodes to skip the update if the change is a single line consisting of the password field.  As of Kilo, by default, passwords are always masked to API requests, which means the logic as a result always attempts to re-assert the password field."
              },
              "properties": {
                "type": "string",
                "description": "Definition of the physical characteristics of this server, used for scheduling purposes"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nunique name identifier to be given to the resource."
              }
            }
          },
          "lineinfile": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "dest",
                        "destfile",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "destfile"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "line",
                        "value"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module will search a file for a line, and ensure that it is present or absent.\nThis is primarily useful when you want to change a single line in a file only. See the M(replace) module if you want to change multiple, similar lines or check M(blockinfile) if you want to insert/update/remove a block of lines in a file. For other cases, see the M(copy) or M(template) modules.",
            "properties": {
              "name": {
                "type": "string",
                "description": "The file to modify.\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "insertbefore": {
                "type": "string",
                "description": "Used with C(state=present). If specified, the line will be inserted before the last match of specified regular expression. A value is available; C(BOF) for inserting the line at the beginning of the file. If specified regular expression has no matches, the line will be inserted at the end of the file.  May not be used with C(backrefs)."
              },
              "dest": {
                "type": "string",
                "description": "The file to modify.\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "create": {
                "description": "Default: no\n\nUsed with C(state=present). If specified, the file will be created if it does not already exist. By default it will fail if the file is missing.",
                "$ref": "#/definitions/ansible_truth"
              },
              "destfile": {
                "type": "string",
                "description": "The file to modify.\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "backrefs": {
                "description": "Default: no\n\nUsed with C(state=present). If set, line can contain backreferences (both positional and named) that will get populated if the C(regexp) matches. This flag changes the operation of the module slightly; C(insertbefore) and C(insertafter) will be ignored, and if the C(regexp) doesn't match anywhere in the file, the file will be left unchanged. If the C(regexp) does match, the last matching line will be replaced by the expanded line parameter.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the line should be there or not."
              },
              "value": {
                "type": "string",
                "description": "Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches."
              },
              "path": {
                "type": "string",
                "description": "The file to modify.\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "insertafter": {
                "type": "string",
                "description": "Default: EOF\n\nUsed with C(state=present). If specified, the line will be inserted after the last match of specified regular expression. A special value is available; C(EOF) for inserting the line at the end of the file. If specified regular expression has no matches, EOF will be used instead. May not be used with C(backrefs)."
              },
              "regexp": {
                "type": "string",
                "description": "The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove.  Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html)."
              },
              "validate": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              },
              "line": {
                "type": "string",
                "description": "Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches."
              }
            }
          },
          "gce_net": {
            "type": "object",
            "description": "This module can create and destroy Google Compute Engine networks and firewall rules U(https://cloud.google.com/compute/docs/networking). The I(name) parameter is reserved for referencing a network while the I(fwname) parameter is used to reference firewall rules. IPv4 Address ranges must be specified using the CIDR U(http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) format. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.",
            "properties": {
              "src_tags": {
                "description": "the source instance tags for creating a firewall rule",
                "$ref": "#/definitions/ansible_array"
              },
              "subnet_region": {
                "type": "string",
                "description": "region of subnet to create"
              },
              "name": {
                "type": "string",
                "description": "name of the network"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\ndesired state of the network or firewall"
              },
              "src_range": {
                "description": "the source IPv4 address range in CIDR notation",
                "$ref": "#/definitions/ansible_array"
              },
              "credentials_file": {
                "type": "string",
                "description": "path to the JSON file associated with the service account email"
              },
              "ipv4_range": {
                "type": "string",
                "description": "the IPv4 address range in CIDR notation for the network this parameter is not mandatory when you specified existing network in name parameter, but when you create new network, this parameter is mandatory"
              },
              "fwname": {
                "type": "string",
                "description": "name of the firewall rule"
              },
              "pem_file": {
                "type": "string",
                "description": "path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'."
              },
              "target_tags": {
                "description": "the target instance tags for creating a firewall rule",
                "$ref": "#/definitions/ansible_array"
              },
              "subnet_name": {
                "type": "string",
                "description": "name of subnet to create"
              },
              "mode": {
                "enum": [
                  "legacy",
                  "auto",
                  "custom"
                ],
                "type": "string",
                "description": "Default: legacy\n\nnetwork mode for Google Cloud \"legacy\" indicates a network with an IP address range \"auto\" automatically generates subnetworks in different regions \"custom\" uses networks to group subnets of user specified IP address ranges https://cloud.google.com/compute/docs/networking#network_types"
              },
              "allowed": {
                "type": "string",
                "description": "the protocol:ports to allow ('tcp:80' or 'tcp:80,443' or 'tcp:80-800;udp:1-25') this parameter is mandatory when creating or updating a firewall rule"
              },
              "service_account_email": {
                "type": "string",
                "description": "service account email"
              },
              "project_id": {
                "type": "string",
                "description": "your GCE project ID"
              },
              "subnet_desc": {
                "type": "string",
                "description": "description of subnet to create"
              }
            }
          },
          "lxd_container": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Management of LXD containers",
            "properties": {
              "description": {
                "type": "string",
                "description": ""
              },
              "source": {
                "type": "object",
                "description": "The source for the container (e.g. { \"type\": \"image\", \"mode\": \"pull\", \"server\": \"https://images.linuxcontainers.org\", \"protocol\": \"lxd\", \"alias\": \"ubuntu/xenial/amd64\" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)"
              },
              "url": {
                "type": "string",
                "description": "Default: unix:/var/lib/lxd/unix.socket\n\nThe unix domain socket path or the https URL for the LXD server."
              },
              "config": {
                "type": "object",
                "description": "The config for the container (e.g. {\"limits.cpu\": \"2\"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)\nIf the container already exists and its \"config\" value in metadata obtained from GET /1.0/containers/<name> U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#10containersname) are different, they this module tries to apply the configurations.\nThe key starts with 'volatile.' are ignored for this comparison.\nNot all config values are supported to apply the existing container. Maybe you need to delete and recreate a container."
              },
              "cert_file": {
                "type": "string",
                "description": "Default: \"{}/.config/lxc/client.crt\" .format(os.environ[\"HOME\"])\n\nThe client certificate file path."
              },
              "ephemeral": {
                "description": "Whether or not the container is ephemeral (e.g. true or false). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)",
                "$ref": "#/definitions/ansible_truth"
              },
              "architecture": {
                "type": "string",
                "description": "The archiecture for the container (e.g. \"x86_64\" or \"i686\"). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)"
              },
              "devices": {
                "type": "object",
                "description": "The devices for the container (e.g. { \"rootfs\": { \"path\": \"/dev/kvm\", \"type\": \"unix-char\" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)"
              },
              "wait_for_ipv4_addresses": {
                "description": "If this is true, the M(lxd_container) waits until IPv4 addresses are set to the all network interfaces in the container after starting or restarting.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "restarted",
                  "absent",
                  "frozen"
                ],
                "type": "string",
                "description": "Default: started\n\nDefine the state of a container."
              },
              "profiles": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "Default: 30\n\nA timeout for changing the state of the container.\nThis is also used as a timeout for waiting until IPv4 addresses are set to the all network interfaces in the container after starting or restarting.",
                "$ref": "#/definitions/ansible_number"
              },
              "key_file": {
                "type": "string",
                "description": "Default: \"{}/.config/lxc/client.key\" .format(os.environ[\"HOME\"])\n\nThe client certificate key file path."
              },
              "trust_password": {
                "type": "string",
                "description": "The client trusted password.\nYou need to set this password on the LXD server before running this module using the following command. lxc config set core.trust_password <some random password> See U(https://www.stgraber.org/2016/04/18/lxd-api-direct-interaction/)\nIf trust_password is set, this module send a request for authentication before sending any requests."
              },
              "force_stop": {
                "description": "If this is true, the M(lxd_container) forces to stop the container when it stops or restarts the container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of a container."
              }
            }
          },
          "asa_acl": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "lines"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "commands"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module allows you to work with access-lists on a Cisco ASA device.",
            "properties": {
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.",
                "$ref": "#/definitions/ansible_truth"
              },
              "transport": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "replace": {
                "enum": [
                  "line",
                  "block"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  Finally if match is set to I(exact), command lines must be an equal match."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuruation to use as the base config for comparision."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a changed needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "apt_rpm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "package",
                        "pkg",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "package"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages packages with I(apt-rpm). Both low-level (I(rpm)) and high-level (I(apt-get)) package manager binaries required.",
            "properties": {
              "name": {
                "type": "string",
                "description": "name of package to install, upgrade or remove."
              },
              "package": {
                "type": "string",
                "description": "name of package to install, upgrade or remove."
              },
              "state": {
                "enum": [
                  "installed",
                  "removed",
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicates the desired package state"
              },
              "update_cache": {
                "description": "update the package database first C(apt-get update).",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "type": "string",
                "description": "name of package to install, upgrade or remove."
              },
              "update-cache": {
                "description": "update the package database first C(apt-get update).",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "avi_virtualservice": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure VirtualService object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "pool_ref": {
                "type": "string",
                "description": "The pool is an object that contains destination servers and related attributes such as load-balancing and persistence.\nIt is a reference to an object of type pool."
              },
              "client_auth": {
                "type": "object",
                "description": "Http authentication configuration for protected resources."
              },
              "auto_allocate_ip": {
                "description": "Auto-allocate vip from the provided subnet.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port_uuid": {
                "type": "string",
                "description": "(internal-use) network port assigned to the virtual service ip address."
              },
              "weight": {
                "description": "The quality of service weight to assign to traffic transmitted from this virtual service.\nA higher weight will prioritize traffic versus other virtual services sharing the same service engines.\nDefault value when not specified in API or module is interpreted by Avi Controller as 1.",
                "$ref": "#/definitions/ansible_number"
              },
              "availability_zone": {
                "type": "string",
                "description": "Availability-zone to place the virtual service."
              },
              "dns_info": {
                "description": "Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.\nNote that only one of fqdn and dns_info setting is allowed.",
                "$ref": "#/definitions/ansible_array"
              },
              "vs_datascripts": {
                "description": "Datascripts applied on the data traffic of the virtual service.",
                "$ref": "#/definitions/ansible_array"
              },
              "content_rewrite": {
                "type": "object",
                "description": "Profile used to match and rewrite strings in request and/or response body."
              },
              "subnet_uuid": {
                "type": "string",
                "description": "It represents subnet for the virtual service ip address allocation when auto_allocate_ip is true.it is only applicable in openstack or aws cloud.\nThis field is required if auto_allocate_ip is true."
              },
              "delay_fairness": {
                "description": "Select the algorithm for qos fairness.\nThis determines how multiple virtual services sharing the same service engines will prioritize traffic over a congested network.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "static_dns_records": {
                "description": "List of static dns records applied to this virtual service.\nThese are static entries and no health monitoring is performed against the ip addresses.",
                "$ref": "#/definitions/ansible_array"
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "discovered_network_ref": {
                "description": "(internal-use) discovered networks providing reachability for client facing virtual service ip.\nThis field is deprecated.\nIt is a reference to an object of type network.",
                "$ref": "#/definitions/ansible_array"
              },
              "enable_rhi_snat": {
                "description": "Enable route health injection for source nat'ted floating ip address using the bgp config in the vrf context.",
                "$ref": "#/definitions/ansible_truth"
              },
              "avi_allocated_vip": {
                "description": "(internal-use) vip allocated by avi in the cloud infrastructure.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vrf_context_ref": {
                "type": "string",
                "description": "Virtual routing context that the virtual service is bound to.\nThis is used to provide the isolation of the set of networks the application is attached to.\nIt is a reference to an object of type vrfcontext."
              },
              "requests_rate_limit": {
                "type": "object",
                "description": "Rate limit the incoming requests to this virtual service."
              },
              "analytics_profile_ref": {
                "type": "string",
                "description": "Specifies settings related to analytics.\nIt is a reference to an object of type analyticsprofile."
              },
              "auto_allocate_floating_ip": {
                "description": "Auto-allocate floating/elastic ip from the cloud infrastructure.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "remove_listening_port_on_vs_down": {
                "description": "Remove listening port if virtualservice is down.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cloud_type": {
                "type": "string",
                "description": "Cloud_type of virtualservice.\nDefault value when not specified in API or module is interpreted by Avi Controller as CLOUD_NONE."
              },
              "uuid": {
                "type": "string",
                "description": "Uuid of the virtualservice."
              },
              "vh_domain_name": {
                "description": "The exact name requested from the client's sni-enabled tls hello domain name field.\nIf this is a match, the parent vs will forward the connection to this child vs.",
                "$ref": "#/definitions/ansible_array"
              },
              "cloud_ref": {
                "type": "string",
                "description": "It is a reference to an object of type cloud."
              },
              "ip_address": {
                "type": "object",
                "description": "Ip address of the virtual service."
              },
              "se_group_ref": {
                "type": "string",
                "description": "The service engine group to use for this virtual service.\nMoving to a new se group is disruptive to existing connections for this vs.\nIt is a reference to an object of type serviceenginegroup."
              },
              "performance_limits": {
                "type": "object",
                "description": "Optional settings that determine performance limits like max connections or bandwdith etc."
              },
              "ssl_profile_ref": {
                "type": "string",
                "description": "Determines the set of ssl versions and ciphers to accept for ssl/tls terminated connections.\nIt is a reference to an object of type sslprofile."
              },
              "created_by": {
                "type": "string",
                "description": "Creator name."
              },
              "scaleout_ecmp": {
                "description": "Disable re-distribution of flows across service engines for a virtual service.\nEnable if the network itself performs flow hashing with ecmp in environments such as gcp.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "max_cps_per_client": {
                "description": "Maximum connections per second per client ip.\nDefault value when not specified in API or module is interpreted by Avi Controller as 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "network_profile_ref": {
                "type": "string",
                "description": "Determines network settings such as protocol, tcp or udp, and related options for the protocol.\nIt is a reference to an object of type networkprofile."
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "cloud_config_cksum": {
                "type": "string",
                "description": "Checksum of cloud configuration for vs.\nInternally set by cloud connector."
              },
              "network_ref": {
                "type": "string",
                "description": "Manually override the network on which the virtual service is placed.\nIt is a reference to an object of type network."
              },
              "microservice_ref": {
                "type": "string",
                "description": "Microservice representing the virtual service.\nIt is a reference to an object of type microservice."
              },
              "ssl_sess_cache_avg_size": {
                "description": "Expected number of ssl session cache entries (may be exceeded).\nDefault value when not specified in API or module is interpreted by Avi Controller as 1024.",
                "$ref": "#/definitions/ansible_number"
              },
              "flow_dist": {
                "type": "string",
                "description": "Criteria for flow distribution among ses.\nDefault value when not specified in API or module is interpreted by Avi Controller as LOAD_AWARE."
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "floating_ip": {
                "type": "object",
                "description": "Floating ip to associate with this virtual service."
              },
              "use_bridge_ip_as_vip": {
                "description": "Use bridge ip as vip on each host in mesos deployments.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "User defined description for the object."
              },
              "subnet": {
                "type": "object",
                "description": "Subnet providing reachability for client facing virtual service ip."
              },
              "http_policies": {
                "description": "Http policies applied on the data traffic of the virtual service.",
                "$ref": "#/definitions/ansible_array"
              },
              "application_profile_ref": {
                "type": "string",
                "description": "Enable application layer specific features for the virtual service.\nIt is a reference to an object of type applicationprofile."
              },
              "active_standby_se_tag": {
                "type": "string",
                "description": "This configuration only applies if the virtualservice is in legacy active standby ha mode and load distribution among active standby is enabled.\nThis field is used to tag the virtualservice so that virtualservices with the same tag will share the same active serviceengine.\nVirtualservices with different tags will have different active serviceengines.\nIf one of the serviceengine's in the serviceenginegroup fails, all virtualservices will end up using the same active serviceengine.\nRedistribution of the virtualservices can be either manual or automated when the failed serviceengine recovers.\nRedistribution is based on the auto redistribute property of the serviceenginegroup.\nDefault value when not specified in API or module is interpreted by Avi Controller as ACTIVE_STANDBY_SE_1."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "services": {
                "description": "List of services defined for this virtual service.",
                "$ref": "#/definitions/ansible_array"
              },
              "avi_allocated_fip": {
                "description": "(internal-use) fip allocated by avi in the cloud infrastructure.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "connections_rate_limit": {
                "type": "object",
                "description": "Rate limit the incoming connections to this virtual service."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "server_network_profile_ref": {
                "type": "string",
                "description": "Determines the network settings profile for the server side of tcp proxied connections.\nLeave blank to use the same settings as the client to vs side of the connection.\nIt is a reference to an object of type networkprofile."
              },
              "ign_pool_net_reach": {
                "description": "Ignore pool servers network reachability constraints for virtual service placement.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pool_group_ref": {
                "type": "string",
                "description": "The pool group is an object that contains pools.\nIt is a reference to an object of type poolgroup."
              },
              "east_west_placement": {
                "description": "Force placement on all se's in service group (mesos mode only).\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "floating_subnet_uuid": {
                "type": "string",
                "description": "If auto_allocate_floating_ip is true and more than one floating-ip subnets exist, then the subnet for the floating ip address allocation.\nThis field is applicable only if the virtualservice belongs to an openstack or aws cloud.\nIn openstack or aws cloud it is required when auto_allocate_floating_ip is selected."
              },
              "limit_doser": {
                "description": "Limit potential dos attackers who exceed max_cps_per_client significantly to a fraction of max_cps_per_client for a while.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name for the virtual service."
              },
              "service_pool_select": {
                "description": "Select pool based on destination port.",
                "$ref": "#/definitions/ansible_array"
              },
              "flow_label_type": {
                "type": "string",
                "description": "Criteria for flow labelling.\nDefault value when not specified in API or module is interpreted by Avi Controller as NO_LABEL."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "type": {
                "type": "string",
                "description": "Specify if this is a normal virtual service, or if it is the parent or child of an sni-enabled virtual hosted virtual service.\nDefault value when not specified in API or module is interpreted by Avi Controller as VS_TYPE_NORMAL."
              },
              "enable_autogw": {
                "description": "Response traffic to clients will be sent back to the source mac address of the connection, rather than statically sent to a default gateway.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "discovered_networks": {
                "description": "(internal-use) discovered networks providing reachability for client facing virtual service ip.\nThis field is used internally by avi, not editable by the user.",
                "$ref": "#/definitions/ansible_array"
              },
              "enabled": {
                "description": "Enable or disable the virtual service.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ipam_network_subnet": {
                "type": "object",
                "description": "Subnet and/or network for allocating virtualservice ip by ipam provider module."
              },
              "fqdn": {
                "type": "string",
                "description": "Dns resolvable, fully qualified domain name of the virtualservice.\nOnly one of 'fqdn' and 'dns_info' configuration is allowed."
              },
              "ssl_key_and_certificate_refs": {
                "description": "Select or create one or two certificates, ec and/or rsa, that will be presented to ssl/tls terminated connections.\nIt is a reference to an object of type sslkeyandcertificate.",
                "$ref": "#/definitions/ansible_array"
              },
              "snat_ip": {
                "description": "Nat'ted floating source ip address(es) for upstream connection to servers.",
                "$ref": "#/definitions/ansible_array"
              },
              "host_name_xlate": {
                "type": "string",
                "description": "Translate the host name sent to the servers to this value.\nTranslate the host name sent from servers back to the value used by the client."
              },
              "analytics_policy": {
                "type": "object",
                "description": "Determines analytics settings for the application."
              },
              "enable_rhi": {
                "description": "Enable route health injection using the bgp config in the vrf context.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vh_parent_vs_uuid": {
                "type": "string",
                "description": "Specifies the virtual service acting as virtual hosting (sni) parent."
              },
              "discovered_subnet": {
                "description": "(internal-use) discovered subnets providing reachability for client facing virtual service ip.\nThis field is deprecated.",
                "$ref": "#/definitions/ansible_array"
              },
              "network_security_policy_ref": {
                "type": "string",
                "description": "Network security policies for the virtual service.\nIt is a reference to an object of type networksecuritypolicy."
              }
            }
          },
          "os_floating_ip": {
            "type": "object",
            "description": "Add or Remove a floating IP to an instance",
            "properties": {
              "fixed_address": {
                "type": "string",
                "description": "To which fixed IP of server the floating IP address should be attached to."
              },
              "network": {
                "type": "string",
                "description": "The name or ID of a neutron external network or a nova pool name."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "wait": {
                "type": "string",
                "description": "When attaching a floating IP address, specify whether we should wait for it to appear as attached."
              },
              "nat_destination": {
                "type": "string",
                "description": "Default: None\n\nThe name or id of a neutron private network that the fixed IP to attach floating IP is on"
              },
              "purge": {
                "type": "string",
                "description": "When I(state) is absent, indicates whether or not to delete the floating IP completely, or only detach it from the server. Default is to detach only."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "floating_ip_address": {
                "type": "string",
                "description": "A floating IP address to attach or to detach. Required only if I(state) is absent. When I(state) is present can be used to specify a IP address to attach."
              },
              "timeout": {
                "type": "string",
                "description": "Default: 60\n\nTime to wait for an IP address to appear as attached. See wait."
              },
              "server": {
                "type": "string",
                "description": "The name or ID of the instance to which the IP address should be assigned."
              },
              "reuse": {
                "type": "string",
                "description": "When I(state) is present, and I(floating_ip_address) is not present, this parameter can be used to specify whether we should try to reuse a floating IP address already allocated to the project."
              }
            }
          },
          "azure_rm_publicipaddress_facts": {
            "type": "object",
            "description": "Get facts for a specific public IP or all public IPs within a resource group.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Only show results for a specific Public IP."
              },
              "resource_group": {
                "type": "string",
                "description": "Limit results by resource group. Required when using name parameter."
              },
              "tags": {
                "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
                "$ref": "#/definitions/ansible_array"
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "s3_logging": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage logging facility of an s3 bucket in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the s3 bucket."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "target_prefix": {
                "type": "string",
                "description": "The prefix that should be prepended to the generated log files written to the target_bucket."
              },
              "target_bucket": {
                "type": "string",
                "description": "The bucket to log to. Required when state=present."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nEnable or disable logging."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "digital_ocean_tag": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_token",
                        "API_TOKEN"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "resource_id",
                        "droplet_id"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create and remove tag(s) to DigitalOcean resource.",
            "properties": {
              "droplet_id": {
                "description": "The ID of the resource to operate on.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "The name of the tag. The supported characters for names include alphanumeric characters, dashes, and underscores."
              },
              "resource_id": {
                "description": "The ID of the resource to operate on.",
                "$ref": "#/definitions/ansible_number"
              },
              "api_token": {
                "type": "string",
                "description": "DigitalOcean api token."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the tag should be present or absent on the resource."
              },
              "API_TOKEN": {
                "type": "string",
                "description": "DigitalOcean api token."
              },
              "resource_type": {
                "enum": [
                  "droplet"
                ],
                "type": "string",
                "description": "Default: droplet\n\nThe type of resource to operate on. Currently only tagging of droplets is supported."
              }
            }
          },
          "os_quota": {
            "type": "object",
            "description": "Manage OpenStack Quotas. Quotas can be created, updated or deleted using this module. A quota will be updated if matches an existing project and is present.",
            "properties": {
              "snapshots_lvm": {
                "type": "string",
                "description": "Default: None\n\nNumber of LVM snapshots to allow."
              },
              "server_groups": {
                "type": "string",
                "description": "Default: None\n\nNumber of server groups to allow."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "ram": {
                "type": "string",
                "description": "Default: None\n\nMaximum amount of ram in MB to allow."
              },
              "snapshots": {
                "type": "string",
                "description": "Default: None\n\nNumber of snapshots to allow."
              },
              "instances": {
                "type": "string",
                "description": "Default: None\n\nMaximum number of instances allowed."
              },
              "backups": {
                "type": "string",
                "description": "Default: None\n\nMaximum number of backups allowed."
              },
              "fixed_ips": {
                "type": "string",
                "description": "Default: None\n\nNumber of fixed IP's to allow."
              },
              "port": {
                "type": "string",
                "description": "Default: None\n\nNumber of Network ports to allow, this needs to be greater than the instances limit."
              },
              "subnet": {
                "type": "string",
                "description": "Default: None\n\nNumber of subnets to allow."
              },
              "per_volume_gigabytes": {
                "type": "string",
                "description": "Default: None\n\nMaximum size in GB's of individual volumes."
              },
              "network": {
                "type": "string",
                "description": "Default: None\n\nNumber of networks to allow."
              },
              "floatingip": {
                "type": "string",
                "description": "Default: None\n\nNumber of floating IP's to allow in Network."
              },
              "volumes_lvm": {
                "type": "string",
                "description": "Default: None\n\nNumber of LVM volumes to allow."
              },
              "floating_ips": {
                "type": "string",
                "description": "Default: None\n\nNumber of floating IP's to allow in Compute."
              },
              "security_group_rule": {
                "type": "string",
                "description": "Default: None\n\nNumber of rules per security group to allow."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nA value of present sets the quota and a value of absent resets the quota to system defaults."
              },
              "injected_files": {
                "type": "string",
                "description": "Default: None\n\nNumber of injected files to allow."
              },
              "rbac_policy": {
                "type": "string",
                "description": "Default: None\n\nNumber of policies to allow."
              },
              "injected_path_size": {
                "type": "string",
                "description": "Default: None\n\nMaximum path size."
              },
              "gigabytes": {
                "type": "string",
                "description": "Default: None\n\nMaximum volume storage allowed for project."
              },
              "backup_gigabytes": {
                "type": "string",
                "description": "Default: None\n\nMaximum size of backups in GB's."
              },
              "subnetpool": {
                "type": "string",
                "description": "Default: None\n\nNumber of subnet pools to allow."
              },
              "key_pairs": {
                "type": "string",
                "description": "Default: None\n\nNumber of key pairs to allow."
              },
              "injected_file_size": {
                "type": "string",
                "description": "Default: None\n\nMaximum file size in bytes."
              },
              "cores": {
                "type": "string",
                "description": "Default: None\n\nMaximum number of CPU's per project."
              },
              "properties": {
                "type": "string",
                "description": "Default: None\n\nNumber of properties to allow."
              },
              "server_group_members": {
                "type": "string",
                "description": "Default: None\n\nNumber of server group members to allow."
              },
              "name": {
                "type": "string",
                "description": "Name of the OpenStack Project to manage."
              },
              "volumes": {
                "type": "string",
                "description": "Default: None\n\nNumber of volumes to allow."
              },
              "gigabytes_lvm": {
                "type": "string",
                "description": "Default: None\n\nMaximum size in GB's of individual lvm volumes."
              },
              "security_group": {
                "type": "string",
                "description": "Default: None\n\nNumber of security groups to allow."
              },
              "router": {
                "type": "string",
                "description": "Default: None\n\nNumber of routers to allow."
              }
            }
          },
          "nxos_vrrp": {
            "required": [
              "group",
              "interface"
            ],
            "type": "object",
            "description": "Manages VRRP configuration on NX-OS switches.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "group": {
                "type": "string",
                "description": "VRRP group number."
              },
              "preempt": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "vip": {
                "type": "string",
                "description": "VRRP virtual IP address."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "authentication": {
                "type": "string",
                "description": "Clear text authentication string."
              },
              "priority": {
                "type": "string",
                "description": "VRRP priority."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify desired state of the resource."
              },
              "admin_state": {
                "type": "string",
                "description": "Default: no shutdown\n\nUsed to enable or disable the VRRP process.\n\nPossible choices:\nshutdown\nno shutdown"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Full name of interface that is being managed for VRRP."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "dellos10_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends arbitrary commands to a Dell OS10 node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.\nThis module does not support running commands in configuration mode. Please use M(dellos10_config) to configure Dell OS10 devices.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.",
                "$ref": "#/definitions/ansible_number"
              },
              "commands": {
                "description": "List of commands to send to the remote dellos10 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "wait_for": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "all",
                  "any"
                ],
                "type": "string",
                "description": ""
              },
              "waitfor": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "gce": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "base_name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates or terminates Google Compute Engine (GCE) instances.  See U(https://cloud.google.com/compute) for an overview. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.",
            "properties": {
              "num_instances": {
                "description": "can be used with 'name', specifies the number of nodes to provision using 'name' as a base name",
                "$ref": "#/definitions/ansible_number"
              },
              "ip_forward": {
                "description": "Default: false\n\nset to true if the instance can forward ip packets (useful for gateways)",
                "$ref": "#/definitions/ansible_truth"
              },
              "image": {
                "type": "string",
                "description": "Default: debian-8\n\nimage string to use for the instance (default will follow latest stable debian image)"
              },
              "service_account_permissions": {
                "description": "service account permissions (see U(https://cloud.google.com/sdk/gcloud/reference/compute/instances/create), --scopes section for detailed information)",
                "$ref": "#/definitions/ansible_array"
              },
              "pem_file": {
                "type": "string",
                "description": "path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'."
              },
              "network": {
                "type": "string",
                "description": "Default: default\n\nname of the network, 'default' will be used if not specified"
              },
              "zone": {
                "type": "string",
                "description": "Default: us-central1-a\n\nthe GCE zone to use"
              },
              "service_account_email": {
                "type": "string",
                "description": "service account email"
              },
              "persistent_boot_disk": {
                "description": "Default: false\n\nif set, create the instance with a persistent boot disk",
                "$ref": "#/definitions/ansible_truth"
              },
              "disk_auto_delete": {
                "description": "Default: true\n\nif set boot disk will be removed after instance destruction",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "active",
                  "present",
                  "absent",
                  "deleted",
                  "started",
                  "stopped",
                  "terminated"
                ],
                "type": "string",
                "description": "Default: present\n\ndesired state of the resource"
              },
              "project_id": {
                "type": "string",
                "description": "your GCE project ID"
              },
              "instance_names": {
                "type": "string",
                "description": "a comma-separated list of instance names to create or destroy"
              },
              "metadata": {
                "type": "string",
                "description": "a hash/dictionary of custom data for the instance; '{\"key\":\"value\", ...}'"
              },
              "tags": {
                "description": "a comma-separated list of tags to associate with the instance",
                "$ref": "#/definitions/ansible_array"
              },
              "preemptible": {
                "description": "Default: false\n\nif set to true, instances will be preemptible and time-limited. (requires libcloud >= 0.20.0)",
                "$ref": "#/definitions/ansible_truth"
              },
              "machine_type": {
                "type": "string",
                "description": "Default: n1-standard-1\n\nmachine type to use for the instance, use 'n1-standard-1' by default"
              },
              "disk_size": {
                "description": "Default: 10\n\nThe size of the boot disk created for this instance (in GB)",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "either a name of a single instance or when used with 'num_instances', the base name of a cluster of nodes"
              },
              "base_name": {
                "type": "string",
                "description": "either a name of a single instance or when used with 'num_instances', the base name of a cluster of nodes"
              },
              "external_ip": {
                "type": "string",
                "description": "Default: ephemeral\n\ntype of external ip, ephemeral by default; alternatively, a fixed gce ip or ip name can be given. Specify 'none' if no external ip is desired."
              },
              "disks": {
                "description": "a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).",
                "$ref": "#/definitions/ansible_array"
              },
              "credentials_file": {
                "type": "string",
                "description": "path to the JSON file associated with the service account email"
              },
              "subnetwork": {
                "type": "string",
                "description": "name of the subnetwork in which the instance should be created"
              }
            }
          },
          "nxos_pim_rp_address": {
            "required": [
              "rp_address"
            ],
            "type": "object",
            "description": "Manages configuration of an Protocol Independent Multicast (PIM) static rendezvous point (RP) address instance.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "bidir": {
                "description": "Group range is treated in PIM bidirectional mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "prefix_list": {
                "type": "string",
                "description": "Prefix list policy for static RP. Valid values are prefix-list policy names."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "route_map": {
                "type": "string",
                "description": "Route map policy for static RP. Valid values are route-map policy names."
              },
              "rp_address": {
                "type": "string",
                "description": "Configures a Protocol Independent Multicast (PIM) static rendezvous point (RP) address. Valid values are unicast addresses."
              },
              "group_list": {
                "type": "string",
                "description": "Group range for static RP. Valid values are multicast addresses."
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "s3": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "expiry",
                        "expiration"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "overwrite",
                        "force"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "retries",
                        "retry"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "s3_url",
                        "S3_URL"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module allows the user to manage S3 buckets and the objects within them. Includes support for creating and deleting both objects and buckets, retrieving objects as files or strings and generating download links. This module has a dependency on python-boto.",
            "properties": {
              "force": {
                "type": "string",
                "description": "Default: always\n\nForce overwrite either locally on the filesystem or remotely with the object/key. Used with PUT and GET operations. Boolean or one of [always, never, different], true is equal to 'always' and false is equal to 'never', new in 2.0"
              },
              "prefix": {
                "type": "string",
                "description": "Limits the response to keys that begin with the specified prefix for list mode"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "marker": {
                "type": "string",
                "description": "Specifies the key to start with when using list mode. Object keys are returned in alphabetical order, starting with key after the marker in order."
              },
              "ignore_nonexistent_bucket": {
                "description": "Overrides initial bucket lookups in case bucket or iam policies are restrictive. Example: a user may have the GetObject permission but no other permissions. In this case using the option mode: get will fail without specifying ignore_nonexistent_bucket: True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "overwrite": {
                "type": "string",
                "description": "Default: always\n\nForce overwrite either locally on the filesystem or remotely with the object/key. Used with PUT and GET operations. Boolean or one of [always, never, different], true is equal to 'always' and false is equal to 'never', new in 2.0"
              },
              "aws_secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "retry": {
                "description": "On recoverable failure, how many times to retry before actually failing.",
                "$ref": "#/definitions/ansible_number"
              },
              "encrypt": {
                "description": "When set for PUT mode, asks for server-side encryption",
                "$ref": "#/definitions/ansible_truth"
              },
              "rgw": {
                "description": "Enable Ceph RGW S3 support. This option requires an explicit url via s3_url.",
                "$ref": "#/definitions/ansible_truth"
              },
              "permission": {
                "description": "Default: private\n\nThis option lets the user set the canned permissions on the object/bucket that are created. The permissions that can be set are 'private', 'public-read', 'public-read-write', 'authenticated-read'. Multiple permissions can be specified as a list.",
                "$ref": "#/definitions/ansible_array"
              },
              "max_keys": {
                "type": "string",
                "description": "Default: 1000\n\nMax number of results to return in list mode, set this if you want to retrieve fewer than the default 1000 keys."
              },
              "version": {
                "type": "string",
                "description": "Version ID of the object inside the bucket. Can be used to get a specific version of a file if versioning is enabled in the target bucket."
              },
              "s3_url": {
                "type": "string",
                "description": "S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc.  Otherwise assumes AWS"
              },
              "mode": {
                "enum": [
                  "get",
                  "put",
                  "delete",
                  "create",
                  "geturl",
                  "getstr",
                  "delobj",
                  "list"
                ],
                "type": "string",
                "description": "Switches the module behaviour between put (upload), get (download), geturl (return download url, Ansible 1.3+), getstr (download object as string (1.3+)), list (list keys, Ansible 2.0+), create (bucket), delete (bucket), and delobj (delete object, Ansible 2.0+)."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "On recoverable failure, how many times to retry before actually failing.",
                "$ref": "#/definitions/ansible_number"
              },
              "dest": {
                "type": "string",
                "description": "The destination file path when downloading an object/key with a GET operation."
              },
              "object": {
                "type": "string",
                "description": "Keyname of the object inside the bucket. Can be used to create \"virtual directories\", see examples."
              },
              "aws_region": {
                "type": "string",
                "description": "AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard.  Prior to ansible 1.8 this parameter could be specified but had no effect."
              },
              "expiry": {
                "type": "string",
                "description": "Default: 600\n\nTime limit (in seconds) for the URL generated and returned by S3/Walrus when performing a mode=put or mode=geturl operation."
              },
              "ec2_access_key": {
                "type": "string",
                "description": "AWS access key id. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "ec2_secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "S3_URL": {
                "type": "string",
                "description": "S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc.  Otherwise assumes AWS"
              },
              "ec2_region": {
                "type": "string",
                "description": "AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard.  Prior to ansible 1.8 this parameter could be specified but had no effect."
              },
              "access_key": {
                "type": "string",
                "description": "AWS access key id. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "src": {
                "type": "string",
                "description": "The source file path when performing a PUT operation."
              },
              "aws_access_key": {
                "type": "string",
                "description": "AWS access key id. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": "AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard.  Prior to ansible 1.8 this parameter could be specified but had no effect."
              },
              "bucket": {
                "type": "string",
                "description": "Bucket name."
              },
              "headers": {
                "type": "object",
                "description": "Custom headers for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'."
              },
              "expiration": {
                "type": "string",
                "description": "Default: 600\n\nTime limit (in seconds) for the URL generated and returned by S3/Walrus when performing a mode=put or mode=geturl operation."
              },
              "secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "metadata": {
                "type": "object",
                "description": "Metadata for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "portage": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "package",
                        "name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages Gentoo packages",
            "properties": {
              "nodeps": {
                "description": "Only merge packages but not their dependencies (--nodeps)",
                "$ref": "#/definitions/ansible_truth"
              },
              "getbinpkg": {
                "description": "Prefer packages specified at PORTAGE_BINHOST in make.conf",
                "$ref": "#/definitions/ansible_truth"
              },
              "onlydeps": {
                "description": "Only merge packages' dependencies but not the packages (--onlydeps)",
                "$ref": "#/definitions/ansible_truth"
              },
              "verbose": {
                "description": "Run emerge in verbose mode (--verbose)",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Package atom or set, e.g. C(sys-apps/foo) or C(>foo-2.13) or C(@world)"
              },
              "package": {
                "type": "string",
                "description": "Package atom or set, e.g. C(sys-apps/foo) or C(>foo-2.13) or C(@world)"
              },
              "oneshot": {
                "description": "Do not add the packages to the world file (--oneshot)",
                "$ref": "#/definitions/ansible_truth"
              },
              "update": {
                "description": "Update packages to the best version available (--update)",
                "$ref": "#/definitions/ansible_truth"
              },
              "deep": {
                "description": "Consider the entire dependency tree of packages (--deep)",
                "$ref": "#/definitions/ansible_truth"
              },
              "sync": {
                "enum": [
                  "yes",
                  "web",
                  "no"
                ],
                "type": "string",
                "description": "Sync package repositories first\nIf yes, perform \"emerge --sync\"\nIf web, perform \"emerge-webrsync\""
              },
              "changed_use": {
                "description": "Include installed packages where USE flags have changed, except when\nflags that the user has not enabled are added or removed\n(--changed-use)",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "emerged",
                  "absent",
                  "removed",
                  "unmerged"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the package atom"
              },
              "quiet": {
                "description": "Run emerge in quiet mode (--quiet)",
                "$ref": "#/definitions/ansible_truth"
              },
              "usepkgonly": {
                "description": "Merge only binaries (no compiling). This sets getbinpkg=yes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "depclean": {
                "description": "Remove packages not needed by explicitly merged packages (--depclean)\nIf no package is specified, clean up the world's dependencies\nOtherwise, --depclean serves as a dependency aware version of --unmerge",
                "$ref": "#/definitions/ansible_truth"
              },
              "usepkg": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "noreplace": {
                "description": "Do not re-emerge installed packages (--noreplace)",
                "$ref": "#/definitions/ansible_truth"
              },
              "newuse": {
                "description": "Include installed packages where USE flags have changed (--newuse)",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "pkgin": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "The standard package manager for SmartOS, but also usable on NetBSD or any OS that uses C(pkgsrc).  (Home: U(http://pkgin.net/))",
            "properties": {
              "upgrade": {
                "description": "Upgrade main packages to their newer versions",
                "$ref": "#/definitions/ansible_truth"
              },
              "force": {
                "description": "Force package reinstall",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "Name of package to install/remove;\nmultiple names may be given, separated by commas",
                "$ref": "#/definitions/ansible_array"
              },
              "full_upgrade": {
                "description": "Upgrade all packages to their newer versions",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIntended state of the package"
              },
              "update_cache": {
                "description": "Update repository database. Can be run with other steps or on it's own.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "Name of package to install/remove;\nmultiple names may be given, separated by commas",
                "$ref": "#/definitions/ansible_array"
              },
              "clean": {
                "description": "Clean packages cache",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ping": {
            "type": "object",
            "description": "A trivial test module, this module always returns C(pong) on successful contact. It does not make sense in playbooks, but it is useful from C(/usr/bin/ansible) to verify the ability to login and that a usable python is configured.\nThis is NOT ICMP ping, this is just a trivial test module.",
            "properties": {
              "data": {
                "type": "string",
                "description": ""
              }
            }
          },
          "nxos_vtp_password": {
            "type": "object",
            "description": "Manages VTP password configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "vtp_password": {
                "type": "string",
                "description": "VTP password"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "pn_cluster": {
            "required": [
              "pn_name",
              "state"
            ],
            "type": "object",
            "description": "Execute cluster-create or cluster-delete command.\nA cluster allows two switches to cooperate in high-availability (HA) deployments. The nodes that form the cluster must be members of the same fabric. Clusters are typically used in conjunction with a virtual link aggregation group (VLAG) that allows links physically connected to two separate switches appear as a single trunk to a third device. The third device can be a switch,server, or any Ethernet device.",
            "properties": {
              "pn_name": {
                "type": "string",
                "description": "Specify the name of the cluster."
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "pn_validate": {
                "description": "Validate the inter-switch links and state of switches in the cluster.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Specify action to perform. Use 'present' to create cluster and 'absent' to delete cluster."
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch to run the cli on."
              },
              "pn_cluster_node1": {
                "type": "string",
                "description": "Specify the name of the first switch in the cluster.\nRequired for 'cluster-create'."
              },
              "pn_cluster_node2": {
                "type": "string",
                "description": "Specify the name of the second switch in the cluster.\nRequired for 'cluster-create'."
              }
            }
          },
          "route53_zone": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates and deletes Route53 private and public zones",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "vpc_region": {
                "type": "string",
                "description": "The VPC Region the zone should be a part of (if this is going to be a private zone)"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "comment": {
                "type": "string",
                "description": "Comment associated with the zone"
              },
              "vpc_id": {
                "type": "string",
                "description": "The VPC ID the zone should be a part of (if this is going to be a private zone)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: True\n\nwhether or not the zone should exist or not"
              },
              "zone": {
                "type": "string",
                "description": "The DNS zone record (eg: foo.com.)"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "netapp_e_storagepool": {
            "required": [
              "state",
              "api_password",
              "ssid",
              "api_url",
              "name",
              "api_username"
            ],
            "type": "object",
            "description": "Create or remove disk groups and disk pools for NetApp E-series storage arrays.",
            "properties": {
              "criteria_size_unit": {
                "type": "string",
                "description": "Default: gb\n\nThe unit used to interpret size parameters"
              },
              "criteria_drive_require_fde": {
                "description": "Whether full disk encryption ability is required for drives to be added to the storage pool",
                "$ref": "#/definitions/ansible_truth"
              },
              "criteria_min_usable_capacity": {
                "description": "The minimum size of the storage pool (in size_unit). The pool will be expanded if this value exceeds itscurrent size.",
                "$ref": "#/definitions/ansible_number"
              },
              "ssid": {
                "type": "string",
                "description": "The ID of the array to manage (as configured on the web services proxy)."
              },
              "log_path": {
                "type": "string",
                "description": ""
              },
              "remove_drives": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "secure_pool": {
                "description": "Whether to convert to a secure storage pool. Will only work if all drives in the pool are security capable.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "raid_level": {
                "enum": [
                  "raidUnsupported",
                  "raidAll",
                  "raid0",
                  "raid1",
                  "raid3",
                  "raid5",
                  "raid6",
                  "raidDiskPool"
                ],
                "type": "string",
                "description": "Only required when the requested state is 'present'.  The RAID level of the storage pool to be created."
              },
              "criteria_drive_min_size": {
                "description": "The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "The name of the storage pool to manage"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified storage pool should exist or not.\nNote that removing a storage pool currently requires the removal of all defined volumes first."
              },
              "remove_volumes": {
                "description": "Prior to removing a storage pool, delete all volumes in the pool.",
                "$ref": "#/definitions/ansible_truth"
              },
              "criteria_drive_type": {
                "enum": [
                  "hdd",
                  "ssd"
                ],
                "type": "string",
                "description": "The type of disk (hdd or ssd) to use when searching for candidates to use."
              },
              "criteria_drive_count": {
                "description": "The number of disks to use for building the storage pool. The pool will be expanded if this number exceeds the number of disks already in place",
                "$ref": "#/definitions/ansible_number"
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "erase_secured_drives": {
                "description": "Whether to erase secured disks before adding to storage pool",
                "$ref": "#/definitions/ansible_truth"
              },
              "criteria_drive_interface_type": {
                "enum": [
                  "sas",
                  "sas4k",
                  "fibre",
                  "fibre520b",
                  "scsi",
                  "sata",
                  "pata"
                ],
                "type": "string",
                "description": "The interface type to use when selecting drives for the storage pool (no value means all interface types will be considered)"
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "reserve_drive_count": {
                "description": "Set the number of drives reserved by the storage pool for reconstruction operations. Only valide on raid disk pools.",
                "$ref": "#/definitions/ansible_number"
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              }
            }
          },
          "cs_securitygroup": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create and remove security groups.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain the security group is related to."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Description of the security group."
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the security group to be created in."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the security group."
              },
              "account": {
                "type": "string",
                "description": "Account the security group is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the security group."
              }
            }
          },
          "bigip_facts": {
            "type": "object",
            "description": "Collect facts from F5 BIG-IP devices via iControl SOAP API",
            "properties": {
              "filter": {
                "type": "string",
                "description": "Shell-style glob matching string used to filter fact keys. Not applicable for software, provision, and system_info fact categories."
              },
              "include": {
                "type": "string",
                "description": "Fact category or list of categories to collect"
              },
              "session": {
                "type": "string",
                "description": "Default: True\n\nBIG-IP session support; may be useful to avoid concurrency issues in certain circumstances."
              }
            }
          },
          "proxysql_query_rules": {
            "type": "object",
            "description": "The M(proxysql_query_rules) module modifies query rules using the proxysql admin interface.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Free form text field, usable for a descriptive comment of the query rule."
              },
              "flagOUT": {
                "description": "Used in combination with I(flagIN) and apply to create chains of rules. When set, I(flagOUT) signifies the I(flagIN) to be used in the next chain of rules.",
                "$ref": "#/definitions/ansible_number"
              },
              "login_user": {
                "type": "string",
                "description": "Default: None\n\nThe username used to authenticate to ProxySQL admin interface."
              },
              "login_password": {
                "type": "string",
                "description": "Default: None\n\nThe password used to authenticate to ProxySQL admin interface."
              },
              "match_pattern": {
                "type": "string",
                "description": "Regular expression that matches the query text. The dialect of regular expressions used is that of re2 - https://github.com/google/re2"
              },
              "mirror_flagOUT": {
                "description": "Enables query mirroring. If set I(mirror_flagOUT) can be used to evaluates the mirrored query against the specified chain of rules.",
                "$ref": "#/definitions/ansible_number"
              },
              "apply": {
                "description": "Used in combination with I(flagIN) and I(flagOUT) to create chains of rules. Setting apply to True signifies the last rule to be applied.",
                "$ref": "#/definitions/ansible_truth"
              },
              "schemaname": {
                "type": "string",
                "description": "Filtering criteria matching schemaname. If I(schemaname) is non-NULL, a query will match only if the connection uses schemaname as its default schema."
              },
              "replace_pattern": {
                "type": "string",
                "description": "This is the pattern with which to replace the matched pattern. Note that this is optional, and when omitted, the query processor will only cache, route, or set other parameters without rewriting."
              },
              "digest": {
                "type": "string",
                "description": "Match queries with a specific digest, as returned by stats_mysql_query_digest.digest."
              },
              "match_digest": {
                "type": "string",
                "description": "Regular expression that matches the query digest. The dialect of regular expressions used is that of re2 - https://github.com/google/re2"
              },
              "mirror_hostgroup": {
                "description": "Enables query mirroring. If set I(mirror_hostgroup) can be used to mirror queries to the same or different hostgroup.",
                "$ref": "#/definitions/ansible_number"
              },
              "log": {
                "description": "Query will be logged.",
                "$ref": "#/definitions/ansible_truth"
              },
              "delay": {
                "description": "Number of milliseconds to delay the execution of the query. This is essentially a throttling mechanism and QoS, and allows a way to give priority to queries over others. This value is added to the mysql-default_query_delay global variable that applies to all queries.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhen C(present) - adds the rule, when C(absent) - removes the rule."
              },
              "proxy_addr": {
                "type": "string",
                "description": "Match incoming traffic on a specific local IP."
              },
              "username": {
                "type": "string",
                "description": "Filtering criteria matching username.  If I(username) is non-NULL, a query will match only if the connection is made with the correct username."
              },
              "config_file": {
                "type": "string",
                "description": "Specify a config file from which login_user and login_password are to be read."
              },
              "login_port": {
                "description": "Default: 6032\n\nThe port used to connect to ProxySQL admin interface.",
                "$ref": "#/definitions/ansible_number"
              },
              "login_host": {
                "type": "string",
                "description": "Default: 127.0.0.1\n\nThe host used to connect to ProxySQL admin interface."
              },
              "destination_hostgroup": {
                "description": "Route matched queries to this hostgroup. This happens unless there is a started transaction and the logged in user has I(transaction_persistent) set to C(True) (see M(proxysql_mysql_users)).",
                "$ref": "#/definitions/ansible_number"
              },
              "proxy_port": {
                "description": "Match incoming traffic on a specific local port.",
                "$ref": "#/definitions/ansible_number"
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "load_to_runtime": {
                "description": "Default: True\n\nDynamically load mysql host config to runtime memory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "save_to_disk": {
                "description": "Default: True\n\nSave mysql host config to sqlite db on disk to persist the configuration.",
                "$ref": "#/definitions/ansible_truth"
              },
              "active": {
                "description": "A rule with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cache_ttl": {
                "description": "The number of milliseconds for which to cache the result of the query. Note in ProxySQL 1.1 I(cache_ttl) was in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "error_msg": {
                "type": "string",
                "description": "Query will be blocked, and the specified error_msg will be returned to the client."
              },
              "retries": {
                "description": "The maximum number of times a query needs to be re-executed in case of detected failure during the execution of the query. If retries is not specified, the global variable mysql-query_retries_on_failure applies.",
                "$ref": "#/definitions/ansible_number"
              },
              "negate_match_pattern": {
                "description": "If I(negate_match_pattern) is set to C(True), only queries not matching the query text will be considered as a match. This acts as a NOT operator in front of the regular expression matching against match_pattern.",
                "$ref": "#/definitions/ansible_truth"
              },
              "force_delete": {
                "description": "By default we avoid deleting more than one schedule in a single batch, however if you need this behaviour and you're not concerned about the schedules deleted, you can set I(force_delete) to C(True).",
                "$ref": "#/definitions/ansible_truth"
              },
              "client_addr": {
                "type": "string",
                "description": "Match traffic from a specific source."
              },
              "timeout": {
                "description": "The maximum timeout in milliseconds with which the matched or rewritten query should be executed. If a query run for longer than the specific threshold, the query is automatically killed. If timeout is not specified, the global variable mysql-default_query_timeout applies.",
                "$ref": "#/definitions/ansible_number"
              },
              "flagIN": {
                "description": "Used in combination with I(flagOUT) and I(apply) to create chains of rules.",
                "$ref": "#/definitions/ansible_number"
              },
              "rule_id": {
                "description": "The unique id of the rule. Rules are processed in rule_id order.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "ec2_customer_gateway": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage an AWS customer gateway",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the customer gateway."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or terminate the Customer Gateway."
              },
              "bgp_asn": {
                "description": "Border Gateway Protocol (BGP) Autonomous System Number (ASN), required when state=present.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ip_address": {
                "type": "string",
                "description": "Internet-routable IP address for customers gateway, must be a static address."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "async_status": {
            "required": [
              "jid"
            ],
            "type": "object",
            "description": "This module gets the status of an asynchronous task.",
            "properties": {
              "jid": {
                "type": "string",
                "description": "Job or task identifier"
              },
              "mode": {
                "enum": [
                  "status",
                  "cleanup"
                ],
                "type": "string",
                "description": "Default: status\n\nif C(status), obtain the status; if C(cleanup), clean up the async job cache located in C(~/.ansible_async/) for the specified job I(jid)."
              }
            }
          },
          "iam_role": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage AWS IAM roles",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the role to create."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Create or remove the IAM role"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "assume_role_policy_document": {
                "type": "string",
                "description": "The trust relationship policy document that grants an entity permission to assume the role.  This parameter is required when state: present."
              },
              "managed_policy": {
                "description": "A list of managed policy ARNs (can't use friendly names due to AWS API limitation) to attach to the role. To embed an inline policy, use M(iam_policy). To remove existing policies, use an empty list item.",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "path": {
                "type": "string",
                "description": "Default: /\n\nThe path to the role. For more information about paths, see U(http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html)."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "npm": {
            "type": "object",
            "description": "Manage node.js packages with Node Package Manager (npm)",
            "properties": {
              "executable": {
                "type": "string",
                "description": "The executable location for npm.\nThis is useful if you are using a version manager, such as nvm"
              },
              "name": {
                "type": "string",
                "description": "The name of a node.js library to install"
              },
              "global": {
                "description": "Install the node.js library globally",
                "$ref": "#/definitions/ansible_truth"
              },
              "ignore_scripts": {
                "description": "Use the --ignore-scripts flag when installing.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "latest"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state of the node.js library"
              },
              "production": {
                "description": "Install dependencies in production mode, excluding devDependencies",
                "$ref": "#/definitions/ansible_truth"
              },
              "registry": {
                "type": "string",
                "description": "The registry to install modules from."
              },
              "version": {
                "type": "string",
                "description": "The version to be installed"
              },
              "path": {
                "type": "string",
                "description": "The base path where to install the node.js libraries"
              }
            }
          },
          "a10_server_axapi3": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_ip",
                        "ip",
                        "address"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "server_ip"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "ip"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "address"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_name",
                        "server"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "server_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "server"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_status",
                        "action"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_ports",
                        "port"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage SLB (Server Load Balancer) server objects on A10 Networks devices via aXAPIv3.",
            "properties": {
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "server_ports": {
                "description": "A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:).",
                "$ref": "#/definitions/ansible_array"
              },
              "ip": {
                "type": "string",
                "description": "The SLB (Server Load Balancer) server IPv4 address."
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "operation": {
                "enum": [
                  "create",
                  "update",
                  "delete"
                ],
                "type": "string",
                "description": "Default: create\n\nCreate, Update or Remove SLB server. For create and update operation, we use the IP address and server name specified in the POST message. For delete operation, we use the server name in the request URI."
              },
              "port": {
                "description": "A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:).",
                "$ref": "#/definitions/ansible_array"
              },
              "client_key": {
                "type": "string",
                "description": ""
              },
              "use_proxy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "server_name": {
                "type": "string",
                "description": "The SLB (Server Load Balancer) server name."
              },
              "server_status": {
                "enum": [
                  "enable",
                  "disable"
                ],
                "type": "string",
                "description": "Default: enable\n\nThe SLB (Server Load Balancer) virtual server status."
              },
              "write_config": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "server_ip": {
                "type": "string",
                "description": "The SLB (Server Load Balancer) server IPv4 address."
              },
              "force_basic_auth": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "address": {
                "type": "string",
                "description": "The SLB (Server Load Balancer) server IPv4 address."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "url_password": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "server": {
                "type": "string",
                "description": "The SLB (Server Load Balancer) server name."
              },
              "url": {
                "type": "string",
                "description": ""
              },
              "url_username": {
                "type": "string",
                "description": ""
              },
              "action": {
                "enum": [
                  "enable",
                  "disable"
                ],
                "type": "string",
                "description": "Default: enable\n\nThe SLB (Server Load Balancer) virtual server status."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vyos_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "The command module allows running one or more commands on remote devices running VyOS.  This module can also be introspected to validate key parameters before returning successfully.  If the conditional statements are not met in the wait period, the task fails.\nCertain C(show) commands in VyOS produce many lines of output and use a custom pager that can cause this module to hang.  If the value of the environment variable C(ANSIBLE_VYOS_TERMINAL_LENGTH) is not set, the default number of 10000 is used.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditionals.",
                "$ref": "#/definitions/ansible_number"
              },
              "commands": {
                "description": "The ordered set of commands to execute on the remote device running VyOS.  The output from the command execution is returned to the playbook.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has been exceeded.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between I(retries) of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_for": {
                "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.  If the conditional is not true by the configured I(retries), the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "any",
                  "all"
                ],
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy. Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "waitfor": {
                "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.  If the conditional is not true by the configured I(retries), the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "set_fact": {
            "type": "object",
            "description": "This module allows setting new variables.  Variables are set on a host-by-host basis just like facts discovered by the setup module.\nThese variables will be available to subsequent plays during an ansible-playbook run, but will not be saved across executions even if you use a fact cache.\nPer the standard Ansible variable precedence rules, many other types of variables have a higher priority, so this value may be overridden. See U(http://docs.ansible.com/ansible/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable) for more information.",
            "properties": {
              "key_value": {
                "type": "string",
                "description": "The C(set_fact) module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the C(args:) statement."
              }
            }
          },
          "vmware_vmkernel_ip_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Configure the VMkernel IP Address",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "vmk_name": {
                "type": "string",
                "description": "VMkernel interface name"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "subnet_mask": {
                "type": "string",
                "description": "Subnet Mask to assign to VMkernel interface"
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "ip_address": {
                "type": "string",
                "description": "IP address to assign to VMkernel interface"
              }
            }
          },
          "newrelic_deployment": {
            "required": [
              "token"
            ],
            "type": "object",
            "description": "Notify newrelic about app deployments (see https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/deployment-notifications#api)",
            "properties": {
              "application_id": {
                "type": "string",
                "description": "(one of app_name or application_id are required) The application id, found in the URL when viewing the application in RPM"
              },
              "description": {
                "type": "string",
                "description": "Text annotation for the deployment - notes for you"
              },
              "changelog": {
                "type": "string",
                "description": "A list of changes for this deployment"
              },
              "appname": {
                "type": "string",
                "description": "Name of the application"
              },
              "environment": {
                "type": "string",
                "description": "The environment for this deployment"
              },
              "token": {
                "type": "string",
                "description": "API token, to place in the x-api-key header."
              },
              "user": {
                "type": "string",
                "description": "The name of the user/process that triggered this deployment"
              },
              "app_name": {
                "type": "string",
                "description": "(one of app_name or application_id are required) The value of app_name in the newrelic.yml file used by the application"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "revision": {
                "type": "string",
                "description": "A revision number (e.g., git commit SHA)"
              }
            }
          },
          "junos_netconf": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "netconf_port",
                        "listens_on"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module provides an abstraction that enables and configures the netconf system service running on Junos devices.  This module can be used to easily enable the Netconf API. Netconf provides a programmatic interface for working with configuration and state resources as defined in RFC 6242.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecifies the state of the C(junos_netconf) resource on the remote device.  If the I(state) argument is set to I(present) the netconf service will be configured.  If the I(state) argument is set to I(absent) the netconf service will be removed from the configuration."
              },
              "netconf_port": {
                "description": "Default: 830\n\nThis argument specifies the port the netconf service should listen on for SSH connections.  The default port as defined in RFC 6242 is 830.",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "listens_on": {
                "description": "Default: 830\n\nThis argument specifies the port the netconf service should listen on for SSH connections.  The default port as defined in RFC 6242 is 830.",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              }
            }
          },
          "na_cdot_aggregate": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or destroy aggregates on NetApp cDOT.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the aggregate to manage."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "disk_count": {
                "description": "Number of disks to place into the aggregate, including parity disks.\nThe disks in this newly-created aggregate come from the spare disk pool.\nThe smallest disks in this pool join the aggregate first, unless the C(disk-size) argument is provided.\nEither C(disk-count) or C(disks) must be supplied. Range [0..2^31-1].\nRequired when C(state=present).",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified aggregate should exist or not."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ovirt_snapshots": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "use_memory",
                        "restore_memory",
                        "save_memory"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage Virtual Machine Snapshots in oVirt",
            "properties": {
              "vm_name": {
                "type": "string",
                "description": "Name of the Virtual Machine to manage."
              },
              "description": {
                "type": "string",
                "description": "Description of the snapshot."
              },
              "use_memory": {
                "description": "If I(true) and C(state) is I(present) save memory of the Virtual Machine if it's running.\nIf I(true) and C(state) is I(restore) restore memory of the Virtual Machine.\nNote that Virtual Machine will be paused while saving the memory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "save_memory": {
                "description": "If I(true) and C(state) is I(present) save memory of the Virtual Machine if it's running.\nIf I(true) and C(state) is I(restore) restore memory of the Virtual Machine.\nNote that Virtual Machine will be paused while saving the memory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "restore",
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the Virtual Machine snapshot be restore/present/absent."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "snapshot_id": {
                "type": "string",
                "description": "ID of the snapshot to manage."
              },
              "restore_memory": {
                "description": "If I(true) and C(state) is I(present) save memory of the Virtual Machine if it's running.\nIf I(true) and C(state) is I(restore) restore memory of the Virtual Machine.\nNote that Virtual Machine will be paused while saving the memory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_igmp_snooping": {
            "type": "object",
            "description": "Manages IGMP snooping global configuration.",
            "properties": {
              "link_local_grp_supp": {
                "description": "Global link-local groups suppression.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "report_supp": {
                "description": "Global IGMPv1/IGMPv2 Report Suppression.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "snooping": {
                "description": "Enables/disables IGMP snooping on the switch.",
                "$ref": "#/definitions/ansible_truth"
              },
              "group_timeout": {
                "type": "string",
                "description": "Group membership timeout value for all VLANs on the device. Accepted values are integer in range 1-10080, I(never) and I(default)."
              },
              "v3_report_supp": {
                "description": "Global IGMPv3 Report Suppression and Proxy Reporting.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "default"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "win_disk_image": {
            "type": "object",
            "description": "Manages mount behavior for a specified ISO, VHD, or VHDX image on a Windows host. When C(state) is C(present), the image will be mounted under a system-assigned drive letter, which will be returned in the C(mount_path) value of the module result. Requires Windows 8+ or Windows Server 2012+.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nwhether the image should be present as a drive-letter mount or not."
              },
              "image_path": {
                "type": "string",
                "description": "path to an ISO, VHD, or VHDX image on the target Windows host (the file cannot reside on a network share)"
              }
            }
          },
          "sns": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "msg",
                        "default"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "msg"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "default"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "The M(sns) module sends notifications to a topic on your Amazon SNS account",
            "properties": {
              "topic": {
                "type": "string",
                "description": "The topic you want to publish to."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "subject": {
                "type": "string",
                "description": "Subject line for email delivery."
              },
              "aws_secret_key": {
                "type": "string",
                "description": "Default: None\n\nAWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "sms": {
                "type": "string",
                "description": "Message to send to SMS-only subscription"
              },
              "https": {
                "type": "string",
                "description": "Message to send to HTTPS-only subscription"
              },
              "msg": {
                "type": "string",
                "description": "Default message to send."
              },
              "email": {
                "type": "string",
                "description": "Message to send to email-only subscription"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "http": {
                "type": "string",
                "description": "Message to send to HTTP-only subscription"
              },
              "sqs": {
                "type": "string",
                "description": "Message to send to SQS-only subscription"
              },
              "aws_region": {
                "type": "string",
                "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used."
              },
              "ec2_access_key": {
                "type": "string",
                "description": "Default: None\n\nAWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "ec2_secret_key": {
                "type": "string",
                "description": "Default: None\n\nAWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "ec2_region": {
                "type": "string",
                "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used."
              },
              "access_key": {
                "type": "string",
                "description": "Default: None\n\nAWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "aws_access_key": {
                "type": "string",
                "description": "Default: None\n\nAWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used."
              },
              "default": {
                "type": "string",
                "description": "Default message to send."
              },
              "secret_key": {
                "type": "string",
                "description": "Default: None\n\nAWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "os_server_volume": {
            "type": "object",
            "description": "Attach or Detach volumes from OpenStack VM's",
            "properties": {
              "volume": {
                "type": "string",
                "description": "Name or id of volume you want to attach to a server"
              },
              "device": {
                "type": "string",
                "description": "Default: None\n\nDevice you want to attach. Defaults to auto finding a device name."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "server": {
                "type": "string",
                "description": "Name or ID of server you want to attach a volume to"
              }
            }
          },
          "bigip_ssl_certificate": {
            "type": "object",
            "description": "This module will import/delete SSL certificates on BIG-IP LTM. Certificates can be imported from certificate and key files on the local disk, in PEM format.",
            "properties": {
              "name": {
                "type": "string",
                "description": "SSL Certificate Name.  This is the cert/key pair name used when importing a certificate/key into the F5. It also determines the filenames of the objects on the LTM (:Partition:name.cer_11111_1 and :Partition_name.key_11111_1)."
              },
              "cert_content": {
                "type": "string",
                "description": "When used instead of 'cert_src', sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present)."
              },
              "partition": {
                "type": "string",
                "description": "Default: Common\n\nBIG-IP partition to use when adding/deleting certificate."
              },
              "cert_src": {
                "type": "string",
                "description": "This is the local filename of the certificate. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present)."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nCertificate and key state. This determines if the provided certificate and key is to be made C(present) on the device or C(absent)."
              },
              "passphrase": {
                "type": "string",
                "description": "Passphrase on certificate private key"
              },
              "key_content": {
                "type": "string",
                "description": "When used instead of 'key_src', sets the contents of a certificate key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present)."
              },
              "key_src": {
                "type": "string",
                "description": "This is the local filename of the private key. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present)."
              }
            }
          },
          "os_object": {
            "type": "object",
            "description": "Create or Delete objects and containers from OpenStack",
            "properties": {
              "container": {
                "type": "string",
                "description": "The name of the container in which to create the object"
              },
              "name": {
                "type": "string",
                "description": "Name to be give to the object. If omitted, operations will be on the entire container"
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "filename": {
                "type": "string",
                "description": "Path to local file to be uploaded."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "container_access": {
                "type": "string",
                "description": "Default: private\n\ndesired container access level."
              }
            }
          },
          "udm_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "samba_user_workstations",
                        "sambaUserWorkstations"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "home_share",
                        "homeShare"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "display_name",
                        "displayName"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "pager_telephonenumber",
                        "pagerTelephonenumber"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "room_number",
                        "roomNumber"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "home_share_path",
                        "homeSharePath"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "mail_home_server",
                        "mailHomeServer"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "home_telephone_number",
                        "homeTelephoneNumber"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "primary_group",
                        "primaryGroup"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "mail_alternative_address",
                        "mailAlternativeAddress"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "overridePWLength",
                        "override_pw_length"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "employee_type",
                        "employeeType"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "pwd_change_next_login",
                        "pwdChangeNextLogin"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "overridePWHistory",
                        "override_pw_history"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "mail_primary_address",
                        "mailPrimaryAddress"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "employee_number",
                        "employeeNumber"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "mobile_telephone_number",
                        "mobileTelephoneNumber"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "samba_privileges",
                        "sambaPrivileges"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "department_number",
                        "departmentNumber"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module allows to manage posix users on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.",
            "properties": {
              "mobileTelephoneNumber": {
                "description": "Mobile phone number",
                "$ref": "#/definitions/ansible_array"
              },
              "samba_user_workstations": {
                "description": "Allow the authentication only on this Microsoft Windows host.",
                "$ref": "#/definitions/ansible_array"
              },
              "pager_telephonenumber": {
                "description": "List of pager telephone numbers.",
                "$ref": "#/definitions/ansible_array"
              },
              "departmentNumber": {
                "type": "string",
                "description": "Default: None\n\nDepartment number of users business address."
              },
              "room_number": {
                "type": "string",
                "description": "Default: None\n\nRoom number of users business address."
              },
              "overridePWLength": {
                "description": "Override password check",
                "$ref": "#/definitions/ansible_truth"
              },
              "overridePWHistory": {
                "description": "Override password history",
                "$ref": "#/definitions/ansible_truth"
              },
              "homeShare": {
                "type": "string",
                "description": "Default: None\n\nHome NFS share. Must be a LDAP DN, e.g. C(cn=home,cn=shares,ou=school,dc=example,dc=com)."
              },
              "postcode": {
                "type": "string",
                "description": "Default: None\n\nPostal code of users business address."
              },
              "scriptpath": {
                "type": "string",
                "description": "Default: None\n\nWindows logon script."
              },
              "sambaPrivileges": {
                "description": "Samba privilege, like allow printer administration, do domain join.",
                "$ref": "#/definitions/ansible_array"
              },
              "home_share": {
                "type": "string",
                "description": "Default: None\n\nHome NFS share. Must be a LDAP DN, e.g. C(cn=home,cn=shares,ou=school,dc=example,dc=com)."
              },
              "homeTelephoneNumber": {
                "description": "List of private telephone numbers.",
                "$ref": "#/definitions/ansible_array"
              },
              "city": {
                "type": "string",
                "description": "Default: None\n\nCity of users business address."
              },
              "position": {
                "type": "string",
                "description": "Define the whole position of users object inside the LDAP tree, e.g. C(cn=employee,cn=users,ou=school,dc=example,dc=com)."
              },
              "display_name": {
                "type": "string",
                "description": "Default: None\n\nDisplay name (not gecos)"
              },
              "homedrive": {
                "type": "string",
                "description": "Default: None\n\nWindows home drive, e.g. C(\"H:\")."
              },
              "title": {
                "type": "string",
                "description": "Default: None\n\nTitle, e.g. C(Prof.)."
              },
              "mailAlternativeAddress": {
                "description": "List of alternative e-mail addresses.",
                "$ref": "#/definitions/ansible_array"
              },
              "serviceprovider": {
                "description": "Default: ['']\n\nEnable user for the following service providers.",
                "$ref": "#/definitions/ansible_array"
              },
              "organisation": {
                "type": "string",
                "description": "Default: None\n\nOrganisation"
              },
              "mailPrimaryAddress": {
                "type": "string",
                "description": "Default: None\n\nPrimary e-mail address"
              },
              "subpath": {
                "type": "string",
                "description": "Default: cn=users\n\nLDAP subpath inside the organizational unit, e.g. C(cn=teachers,cn=users) for LDAP container C(cn=teachers,cn=users,dc=example,dc=com)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the user is present or not."
              },
              "home_share_path": {
                "type": "string",
                "description": "Default: None\n\nPath to home NFS share, inside the homeShare."
              },
              "userexpiry": {
                "type": "string",
                "description": "Default: Today + 1 year\n\nAccount expiry date, e.g. C(1999-12-31)."
              },
              "override_pw_history": {
                "description": "Override password history",
                "$ref": "#/definitions/ansible_truth"
              },
              "unixhome": {
                "type": "string",
                "description": "Default: /home/$USERNAME\n\nUnix home directory"
              },
              "mail_home_server": {
                "type": "string",
                "description": "Default: None\n\nFQDN of mail server"
              },
              "sambaUserWorkstations": {
                "description": "Allow the authentication only on this Microsoft Windows host.",
                "$ref": "#/definitions/ansible_array"
              },
              "email": {
                "description": "Default: ['']\n\nA list of e-mail addresses.",
                "$ref": "#/definitions/ansible_array"
              },
              "sambahome": {
                "type": "string",
                "description": "Default: None\n\nWindows home path, e.g. C('\\\\$FQDN\\$USERNAME')."
              },
              "username": {
                "type": "string",
                "description": "User name"
              },
              "home_telephone_number": {
                "description": "List of private telephone numbers.",
                "$ref": "#/definitions/ansible_array"
              },
              "shell": {
                "type": "string",
                "description": "Default: /bin/bash\n\nLogin shell"
              },
              "street": {
                "type": "string",
                "description": "Default: None\n\nStreet of users business address."
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nDescription (not gecos)"
              },
              "firstname": {
                "type": "string",
                "description": "First name. Required if C(state=present)."
              },
              "pagerTelephonenumber": {
                "description": "List of pager telephone numbers.",
                "$ref": "#/definitions/ansible_array"
              },
              "lastname": {
                "type": "string",
                "description": "Last name. Required if C(state=present)."
              },
              "mailHomeServer": {
                "type": "string",
                "description": "Default: None\n\nFQDN of mail server"
              },
              "mail_alternative_address": {
                "description": "List of alternative e-mail addresses.",
                "$ref": "#/definitions/ansible_array"
              },
              "phone": {
                "description": "List of telephone numbers.",
                "$ref": "#/definitions/ansible_array"
              },
              "birthday": {
                "type": "string",
                "description": "Default: None\n\nBirthday"
              },
              "employeeNumber": {
                "type": "string",
                "description": "Default: None\n\nEmployee number"
              },
              "groups": {
                "description": "POSIX groups, the LDAP DNs of the groups will be found with the LDAP filter for each group as $GROUP: C((&(objectClass=posixGroup)(cn=$GROUP))).",
                "$ref": "#/definitions/ansible_array"
              },
              "primaryGroup": {
                "type": "string",
                "description": "Default: cn=Domain Users,cn=groups,$LDAP_BASE_DN\n\nPrimary group. This must be the group LDAP DN."
              },
              "employeeType": {
                "type": "string",
                "description": "Default: None\n\nEmployee type"
              },
              "employee_type": {
                "type": "string",
                "description": "Default: None\n\nEmployee type"
              },
              "password": {
                "type": "string",
                "description": "Default: None\n\nPassword. Required if C(state=present)."
              },
              "pwd_change_next_login": {
                "enum": [
                  "0",
                  "1"
                ],
                "type": "string",
                "description": "Default: None\n\nChange password on next login."
              },
              "displayName": {
                "type": "string",
                "description": "Default: None\n\nDisplay name (not gecos)"
              },
              "name": {
                "type": "string",
                "description": "User name"
              },
              "mail_primary_address": {
                "type": "string",
                "description": "Default: None\n\nPrimary e-mail address"
              },
              "country": {
                "type": "string",
                "description": "Default: None\n\nCountry of users business address."
              },
              "primary_group": {
                "type": "string",
                "description": "Default: cn=Domain Users,cn=groups,$LDAP_BASE_DN\n\nPrimary group. This must be the group LDAP DN."
              },
              "employee_number": {
                "type": "string",
                "description": "Default: None\n\nEmployee number"
              },
              "roomNumber": {
                "type": "string",
                "description": "Default: None\n\nRoom number of users business address."
              },
              "override_pw_length": {
                "description": "Override password check",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_privileges": {
                "description": "Samba privilege, like allow printer administration, do domain join.",
                "$ref": "#/definitions/ansible_array"
              },
              "pwdChangeNextLogin": {
                "enum": [
                  "0",
                  "1"
                ],
                "type": "string",
                "description": "Default: None\n\nChange password on next login."
              },
              "gecos": {
                "type": "string",
                "description": "Default: None\n\nGECOS"
              },
              "mobile_telephone_number": {
                "description": "Mobile phone number",
                "$ref": "#/definitions/ansible_array"
              },
              "profilepath": {
                "type": "string",
                "description": "Default: None\n\nWindows profile directory"
              },
              "ou": {
                "type": "string",
                "description": "Organizational Unit inside the LDAP Base DN, e.g. C(school) for LDAP OU C(ou=school,dc=example,dc=com)."
              },
              "department_number": {
                "type": "string",
                "description": "Default: None\n\nDepartment number of users business address."
              },
              "homeSharePath": {
                "type": "string",
                "description": "Default: None\n\nPath to home NFS share, inside the homeShare."
              },
              "secretary": {
                "description": "A list of superiors as LDAP DNs.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "elasticache": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cache_parameter_group",
                        "parameter_group"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage cache clusters in Amazon Elasticache.\nReturns information about the specified cache cluster.",
            "properties": {
              "engine": {
                "type": "string",
                "description": "Default: memcached\n\nName of the cache engine to be used."
              },
              "node_type": {
                "type": "string",
                "description": "Default: cache.m1.small\n\nThe compute and memory capacity of the nodes in the cache cluster"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "security_group_ids": {
                "description": "Default: None\n\nA list of vpc security group names to associate with this cache cluster. Only use if inside a vpc",
                "$ref": "#/definitions/ansible_array"
              },
              "zone": {
                "type": "string",
                "description": "Default: None\n\nThe EC2 Availability Zone in which the cache cluster will be created"
              },
              "parameter_group": {
                "type": "string",
                "description": "Default: None\n\nThe name of the cache parameter group to associate with this cache cluster. If this argument is omitted, the default cache parameter group for the specified engine will be used."
              },
              "num_nodes": {
                "description": "The initial number of cache nodes that the cache cluster will have. Required when state=present.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "rebooted"
                ],
                "type": "string",
                "description": "C(absent) or C(present) are idempotent actions that will create or destroy a cache cluster as needed. C(rebooted) will reboot the cluster, resulting in a momentary outage."
              },
              "cache_subnet_group": {
                "type": "string",
                "description": "Default: None\n\nThe subnet group name to associate with. Only use if inside a vpc. Required if inside a vpc"
              },
              "wait": {
                "description": "Default: True\n\nWait for cache cluster result before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "cache_engine_version": {
                "type": "string",
                "description": "Default: None\n\nThe version number of the cache engine"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "cache_port": {
                "description": "Default: None\n\nThe port number on which each of the cache nodes will accept connections",
                "$ref": "#/definitions/ansible_number"
              },
              "cache_parameter_group": {
                "type": "string",
                "description": "Default: None\n\nThe name of the cache parameter group to associate with this cache cluster. If this argument is omitted, the default cache parameter group for the specified engine will be used."
              },
              "name": {
                "type": "string",
                "description": "The cache cluster identifier"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "hard_modify": {
                "description": "Whether to destroy and recreate an existing cache cluster if necessary in order to modify its state",
                "$ref": "#/definitions/ansible_truth"
              },
              "cache_security_groups": {
                "description": "Default: None\n\nA list of cache security group names to associate with this cache cluster. Must be an empty list if inside a vpc",
                "$ref": "#/definitions/ansible_array"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "efs_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module searches Amazon EFS file systems",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nCreation Token of Amazon EFS file system."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "Default: None\n\nList of tags of Amazon EFS. Should be defined as dictionary\n"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "id": {
                "type": "string",
                "description": "Default: None\n\nID of Amazon EFS."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "targets": {
                "description": "Default: None\n\nList of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes:\n    - SubnetId - Mandatory. The ID of the subnet to add the mount target in.\n    - IpAddress - Optional. A valid IPv4 address within the address range of the specified subnet.\n    - SecurityGroups - Optional. List of security group IDs, of the form \"sg-xxxxxxxx\". These must be for the same VPC as subnet specified.\n",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ovirt_clusters": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ballooning",
                        "balloon"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage clusters in oVirt",
            "properties": {
              "ha_reservation": {
                "description": "If I(True) enable the oVirt to monitor cluster capacity for highly available virtual machines.",
                "$ref": "#/definitions/ansible_truth"
              },
              "comment": {
                "type": "string",
                "description": "Comment of the cluster."
              },
              "fence_skip_if_connectivity_broken": {
                "description": "If I(True) fencing will be temporarily disabled if the percentage of hosts in the cluster that are experiencing connectivity issues is greater than or equal to the defined threshold.\nThe threshold can be specified by C(fence_connectivity_threshold).",
                "$ref": "#/definitions/ansible_truth"
              },
              "virt": {
                "description": "If I(True), hosts in this cluster will be used to run virtual machines.",
                "$ref": "#/definitions/ansible_truth"
              },
              "threads_as_cores": {
                "description": "If I(True) the exposed host threads would be treated as cores which can be utilized by virtual machines.",
                "$ref": "#/definitions/ansible_truth"
              },
              "gluster": {
                "description": "If I(True), hosts in this cluster will be used as Gluster Storage server nodes, and not for running virtual machines.\nBy default the cluster is created for virtual machine hosts.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vm_reason": {
                "description": "If I(True) enable an optional reason field when a virtual machine is shut down from the Manager, allowing the administrator to provide an explanation for the maintenance.",
                "$ref": "#/definitions/ansible_truth"
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "migration_bandwidth_limit": {
                "description": "Set the I(custom) migration bandwidth limit.\nThis parameter is used only when C(migration_bandwidth) is I(custom).",
                "$ref": "#/definitions/ansible_number"
              },
              "data_center": {
                "type": "string",
                "description": "Datacenter name where cluster reside."
              },
              "ksm_numa": {
                "description": "If I(True) enables KSM C(ksm) for best berformance inside NUMA nodes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "Description of the cluster."
              },
              "cpu_arch": {
                "enum": [
                  "x86_64",
                  "ppc64",
                  "undefined"
                ],
                "type": "string",
                "description": "CPU architecture of cluster."
              },
              "rng_sources": {
                "description": "List that specify the random number generator devices that all hosts in the cluster will use.\nSupported generators are: I(hwrng) and I(random).",
                "$ref": "#/definitions/ansible_array"
              },
              "compatibility_version": {
                "type": "string",
                "description": "The compatibility version of the cluster. All hosts in this cluster must support at least this compatibility version."
              },
              "network": {
                "type": "string",
                "description": "Management network of cluster to access cluster hosts."
              },
              "balloon": {
                "description": "If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the cluster be present or absent"
              },
              "ksm": {
                "description": "I I(True) MoM enables to run Kernel Same-page Merging I(KSM) when necessary and when it can yield a memory saving benefit that outweighs its CPU cost.",
                "$ref": "#/definitions/ansible_truth"
              },
              "migration_compressed": {
                "enum": [
                  "true",
                  "false",
                  "inherit"
                ],
                "type": "string",
                "description": "If I(True) compression is used during live migration of the virtual machine.\nUsed only when C(migration_policy) is set to I(legacy).\nFollowing options are supported:\nC(true) - Override the global setting to I(true).\nC(false) - Override the global setting to I(false).\nC(inherit) - Use value which is set globally."
              },
              "ballooning": {
                "description": "If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.",
                "$ref": "#/definitions/ansible_truth"
              },
              "migration_auto_converge": {
                "enum": [
                  "true",
                  "false",
                  "inherit"
                ],
                "type": "string",
                "description": "If I(True) auto-convergence is used during live migration of virtual machines.\nUsed only when C(migration_policy) is set to I(legacy).\nFollowing options are supported:\nC(true) - Override the global setting to I(true).\nC(false) - Override the global setting to I(false).\nC(inherit) - Use value which is set globally."
              },
              "fence_enabled": {
                "description": "If I(True) enables fencing on the cluster.\nFencing is enabled by default.",
                "$ref": "#/definitions/ansible_truth"
              },
              "migration_policy": {
                "enum": [
                  "legacy",
                  "minimal_downtime",
                  "suspend_workload"
                ],
                "type": "string",
                "description": "A migration policy defines the conditions for live migrating virtual machines in the event of host failure.\nFollowing policies are supported:\nC(legacy) - Legacy behavior of 3.6 version.\nC(minimal_downtime) - Virtual machines should not experience any significant downtime.\nC(suspend_workload) - Virtual machines may experience a more significant downtime."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "resilience_policy": {
                "enum": [
                  "do_not_migrate",
                  "migrate",
                  "migrate_highly_available"
                ],
                "type": "string",
                "description": "The resilience policy defines how the virtual machines are prioritized in the migration.\nFollowing values are supported:\nC(do_not_migrate) -  Prevents virtual machines from being migrated. \nC(migrate) - Migrates all virtual machines in order of their defined priority.\nC(migrate_highly_available) - Migrates only highly available virtual machines to prevent overloading other hosts."
              },
              "fence_connectivity_threshold": {
                "description": "The threshold used by C(fence_skip_if_connectivity_broken).",
                "$ref": "#/definitions/ansible_number"
              },
              "spice_proxy": {
                "type": "string",
                "description": "The proxy by which the SPICE client will connect to virtual machines.\nThe address must be in the following format: I(protocol://[host]:[port])"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "memory_policy": {
                "enum": [
                  "disabled",
                  "server",
                  "desktop"
                ],
                "type": "string",
                "description": "I(disabled) - Disables memory page sharing.\nI(server) - Sets the memory page sharing threshold to 150% of the system memory on each host.\nI(desktop) - Sets the memory page sharing threshold to 200% of the system memory on each host."
              },
              "migration_bandwidth": {
                "enum": [
                  "auto",
                  "hypervisor_default",
                  "custom"
                ],
                "type": "string",
                "description": "The bandwidth settings define the maximum bandwidth of both outgoing and incoming migrations per host.\nFollowing bandwith options are supported:\nC(auto) - Bandwidth is copied from the I(rate limit) [Mbps] setting in the data center host network QoS.\nC(hypervisor_default) - Bandwidth is controlled by local VDSM setting on sending host.\nC(custom) - Defined by user (in Mbps)."
              },
              "fence_skip_if_sd_active": {
                "description": "If I(True) any hosts in the cluster that are Non Responsive and still connected to storage will not be fenced.",
                "$ref": "#/definitions/ansible_truth"
              },
              "scheduling_policy": {
                "type": "string",
                "description": "Name of the scheduling policy to be used for cluster."
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "switch_type": {
                "enum": [
                  "legacy",
                  "ovs"
                ],
                "type": "string",
                "description": "Type of switch to be used by all networks in given cluster. Either I(legacy) which is using linux brigde or I(ovs) using Open vSwitch."
              },
              "serial_policy_value": {
                "type": "string",
                "description": "Allows you to specify a custom serial number.\nThis parameter is used only when C(serial_policy) is I(custom)."
              },
              "name": {
                "type": "string",
                "description": "Name of the the cluster to manage."
              },
              "host_reason": {
                "description": "If I(True) enable an optional reason field when a host is placed into maintenance mode from the Manager, allowing the administrator to provide an explanation for the maintenance.",
                "$ref": "#/definitions/ansible_truth"
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "cpu_type": {
                "type": "string",
                "description": "CPU codename. For example I(Intel SandyBridge Family)."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "serial_policy": {
                "enum": [
                  "vm",
                  "host",
                  "custom"
                ],
                "type": "string",
                "description": "Specify a serial number policy for the virtual machines in the cluster.\nFollowing options are supported:\nC(vm) - Sets the virtual machine's UUID as its serial number.\nC(host) - Sets the host's UUID as the virtual machine's serial number.\nC(custom) - Allows you to specify a custom serial number in C(serial_policy_value)."
              },
              "trusted_service": {
                "description": "If (True) enable integration with an OpenAttestation server.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "azure_rm_resourcegroup": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, update and delete a resource group.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "force": {
                "description": "Remove a resource group and all associated resources. Use with state 'absent' to delete a resource group that contains resources.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the resource group."
              },
              "tags": {
                "type": "object",
                "description": ""
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "append_tags": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nAssert the state of the resource group. Use 'present' to create or update and 'absent' to delete. When 'absent' a resource group containing resources will not be removed unless the force option is used."
              },
              "location": {
                "type": "string",
                "description": "Azure location for the resource group. Required when creating a new resource group. Cannot be changed once resource group is created."
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "nxos_portchannel": {
            "required": [
              "group"
            ],
            "type": "object",
            "description": "Manages port-channel specific configuration parameters.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "force": {
                "enum": [
                  "true",
                  "false"
                ],
                "type": "string",
                "description": "When true it forces port-channel members to match what is declared in the members param. This can be used to remove members."
              },
              "members": {
                "description": "List of interfaces that will be managed in a given portchannel.",
                "$ref": "#/definitions/ansible_array"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "min_links": {
                "type": "string",
                "description": "Min links required to keep portchannel up."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "group": {
                "type": "string",
                "description": "Channel-group number for the port-channel."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "mode": {
                "enum": [
                  "active",
                  "passive",
                  "on"
                ],
                "type": "string",
                "description": "Default: True\n\nMode for the port-channel, i.e. on, active, passive."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "tower_project": {
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower projects. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "scm_credential": {
                "type": "string",
                "description": "Name of the credential to use with this scm resource."
              },
              "scm_branch": {
                "type": "string",
                "description": "The branch to use for the scm resource."
              },
              "description": {
                "type": "string",
                "description": "Description to use for the project."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "scm_update_on_launch": {
                "description": "Before an update to the local repository before launching a job with this project.",
                "$ref": "#/definitions/ansible_truth"
              },
              "scm_clean": {
                "description": "Remove local modifications before updating.",
                "$ref": "#/definitions/ansible_truth"
              },
              "scm_type": {
                "enum": [
                  "manual",
                  "git",
                  "hg",
                  "svn"
                ],
                "type": "string",
                "description": "Default: manual\n\nType of scm resource."
              },
              "scm_delete_on_update": {
                "description": "Remove the repository completely before updating.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "local_path": {
                "type": "string",
                "description": "The server playbook directory for manual projects."
              },
              "scm_url": {
                "type": "string",
                "description": "URL of scm resource."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "organization": {
                "type": "string",
                "description": "Primary key of organization for project."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name to use for the project."
              }
            }
          },
          "ec2_vpc_dhcp_options_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about dhcp options sets in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "DryRun": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "DhcpOptionsIds": {
                "description": "Default: None\n\nGet details of specific DHCP Option ID\nProvide this value as a list",
                "$ref": "#/definitions/ansible_array"
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "nxos_vxlan_vtep": {
            "required": [
              "interface"
            ],
            "type": "object",
            "description": "Manages VXLAN Network Virtualization Endpoint (NVE) overlay interface that terminates VXLAN tunnels.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "m_facts": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Description of the NVE interface."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "source_interface": {
                "type": "string",
                "description": "Specify the loopback interface whose IP address should be used for the NVE interface."
              },
              "host_reachability": {
                "description": "Specify mechanism for host reachability advertisement.",
                "$ref": "#/definitions/ansible_truth"
              },
              "source_interface_hold_down_time": {
                "type": "string",
                "description": "Suppresses advertisement of the NVE loopback address until the overlay has converged."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "shutdown": {
                "description": "Administratively shutdown the NVE interface.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Interface name for the VXLAN Network Virtualization Endpoint."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "gcdns_record": {
            "type": "object",
            "description": "Creates or removes resource records in Google Cloud DNS.",
            "properties": {
              "zone_id": {
                "type": "string",
                "description": "The Google Cloud ID of the zone (e.g., example-com).\nOne of either I(zone) or I(zone_id) must be specified as an option, or the module will fail.\nThese usually take the form of domain names with the dots replaced with dashes. A zone ID will never have any dots in it.\nI(zone_id) can be faster than I(zone) in projects with a large number of zones.\nIf both I(zone) and I(zone_id) are specifed, I(zone_id) will be used."
              },
              "zone": {
                "type": "string",
                "description": "The DNS domain name of the zone (e.g., example.com).\nOne of either I(zone) or I(zone_id) must be specified as an option, or the module will fail.\nIf both I(zone) and I(zone_id) are specifed, I(zone_id) will be used."
              },
              "record_data": {
                "type": "string",
                "description": "The record_data to use for the resource record.\nI(record_data) must be specified if I(state) is C(present) or I(overwrite) is C(True), or the module will fail.\nValid record_data vary based on the record's I(type). In addition, resource records that contain a DNS domain name in the value field (e.g., CNAME, PTR, SRV, .etc) MUST include a trailing dot in the value.\nIndividual string record_data for TXT records must be enclosed in double quotes.\nFor resource records that have the same name but different record_data (e.g., multiple A records), they must be defined as multiple list entries in a single record."
              },
              "service_account_email": {
                "type": "string",
                "description": "The e-mail address for a service account with access to Google Cloud DNS."
              },
              "credentials_file": {
                "type": "string",
                "description": "The path to the JSON file associated with the service account email."
              },
              "pem_file": {
                "type": "string",
                "description": "The path to the PEM file associated with the service account email.\nThis option is deprecated and may be removed in a future release. Use I(credentials_file) instead."
              },
              "record": {
                "type": "string",
                "description": "The fully-qualified domain name of the resource record."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhether the given resource record should or should not be present."
              },
              "ttl": {
                "type": "string",
                "description": "Default: 300\n\nThe amount of time in seconds that a resource record will remain cached by a caching resolver."
              },
              "project_id": {
                "type": "string",
                "description": "The Google Cloud Platform project ID to use."
              },
              "type": {
                "type": "string",
                "description": "The type of resource record to add."
              },
              "overwrite": {
                "type": "string",
                "description": "Whether an attempt to overwrite an existing record should succeed or fail. The behavior of this option depends on I(state).\nIf I(state) is C(present) and I(overwrite) is C(True), this module will replace an existing resource record of the same name with the provided I(record_data). If I(state) is C(present) and I(overwrite) is C(False), this module will fail if there is an existing resource record with the same name and type, but different resource data.\nIf I(state) is C(absent) and I(overwrite) is C(True), this module will remove the given resource record unconditionally. If I(state) is C(absent) and I(overwrite) is C(False), this module will fail if the provided record_data do not match exactly with the existing resource record's record_data."
              }
            }
          },
          "os_keystone_service": {
            "type": "object",
            "description": "Create, update, or delete OpenStack Identity service. If a service with the supplied name already exists, it will be updated with the new description and enabled attributes.",
            "properties": {
              "service_type": {
                "type": "string",
                "description": "The type of service"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "enabled": {
                "type": "string",
                "description": "Default: True\n\nIs the service enabled"
              },
              "name": {
                "type": "string",
                "description": "Name of the service"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nDescription of the service"
              }
            }
          },
          "cloudflare_dns": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "zone",
                        "domain"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "zone"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "domain"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "value",
                        "content"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "record",
                        "name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages dns records via the Cloudflare API, see the docs: U(https://api.cloudflare.com/)",
            "properties": {
              "solo": {
                "description": "Whether the record should be the only one for that record type and record name. Only use with C(state=present)\nThis will delete all other records with the same record name and type.",
                "$ref": "#/definitions/ansible_truth"
              },
              "domain": {
                "type": "string",
                "description": "The name of the Zone to work with (e.g. \"example.com\"). The Zone must already exist."
              },
              "weight": {
                "description": "Default: 1\n\nService weight. Required for C(type=SRV)",
                "$ref": "#/definitions/ansible_number"
              },
              "zone": {
                "type": "string",
                "description": "The name of the Zone to work with (e.g. \"example.com\"). The Zone must already exist."
              },
              "proto": {
                "enum": [
                  "tcp",
                  "udp"
                ],
                "type": "string",
                "description": "Service protocol. Required for C(type=SRV)"
              },
              "value": {
                "type": "string",
                "description": "The record value. Required for C(state=present)"
              },
              "name": {
                "type": "string",
                "description": "Default: @\n\nRecord to add. Required if C(state=present). Default is C(@) (e.g. the zone name)"
              },
              "content": {
                "type": "string",
                "description": "The record value. Required for C(state=present)"
              },
              "record": {
                "type": "string",
                "description": "Default: @\n\nRecord to add. Required if C(state=present). Default is C(@) (e.g. the zone name)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the record(s) should exist or not"
              },
              "service": {
                "type": "string",
                "description": "Record service. Required for C(type=SRV)"
              },
              "timeout": {
                "description": "Default: 30\n\nTimeout for Cloudflare API calls",
                "$ref": "#/definitions/ansible_number"
              },
              "ttl": {
                "description": "Default: 1 (automatic)\n\nThe TTL to give the new record. Must be between 120 and 2,147,483,647 seconds, or 1 for automatic.",
                "$ref": "#/definitions/ansible_number"
              },
              "account_email": {
                "type": "string",
                "description": "Account email."
              },
              "account_api_token": {
                "type": "string",
                "description": "Account API token. You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://www.cloudflare.com/a/account)"
              },
              "type": {
                "enum": [
                  "A",
                  "AAAA",
                  "CNAME",
                  "TXT",
                  "SRV",
                  "MX",
                  "NS",
                  "SPF"
                ],
                "type": "string",
                "description": "The type of DNS record to create. Required if C(state=present)"
              },
              "port": {
                "description": "Service port. Required for C(type=SRV)",
                "$ref": "#/definitions/ansible_number"
              },
              "priority": {
                "description": "Default: 1\n\nRecord priority. Required for C(type=MX) and C(type=SRV)",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "clc_blueprint_package": {
            "required": [
              "server_ids",
              "package_id"
            ],
            "type": "object",
            "description": "An Ansible module to deploy blue print package on a set of servers in CenturyLink Cloud.",
            "properties": {
              "server_ids": {
                "description": "A list of server Ids to deploy the blue print package.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to install or un-install the package. Currently it supports only \"present\" for install action."
              },
              "package_params": {
                "type": "object",
                "description": "The dictionary of arguments required to deploy the blue print."
              },
              "package_id": {
                "type": "string",
                "description": "The package id of the blue print."
              },
              "wait": {
                "type": "string",
                "description": "Default: True\n\nWhether to wait for the tasks to finish before returning."
              }
            }
          },
          "vca_nat": {
            "type": "object",
            "description": "Adds or removes nat rules from a gateway in a vca environment",
            "properties": {
              "nat_rules": {
                "type": "string",
                "description": "A list of rules to be added to the gateway, Please see examples on valid entries"
              },
              "purge_rules": {
                "type": "string",
                "description": "If set to true, it will delete all rules in the gateway that are not given as paramter to this module."
              }
            }
          },
          "aos_rack_type": {
            "required": [
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS Rack Type module let you manage your Rack Type easily. You can create create and delete Rack Type by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "content": {
                "type": "string",
                "description": "Datastructure of the Rack Type to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the Rack Type (present or not)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "id": {
                "type": "string",
                "description": "AOS Id of the Rack Type to manage (can't be used to create a new Rack Type), Only one of I(name), I(id) or I(content) can be set."
              },
              "name": {
                "type": "string",
                "description": "Name of the Rack Type to manage. Only one of I(name), I(id) or I(content) can be set."
              }
            }
          },
          "sendgrid": {
            "required": [
              "body",
              "subject",
              "to_addresses",
              "from_address"
            ],
            "type": "object",
            "description": "Sends an email with a SendGrid account through their API, not through the SMTP service.",
            "properties": {
              "body": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": "username for logging into the SendGrid account.\nSince 2.2 it is only required if api_key is not supplied."
              },
              "password": {
                "type": "string",
                "description": "password that corresponds to the username\nSince 2.2 it is only required if api_key is not supplied."
              },
              "from_name": {
                "type": "string",
                "description": "the name you want to appear in the from field, i.e 'John Doe'"
              },
              "attachments": {
                "description": "a list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs)",
                "$ref": "#/definitions/ansible_array"
              },
              "cc": {
                "description": "a list of email addresses to cc",
                "$ref": "#/definitions/ansible_array"
              },
              "bcc": {
                "description": "a list of email addresses to bcc",
                "$ref": "#/definitions/ansible_array"
              },
              "headers": {
                "type": "object",
                "description": "a dict to pass on as headers"
              },
              "to_addresses": {
                "description": "a list with one or more recipient email addresses",
                "$ref": "#/definitions/ansible_array"
              },
              "html_body": {
                "description": "whether the body is html content that should be rendered",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_key": {
                "type": "string",
                "description": "sendgrid API key to use instead of username/password"
              },
              "from_address": {
                "type": "string",
                "description": "the address in the \"from\" field for the email"
              },
              "subject": {
                "type": "string",
                "description": "the desired subject for the email"
              }
            }
          },
          "na_cdot_lun": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, destroy, resize luns on NetApp cDOT.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "vserver": {
                "type": "string",
                "description": "The name of the vserver to use."
              },
              "name": {
                "type": "string",
                "description": "The name of the lun to manage."
              },
              "flexvol_name": {
                "type": "string",
                "description": "The name of the FlexVol the lun should exist on.\nRequired when C(state=present)."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "size_unit": {
                "enum": [
                  "bytes",
                  "b",
                  "kb",
                  "mb",
                  "gb",
                  "tb",
                  "pb",
                  "eb",
                  "zb",
                  "yb"
                ],
                "type": "string",
                "description": "Default: gb\n\nThe unit used to interpret the size parameter."
              },
              "force_remove": {
                "description": "If \"true\", override checks that prevent a LUN from being destroyed if it is online and mapped.\nIf \"false\", destroying an online and mapped LUN will fail.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified lun should exist or not."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "force_resize": {
                "description": "Forcibly reduce the size. This is required for reducing the size of the LUN to avoid accidentally reducing the LUN size.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "force_remove_fenced": {
                "description": "If \"true\", override checks that prevent a LUN from being destroyed while it is fenced.\nIf \"false\", attempting to destroy a fenced LUN will fail.\nThe default if not specified is \"false\". This field is available in Data ONTAP 8.2 and later.",
                "$ref": "#/definitions/ansible_truth"
              },
              "size": {
                "description": "The size of the lun in C(size_unit).\nRequired when C(state=present).",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "jira": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "operation",
                        "command"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "operation"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "command"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "issue",
                        "ticket"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create and modify issues in a JIRA instance.",
            "properties": {
              "status": {
                "type": "string",
                "description": "The desired status; only relevant for the transition operation."
              },
              "comment": {
                "type": "string",
                "description": "The comment text to add."
              },
              "description": {
                "type": "string",
                "description": "The issue description, where appropriate."
              },
              "fields": {
                "type": "object",
                "description": "This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields."
              },
              "username": {
                "type": "string",
                "description": "The username to log-in with."
              },
              "uri": {
                "type": "string",
                "description": "Base URI for the JIRA instance"
              },
              "summary": {
                "type": "string",
                "description": "The issue summary, where appropriate."
              },
              "project": {
                "type": "string",
                "description": "The project for this operation. Required for issue creation."
              },
              "assignee": {
                "type": "string",
                "description": "Sets the assignee on create or transition operations. Note not all transitions will allow this."
              },
              "command": {
                "enum": [
                  "create",
                  "comment",
                  "edit",
                  "fetch",
                  "transition"
                ],
                "type": "string",
                "description": "The operation to perform."
              },
              "issuetype": {
                "type": "string",
                "description": "The issue type, for issue creation."
              },
              "operation": {
                "enum": [
                  "create",
                  "comment",
                  "edit",
                  "fetch",
                  "transition"
                ],
                "type": "string",
                "description": "The operation to perform."
              },
              "password": {
                "type": "string",
                "description": "The password to log-in with."
              },
              "issue": {
                "type": "string",
                "description": "An existing issue key to operate on."
              },
              "ticket": {
                "type": "string",
                "description": "An existing issue key to operate on."
              }
            }
          },
          "hostname": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Set system's hostname, supports most OSs/Distributions, including those using systemd.\nNote, this module does *NOT* modify C(/etc/hosts). You need to modify it yourself using other modules like template or replace.\nWindows, HP-UX and AIX are not currently supported",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the host"
              }
            }
          },
          "sysctl": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "key"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "key"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "value",
                        "val"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module manipulates sysctl entries and optionally performs a C(/sbin/sysctl -p) after changing them.",
            "properties": {
              "name": {
                "type": "string",
                "description": "The dot-separated path (aka I(key)) specifying the sysctl variable."
              },
              "val": {
                "type": "string",
                "description": "Desired value of the sysctl key."
              },
              "ignoreerrors": {
                "description": "Use this option to ignore errors about unknown keys.",
                "$ref": "#/definitions/ansible_truth"
              },
              "value": {
                "type": "string",
                "description": "Desired value of the sysctl key."
              },
              "reload": {
                "description": "Default: yes\n\nIf C(yes), performs a I(/sbin/sysctl -p) if the C(sysctl_file) is updated. If C(no), does not reload I(sysctl) even if the C(sysctl_file) is updated.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the entry should be present or absent in the sysctl file."
              },
              "key": {
                "type": "string",
                "description": "The dot-separated path (aka I(key)) specifying the sysctl variable."
              },
              "sysctl_set": {
                "description": "Verify token value with the sysctl command and set with -w if necessary",
                "$ref": "#/definitions/ansible_truth"
              },
              "sysctl_file": {
                "type": "string",
                "description": "Default: /etc/sysctl.conf\n\nSpecifies the absolute path to C(sysctl.conf), if not C(/etc/sysctl.conf)."
              }
            }
          },
          "nxos_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Cisco NXOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with NXOS configuration sections in a deterministic way.  This module works with either CLI or NXAPI transports.",
            "properties": {
              "force": {
                "description": "The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.\nNote this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release.",
                "$ref": "#/definitions/ansible_truth"
              },
              "replace": {
                "enum": [
                  "line",
                  "block"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
                "$ref": "#/definitions/ansible_array"
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "The C(save) argument instructs the module to save the running-config to startup-config.  This operation is performed after any changes are made to the current running config.  If no changes are made, the configuration is still saved to the startup config.  This option will always cause the module to return changed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "defaults": {
                "description": "The I(defaults) argument will influence how the running-config is collected from the device.  When the value is set to true, the command used to collect the running-config is append with the all keyword.  When the value is set to false, the command is issued without the all keyword",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "win_shortcut": {
            "type": "object",
            "description": "Create, manage and delete Windows shortcuts",
            "properties": {
              "windowstyle": {
                "type": "string",
                "description": "Influences how the application is displayed when it is launched."
              },
              "src": {
                "type": "string",
                "description": "Executable or URL the shortcut points to."
              },
              "description": {
                "type": "string",
                "description": "Description for the shortcut.\nThis is usually shown when hoovering the icon."
              },
              "dest": {
                "type": "string",
                "description": "Destination file for the shortcuting file.\nFile name should have a C(.lnk) or C(.url) extension."
              },
              "args": {
                "type": "string",
                "description": "Additional arguments for the executable defined in C(src)."
              },
              "hotkey": {
                "type": "string",
                "description": "Key combination for the shortcut."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhen C(present), creates or updates the shortcut.  When C(absent), removes the shortcut if it exists."
              },
              "directory": {
                "type": "string",
                "description": "Working directory for executable defined in C(src)."
              },
              "icon": {
                "type": "string",
                "description": "Icon used for the shortcut\nFile name should have a C(.ico) extension.\nThe file name is followed by a comma and the number in the library file (.dll) or use 0 for an image file."
              }
            }
          },
          "os_subnets_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more subnets from OpenStack.",
            "properties": {
              "subnet": {
                "type": "string",
                "description": "Name or ID of the subnet"
              },
              "filters": {
                "type": "string",
                "description": "A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              }
            }
          },
          "na_cdot_volume": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "is_infinite",
                        "infinite"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "is_online",
                        "online"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or destroy volumes on NetApp cDOT",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "is_infinite": {
                "description": "Default: False\n\nSet True if the volume is an Infinite Volume.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name of the lun to manage."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "size_unit": {
                "enum": [
                  "bytes",
                  "b",
                  "kb",
                  "mb",
                  "gb",
                  "tb",
                  "pb",
                  "eb",
                  "zb",
                  "yb"
                ],
                "type": "string",
                "description": "Default: gb\n\nThe unit used to interpret the size parameter."
              },
              "vserver": {
                "type": "string",
                "description": "Default: None\n\nName of the vserver to use."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified volume should exist or not."
              },
              "online": {
                "description": "Default: True\n\nWhether the specified volume is online, or not.",
                "$ref": "#/definitions/ansible_truth"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "is_online": {
                "description": "Default: True\n\nWhether the specified volume is online, or not.",
                "$ref": "#/definitions/ansible_truth"
              },
              "infinite": {
                "description": "Default: False\n\nSet True if the volume is an Infinite Volume.",
                "$ref": "#/definitions/ansible_truth"
              },
              "aggregate_name": {
                "type": "string",
                "description": "The name of the aggregate the flexvol should exist on. Required when C(state=present)."
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "size": {
                "description": "The size of the volume in (size_unit). Required when C(state=present).",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "nova_compute": {
            "required": [
              "login_password",
              "name"
            ],
            "type": "object",
            "description": "Create or Remove virtual machines from Openstack.",
            "properties": {
              "availability_zone": {
                "type": "string",
                "description": "Default: None\n\nName of the availability zone"
              },
              "image_exclude": {
                "type": "string",
                "description": "Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to \"(deprecated)\""
              },
              "flavor_include": {
                "type": "string",
                "description": "Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name."
              },
              "meta": {
                "type": "object",
                "description": "Default: None\n\nA list of key value pairs that should be provided as a metadata to the new VM"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone url for authentication"
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "wait_for": {
                "type": "string",
                "description": "Default: 180\n\nThe amount of time the module should wait for the VM to get into active state"
              },
              "auto_floating_ip": {
                "description": "Default: no\n\nShould a floating ip be auto created and assigned",
                "$ref": "#/definitions/ansible_truth"
              },
              "scheduler_hints": {
                "type": "object",
                "description": "Default: None\n\nArbitrary key/value pairs to the scheduler for custom use"
              },
              "nics": {
                "description": "Default: None\n\nA list of network id's to which the VM's interface should be attached",
                "$ref": "#/definitions/ansible_array"
              },
              "floating_ips": {
                "description": "Default: None\n\nlist of valid floating IPs that pre-exist to assign to this node",
                "$ref": "#/definitions/ansible_array"
              },
              "flavor_ram": {
                "description": "Default: 1\n\nThe minimum amount of ram in MB that the flavor in which the new VM has to be created must have. Mutually exclusive with flavor_id",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "security_groups": {
                "type": "string",
                "description": "Default: None\n\nThe name of the security group to which the VM should be added"
              },
              "config_drive": {
                "description": "Default: no\n\nWhether to boot the server with config drive enabled",
                "$ref": "#/definitions/ansible_truth"
              },
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nName of the region"
              },
              "key_name": {
                "type": "string",
                "description": "Default: None\n\nThe key pair name to be used when creating a VM"
              },
              "image_name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the base image to boot. Mutually exclusive with image_id"
              },
              "user_data": {
                "type": "string",
                "description": "Default: None\n\nOpaque blob of data which is made available to the instance"
              },
              "image_id": {
                "type": "string",
                "description": "Default: None\n\nThe id of the base image to boot. Mutually exclusive with image_name"
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\nPassword of login user"
              },
              "wait": {
                "enum": [
                  "yes",
                  "no"
                ],
                "type": "string",
                "description": "Default: yes\n\nIf the module should wait for the VM to be created."
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nName that has to be given to the instance"
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: yes\n\nThe tenant name of the login user"
              },
              "flavor_id": {
                "type": "string",
                "description": "Default: 1\n\nThe id of the flavor in which the new VM has to be created. Mutually exclusive with flavor_ram"
              },
              "floating_ip_pools": {
                "description": "Default: None\n\nlist of floating IP pools from which to choose a floating IP",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "panos_import": {
            "required": [
              "password",
              "ip_address"
            ],
            "type": "object",
            "description": "Import file on PAN-OS device",
            "properties": {
              "category": {
                "type": "string",
                "description": "Default: software\n\nCategory of file uploaded. The default is software."
              },
              "username": {
                "type": "string",
                "description": "Default: admin\n\nUsername for device authentication."
              },
              "url": {
                "type": "string",
                "description": "Default: None\n\nURL of the file that will be imported to device."
              },
              "file": {
                "type": "string",
                "description": "Default: None\n\nLocation of the file to import into device."
              },
              "password": {
                "type": "string",
                "description": "Password for device authentication."
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device."
              }
            }
          },
          "ecs_ecr": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage Elastic Container Registry repositories",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "the name of the repository"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "delete_policy": {
                "description": "if yes, remove the policy from the repository",
                "$ref": "#/definitions/ansible_truth"
              },
              "force_set_policy": {
                "description": "if no, prevents setting a policy that would prevent you from setting another policy in the future.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\ncreate or destroy the repository"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "policy": {
                "type": "string",
                "description": "JSON or dict that represents the new policy"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "registry_id": {
                "type": "string",
                "description": "AWS account id associated with the registry.\nIf not specified, the default registry is assumed."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ovirt_mac_pools": {
            "required": [
              "name",
              "auth"
            ],
            "type": "object",
            "description": "This module manage MAC pools in oVirt.",
            "properties": {
              "allow_duplicates": {
                "description": "If (true) allow a MAC address to be used multiple times in a pool.\nDefault value is set by oVirt engine to I(false).",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the the MAC pool to manage."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "ranges": {
                "description": "List of MAC ranges. The from and to should be splitted by comma.\nFor example: 00:1a:4a:16:01:51,00:1a:4a:16:01:61",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the mac pool be present or absent."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "Description of the MAC pool."
              }
            }
          },
          "aos_blueprint": {
            "required": [
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS Blueprint module let you manage your Blueprint easily. You can create create and delete Blueprint by Name or ID. You can also use it to retrieve all data from a blueprint. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the Blueprint to manage. Only one of I(name) or I(id) can be set."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "build-ready"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the Blueprint."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "reference_arch": {
                "type": "string",
                "description": "When creating a blueprint, this value identifies a known AOS reference architecture value. I(Refer to AOS-server documentation for available values)."
              },
              "timeout": {
                "description": "Default: 5\n\nWhen I(state=build-ready), this timeout identifies timeout in seconds to wait before declaring a failure.",
                "$ref": "#/definitions/ansible_number"
              },
              "id": {
                "type": "string",
                "description": "AOS Id of the IP Pool to manage (can't be used to create a new IP Pool). Only one of I(name) or I(id) can be set."
              },
              "template": {
                "type": "string",
                "description": "When creating a blueprint, this value identifies, by name, an existing engineering design template within the AOS-server."
              }
            }
          },
          "exo_dns_domain": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create and remove domain records.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the record."
              },
              "api_secret": {
                "type": "string",
                "description": "Secret key of the Exoscale DNS API."
              },
              "api_timeout": {
                "description": "Default: 10\n\nHTTP timeout to Exoscale DNS API.",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": "Default: cloudstack\n\nName of the ini section in the C(cloustack.ini) file."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the resource."
              },
              "api_key": {
                "type": "string",
                "description": "API key of the Exoscale DNS API."
              },
              "validate_certs": {
                "description": "Default: True\n\nValidate SSL certs of the Exoscale DNS API.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "win_webpicmd": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Installs packages using Web Platform Installer command-line (http://www.iis.net/learn/install/web-platform-installer/web-platform-installer-v4-command-line-webpicmdexe-rtw-release).\nMust be installed and present in PATH (see win_chocolatey module; 'webpicmd' is the package name, and you must install 'lessmsi' first too)\nInstall IIS first (see win_feature module)",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": ""
              },
              "names": {
                "type": "string",
                "description": "Name of the package to be installed"
              },
              "name": {
                "type": "string",
                "description": "Name of the package to be installed"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "postgresql_privs": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "objs",
                        "obj"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "roles",
                        "role"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "roles"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "role"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "privs",
                        "priv"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "database",
                        "db"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "database"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "db"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "host",
                        "login_host"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "unix_socket",
                        "login_unix_socket"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "login",
                        "login_user"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "login_password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "grant_option",
                        "admin_option"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Grant or revoke privileges on PostgreSQL database objects.\nThis module is basically a wrapper around most of the functionality of PostgreSQL's GRANT and REVOKE statements with detection of changes (GRANT/REVOKE I(privs) ON I(type) I(objs) TO/FROM I(roles))",
            "properties": {
              "objs": {
                "type": "string",
                "description": "Comma separated list of database objects to set privileges on.\nIf I(type) is C(table) or C(sequence), the special value C(ALL_IN_SCHEMA) can be provided instead to specify all database objects of type I(type) in the schema specified via I(schema). (This also works with PostgreSQL < 9.0.)\nIf I(type) is C(database), this parameter can be omitted, in which case privileges are set for the database specified via I(database).\nIf I(type) is I(function), colons (\":\") in object names will be replaced with commas (needed to specify function signatures, see examples)\nAlias: I(obj)"
              },
              "ssl_mode": {
                "enum": [
                  "disable",
                  "allow",
                  "prefer",
                  "require",
                  "verify-ca",
                  "verify-full"
                ],
                "type": "string",
                "description": "Default: prefer\n\nDetermines whether or with what priority a secure SSL TCP/IP connection will be negotiated with the server.\nSee https://www.postgresql.org/docs/current/static/libpq-ssl.html for more information on the modes.\nDefault of C(prefer) matches libpq default."
              },
              "login_user": {
                "type": "string",
                "description": "Default: postgres\n\nThe username to authenticate with.\nAlias: I(login_user)"
              },
              "admin_option": {
                "description": "Whether C(role) may grant/revoke the specified privileges/group memberships to others.\nSet to C(no) to revoke GRANT OPTION, leave unspecified to make no changes.\nI(grant_option) only has an effect if I(state) is C(present).\nAlias: I(admin_option)",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "Default: 5432\n\nDatabase port to connect to.",
                "$ref": "#/definitions/ansible_number"
              },
              "priv": {
                "type": "string",
                "description": "Comma separated list of privileges to grant/revoke.\nAlias: I(priv)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIf C(present), the specified privileges are granted, if C(absent) they are revoked."
              },
              "role": {
                "type": "string",
                "description": "Comma separated list of role (user/group) names to set permissions for.\nThe special value C(PUBLIC) can be provided instead to set permissions for the implicitly defined PUBLIC group.\nAlias: I(role)"
              },
              "type": {
                "enum": [
                  "table",
                  "sequence",
                  "function",
                  "database",
                  "schema",
                  "language",
                  "tablespace",
                  "group"
                ],
                "type": "string",
                "description": "Default: table\n\nType of database object to set privileges on."
              },
              "schema": {
                "type": "string",
                "description": "Schema that contains the database objects specified via I(objs).\nMay only be provided if I(type) is C(table), C(sequence) or C(function). Defaults to  C(public) in these cases."
              },
              "ssl_rootcert": {
                "type": "string",
                "description": "Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities."
              },
              "login_host": {
                "type": "string",
                "description": "Database host address. If unspecified, connect via Unix socket.\nAlias: I(login_host)"
              },
              "db": {
                "type": "string",
                "description": "Name of database to connect to.\nAlias: I(db)"
              },
              "login_unix_socket": {
                "type": "string",
                "description": "Path to a Unix domain socket for local connections.\nAlias: I(login_unix_socket)"
              },
              "host": {
                "type": "string",
                "description": "Database host address. If unspecified, connect via Unix socket.\nAlias: I(login_host)"
              },
              "login_password": {
                "type": "string",
                "description": "The password to authenticate with.\nAlias: I(login_password))"
              },
              "password": {
                "type": "string",
                "description": "The password to authenticate with.\nAlias: I(login_password))"
              },
              "grant_option": {
                "description": "Whether C(role) may grant/revoke the specified privileges/group memberships to others.\nSet to C(no) to revoke GRANT OPTION, leave unspecified to make no changes.\nI(grant_option) only has an effect if I(state) is C(present).\nAlias: I(admin_option)",
                "$ref": "#/definitions/ansible_truth"
              },
              "obj": {
                "type": "string",
                "description": "Comma separated list of database objects to set privileges on.\nIf I(type) is C(table) or C(sequence), the special value C(ALL_IN_SCHEMA) can be provided instead to specify all database objects of type I(type) in the schema specified via I(schema). (This also works with PostgreSQL < 9.0.)\nIf I(type) is C(database), this parameter can be omitted, in which case privileges are set for the database specified via I(database).\nIf I(type) is I(function), colons (\":\") in object names will be replaced with commas (needed to specify function signatures, see examples)\nAlias: I(obj)"
              },
              "roles": {
                "type": "string",
                "description": "Comma separated list of role (user/group) names to set permissions for.\nThe special value C(PUBLIC) can be provided instead to set permissions for the implicitly defined PUBLIC group.\nAlias: I(role)"
              },
              "privs": {
                "type": "string",
                "description": "Comma separated list of privileges to grant/revoke.\nAlias: I(priv)"
              },
              "database": {
                "type": "string",
                "description": "Name of database to connect to.\nAlias: I(db)"
              },
              "unix_socket": {
                "type": "string",
                "description": "Path to a Unix domain socket for local connections.\nAlias: I(login_unix_socket)"
              },
              "login": {
                "type": "string",
                "description": "Default: postgres\n\nThe username to authenticate with.\nAlias: I(login_user)"
              }
            }
          },
          "svr4pkg": {
            "required": [
              "state",
              "name"
            ],
            "type": "object",
            "description": "Manages SVR4 packages on Solaris 10 and 11.\nThese were the native packages on Solaris <= 10 and are available as a legacy feature in Solaris 11.\nNote that this is a very basic packaging system. It will not enforce dependencies on install or remove.",
            "properties": {
              "category": {
                "description": "Install/Remove category instead of a single package.",
                "$ref": "#/definitions/ansible_truth"
              },
              "src": {
                "type": "string",
                "description": "Specifies the location to install the package from. Required when C(state=present).\nCan be any path acceptable to the C(pkgadd) command's C(-d) option. e.g.: C(somefile.pkg), C(/dir/with/pkgs), C(http:/server/mypkgs.pkg).\nIf using a file or directory, they must already be accessible by the host. See the M(copy) module for a way to get them there."
              },
              "name": {
                "type": "string",
                "description": "Package name, e.g. C(SUNWcsr)"
              },
              "zone": {
                "enum": [
                  "current",
                  "all"
                ],
                "type": "string",
                "description": "Default: all\n\nWhether to install the package only in the current zone, or install it into all zones.\nThe installation into all zones works only if you are working with the global zone."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether to install (C(present)), or remove (C(absent)) a package.\nIf the package is to be installed, then I(src) is required.\nThe SVR4 package system doesn't provide an upgrade operation. You need to uninstall the old, then install the new package."
              },
              "proxy": {
                "type": "string",
                "description": "HTTP[s] proxy to be used if C(src) is a URL."
              },
              "response_file": {
                "type": "string",
                "description": "Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)"
              }
            }
          },
          "os_volume": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "display_name",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "display_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "verify",
                        "validate_certs"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "display_description",
                        "description"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or Remove cinder block storage volumes",
            "properties": {
              "auth_type": {
                "type": "string",
                "description": ""
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "image": {
                "type": "string",
                "description": "Default: None\n\nImage name or id for boot from volume"
              },
              "snapshot_id": {
                "type": "string",
                "description": "Default: None\n\nVolume snapshot id to create from"
              },
              "cloud": {
                "type": "string",
                "description": ""
              },
              "size": {
                "type": "string",
                "description": "Default: None\n\nSize of volume in GB. This parameter is required when the I(state) parameter is 'present'."
              },
              "display_name": {
                "type": "string",
                "description": "Name of volume"
              },
              "verify": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "display_description": {
                "type": "string",
                "description": "Default: None\n\nString describing the volume"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nString describing the volume"
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "volume": {
                "type": "string",
                "description": "Default: None\n\nVolume name or id to create from"
              },
              "endpoint_type": {
                "enum": [
                  "public",
                  "internal",
                  "admin"
                ],
                "type": "string",
                "description": ""
              },
              "key": {
                "type": "string",
                "description": ""
              },
              "cacert": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of volume"
              },
              "region_name": {
                "type": "string",
                "description": ""
              },
              "volume_type": {
                "type": "string",
                "description": "Default: None\n\nVolume type for volume"
              },
              "cert": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "tower_job_cancel": {
            "type": "object",
            "description": "Cancel Ansible Tower jobs. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "job_id": {
                "type": "string",
                "description": "ID of the job to cancel"
              },
              "fail_if_not_running": {
                "type": "string",
                "description": "Fail loudly if the job_id does not reference a running job."
              }
            }
          },
          "gluster_volume": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "bricks",
                        "brick"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "volume"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "volume"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, remove, start, stop and tune GlusterFS volumes",
            "properties": {
              "force": {
                "description": "If brick is being created in the root partition, module will fail. Set force to true to override this behaviour",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The volume name"
              },
              "replicas": {
                "description": "Replica count for volume",
                "$ref": "#/definitions/ansible_number"
              },
              "bricks": {
                "type": "string",
                "description": "Brick paths on servers. Multiple brick paths can be separated by commas"
              },
              "disperses": {
                "description": "Disperse count for volume",
                "$ref": "#/definitions/ansible_number"
              },
              "quota": {
                "type": "string",
                "description": "Quota value for limit-usage (be sure to use 10.0MB instead of 10MB, see quota list)"
              },
              "stripes": {
                "description": "Stripe count for volume",
                "$ref": "#/definitions/ansible_number"
              },
              "volume": {
                "type": "string",
                "description": "The volume name"
              },
              "cluster": {
                "description": "List of hosts to use for probing and brick setup",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": "Override local hostname (for peer probing purposes)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "started",
                  "stopped",
                  "rebalanced"
                ],
                "type": "string",
                "description": "Use present/absent ensure if a volume exists or not, use started/stopped to control it's availability."
              },
              "start_on_create": {
                "description": "Default: yes\n\nControls whether the volume is started after creation or not, defaults to yes",
                "$ref": "#/definitions/ansible_truth"
              },
              "redundancies": {
                "description": "Redundancy count for volume",
                "$ref": "#/definitions/ansible_number"
              },
              "directory": {
                "type": "string",
                "description": "Directory for limit-usage"
              },
              "brick": {
                "type": "string",
                "description": "Brick paths on servers. Multiple brick paths can be separated by commas"
              },
              "rebalance": {
                "description": "Default: no\n\nControls whether the cluster is rebalanced after changes",
                "$ref": "#/definitions/ansible_truth"
              },
              "options": {
                "type": "object",
                "description": "A dictionary/hash with options/settings for the volume"
              },
              "transport": {
                "enum": [
                  "tcp",
                  "rdma",
                  "tcp,rdma"
                ],
                "type": "string",
                "description": "Default: tcp\n\nTransport type for volume"
              }
            }
          },
          "systemd": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "unit",
                        "service"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "unit"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "service"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "daemon_reload",
                        "daemon-reload"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Controls systemd services on remote hosts.",
            "properties": {
              "no_block": {
                "description": "Do not synchronously wait for the requested operation to finish. Enqueued job will continue without Ansible blocking on its completion.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the service. When using in a chroot environment you always need to specify the full name i.e. (crond.service)."
              },
              "service": {
                "type": "string",
                "description": "Name of the service. When using in a chroot environment you always need to specify the full name i.e. (crond.service)."
              },
              "enabled": {
                "description": "Whether the service should start on boot. B(At least one of state and enabled are required.)",
                "$ref": "#/definitions/ansible_truth"
              },
              "daemon_reload": {
                "description": "run daemon-reload before doing any other operations, to make sure systemd has read any changes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "restarted",
                  "reloaded"
                ],
                "type": "string",
                "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. C(restarted) will always bounce the service. C(reloaded) will always reload."
              },
              "daemon-reload": {
                "description": "run daemon-reload before doing any other operations, to make sure systemd has read any changes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "user": {
                "description": "run systemctl talking to the service manager of the calling user, rather than the service manager of the system.",
                "$ref": "#/definitions/ansible_truth"
              },
              "unit": {
                "type": "string",
                "description": "Name of the service. When using in a chroot environment you always need to specify the full name i.e. (crond.service)."
              },
              "masked": {
                "description": "Whether the unit should be masked or not, a masked unit is impossible to start.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cs_sshkeypair": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, register and remove SSH keys.\nIf no key was found and no public key was provided and a new SSH private/public key pair will be created and the private key will be returned.",
            "properties": {
              "public_key": {
                "type": "string",
                "description": "String of the public key."
              },
              "account": {
                "type": "string",
                "description": "Account the public key is related to."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the public key to be registered in."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the public key."
              },
              "domain": {
                "type": "string",
                "description": "Domain the public key is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of public key."
              }
            }
          },
          "group": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manage presence of groups on a host.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the group should be present or not on the remote host."
              },
              "gid": {
                "type": "string",
                "description": "Optional I(GID) to set for the group."
              },
              "system": {
                "description": "Default: no\n\nIf I(yes), indicates that the group created is a system group.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the group to manage."
              }
            }
          },
          "tower_job_wait": {
            "type": "object",
            "description": "Wait for Ansible Tower job to finish and report success or failure. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "min_interval": {
                "type": "string",
                "description": "Default: 1\n\nMinimum interval in seconds, to request an update from Tower."
              },
              "max_interval": {
                "type": "string",
                "description": "Default: 30\n\nMaximum interval in seconds, to request an update from Tower."
              },
              "job_id": {
                "type": "string",
                "description": "ID of the job to monitor."
              },
              "timeout": {
                "type": "string",
                "description": "Maximum time in seconds to wait for a job to finish."
              }
            }
          },
          "tempfile": {
            "type": "object",
            "description": "The C(tempfile) module creates temporary files and directories. C(mktemp) command takes different parameters on various systems, this module helps to avoid troubles related to that. Files/directories created by module are accessible only by creator. In case you need to make them world-accessible you need to use M(file) module.",
            "properties": {
              "path": {
                "type": "string",
                "description": "Location where temporary file or directory should be created. If path is not specified default system temporary directory will be used."
              },
              "prefix": {
                "type": "string",
                "description": "Default: ansible.\n\nPrefix of file/directory name created by module."
              },
              "suffix": {
                "type": "string",
                "description": "Suffix of file/directory name created by module."
              },
              "state": {
                "enum": [
                  "file",
                  "directory"
                ],
                "type": "string",
                "description": "Default: file\n\nWhether to create file or directory."
              }
            }
          },
          "icinga2_feature": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Enable or disable an Icinga2 feature",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nApply feature state."
              },
              "name": {
                "type": "string",
                "description": "This is the feature name to enable or disable."
              }
            }
          },
          "netapp_e_flashcache": {
            "required": [
              "api_password",
              "name",
              "ssid",
              "api_url",
              "api_username"
            ],
            "type": "object",
            "description": "Create or remove SSD caches on a NetApp E-Series storage array.",
            "properties": {
              "cache_size_min": {
                "description": "The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "The name of the SSD cache to manage"
              },
              "log_path": {
                "type": "string",
                "description": ""
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "io_type": {
                "enum": [
                  "filesystem",
                  "database",
                  "media"
                ],
                "type": "string",
                "description": "Default: filesystem\n\nThe type of workload to optimize the cache for."
              },
              "disk_count": {
                "description": "The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place",
                "$ref": "#/definitions/ansible_number"
              },
              "size_unit": {
                "enum": [
                  "bytes",
                  "b",
                  "kb",
                  "mb",
                  "gb",
                  "tb",
                  "pb",
                  "eb",
                  "zb",
                  "yb"
                ],
                "type": "string",
                "description": "Default: gb\n\nThe unit to be applied to size arguments"
              },
              "log_mode": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the specified SSD cache should exist or not."
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "disk_refs": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "criteria_disk_phy_type": {
                "enum": [
                  "sas",
                  "sas4k",
                  "fibre",
                  "fibre520b",
                  "scsi",
                  "sata",
                  "pata"
                ],
                "type": "string",
                "description": ""
              },
              "ssid": {
                "type": "string",
                "description": "The ID of the array to manage (as configured on the web services proxy)."
              }
            }
          },
          "keystone_user": {
            "type": "object",
            "description": "Manage users,tenants, roles from OpenStack.",
            "properties": {
              "tenant_description": {
                "type": "string",
                "description": "Default: None\n\nA description for the tenant"
              },
              "endpoint": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone url for authentication"
              },
              "region_name": {
                "type": "string",
                "description": ""
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "login_user": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "token": {
                "type": "string",
                "description": "Default: None\n\nThe token to be uses in case the password is not specified"
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: None\n\nThe tenant login_user belongs to"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "role": {
                "type": "string",
                "description": "Default: None\n\nThe name of the role to be assigned or created"
              },
              "user": {
                "type": "string",
                "description": "Default: None\n\nThe name of the user that has to added/removed from OpenStack"
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\nPassword of login user"
              },
              "login_username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": "Default: None\n\nThe password to be assigned to the user"
              },
              "email": {
                "type": "string",
                "description": "Default: None\n\nAn email address for the user"
              },
              "tenant": {
                "type": "string",
                "description": "Default: None\n\nThe tenant name that has be added/removed"
              }
            }
          },
          "a10_server": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_ip",
                        "ip",
                        "address"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_name",
                        "server"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "server_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "server"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_status",
                        "status"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_ports",
                        "port"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage slb server objects on A10 Networks devices via aXAPI",
            "properties": {
              "status": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enabled\n\nslb virtual server status"
              },
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "server_ports": {
                "description": "A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:), but can also optionally specify the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).",
                "$ref": "#/definitions/ansible_array"
              },
              "ip": {
                "type": "string",
                "description": "slb server IP address"
              },
              "pass": {
                "type": "string",
                "description": "admin password of your A10 Networks device"
              },
              "port": {
                "description": "A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:), but can also optionally specify the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).",
                "$ref": "#/definitions/ansible_array"
              },
              "client_key": {
                "type": "string",
                "description": ""
              },
              "use_proxy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "server_name": {
                "type": "string",
                "description": "slb server name"
              },
              "server_status": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enabled\n\nslb virtual server status"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\ncreate, update or remove slb server"
              },
              "write_config": {
                "description": "Default: no\n\nIf C(yes), any changes will cause a write of the running configuration to non-volatile memory. This will save I(all) configuration changes, including those that may have been made manually or through other modules, so care should be taken when specifying C(yes).",
                "$ref": "#/definitions/ansible_truth"
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": "admin account of your A10 Networks device"
              },
              "server_ip": {
                "type": "string",
                "description": "slb server IP address"
              },
              "force_basic_auth": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": "hostname or ip of your A10 Networks device"
              },
              "user": {
                "type": "string",
                "description": "admin account of your A10 Networks device"
              },
              "address": {
                "type": "string",
                "description": "slb server IP address"
              },
              "password": {
                "type": "string",
                "description": "admin password of your A10 Networks device"
              },
              "url_password": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": "admin account of your A10 Networks device"
              },
              "pwd": {
                "type": "string",
                "description": "admin password of your A10 Networks device"
              },
              "server": {
                "type": "string",
                "description": "slb server name"
              },
              "url": {
                "type": "string",
                "description": ""
              },
              "url_username": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "avi_pkiprofile": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure PKIProfile object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "crls": {
                "description": "Certificate revocation lists.",
                "$ref": "#/definitions/ansible_array"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "uuid": {
                "type": "string",
                "description": "Unique object identifier of the object."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "ignore_peer_chain": {
                "description": "When enabled, avi will not trust intermediate and root certs presented by a client.\nInstead, only the chain certs configured in the certificate authority section will be used to verify trust of the client's cert.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "created_by": {
                "type": "string",
                "description": "Creator name."
              },
              "ca_certs": {
                "description": "List of certificate authorities (root and intermediate) trusted that is used for certificate validation.",
                "$ref": "#/definitions/ansible_array"
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "validate_only_leaf_crl": {
                "description": "When enabled, avi will only validate the revocation status of the leaf certificate using crl.\nTo enable validation for the entire chain, disable this option and provide all the relevant crls.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "crl_check": {
                "description": "When enabled, avi will verify via crl checks that certificates in the trust chain have not been revoked.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the pki profile."
              }
            }
          },
          "webfaction_app": {
            "required": [
              "name",
              "login_name",
              "login_password",
              "type"
            ],
            "type": "object",
            "description": "Add or remove applications on a Webfaction host.  Further documentation at http://github.com/quentinsf/ansible-webfaction.",
            "properties": {
              "name": {
                "type": "string",
                "description": "The name of the application"
              },
              "port_open": {
                "description": "IF the port should be opened",
                "$ref": "#/definitions/ansible_truth"
              },
              "machine": {
                "type": "string",
                "description": "The machine name to use (optional for accounts with only one machine)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the application should exist"
              },
              "autostart": {
                "description": "Default: no\n\nWhether the app should restart with an autostart.cgi script",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_password": {
                "type": "string",
                "description": "The webfaction password to use"
              },
              "type": {
                "type": "string",
                "description": "The type of application to create. See the Webfaction docs at http://docs.webfaction.com/xmlrpc-api/apps.html for a list."
              },
              "login_name": {
                "type": "string",
                "description": "The webfaction account to use"
              },
              "extra_info": {
                "type": "string",
                "description": "Any extra parameters required by the app"
              }
            }
          },
          "mqtt": {
            "required": [
              "payload",
              "topic"
            ],
            "type": "object",
            "description": "Publish a message on an MQTT topic.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username to authenticate against the broker."
              },
              "qos": {
                "enum": [
                  "0",
                  "1",
                  "2"
                ],
                "type": "string",
                "description": "QoS (Quality of Service)"
              },
              "port": {
                "description": "Default: 1883\n\nMQTT broker port number",
                "$ref": "#/definitions/ansible_number"
              },
              "server": {
                "type": "string",
                "description": "Default: localhost\n\nMQTT broker address/name"
              },
              "topic": {
                "type": "string",
                "description": "MQTT topic name"
              },
              "client_id": {
                "type": "string",
                "description": "Default: hostname + pid\n\nMQTT client identifier"
              },
              "retain": {
                "description": "Setting this flag causes the broker to retain (i.e. keep) the message so that applications that subsequently subscribe to the topic can received the last retained message immediately.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "Password for C(username) to authenticate against the broker."
              },
              "payload": {
                "type": "string",
                "description": "Payload. The special string C(\"None\") may be used to send a NULL (i.e. empty) payload which is useful to simply notify with the I(topic) or to clear previously retained messages."
              }
            }
          },
          "gem": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "repository",
                        "source"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage installation and uninstallation of Ruby gems.",
            "properties": {
              "include_dependencies": {
                "description": "Default: yes\n\nWhether to include dependencies or not.",
                "$ref": "#/definitions/ansible_truth"
              },
              "executable": {
                "type": "string",
                "description": "Override the path to the gem executable"
              },
              "name": {
                "type": "string",
                "description": "The name of the gem to be managed."
              },
              "repository": {
                "type": "string",
                "description": "The repository from which the gem will be installed"
              },
              "build_flags": {
                "type": "string",
                "description": "Allow adding build flags for gem compilation"
              },
              "include_doc": {
                "description": "Default: no\n\nInstall with or without docs.",
                "$ref": "#/definitions/ansible_truth"
              },
              "user_install": {
                "description": "Default: yes\n\nInstall gem in user's local gems cache or for all users",
                "$ref": "#/definitions/ansible_truth"
              },
              "pre_release": {
                "description": "Default: no\n\nAllow installation of pre-release versions of the gem.",
                "$ref": "#/definitions/ansible_truth"
              },
              "env_shebang": {
                "description": "Default: no\n\nRewrite the shebang line on installed scripts to use /usr/bin/env.",
                "$ref": "#/definitions/ansible_truth"
              },
              "source": {
                "type": "string",
                "description": "The repository from which the gem will be installed"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "latest"
                ],
                "type": "string",
                "description": "Default: present\n\nThe desired state of the gem. C(latest) ensures that the latest version is installed."
              },
              "version": {
                "type": "string",
                "description": "Version of the gem to be installed/removed."
              },
              "gem_source": {
                "type": "string",
                "description": "The path to a local gem used as installation source."
              }
            }
          },
          "iam_server_certificate_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Retrieve the attributes of a server certificate",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the server certificate you are retrieving attributes for."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "gcspanner": {
            "required": [
              "instance_id",
              "configuration"
            ],
            "type": "object",
            "description": "Create and Delete Instances/Databases on Spanner. See U(https://cloud.google.com/spanner/docs) for an overview.",
            "properties": {
              "configuration": {
                "type": "string",
                "description": "Configuration the instance should use. Examples are us-central1, asia-east1 and europe-west1."
              },
              "service_account_email": {
                "type": "string",
                "description": ""
              },
              "database_name": {
                "type": "string",
                "description": "Name of database contained on the instance."
              },
              "force_instance_delete": {
                "description": "To delete an instance, this argument must exist and be true (along with state being equal to absent).",
                "$ref": "#/definitions/ansible_truth"
              },
              "instance_id": {
                "type": "string",
                "description": "GCP spanner instance name."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the instance or database (absent, present). Applies to the most granular resource. If a database_name is specified we remove it.  If only instance_id is specified, that is what is removed."
              },
              "credentials_file": {
                "type": "string",
                "description": ""
              },
              "node_count": {
                "description": "Number of nodes in the instance.  If not specified while creating an instance, node_count will be set to 1.",
                "$ref": "#/definitions/ansible_number"
              },
              "project_id": {
                "type": "string",
                "description": ""
              },
              "instance_display_name": {
                "type": "string",
                "description": "Name of Instance to display.  If not specified, instance_id will be used instead."
              }
            }
          },
          "mail": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sender",
                        "from"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "subject",
                        "msg"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "subject"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "msg"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "to",
                        "recipients"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module is useful for sending emails from playbooks.\nOne may wonder why automate sending emails?  In complex environments there are from time to time processes that cannot be automated, either because you lack the authority to make it so, or because not everyone agrees to a common approach.\nIf you cannot automate a specific step, but the step is non-blocking, sending out an email to the responsible party to make him perform his part of the bargain is an elegant way to put the responsibility in someone else's lap.\nOf course sending out a mail can be equally useful as a way to notify one or more people in a team that a specific action has been (successfully) taken.",
            "properties": {
              "body": {
                "type": "string",
                "description": "Default: $subject\n\nThe body of the email being sent."
              },
              "username": {
                "type": "string",
                "description": "If SMTP requires username"
              },
              "from": {
                "type": "string",
                "description": "Default: root\n\nThe email-address the mail is sent from. May contain address and phrase."
              },
              "sender": {
                "type": "string",
                "description": "Default: root\n\nThe email-address the mail is sent from. May contain address and phrase."
              },
              "recipients": {
                "type": "string",
                "description": "Default: root\n\nThe email-address(es) the mail is being sent to. This is a comma-separated list, which may contain address and phrase portions."
              },
              "to": {
                "type": "string",
                "description": "Default: root\n\nThe email-address(es) the mail is being sent to. This is a comma-separated list, which may contain address and phrase portions."
              },
              "cc": {
                "type": "string",
                "description": "The email-address(es) the mail is being copied to. This is a comma-separated list, which may contain address and phrase portions."
              },
              "charset": {
                "type": "string",
                "description": "Default: us-ascii\n\nThe character set of email being sent"
              },
              "bcc": {
                "type": "string",
                "description": "The email-address(es) the mail is being 'blind' copied to. This is a comma-separated list, which may contain address and phrase portions."
              },
              "headers": {
                "type": "string",
                "description": "A vertical-bar-separated list of headers which should be added to the message. Each individual header is specified as C(header=value) (see example below)."
              },
              "attach": {
                "type": "string",
                "description": "A space-separated list of pathnames of files to attach to the message. Attached files will have their content-type set to C(application/octet-stream)."
              },
              "host": {
                "type": "string",
                "description": "Default: localhost\n\nThe mail server"
              },
              "subtype": {
                "type": "string",
                "description": "Default: plain\n\nThe minor mime type, can be either text or html. The major type is always text."
              },
              "msg": {
                "type": "string",
                "description": "The subject of the email being sent."
              },
              "password": {
                "type": "string",
                "description": "If SMTP requires password"
              },
              "port": {
                "type": "string",
                "description": "Default: 25\n\nThe mail server port"
              },
              "subject": {
                "type": "string",
                "description": "The subject of the email being sent."
              }
            }
          },
          "win_iis_webbinding": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, Removes and configures a binding to an existing IIS Web site",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "State of the binding"
              },
              "names": {
                "type": "string",
                "description": "Names of web site"
              },
              "name": {
                "type": "string",
                "description": "Names of web site"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "gce_eip": {
            "required": [
              "name",
              "region"
            ],
            "type": "object",
            "description": "Create (reserve) or Destroy (release) Regional or Global IP Addresses. See U(https://cloud.google.com/compute/docs/configure-instance-ip-addresses#reserve_new_static) for more on reserving static addresses.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of Address."
              },
              "service_account_email": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": "Region to create the address in. Set to 'global' to create a global address."
              },
              "service_account_permissions": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "pem_file": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state the address should be in. C(present) or C(absent) are the only valid options."
              },
              "credentials_file": {
                "type": "string",
                "description": ""
              },
              "project_id": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ovirt_quotas_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt quotas.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the quota, can be used as glob expression."
              },
              "data_center": {
                "type": "string",
                "description": "Name of the datacenter where quota resides."
              }
            }
          },
          "apt_repository": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove an APT repositories in Ubuntu and Debian.",
            "properties": {
              "install_python_apt": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "filename": {
                "type": "string",
                "description": "Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added."
              },
              "repo": {
                "type": "string",
                "description": "Default: none\n\nA source string for the repository."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nA source string state."
              },
              "update_cache": {
                "description": "Default: yes\n\nRun the equivalent of C(apt-get update) when a change occurs.  Cache updates are run after making changes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "mode": {
                "type": "string",
                "description": "Default: 420\n\nThe octal mode for newly created files in sources.list.d"
              },
              "update-cache": {
                "description": "Default: yes\n\nRun the equivalent of C(apt-get update) when a change occurs.  Cache updates are run after making changes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "codename": {
                "type": "string",
                "description": "Override the distribution codename to use for PPA repositories. Should usually only be set when working with a PPA on a non-Ubuntu target (e.g. Debian or Mint)"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates for the target repo will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_vmpools": {
            "required": [
              "auth",
              "name"
            ],
            "type": "object",
            "description": "Module to manage VM pools in oVirt.",
            "properties": {
              "comment": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Name of the the VM pool to manage."
              },
              "description": {
                "type": "string",
                "description": "Description of the VM pool."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the VM pool be present/absent.\nNote that when C(state) is I(absent) all VMs in VM pool are stopped and removed."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "vm_per_user": {
                "description": "Maximum number of VMs a single user can attach to from this pool.\nDefault value is set by engine.",
                "$ref": "#/definitions/ansible_number"
              },
              "cluster": {
                "type": "string",
                "description": "Name of the cluster, where VM pool should be created."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "prestarted": {
                "description": "Number of pre-started VMs defines the number of VMs in run state, that are waiting to be attached to Users.\nDefault value is set by engine.",
                "$ref": "#/definitions/ansible_number"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "template": {
                "type": "string",
                "description": "Name of the template, which will be used to create VM pool."
              },
              "vm_count": {
                "description": "Number of VMs in the pool.\nDefault value is set by engine.",
                "$ref": "#/definitions/ansible_number"
              },
              "type": {
                "enum": [
                  "manual",
                  "automatic"
                ],
                "type": "string",
                "description": "Type of the VM pool. Either manual or automatic.\nC(manual) - The administrator is responsible for explicitly returning the virtual machine to the pool. The virtual machine reverts to the original base image after the administrator returns it to the pool.\nC(Automatic) - When the virtual machine is shut down, it automatically reverts to its base image and is returned to the virtual machine pool.\nDefault value is set by engine."
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "azure_rm_publicip_facts": {
            "type": "object",
            "description": "Get facts for a specific public IP or all public IPs within a resource group.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Only show results for a specific Public IP."
              },
              "resource_group": {
                "type": "string",
                "description": "Limit results by resource group. Required when using name parameter."
              },
              "tags": {
                "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
                "$ref": "#/definitions/ansible_array"
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "gce_mig": {
            "required": [
              "name",
              "zone"
            ],
            "type": "object",
            "description": "Create, Update or Destroy a Managed Instance Group (MIG).  See U(https://cloud.google.com/compute/docs/instance-groups) for an overview. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.",
            "properties": {
              "service_account_permissions": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Name of the Managed Instance Group."
              },
              "zone": {
                "type": "string",
                "description": "The GCE zone to use for this Managed Instance Group."
              },
              "service_account_email": {
                "type": "string",
                "description": "service account email"
              },
              "autoscaling": {
                "type": "object",
                "description": "A dictionary of configuration for the autoscaler. 'enabled (bool)', 'name (str)' and policy.max_instances (int) are required fields if autoscaling is used. See U(https://cloud.google.com/compute/docs/reference/beta/autoscalers) for more information on Autoscaling."
              },
              "recreate_instances": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "pem_file": {
                "type": "string",
                "description": ""
              },
              "named_ports": {
                "description": "Define named ports that backend services can forward data to.  Format is a a list of name:port dictionaries.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\ndesired state of the resource"
              },
              "template": {
                "type": "string",
                "description": "Instance Template to be used in creating the VMs.  See U(https://cloud.google.com/compute/docs/instance-templates) to learn more about Instance Templates.  Required for creating MIGs."
              },
              "credentials_file": {
                "type": "string",
                "description": "Path to the JSON file associated with the service account email"
              },
              "project_id": {
                "type": "string",
                "description": "GCE project ID"
              },
              "size": {
                "description": "Size of Managed Instance Group.  If MIG already exists, it will be resized to the number provided here.  Required for creating MIGs.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "quantum_router_interface": {
            "required": [
              "login_password",
              "subnet_name",
              "router_name"
            ],
            "type": "object",
            "description": "Attach/Detach a subnet interface to a router, to provide a gateway for the subnet.",
            "properties": {
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nName of the region"
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": "Default: None\n\nName of the tenant whose subnet has to be attached."
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: yes\n\nThe tenant name of the login user"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone URL for authentication"
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\nPassword of login user"
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "subnet_name": {
                "type": "string",
                "description": "Default: None\n\nName of the subnet to whose interface should be attached to the router."
              },
              "router_name": {
                "type": "string",
                "description": "Default: None\n\nName of the router to which the subnet's interface should be attached."
              }
            }
          },
          "ec2_ami_copy": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Copies AMI from a source region to a destination region. This module has a dependency on python-boto >= 2.5",
            "properties": {
              "encrypted": {
                "description": "Whether or not to encrypt the target image",
                "$ref": "#/definitions/ansible_truth"
              },
              "kms_key_id": {
                "type": "string",
                "description": "KMS key id used to encrypt image. If not specified, uses default EBS Customer Master Key (CMK) for your account."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "source_image_id": {
                "type": "string",
                "description": "the id of the image in source region that should be copied"
              },
              "wait": {
                "description": "Default: no\n\nwait for the copied AMI to be in state 'available' before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "An optional human-readable string describing the contents and purpose of the new AMI."
              },
              "tags": {
                "type": "object",
                "description": "a hash/dictionary of tags to add to the new copied AMI; '{\"key\":\"value\"}' and '{\"key\":\"value\",\"key\":\"value\"}'"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 1200\n\nhow long before wait gives up, in seconds"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the new image to copy"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "source_region": {
                "type": "string",
                "description": "the source region that AMI should be copied from"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "pushover": {
            "required": [
              "msg",
              "user_key",
              "app_token"
            ],
            "type": "object",
            "description": "Send notifications via pushover, to subscriber list of devices, and email addresses. Requires pushover app on devices.",
            "properties": {
              "msg": {
                "type": "string",
                "description": "What message you wish to send."
              },
              "user_key": {
                "type": "string",
                "description": "Pushover issued authentication key for your user."
              },
              "app_token": {
                "type": "string",
                "description": "Pushover issued token identifying your pushover app."
              },
              "pri": {
                "enum": [
                  "-2",
                  "-1",
                  "0",
                  "1",
                  "2"
                ],
                "type": "string",
                "description": "Message priority (see U(https://pushover.net) for details.)"
              }
            }
          },
          "dellos9_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends arbitrary commands to a Dell OS9 node and returns the results read from the device. This  module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.\nThis module does not support running commands in configuration mode. Please use M(dellos9_config) to configure Dell OS9 devices.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.",
                "$ref": "#/definitions/ansible_number"
              },
              "commands": {
                "description": "List of commands to send to the remote dellos9 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "wait_for": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "all",
                  "any"
                ],
                "type": "string",
                "description": ""
              },
              "waitfor": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "cnos_image": {
            "type": "object",
            "description": "This module allows you to work with switch firmware images. It provides a way to download a firmware image to a network device from a remote server using FTP, SFTP, TFTP, or SCP. The first step is to create a directory from where the remote server can be reached. The next step is to provide the full file path of the image’s location. Authentication details required by the remote server must be provided as well. By default, this method makes the newly downloaded firmware image the active image, which will be used by the switch during the next restart. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_image.html)",
            "properties": {
              "serverpassword": {
                "type": "string",
                "description": "Specify the password for the server relating to the protocol used."
              },
              "protocol": {
                "type": "string",
                "description": "This refers to the protocol used by the network device to interact with the remote server from where to download the firmware image. The choices are FTP, SFTP, TFTP, or SCP. Any other protocols will result in error. If this parameter is not specified, there is no default value to be used."
              },
              "serverip": {
                "type": "string",
                "description": "This specifies the IP Address of the remote server from where the software image will be downloaded."
              },
              "imgpath": {
                "type": "string",
                "description": "This specifies the full file path of the image located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified."
              },
              "serverusername": {
                "type": "string",
                "description": "Specify the username for the server relating to the protocol used."
              },
              "imgtype": {
                "type": "string",
                "description": "This specifies the firmware image type to be downloaded"
              }
            }
          },
          "dladm_linkprop": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "property",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "property"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "link",
                        "nic",
                        "interface"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "link"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "nic"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "interface"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Set / reset link properties on Solaris/illumos systems.",
            "properties": {
              "temporary": {
                "description": "Specifies that lin property configuration is temporary. Temporary link property configuration does not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Specifies the name of the property we want to manage."
              },
              "nic": {
                "type": "string",
                "description": "Link interface name."
              },
              "value": {
                "type": "string",
                "description": "Specifies the value we want to set for the link property."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "reset"
                ],
                "type": "string",
                "description": "Default: present\n\nSet or reset the property value."
              },
              "link": {
                "type": "string",
                "description": "Link interface name."
              },
              "interface": {
                "type": "string",
                "description": "Link interface name."
              },
              "property": {
                "type": "string",
                "description": "Specifies the name of the property we want to manage."
              }
            }
          },
          "sts_assume_role": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Assume a role using AWS Security Token Service and obtain temporary credentials",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "role_arn": {
                "type": "string",
                "description": "The Amazon Resource Name (ARN) of the role that the caller is assuming (http://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html#Identifiers_ARNs)"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "duration_seconds": {
                "description": "The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "role_session_name": {
                "type": "string",
                "description": "Name of the role's session - will be used by CloudTrail"
              },
              "mfa_token": {
                "type": "string",
                "description": "The value provided by the MFA device, if the trust policy of the role being assumed requires MFA."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "policy": {
                "type": "string",
                "description": "Supplemental policy to use in addition to assumed role's policies."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "external_id": {
                "type": "string",
                "description": "A unique identifier that is used by third parties to assume a role in their customers' accounts."
              },
              "mfa_serial_number": {
                "type": "string",
                "description": "he identification number of the MFA device that is associated with the user who is making the AssumeRole call."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "rax_cdb_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "create / delete a database in the Cloud Databases.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": "Default: %\n\nSpecifies the host from which a user is allowed to connect to the database. Possible values are a string containing an IPv4 address or \"%\" to allow connecting from any host"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "db_password": {
                "type": "string",
                "description": "Database user password"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "cdb_id": {
                "type": "string",
                "description": "The databases server UUID"
              },
              "db_username": {
                "type": "string",
                "description": "Name of the database user"
              },
              "databases": {
                "description": "Name of the databases that the user can access",
                "$ref": "#/definitions/ansible_array"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "proxmox": {
            "required": [
              "vmid",
              "api_host",
              "api_user"
            ],
            "type": "object",
            "description": "allows you to create/delete/stop instances in Proxmox VE cluster\nStarting in Ansible 2.1, it automatically detects containerization type (lxc for PVE 4, openvz for older)",
            "properties": {
              "force": {
                "description": "forcing operations\ncan be used only with states C(present), C(stopped), C(restarted)\nwith C(state=present) force option allow to overwrite existing container\nwith states C(stopped) , C(restarted) allow to force stop instance",
                "$ref": "#/definitions/ansible_truth"
              },
              "cpus": {
                "description": "Default: 1\n\nnumbers of allocated cpus for instance",
                "$ref": "#/definitions/ansible_number"
              },
              "ostemplate": {
                "type": "string",
                "description": "the template for VM creating\nrequired only for C(state=present)"
              },
              "disk": {
                "type": "string",
                "description": "Default: 3\n\nhard disk size in GB for instance"
              },
              "searchdomain": {
                "type": "string",
                "description": "sets DNS search domain for a container"
              },
              "api_user": {
                "type": "string",
                "description": "the user to authenticate with"
              },
              "hostname": {
                "type": "string",
                "description": "the instance hostname\nrequired only for C(state=present)"
              },
              "storage": {
                "type": "string",
                "description": "Default: local\n\ntarget storage"
              },
              "state": {
                "enum": [
                  "present",
                  "started",
                  "absent",
                  "stopped",
                  "restarted"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the instance"
              },
              "swap": {
                "description": "swap memory size in MB for instance",
                "$ref": "#/definitions/ansible_number"
              },
              "memory": {
                "description": "Default: 512\n\nmemory size in MB for instance",
                "$ref": "#/definitions/ansible_number"
              },
              "node": {
                "type": "string",
                "description": "Proxmox VE node, when new VM will be created\nrequired only for C(state=present)\nfor another states will be autodiscovered"
              },
              "cpuunits": {
                "description": "Default: 1000\n\nCPU weight for a VM",
                "$ref": "#/definitions/ansible_number"
              },
              "api_password": {
                "type": "string",
                "description": "the password to authenticate with\nyou can use PROXMOX_PASSWORD environment variable"
              },
              "password": {
                "type": "string",
                "description": "the instance root password\nrequired only for C(state=present)"
              },
              "ip_address": {
                "type": "string",
                "description": "specifies the address the container will be assigned"
              },
              "api_host": {
                "type": "string",
                "description": "the host of the Proxmox VE cluster"
              },
              "netif": {
                "type": "object",
                "description": "specifies network interfaces for the container"
              },
              "vmid": {
                "type": "string",
                "description": "the instance id"
              },
              "timeout": {
                "description": "Default: 30\n\ntimeout for operations",
                "$ref": "#/definitions/ansible_number"
              },
              "mounts": {
                "type": "object",
                "description": "specifies additional mounts (separate disks) for the container"
              },
              "nameserver": {
                "type": "string",
                "description": "sets DNS server IP address for a container"
              },
              "validate_certs": {
                "description": "enable / disable https certificate verification",
                "$ref": "#/definitions/ansible_truth"
              },
              "onboot": {
                "description": "specifies whether a VM will be started during system bootup",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "pkg5_publisher": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "publisher"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "publisher"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "IPS packages are the native packages in Solaris 11 and higher.\nThis modules will configure which publishers a client will download IPS packages from.",
            "properties": {
              "origin": {
                "description": "A path or URL to the repository.\nMultiple values may be provided.",
                "$ref": "#/definitions/ansible_array"
              },
              "publisher": {
                "type": "string",
                "description": "The publisher's name."
              },
              "name": {
                "type": "string",
                "description": "The publisher's name."
              },
              "enabled": {
                "description": "Is the repository enabled or disabled?",
                "$ref": "#/definitions/ansible_truth"
              },
              "sticky": {
                "description": "Packages installed from a sticky repository can only receive updates from that repository.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to ensure that a publisher is present or absent."
              },
              "mirror": {
                "description": "A path or URL to the repository mirror.\nMultiple values may be provided.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "openbsd_pkg": {
            "required": [
              "state",
              "name"
            ],
            "type": "object",
            "description": "Manage packages on OpenBSD using the pkg tools.",
            "properties": {
              "state": {
                "enum": [
                  "absent",
                  "installed",
                  "latest",
                  "present",
                  "removed"
                ],
                "type": "string",
                "description": "C(present) will make sure the package is installed. C(latest) will make sure the latest version of the package is installed. C(absent) will make sure the specified package is not installed."
              },
              "build": {
                "description": "Build the package from source instead of downloading and installing a binary. Requires that the port source tree is already installed. Automatically builds and installs the 'sqlports' package, if it is not already installed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the package."
              },
              "ports_dir": {
                "type": "string",
                "description": "Default: /usr/ports\n\nWhen used in combination with the 'build' option, allows overriding the default ports source directory."
              }
            }
          },
          "pn_vlag": {
            "required": [
              "pn_name",
              "state"
            ],
            "type": "object",
            "description": "Execute vlag-create/vlag-delete/vlag-modify command.\nA virtual link aggregation group (VLAG) allows links that are physically connected to two different Pluribus Networks devices to appear as a single trunk to a third device. The third device can be a switch, server, or any Ethernet device. A VLAG can provide Layer 2 multipathing, which allows you to create redundancy by increasing bandwidth, enabling multiple parallel paths between nodes and loadbalancing traffic where alternative paths exist.",
            "properties": {
              "pn_name": {
                "type": "string",
                "description": "The C(pn_name) takes a valid name for vlag configuration."
              },
              "pn_lacp_fallback": {
                "enum": [
                  "individual",
                  "bundled"
                ],
                "type": "string",
                "description": "Specify the LACP fallback mode as bundles or individual."
              },
              "pn_lacp_fallback_timeout": {
                "type": "string",
                "description": "Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds."
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_lacp_timeout": {
                "enum": [
                  "slow",
                  "fast"
                ],
                "type": "string",
                "description": "Specify the LACP timeout as slow(30 seconds) or fast(4 seconds)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "update"
                ],
                "type": "string",
                "description": "State the action to perform. Use 'present' to create vlag, 'absent' to delete vlag and 'update' to modify vlag."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "pn_lacp_mode": {
                "enum": [
                  "off",
                  "passive",
                  "active"
                ],
                "type": "string",
                "description": "Specify the LACP mode."
              },
              "pn_failover_action": {
                "enum": [
                  "move",
                  "ignore"
                ],
                "type": "string",
                "description": "Specify the failover action as move or ignore."
              },
              "pn_peer_port": {
                "type": "string",
                "description": "Specify the peer VLAG port.\nRequired for vlag-create."
              },
              "pn_peer_switch": {
                "type": "string",
                "description": "Specify the fabric-name of the peer switch."
              },
              "pn_port": {
                "type": "string",
                "description": "Specify the local VLAG port.\nRequired for vlag-create."
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch(es) to run this command on."
              },
              "pn_mode": {
                "enum": [
                  "active-active",
                  "active-standby"
                ],
                "type": "string",
                "description": "Specify the mode for the VLAG. Active-standby indicates one side is active and the other side is in standby mode. Active-active indicates that both sides of the vlag are up by default."
              }
            }
          },
          "hall": {
            "required": [
              "msg",
              "title",
              "room_token"
            ],
            "type": "object",
            "description": "The M(hall) module connects to the U(https://hall.com) messaging API and allows you to deliver notication messages to rooms.",
            "properties": {
              "msg": {
                "type": "string",
                "description": "The message you wish to deliver as a notifcation"
              },
              "picture": {
                "type": "string",
                "description": "The full URL to the image you wish to use for the Icon of the message. Defaults to U(http://cdn2.hubspot.net/hub/330046/file-769078210-png/Official_Logos/ansible_logo_black_square_small.png?t=1421076128627)"
              },
              "room_token": {
                "type": "string",
                "description": "Room token provided to you by setting up the Ansible room integation on U(https://hall.com)"
              },
              "title": {
                "type": "string",
                "description": "The title of the message"
              }
            }
          },
          "dnsimple": {
            "type": "object",
            "description": "Manages domains and records via the DNSimple API, see the docs: U(http://developer.dnsimple.com/)",
            "properties": {
              "solo": {
                "description": "Whether the record should be the only one for that record type and record name. Only use with state=present on a record",
                "$ref": "#/definitions/ansible_truth"
              },
              "domain": {
                "type": "string",
                "description": "Domain to work with. Can be the domain name (e.g. \"mydomain.com\") or the numeric ID of the domain in DNSimple. If omitted, a list of domains will be returned.\nIf domain is present but the domain doesn't exist, it will be created."
              },
              "account_email": {
                "type": "string",
                "description": "Account email. If omitted, the env variables DNSIMPLE_EMAIL and DNSIMPLE_API_TOKEN will be looked for. If those aren't found, a C(.dnsimple) file will be looked for, see: U(https://github.com/mikemaccana/dnsimple-python#getting-started)"
              },
              "record_ids": {
                "description": "List of records to ensure they either exist or don't exist",
                "$ref": "#/definitions/ansible_array"
              },
              "value": {
                "type": "string",
                "description": "Record value\nMust be specified when trying to ensure a record exists"
              },
              "priority": {
                "description": "Record priority",
                "$ref": "#/definitions/ansible_number"
              },
              "record": {
                "type": "string",
                "description": "Record to add, if blank a record for the domain will be created, supports the wildcard (*)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "whether the record should exist or not"
              },
              "ttl": {
                "description": "Default: 3600 (one hour)\n\nThe TTL to give the new record",
                "$ref": "#/definitions/ansible_number"
              },
              "type": {
                "enum": [
                  "A",
                  "ALIAS",
                  "CNAME",
                  "MX",
                  "SPF",
                  "URL",
                  "TXT",
                  "NS",
                  "SRV",
                  "NAPTR",
                  "PTR",
                  "AAAA",
                  "SSHFP",
                  "HINFO",
                  "POOL"
                ],
                "type": "string",
                "description": "The type of DNS record to create"
              },
              "account_api_token": {
                "type": "string",
                "description": "Account API token. See I(account_email) for info."
              }
            }
          },
          "vmware_migrate_vmk": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Migrate a VMK interface from VSS to VDS",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "current_switch_name": {
                "type": "string",
                "description": "Switch VMK interface is currently on"
              },
              "migrate_portgroup_name": {
                "type": "string",
                "description": "Portgroup name to migrate VMK interface to"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "esxi_hostname": {
                "type": "string",
                "description": "ESXi hostname to be managed"
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "device": {
                "type": "string",
                "description": "VMK interface name"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "current_portgroup_name": {
                "type": "string",
                "description": "Portgroup name VMK interface is currently on"
              },
              "migrate_switch_name": {
                "type": "string",
                "description": "Switch name to migrate VMK interface to"
              }
            }
          },
          "win_scheduled_task": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage scheduled tasks",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "State that the task should become"
              },
              "names": {
                "type": "string",
                "description": "Name of the scheduled task"
              },
              "name": {
                "type": "string",
                "description": "Name of the scheduled task"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rax_mon_alarm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or delete a Rackspace Cloud Monitoring alarm that associates an existing rax_mon_entity, rax_mon_check, and rax_mon_notification_plan with criteria that specify what conditions will trigger which levels of notifications. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> rax_mon_notification -> rax_mon_notification_plan -> *rax_mon_alarm*",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "entity_id": {
                "type": "string",
                "description": "ID of the entity this alarm is attached to. May be acquired by registering the value of a rax_mon_entity task."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "notification_plan_id": {
                "type": "string",
                "description": "ID of the notification plan to trigger if this alarm fires. May be acquired by registering the value of a rax_mon_notification_plan task."
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "label": {
                "type": "string",
                "description": "Friendly name for this alarm, used to achieve idempotence. Must be a String between 1 and 255 characters long."
              },
              "disabled": {
                "description": "If yes, create this alarm, but leave it in an inactive state. Defaults to no.",
                "$ref": "#/definitions/ansible_truth"
              },
              "check_id": {
                "type": "string",
                "description": "ID of the check that should be alerted on. May be acquired by registering the value of a rax_mon_check task."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nEnsure that the alarm with this C(label) exists or does not exist."
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "criteria": {
                "type": "string",
                "description": "Alarm DSL that describes alerting conditions and their output states. Must be between 1 and 16384 characters long. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/alerts-language.html for a reference on the alerting language."
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "metadata": {
                "type": "object",
                "description": "Arbitrary key/value pairs to accompany the alarm. Must be a hash of String keys and values between 1 and 255 characters long."
              }
            }
          },
          "ios_template": {
            "type": "object",
            "description": "Manages Cisco IOS network device configurations over SSH.  This module allows implementers to work with the device running-config.  It provides a way to push a set of commands onto a network device by evaluating the current running-config and only pushing configuration commands that are not already configured.  The config source can be a set of commands or a template.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will first search for the source file in role or playbook root folder in templates unless a full path to the file is given."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "The force argument instructs the module not to consider the current device running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "description": "The module, by default, will collect the current device running-config to use as a base for comparison to the commands in I(src).  Setting this value to true will cause the command issued to add any necessary flags to collect all defaults as well as the device configuration.  If the destination device does not support such a flag, this argument is silently ignored.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "name": {
            "type": "string"
          },
          "ec2_vpc_dhcp_options": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tags",
                        "resource_tags"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module removes, or creates DHCP option sets, and can associate them to a VPC. Optionally, a new DHCP Options set can be created that converges a VPC's existing DHCP option set with values provided. When dhcp_options_id is provided, the module will 1. remove (with state='absent') 2. ensure tags are applied (if state='present' and tags are provided 3. attach it to a VPC (if state='present' and a vpc_id is provided. If any of the optional values are missing, they will either be treated as a no-op (i.e., inherit what already exists for the VPC) To remove existing options while inheriting, supply an empty value (e.g. set ntp_servers to [] if you want to remove them from the VPC's options) Most of the options should be self-explanatory.",
            "properties": {
              "dns_servers": {
                "description": "Default: None\n\nA list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)",
                "$ref": "#/definitions/ansible_array"
              },
              "netbios_node_type": {
                "description": "Default: None\n\nNetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "inherit_existing": {
                "description": "For any DHCP options not specified in these parameters, whether to inherit them from the options set already applied to vpc_id, or to reset them to be empty.",
                "$ref": "#/definitions/ansible_truth"
              },
              "domain_name": {
                "type": "string",
                "description": "Default: None\n\nThe domain name to set in the DHCP option sets"
              },
              "delete_old": {
                "description": "Default: True\n\nWhether to delete the old VPC DHCP option set when associating a new one. This is primarily useful for debugging/development purposes when you want to quickly roll back to the old option set. Note that this setting will be ignored, and the old DHCP option set will be preserved, if it is in use by any other VPC. (Otherwise, AWS will return an error.)",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\ncreate/assign or remove the DHCP options. If state is set to absent, then a DHCP options set matched either by id, or tags and options will be removed if possible."
              },
              "dhcp_options_id": {
                "type": "string",
                "description": "Default: None\n\nThe resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "Default: None\n\nTags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)"
              },
              "ntp_servers": {
                "description": "Default: None\n\nList of hosts to advertise as NTP servers for the VPC.",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "resource_tags": {
                "type": "object",
                "description": "Default: None\n\nTags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)"
              },
              "vpc_id": {
                "type": "string",
                "description": "Default: None\n\nVPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "netbios_name_servers": {
                "description": "Default: None\n\nList of hosts to advertise as NetBIOS servers.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "clc_server": {
            "type": "object",
            "description": "An Ansible module to Create, Delete, Start and Stop servers in CenturyLink Cloud.",
            "properties": {
              "anti_affinity_policy_name": {
                "type": "string",
                "description": "Default: None\n\nThe anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_id'."
              },
              "storage_type": {
                "enum": [
                  "standard",
                  "hyperscale"
                ],
                "type": "string",
                "description": "Default: standard\n\nThe type of storage to attach to the server."
              },
              "anti_affinity_policy_id": {
                "type": "string",
                "description": "Default: None\n\nThe anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_name'."
              },
              "ttl": {
                "type": "string",
                "description": "Default: None\n\nThe time to live for the server in seconds.  The server will be deleted when this time expires."
              },
              "count_group": {
                "type": "string",
                "description": "Default: None\n\nRequired when exact_count is specified.  The Server Group use to determine how many severs to deploy."
              },
              "secondary_dns": {
                "type": "string",
                "description": "Default: None\n\nSecondary DNS used by the server."
              },
              "custom_fields": {
                "description": "The list of custom fields to set on the server.",
                "$ref": "#/definitions/ansible_array"
              },
              "password": {
                "type": "string",
                "description": "Default: None\n\nPassword for the administrator / root user"
              },
              "packages": {
                "description": "The list of blue print packages to run on the server after its created.",
                "$ref": "#/definitions/ansible_array"
              },
              "group": {
                "type": "string",
                "description": "Default: Default Group\n\nThe Server Group to create servers under."
              },
              "exact_count": {
                "description": "Default: None\n\nRun in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count.  Requires count_group to be set.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "started",
                  "stopped"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state to insure that the provided resources are in."
              },
              "cpu_autoscale_policy_id": {
                "type": "string",
                "description": "Default: None\n\nThe autoscale policy to assign to the server."
              },
              "template": {
                "type": "string",
                "description": "Default: None\n\nThe template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'"
              },
              "memory": {
                "type": "string",
                "description": "Default: 1\n\nMemory in GB."
              },
              "server_ids": {
                "description": "Required for started, stopped, and absent states. A list of server Ids to insure are started, stopped, or absent.",
                "$ref": "#/definitions/ansible_array"
              },
              "type": {
                "enum": [
                  "standard",
                  "hyperscale",
                  "bareMetal"
                ],
                "type": "string",
                "description": "Default: standard\n\nThe type of server to create."
              },
              "managed_os": {
                "description": "Whether to create the server as 'Managed' or not.",
                "$ref": "#/definitions/ansible_truth"
              },
              "location": {
                "type": "string",
                "description": "Default: None\n\nThe Datacenter to create servers in."
              },
              "additional_disks": {
                "description": "The list of additional disks for the server",
                "$ref": "#/definitions/ansible_array"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nThe description to set for the server."
              },
              "add_public_ip": {
                "description": "Whether to add a public ip to the server",
                "$ref": "#/definitions/ansible_truth"
              },
              "configuration_id": {
                "type": "string",
                "description": "Default: None\n\nOnly required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy."
              },
              "alert_policy_name": {
                "type": "string",
                "description": "Default: None\n\nThe alert policy to assign to the server. This is mutually exclusive with 'alert_policy_id'."
              },
              "alert_policy_id": {
                "type": "string",
                "description": "Default: None\n\nThe alert policy to assign to the server. This is mutually exclusive with 'alert_policy_name'."
              },
              "public_ip_ports": {
                "description": "A list of ports to allow on the firewall to the servers public ip, if add_public_ip is set to True.",
                "$ref": "#/definitions/ansible_array"
              },
              "ip_address": {
                "type": "string",
                "description": "Default: None\n\nThe IP Address for the server. One is assigned if not provided."
              },
              "public_ip_protocol": {
                "enum": [
                  "TCP",
                  "UDP",
                  "ICMP"
                ],
                "type": "string",
                "description": "Default: TCP\n\nThe protocol to use for the public ip if add_public_ip is set to True."
              },
              "wait": {
                "description": "Default: True\n\nWhether to wait for the provisioning tasks to finish before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "count": {
                "description": "Default: 1\n\nThe number of servers to build (mutually exclusive with exact_count)",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nA 1 to 6 character identifier to use for the server. This is required when state is 'present'"
              },
              "network_id": {
                "type": "string",
                "description": "Default: None\n\nThe network UUID on which to create servers."
              },
              "primary_dns": {
                "type": "string",
                "description": "Default: None\n\nPrimary DNS used by the server."
              },
              "alias": {
                "type": "string",
                "description": "Default: None\n\nThe account alias to provision the servers under."
              },
              "source_server_password": {
                "type": "string",
                "description": "Default: None\n\nThe password for the source server if a clone is specified."
              },
              "os_type": {
                "enum": [
                  "redHat6_64Bit",
                  "centOS6_64Bit",
                  "windows2012R2Standard_64Bit",
                  "ubuntu14_64Bit"
                ],
                "type": "string",
                "description": "Default: None\n\nOnly required for bare metal servers. Specifies the OS to provision with the bare metal server."
              },
              "cpu": {
                "type": "string",
                "description": "Default: 1\n\nHow many CPUs to provision on the server"
              }
            }
          },
          "win_chocolatey": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Installs packages using Chocolatey (http://chocolatey.org/). If Chocolatey is missing from the system, the module will install it. List of packages can be found at http://chocolatey.org/packages",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the package on the system"
              },
              "names": {
                "type": "string",
                "description": "Name of the package to be installed"
              },
              "name": {
                "type": "string",
                "description": "Name of the package to be installed"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "iosxr_facts": {
            "type": "object",
            "description": "Collects a base set of device facts from a remote device that is running IOS XR.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "synchronize": {
            "required": [
              "src",
              "dest"
            ],
            "type": "object",
            "description": "C(synchronize) is a wrapper around rsync to make common tasks in your playbooks quick and easy. It is run and originates on the local host where Ansible is being run. Of course, you could just use the C(command) action to call rsync yourself, but you also have to add a fair number of boilerplate options and host facts. C(synchronize) is not intended to provide access to the full power of rsync, but does make the most common invocations easier to implement. You `still` may need to call rsync directly via C(command) or C(shell) depending on your use case.",
            "properties": {
              "partial": {
                "description": "Tells rsync to keep the partial file which should make a subsequent transfer of the rest of the file much faster.",
                "$ref": "#/definitions/ansible_truth"
              },
              "links": {
                "description": "Default: the value of the archive option\n\nCopy symlinks as symlinks.",
                "$ref": "#/definitions/ansible_truth"
              },
              "copy_links": {
                "description": "Default: no\n\nCopy symlinks as the item that they point to (the referent) is copied, rather than the symlink.",
                "$ref": "#/definitions/ansible_truth"
              },
              "perms": {
                "description": "Default: the value of the archive option\n\nPreserve permissions.",
                "$ref": "#/definitions/ansible_truth"
              },
              "owner": {
                "description": "Default: the value of the archive option\n\nPreserve owner (super user only)",
                "$ref": "#/definitions/ansible_truth"
              },
              "archive": {
                "description": "Default: yes\n\nMirrors the rsync archive flag, enables recursive, links, perms, times, owner, group flags and -D.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dest_port": {
                "description": "Default: Value of ansible_ssh_port for this host, remote_port config setting, or the value from ssh client configuration if none of those are set\n\nPort number for ssh on the destination host. Prior to ansible 2.0, the ansible_ssh_port inventory var took precedence over this value.",
                "$ref": "#/definitions/ansible_number"
              },
              "_local_rsync_path": {
                "type": "string",
                "description": ""
              },
              "group": {
                "description": "Default: the value of the archive option\n\nPreserve group",
                "$ref": "#/definitions/ansible_truth"
              },
              "existing_only": {
                "description": "Default: no\n\nSkip creating new files on receiver.",
                "$ref": "#/definitions/ansible_truth"
              },
              "rsync_path": {
                "type": "string",
                "description": "Specify the rsync command to run on the remote host. See C(--rsync-path) on the rsync man page."
              },
              "dest": {
                "type": "string",
                "description": "Path on the destination host that will be synchronized from the source; The path can be absolute or relative."
              },
              "verify_host": {
                "description": "Verify destination host key.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dirs": {
                "description": "Default: no\n\nTransfer directories without recursing",
                "$ref": "#/definitions/ansible_truth"
              },
              "private_key": {
                "type": "string",
                "description": ""
              },
              "_substitute_controller": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "compress": {
                "description": "Default: yes\n\nCompress file data during the transfer. In most cases, leave this enabled unless it causes problems.",
                "$ref": "#/definitions/ansible_truth"
              },
              "rsync_timeout": {
                "description": "Specify a --timeout for the rsync command in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "rsync_opts": {
                "description": "Specify additional rsync options by passing in an array.",
                "$ref": "#/definitions/ansible_array"
              },
              "set_remote_user": {
                "description": "Default: True\n\nput user@ for the remote paths. If you have a custom ssh config to define the remote user for a host that does not match the inventory user, you should set this parameter to \"no\".",
                "$ref": "#/definitions/ansible_truth"
              },
              "recursive": {
                "description": "Default: the value of the archive option\n\nRecurse into directories.",
                "$ref": "#/definitions/ansible_truth"
              },
              "src": {
                "type": "string",
                "description": "Path on the source host that will be synchronized to the destination; The path can be absolute or relative."
              },
              "checksum": {
                "description": "Default: no\n\nSkip based on checksum, rather than mod-time & size; Note that that \"archive\" option is still enabled by default - the \"checksum\" option will not disable it.",
                "$ref": "#/definitions/ansible_truth"
              },
              "times": {
                "description": "Default: the value of the archive option\n\nPreserve modification times",
                "$ref": "#/definitions/ansible_truth"
              },
              "mode": {
                "enum": [
                  "push",
                  "pull"
                ],
                "type": "string",
                "description": "Default: push\n\nSpecify the direction of the synchronization. In push mode the localhost or delegate is the source; In pull mode the remote host in context is the source."
              },
              "ssh_args": {
                "type": "string",
                "description": ""
              },
              "delete": {
                "description": "Default: no\n\nDelete files in C(dest) that don't exist (after transfer, not before) in the C(src) path. This option requires C(recursive=yes).",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_nics": {
            "required": [
              "vm",
              "name",
              "auth"
            ],
            "type": "object",
            "description": "Module to manage network interfaces of Virtual Machines in oVirt.",
            "properties": {
              "profile": {
                "type": "string",
                "description": "Virtual network interface profile to be attached to VM network interface."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "network": {
                "type": "string",
                "description": "Logical network to which the VM network interface should use, by default Empty network is used if network is not specified."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "vm": {
                "type": "string",
                "description": "Name of the Virtual Machine to manage."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "plugged",
                  "unplugged"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the Virtual Machine NIC be present/absent/plugged/unplugged."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "mac_address": {
                "type": "string",
                "description": "Custom MAC address of the network interface, by default it's obtained from MAC pool."
              },
              "interface": {
                "type": "string",
                "description": "Default: virtio\n\nType of the network interface."
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the network interface to manage."
              }
            }
          },
          "vyos_facts": {
            "type": "object",
            "description": "Collects a base set of device facts from a remote device that is running VyOS.  This module prepends all of the base network fact keys with U(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, default, config, and neighbors.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "opkg": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages OpenWrt packages",
            "properties": {
              "force": {
                "enum": [
                  "",
                  "depends",
                  "maintainer",
                  "reinstall",
                  "overwrite",
                  "downgrade",
                  "space",
                  "postinstall",
                  "remove",
                  "checksum",
                  "removal-of-dependent-packages"
                ],
                "type": "string",
                "description": "Default: absent\n\nopkg --force parameter used"
              },
              "name": {
                "type": "string",
                "description": "name of package to install/remove"
              },
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "absent",
                  "removed"
                ],
                "type": "string",
                "description": "Default: present\n\nstate of the package"
              },
              "update_cache": {
                "description": "Default: no\n\nupdate the package db first",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "type": "string",
                "description": "name of package to install/remove"
              },
              "update-cache": {
                "description": "Default: no\n\nupdate the package db first",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "debug": {
            "type": "object",
            "description": "This module prints statements during execution and can be useful for debugging variables or expressions without necessarily halting the playbook. Useful for debugging together with the 'when:' directive.",
            "properties": {
              "msg": {
                "type": "string",
                "description": "Default: Hello world!\n\nThe customized message that is printed. If omitted, prints a generic message."
              },
              "var": {
                "type": "string",
                "description": "A variable name to debug.  Mutually exclusive with the 'msg' option."
              },
              "verbosity": {
                "type": "string",
                "description": "A number that controls when the debug is run, if you set to 3 it will only run debug when -vvv or above"
              }
            }
          },
          "udm_dns_zone": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "zone",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "zone"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module allows to manage dns zones on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.",
            "properties": {
              "retry": {
                "description": "Default: 1800\n\nInterval that should elapse before a failed refresh should be retried.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "DNS zone name, e.g. C(example.com)."
              },
              "zone": {
                "type": "string",
                "description": "DNS zone name, e.g. C(example.com)."
              },
              "interfaces": {
                "description": "List of interface IP addresses, on which the server should response this zone. Required if C(state=present).",
                "$ref": "#/definitions/ansible_array"
              },
              "refresh": {
                "description": "Default: 3600\n\nInterval before the zone should be refreshed.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the dns zone is present or not."
              },
              "contact": {
                "type": "string",
                "description": "Contact person in the SOA record."
              },
              "expire": {
                "description": "Default: 604800\n\nSpecifies the upper limit on the time interval that can elapse before the zone is no longer authoritative.",
                "$ref": "#/definitions/ansible_number"
              },
              "ttl": {
                "description": "Default: 600\n\nMinimum TTL field that should be exported with any RR from this zone.",
                "$ref": "#/definitions/ansible_number"
              },
              "nameserver": {
                "description": "List of appropriate name servers. Required if C(state=present).",
                "$ref": "#/definitions/ansible_array"
              },
              "type": {
                "type": "string",
                "description": "Define if the zone is a forward or reverse DNS zone."
              },
              "mx": {
                "description": "List of MX servers. (Must declared as A or AAAA records).",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "win_reg_stat": {
            "type": "object",
            "description": "Like M(win_file), M(win_reg_stat) will return whether the key/property exists.\nIt also returns the sub keys and properties of the key specified.\nIf specifying a property name through I(property), it will return the information specific for that property.",
            "properties": {
              "path": {
                "type": "string",
                "description": "The full registry key path including the hive to search for."
              },
              "name": {
                "type": "string",
                "description": "The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified."
              }
            }
          },
          "ec2_vpc_route_table": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tags",
                        "resource_tags"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage route tables for AWS virtual private clouds",
            "properties": {
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "route_table_id": {
                "type": "string",
                "description": "The ID of the route table to update or delete."
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or destroy the VPC route table"
              },
              "lookup": {
                "enum": [
                  "tag",
                  "id"
                ],
                "type": "string",
                "description": "Default: tag\n\nLook up route table by either tags or by route table ID. Non-unique tag lookup will fail. If no tags are specifed then no lookup for an existing route table is performed and a new route table will be created. To change tags of a route table, you must look up by id."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "subnets": {
                "description": "An array of subnets to add to this route table. Subnets may be specified by either subnet ID, Name tag, or by a CIDR such as '10.0.0.0/24'.",
                "$ref": "#/definitions/ansible_array"
              },
              "tags": {
                "type": "object",
                "description": "A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }. Tags are used to uniquely identify route tables within a VPC when the route_table_id is not supplied."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "resource_tags": {
                "type": "object",
                "description": "A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }. Tags are used to uniquely identify route tables within a VPC when the route_table_id is not supplied."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "propagating_vgw_ids": {
                "description": "Default: None\n\nEnable route propagation from virtual gateways specified by ID.",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "routes": {
                "description": "Default: None\n\nList of routes in the route table. Routes are specified as dicts containing the keys 'dest' and one of 'gateway_id', 'instance_id', 'interface_id', or 'vpc_peering_connection_id'. If 'gateway_id' is specified, you can refer to the VPC's IGW by using the value 'igw'. Routes are required for present states.",
                "$ref": "#/definitions/ansible_array"
              },
              "vpc_id": {
                "type": "string",
                "description": "VPC ID of the VPC in which to create the route table."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cloudscale_server": {
            "type": "object",
            "description": "Create, start, stop and delete servers on the cloudscale.ch IaaS service.\nAll operations are performed using the cloudscale.ch public API v1.\nFor details consult the full API documentation: U(https://www.cloudscale.ch/en/api/v1).\nAn valid API token is required for all operations. You can create as many tokens as you like using the cloudscale.ch control panel at U(https://control.cloudscale.ch).",
            "properties": {
              "volume_size_gb": {
                "description": "Default: 10\n\nSize of the root volume in GB",
                "$ref": "#/definitions/ansible_number"
              },
              "uuid": {
                "type": "string",
                "description": "UUID of the server\nEither C(name) or C(uuid) are required. These options are mutually exclusive."
              },
              "use_public_network": {
                "description": "Default: True\n\nAttach a public network interface to the server",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "running",
                  "stopped",
                  "absent"
                ],
                "type": "string",
                "description": "Default: running\n\nState of the server"
              },
              "image": {
                "type": "string",
                "description": "Image used to create the server"
              },
              "api_token": {
                "type": "string",
                "description": "cloudscale.ch API token.\nThis can also be passed in the CLOUDSCALE_API_TOKEN environment variable."
              },
              "user_data": {
                "type": "string",
                "description": "Cloud-init configuration (cloud-config) data to use for the server."
              },
              "name": {
                "type": "string",
                "description": "Name of the Server\nEither C(name) or C(uuid) are required. These options are mutually exclusive."
              },
              "anti_affinity_with": {
                "type": "string",
                "description": "UUID of another server to create an anti-affinity group with"
              },
              "use_private_network": {
                "description": "Attach a private network interface to the server",
                "$ref": "#/definitions/ansible_truth"
              },
              "bulk_volume_size_gb": {
                "description": "Default: null (no bulk storage volume)\n\nSize of the bulk storage volume in GB",
                "$ref": "#/definitions/ansible_number"
              },
              "use_ipv6": {
                "description": "Default: True\n\nEnable IPv6 on the public network interface",
                "$ref": "#/definitions/ansible_truth"
              },
              "flavor": {
                "type": "string",
                "description": "Flavor of the server"
              },
              "ssh_keys": {
                "description": "List of SSH public keys\nUse the full content of your .pub file here.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "win_acl_inheritance": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Change ACL (Access Control List) inheritance and optionally copy inherited ACE's (Access Control Entry) to dedicated ACE's or vice versa.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: absent\n\nSpecify whether to enable I(present) or disable I(absent) ACL inheritance"
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_vtp_version": {
            "required": [
              "version"
            ],
            "type": "object",
            "description": "Manages VTP version configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "version": {
                "enum": [
                  "1",
                  "2"
                ],
                "type": "string",
                "description": "VTP version number."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "avi_tenant": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure Tenant object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "User defined description for the object."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "created_by": {
                "type": "string",
                "description": "Creator of this tenant."
              },
              "name": {
                "type": "string",
                "description": "Name of the object."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "config_settings": {
                "type": "object",
                "description": "Tenantconfiguration settings for tenant."
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "local": {
                "description": "Boolean flag to set local.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "uuid": {
                "type": "string",
                "description": "Unique object identifier of the object."
              }
            }
          },
          "proxysql_scheduler": {
            "required": [
              "filename"
            ],
            "type": "object",
            "description": "The M(proxysql_scheduler) module adds or removes schedules using the proxysql admin interface.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Text field that can be used for any purposed defined by the user."
              },
              "login_port": {
                "description": "Default: 6032\n\nThe port used to connect to ProxySQL admin interface.",
                "$ref": "#/definitions/ansible_number"
              },
              "config_file": {
                "type": "string",
                "description": "Specify a config file from which login_user and login_password are to be read."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhen C(present) - adds the schedule, when C(absent) - removes the schedule."
              },
              "arg1": {
                "type": "string",
                "description": "Argument that can be passed to the job."
              },
              "login_user": {
                "type": "string",
                "description": "Default: None\n\nThe username used to authenticate to ProxySQL admin interface."
              },
              "arg2": {
                "type": "string",
                "description": "Argument that can be passed to the job."
              },
              "arg3": {
                "type": "string",
                "description": "Argument that can be passed to the job."
              },
              "arg4": {
                "type": "string",
                "description": "Argument that can be passed to the job."
              },
              "arg5": {
                "type": "string",
                "description": "Argument that can be passed to the job."
              },
              "filename": {
                "type": "string",
                "description": "Full path of the executable to be executed."
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "force_delete": {
                "description": "By default we avoid deleting more than one schedule in a single batch, however if you need this behaviour and you're not concerned about the schedules deleted, you can set I(force_delete) to C(True).",
                "$ref": "#/definitions/ansible_truth"
              },
              "interval_ms": {
                "description": "Default: 10000\n\nHow often (in millisecond) the job will be started. The minimum value for I(interval_ms) is 100 milliseconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "load_to_runtime": {
                "description": "Default: True\n\nDynamically load mysql host config to runtime memory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_password": {
                "type": "string",
                "description": "Default: None\n\nThe password used to authenticate to ProxySQL admin interface."
              },
              "active": {
                "description": "Default: True\n\nA schedule with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures.",
                "$ref": "#/definitions/ansible_truth"
              },
              "save_to_disk": {
                "description": "Default: True\n\nSave mysql host config to sqlite db on disk to persist the configuration.",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_host": {
                "type": "string",
                "description": "Default: 127.0.0.1\n\nThe host used to connect to ProxySQL admin interface."
              }
            }
          },
          "homebrew_cask": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_homebrew",
                        "update-brew"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "install_options",
                        "options"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg",
                        "package",
                        "cask"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages Homebrew casks.",
            "properties": {
              "install_options": {
                "description": "options flags to install a package",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "description": "name of cask to install/remove",
                "$ref": "#/definitions/ansible_array"
              },
              "package": {
                "description": "name of cask to install/remove",
                "$ref": "#/definitions/ansible_array"
              },
              "update_homebrew": {
                "description": "update homebrew itself first. Note that C(brew cask update) is a synonym for C(brew update).",
                "$ref": "#/definitions/ansible_truth"
              },
              "cask": {
                "description": "name of cask to install/remove",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "absent",
                  "removed",
                  "uninstalled"
                ],
                "type": "string",
                "description": "Default: present\n\nstate of the cask"
              },
              "update-brew": {
                "description": "update homebrew itself first. Note that C(brew cask update) is a synonym for C(brew update).",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "name of cask to install/remove",
                "$ref": "#/definitions/ansible_array"
              },
              "path": {
                "type": "string",
                "description": "Default: /usr/local/bin\n\n':' separated list of paths to search for 'brew' executable."
              },
              "options": {
                "description": "options flags to install a package",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "vertica_role": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "assigned_roles",
                        "assigned_role"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "role",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "role"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Adds or removes Vertica database role and, optionally, assign other roles.",
            "properties": {
              "assigned_roles": {
                "type": "string",
                "description": "Comma separated list of roles to assign to the role."
              },
              "name": {
                "type": "string",
                "description": "Name of the role to add or remove."
              },
              "login_user": {
                "type": "string",
                "description": "Default: dbadmin\n\nThe username used to authenticate with."
              },
              "db": {
                "type": "string",
                "description": "Name of the Vertica database."
              },
              "cluster": {
                "type": "string",
                "description": "Default: localhost\n\nName of the Vertica cluster."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to create C(present), drop C(absent) or lock C(locked) a role."
              },
              "role": {
                "type": "string",
                "description": "Name of the role to add or remove."
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with."
              },
              "port": {
                "type": "string",
                "description": "Default: 5433\n\nVertica cluster port to connect to."
              },
              "assigned_role": {
                "type": "string",
                "description": "Comma separated list of roles to assign to the role."
              }
            }
          },
          "cs_instancegroup": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create and remove instance groups.",
            "properties": {
              "account": {
                "type": "string",
                "description": "Account the instance group is related to."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Project the instance group is related to."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the instance group."
              },
              "domain": {
                "type": "string",
                "description": "Domain the instance group is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the instance group."
              }
            }
          },
          "cs_vmsnapshot": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "display_name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "display_name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, remove and revert VM from snapshots.",
            "properties": {
              "snapshot_memory": {
                "description": "Snapshot memory if set to true.",
                "$ref": "#/definitions/ansible_truth"
              },
              "domain": {
                "type": "string",
                "description": "Domain the VM snapshot is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "display_name": {
                "type": "string",
                "description": "Unique Name of the snapshot. In CloudStack terms display name."
              },
              "description": {
                "type": "string",
                "description": "Description of the snapshot."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "vm": {
                "type": "string",
                "description": "Name of the virtual machine."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the VM is assigned to."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "revert"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the snapshot."
              },
              "account": {
                "type": "string",
                "description": "Account the VM snapshot is related to."
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the VM is in. If not set, default zone is used."
              },
              "name": {
                "type": "string",
                "description": "Unique Name of the snapshot. In CloudStack terms display name."
              }
            }
          },
          "pn_vrouterbgp": {
            "required": [
              "pn_vrouter_name",
              "state"
            ],
            "type": "object",
            "description": "Execute vrouter-bgp-add, vrouter-bgp-remove, vrouter-bgp-modify command.\nEach fabric, cluster, standalone switch, or virtual network (VNET) can provide its tenants with a vRouter service that forwards traffic between networks and implements Layer 4 protocols.",
            "properties": {
              "pn_neighbor": {
                "type": "string",
                "description": "Specify a neighbor IP address to use for BGP.\nRequired for vrouter-bgp-add."
              },
              "pn_vrouter_name": {
                "type": "string",
                "description": "Specify a name for the vRouter service."
              },
              "pn_soft_reconfig": {
                "description": "Specify if you want a soft reconfiguration of inbound traffic.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_ebgp": {
                "description": "Specify a value for external BGP to accept or attempt BGP connections to external peers, not directly connected, on the network. This is a value between 1 and 255.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_route_reflector": {
                "description": "Specify if a route reflector client is used.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_keepalive": {
                "type": "string",
                "description": "Specify BGP neighbor keepalive interval in seconds."
              },
              "pn_multiprotocol": {
                "enum": [
                  "ipv4-unicast",
                  "ipv6-unicast"
                ],
                "type": "string",
                "description": "Specify a multi-protocol for BGP."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "update"
                ],
                "type": "string",
                "description": "State the action to perform. Use 'present' to add bgp, 'absent' to remove bgp and 'update' to modify bgp."
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch(es) to run the cli on."
              },
              "pn_max_prefix": {
                "description": "Specify the maximum number of prefixes.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_route_mapout": {
                "type": "string",
                "description": "Specify outbound route map for neighbor."
              },
              "pn_bfd": {
                "description": "Specify if you want BFD protocol support for fault detection.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_route_mapin": {
                "type": "string",
                "description": "Specify inbound route map for neighbor."
              },
              "pn_override_capability": {
                "description": "Specify if you want to override capability.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_prefix_listin": {
                "type": "string",
                "description": "Specify the prefix list to filter traffic inbound."
              },
              "pn_password": {
                "type": "string",
                "description": "Specify a password, if desired."
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_default_originate": {
                "description": "Specify if you want announce default routes to the neighbor or not.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "pn_weight": {
                "description": "Specify a default weight value between 0 and 65535 for the neighbor routes.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_prefix_listout": {
                "type": "string",
                "description": "Specify the prefix list to filter traffic outbound."
              },
              "pn_remote_as": {
                "type": "string",
                "description": "Specify the remote Autonomous System(AS) number. This value is between 1 and 4294967295.\nRequired for vrouter-bgp-add."
              },
              "pn_max_prefix_warn": {
                "description": "Specify if you want a warning message when the maximum number of prefixes is exceeded.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_holdtime": {
                "type": "string",
                "description": "Specify BGP neighbor holdtime in seconds."
              },
              "pn_next_hop_self": {
                "description": "Specify if the next-hop is the same router or not.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "expect": {
            "required": [
              "command",
              "responses"
            ],
            "type": "object",
            "description": "The M(expect) module executes a command and responds to prompts\nThe given command will be executed on all selected nodes. It will not be processed through the shell, so variables like C($HOME) and operations like C(\"<\"), C(\">\"), C(\"|\"), and C(\"&\") will not work",
            "properties": {
              "chdir": {
                "type": "string",
                "description": "cd into this directory before running the command"
              },
              "responses": {
                "type": "object",
                "description": "Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1."
              },
              "removes": {
                "type": "string",
                "description": "a filename, when it does not exist, this step will B(not) be run."
              },
              "echo": {
                "description": "Whether or not to echo out your response strings",
                "$ref": "#/definitions/ansible_truth"
              },
              "creates": {
                "type": "string",
                "description": "a filename, when it already exists, this step will B(not) be run."
              },
              "command": {
                "type": "string",
                "description": "the command module takes command to run."
              },
              "timeout": {
                "description": "Default: 30\n\nAmount of time in seconds to wait for the expected strings",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "vca_fw": {
            "type": "object",
            "description": "Adds or removes firewall rules from a gateway in a vca environment",
            "properties": {
              "fw_rules": {
                "type": "string",
                "description": "A list of firewall rules to be added to the gateway, Please see examples on valid entries"
              }
            }
          },
          "cnos_backup": {
            "type": "object",
            "description": "This module allows you to work with switch configurations. It provides a way to back up the running or startup configurations of a switch to a remote server. This is achieved by periodically saving a copy of the startup or running configuration of the network device to a remote server using FTP, SFTP, TFTP, or SCP. The first step is to create a directory from where the remote server can be reached. The next step is to provide the full file path of the location where the configuration will be backed up. Authentication details required by the remote server must be provided as well. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_backup.html)",
            "properties": {
              "serverpassword": {
                "type": "string",
                "description": "Specify the password for the server relating to the protocol used."
              },
              "protocol": {
                "type": "string",
                "description": "This refers to the protocol used by the network device to interact with the remote server to where to upload the backup configuration. The choices are FTP, SFTP, TFTP, or SCP. Any other protocols will result in error. If this parameter is not specified, there is no default value to be used."
              },
              "configType": {
                "type": "string",
                "description": "This specifies what type of configuration will be backed up. The choices are the running or startup configurations. There is no default value, so it will result in an error if the input is incorrect."
              },
              "serverusername": {
                "type": "string",
                "description": "Specify the username for the server relating to the protocol used."
              },
              "rcserverip": {
                "type": "string",
                "description": "-This specifies the IP Address of the remote server to where the configuration will be backed up."
              },
              "rcpath": {
                "type": "string",
                "description": "This specifies the full file path where the configuration file will be copied on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified."
              }
            }
          },
          "os_subnet": {
            "type": "object",
            "description": "Add or Remove a subnet to an OpenStack network",
            "properties": {
              "no_gateway_ip": {
                "type": "string",
                "description": "The gateway IP would not be assigned for this subnet"
              },
              "use_default_subnetpool": {
                "type": "string",
                "description": "Use the default subnetpool for I(ip_version) to obtain a CIDR."
              },
              "enable_dhcp": {
                "type": "string",
                "description": "Default: True\n\nWhether DHCP should be enabled for this subnet."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "dns_nameservers": {
                "type": "string",
                "description": "Default: None\n\nList of DNS nameservers for this subnet."
              },
              "gateway_ip": {
                "type": "string",
                "description": "Default: None\n\nThe ip that would be assigned to the gateway for this subnet"
              },
              "project": {
                "type": "string",
                "description": "Default: None\n\nProject name or ID containing the subnet (name admin-only)"
              },
              "ipv6_ra_mode": {
                "type": "string",
                "description": "Default: None\n\nIPv6 router advertisement mode"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "allocation_pool_start": {
                "type": "string",
                "description": "Default: None\n\nFrom the subnet pool the starting address from which the IP should be allocated."
              },
              "host_routes": {
                "type": "string",
                "description": "Default: None\n\nA list of host route dictionaries for the subnet."
              },
              "ip_version": {
                "type": "string",
                "description": "Default: 4\n\nThe IP version of the subnet 4 or 6"
              },
              "ipv6_address_mode": {
                "type": "string",
                "description": "Default: None\n\nIPv6 address mode"
              },
              "cidr": {
                "type": "string",
                "description": "Default: None\n\nThe CIDR representation of the subnet that should be assigned to the subnet. Required when I(state) is 'present' and a subnetpool is not specified."
              },
              "network_name": {
                "type": "string",
                "description": "Name of the network to which the subnet should be attached\nRequired when I(state) is 'present'"
              },
              "allocation_pool_end": {
                "type": "string",
                "description": "Default: None\n\nFrom the subnet pool the last IP that should be assigned to the virtual machines."
              },
              "name": {
                "type": "string",
                "description": "The name of the subnet that should be created. Although Neutron allows for non-unique subnet names, this module enforces subnet name uniqueness."
              }
            }
          },
          "cs_loadbalancer_rule_member": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ip_address",
                        "public_ip"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "vms",
                        "vm"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "vms"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "vm"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add and remove load balancer rule members.",
            "properties": {
              "public_ip": {
                "type": "string",
                "description": "Public IP address from where the network traffic will be load balanced from.\nOnly needed to find the rule if C(name) is not unique."
              },
              "account": {
                "type": "string",
                "description": "Account the rule is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "poll_async": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "vm": {
                "description": "List of VMs to assign to or remove from the rule.",
                "$ref": "#/definitions/ansible_array"
              },
              "project": {
                "type": "string",
                "description": "Name of the project the firewall rule is related to."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the VMs be present or absent from the rule."
              },
              "domain": {
                "type": "string",
                "description": "Domain the rule is related to."
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the rule should be located.\nIf not set, default zone is used."
              },
              "ip_address": {
                "type": "string",
                "description": "Public IP address from where the network traffic will be load balanced from.\nOnly needed to find the rule if C(name) is not unique."
              },
              "vms": {
                "description": "List of VMs to assign to or remove from the rule.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "The name of the load balancer rule."
              }
            }
          },
          "eos_user": {
            "type": "object",
            "description": "This module provides declarative management of the local usernames configured on Arista EOS devices.  It allows playbooks to manage either individual usernames or the collection of usernames in the current running config.  It also supports purging usernames from the configuration that are not explicitly defined.",
            "properties": {
              "username": {
                "type": "string",
                "description": "The username to be configured on the remote Arista EOS device.  This argument accepts a stringv value and is mutually exclusive with the C(users) argument. Please note that this option is not same as C(provider username)."
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "update_password": {
                "enum": [
                  "on_create",
                  "always"
                ],
                "type": "string",
                "description": "Default: always\n\nSince passwords are encrypted in the device running config, this argument will instruct the module when to change the password.  When set to C(always), the password will always be updated in the device and when set to C(on_create) the password will be updated only if the username is created."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "users": {
                "description": "The set of username objects to be configured on the remote Arista EOS device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(username) argument.",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nConfigures the state of the username definition as it relates to the device operational configuration.  When set to I(present), the username(s) should be configured in the device active configuration and when set to I(absent) the username(s) should not be in the device active configuration"
              },
              "purge": {
                "description": "Instructs the module to consider the resource definition absolute.  It will remove any previously configured usernames on the device with the exception of the `admin` user which cannot be deleted per EOS constraints.",
                "$ref": "#/definitions/ansible_truth"
              },
              "privilege": {
                "description": "The C(privilege) argument configures the privilege level of the user when logged into the system.  This argument accepts integer values in the range of 1 to 15.",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "role": {
                "type": "string",
                "description": "Configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "nopassword": {
                "description": "Defines the username without assigning a password.  This will allow the user to login to the system without being authenticated by a password.",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "eapi"
                ],
                "type": "string",
                "description": ""
              },
              "sshkey": {
                "type": "string",
                "description": "Specifies the SSH public key to configure for the given username.  This argument accepts a valid SSH key value."
              }
            }
          },
          "azure_rm_deployment": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "resource_group_name",
                        "resource_group"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "resource_group_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "resource_group"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or destroy Azure Resource Manager template deployments via the Azure SDK for Python. You can find some quick start templates in GitHub here https://github.com/azure/azure-quickstart-templates. For more information on Azue resource manager templates see https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-deploy/.",
            "properties": {
              "deployment_name": {
                "type": "string",
                "description": "Default: ansible-arm\n\nThe name of the deployment to be tracked in the resource group deployment history. Re-using a deployment name will overwrite the previous value in the resource group's deployment history."
              },
              "wait_for_deployment_polling_period": {
                "description": "Default: 10\n\nTime (in seconds) to wait between polls when waiting for deployment completion.",
                "$ref": "#/definitions/ansible_number"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "wait_for_deployment_completion": {
                "description": "Default: True\n\nWhether or not to block until the deployment has completed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "resource_group": {
                "type": "string",
                "description": "The resource group name to use or create to host the deployed template"
              },
              "parameters": {
                "type": "object",
                "description": "A hash of all the required template variables for the deployment template. This parameter is mutually exclusive with 'parameters_link'. Either one of them is required if \"state\" parameter is \"present\"."
              },
              "append_tags": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIf state is \"present\", template will be created. If state is \"present\" and if deployment exists, it will be updated. If state is \"absent\", stack will be removed."
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "location": {
                "type": "string",
                "description": "Default: westus\n\nThe geo-locations in which the resource group will be located."
              },
              "template": {
                "type": "object",
                "description": "A hash containing the templates inline. This parameter is mutually exclusive with 'template_link'. Either one of them is required if \"state\" parameter is \"present\"."
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "tags": {
                "type": "object",
                "description": ""
              },
              "template_link": {
                "type": "string",
                "description": "Uri of file containing the template body. This parameter is mutually exclusive with 'template'. Either one of them is required if \"state\" parameter is \"present\"."
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "resource_group_name": {
                "type": "string",
                "description": "The resource group name to use or create to host the deployed template"
              },
              "deployment_mode": {
                "enum": [
                  "complete",
                  "incremental"
                ],
                "type": "string",
                "description": "Default: incremental\n\nIn incremental mode, resources are deployed without deleting existing resources that are not included in the template. In complete mode resources are deployed and existing resources in the resource group not included in the template are deleted."
              },
              "parameters_link": {
                "type": "string",
                "description": "Uri of file containing the parameters body. This parameter is mutually exclusive with 'parameters'. Either one of them is required if \"state\" parameter is \"present\"."
              }
            }
          },
          "opendj_backendprop": {
            "required": [
              "name",
              "hostname",
              "value",
              "port",
              "backend"
            ],
            "type": "object",
            "description": "This module will update settings for OpenDJ with the command set-backend-prop.\nIt will check first via de get-backend-prop if configuration needs to be applied.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: cn=Directory Manager\n\nThe username to connect to."
              },
              "name": {
                "type": "string",
                "description": "The configuration setting to update."
              },
              "hostname": {
                "type": "string",
                "description": "The hostname of the OpenDJ server."
              },
              "value": {
                "type": "string",
                "description": "The value for the configuration item."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIf configuration needs to be added/updated"
              },
              "passwordfile": {
                "type": "string",
                "description": "Location to the password file which holds the password for the cn=Directory Manager user.\nEither password or passwordfile is needed."
              },
              "password": {
                "type": "string",
                "description": "The password for the cn=Directory Manager user.\nEither password or passwordfile is needed."
              },
              "opendj_bindir": {
                "type": "string",
                "description": "Default: /opt/opendj/bin\n\nThe path to the bin directory of OpenDJ."
              },
              "port": {
                "type": "string",
                "description": "The Admin port on which the OpenDJ instance is available."
              },
              "backend": {
                "type": "string",
                "description": "The name of the backend on which the property needs to be updated."
              }
            }
          },
          "eos_system": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "domain_list",
                        "domain_search"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module provides declarative management of node system attributes on Arista EOS devices.  It provides an option to configure host system parameters or remove those parameters from the device active configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "lookup_source": {
                "description": "Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) can only exist in a single VRF.  This argument accepts either a list of interface names or a list of hashes that configure the interface name and VRF name.  See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "domain_search": {
                "description": "Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "domain_list": {
                "description": "Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.",
                "$ref": "#/definitions/ansible_array"
              },
              "domain_name": {
                "type": "string",
                "description": "Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the configuration values in the device's current active configuration.  When set to I(present), the values should be configured in the device active configuration and when set to I(absent) the values should not be in the device active configuration"
              },
              "hostname": {
                "type": "string",
                "description": "Configure the device hostname parameter. This option takes an ASCII string value."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "name_servers": {
                "description": "List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "eapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "rax_queue": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "creates / deletes a Rackspace Public Cloud queue.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name to give the queue"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "packet_sshkey": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "label",
                        "name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create/delete an SSH key in Packet host.\nAPI is documented at U(https://www.packet.net/help/api/#page:ssh-keys,header:ssh-keys-ssh-keys-post).",
            "properties": {
              "name": {
                "type": "string",
                "description": "Label for the key. If you keep it empty, it will be read from key string."
              },
              "auth_token": {
                "type": "string",
                "description": "Packet api token. You can also supply it in env var C(PACKET_API_TOKEN)."
              },
              "label": {
                "type": "string",
                "description": "Label for the key. If you keep it empty, it will be read from key string."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the target."
              },
              "key": {
                "type": "string",
                "description": "Public Key string ({type} {base64 encoded key} {description})."
              },
              "fingerprint": {
                "type": "string",
                "description": "Fingerprint of the key which you want to remove."
              },
              "key_file": {
                "type": "string",
                "description": "File with the public key."
              },
              "id": {
                "type": "string",
                "description": "UUID of the key which you want to remove."
              }
            }
          },
          "nmcli": {
            "required": [
              "conn_name",
              "state"
            ],
            "type": "object",
            "description": "Manage the network devices. Create, modify, and manage, ethernet, teams, bonds, vlans etc.",
            "properties": {
              "conn_name": {
                "type": "string",
                "description": "Where conn_name will be the name used to call the connection. when not provided a default name is generated: <type>[-<ifname>][-<num>]"
              },
              "ingress": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with VLAN - VLAN ingress priority mapping"
              },
              "slavepriority": {
                "type": "string",
                "description": "Default: 32\n\nThis is only used with 'bridge-slave' - [<0-63>] - STP priority of this slave"
              },
              "vlandev": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with VLAN - parent device this VLAN is on, can use ifname"
              },
              "forwarddelay": {
                "type": "string",
                "description": "Default: 15\n\nThis is only used with bridge - [forward-delay <2-30>] STP forwarding delay, in seconds"
              },
              "egress": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with VLAN - VLAN egress priority mapping"
              },
              "vlanid": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with VLAN - VLAN ID in range <0-4095>"
              },
              "dns4": {
                "type": "string",
                "description": "Default: None\n\nA list of upto 3 dns servers, ipv4 format e.g. To add two IPv4 DNS server addresses: [\"192.0.2.53\", \"198.51.100.53\"]"
              },
              "hellotime": {
                "type": "string",
                "description": "Default: 2\n\nThis is only used with bridge - [hello-time <1-10>] STP hello time, in seconds"
              },
              "maxage": {
                "type": "string",
                "description": "Default: 20\n\nThis is only used with bridge - [max-age <6-42>] STP maximum message age, in seconds"
              },
              "ageingtime": {
                "type": "string",
                "description": "Default: 300\n\nThis is only used with bridge - [ageing-time <0-1000000>] the Ethernet MAC address aging time, in seconds"
              },
              "priority": {
                "type": "string",
                "description": "Default: 128\n\nThis is only used with 'bridge' - sets STP priority"
              },
              "gw4": {
                "type": "string",
                "description": "The IPv4 gateway for this interface using this format ie: \"192.0.2.1\""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the device should exist or not, taking action if the state is different from what is stated."
              },
              "gw6": {
                "type": "string",
                "description": "Default: None\n\nThe IPv6 gateway for this interface using this format ie: \"2001:db8::1\""
              },
              "master": {
                "type": "string",
                "description": "Default: None\n\nmaster <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile."
              },
              "stp": {
                "description": "Default: None\n\nThis is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge",
                "$ref": "#/definitions/ansible_truth"
              },
              "ifname": {
                "type": "string",
                "description": "Default: conn_name\n\nWhere IFNAME will be the what we call the interface name.\ninterface to bind the connection to. The connection will only be applicable to this interface name.\nA special value of \"*\" can be used for interface-independent connections.\nThe ifname argument is mandatory for all connection types except bond, team, bridge and vlan."
              },
              "type": {
                "enum": [
                  "ethernet",
                  "team",
                  "team-slave",
                  "bond",
                  "bond-slave",
                  "bridge",
                  "vlan"
                ],
                "type": "string",
                "description": "This is the type of device or network connection that you wish to create."
              },
              "miimon": {
                "type": "string",
                "description": "Default: 100\n\nThis is only used with bond - miimon"
              },
              "arp_ip_target": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with bond - ARP IP target"
              },
              "downdelay": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with bond - downdelay"
              },
              "mac": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with bridge - MAC address of the bridge (note: this requires a recent kernel feature, originally introduced in 3.15 upstream kernel)"
              },
              "ip6": {
                "type": "string",
                "description": "Default: None\n\nThe IPv6 address to this interface using this format ie: \"abbe::cafe\""
              },
              "ip4": {
                "type": "string",
                "description": "Default: None\n\nThe IPv4 address to this interface using this format ie: \"192.0.2.24/24\""
              },
              "autoconnect": {
                "description": "Default: yes\n\nWhether the connection should start on boot.\nWhether the connection profile can be automatically activated",
                "$ref": "#/definitions/ansible_truth"
              },
              "dns6": {
                "type": "string",
                "description": "A list of upto 3 dns servers, ipv6 format e.g. To add two IPv6 DNS server addresses: [\"2001:4860:4860::8888 2001:4860:4860::8844\"]"
              },
              "mtu": {
                "type": "string",
                "description": "Default: 1500\n\nThe connection MTU, e.g. 9000. This can't be applied when creating the interface and is done once the interface has been created.\nCan be used when modifying Team, VLAN, Ethernet (Future plans to implement wifi, pppoe, infiniband)"
              },
              "arp_interval": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with bond - ARP interval"
              },
              "flags": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with VLAN - flags"
              },
              "mode": {
                "enum": [
                  "balance-rr",
                  "active-backup",
                  "balance-xor",
                  "broadcast",
                  "802.3ad",
                  "balance-tlb",
                  "balance-alb"
                ],
                "type": "string",
                "description": "Default: balence-rr\n\nThis is the type of device or network connection that you wish to create for a bond, team or bridge."
              },
              "updelay": {
                "type": "string",
                "description": "Default: None\n\nThis is only used with bond - updelay"
              }
            }
          },
          "avi_role": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure Role object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "uuid": {
                "type": "string",
                "description": "Unique object identifier of the object."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "privileges": {
                "description": "List of permission.",
                "$ref": "#/definitions/ansible_array"
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the object."
              }
            }
          },
          "ec2_vpc_igw": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage an AWS VPC Internet gateway",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "vpc_id": {
                "type": "string",
                "description": "The VPC ID for the VPC in which to manage the Internet Gateway."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or terminate the IGW"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ovh_ip_loadbalancing_backend": {
            "required": [
              "endpoint",
              "name",
              "application_key",
              "application_secret",
              "consumer_key",
              "backend"
            ],
            "type": "object",
            "description": "Manage OVH (French European hosting provider) LoadBalancing IP backends",
            "properties": {
              "endpoint": {
                "type": "string",
                "description": "The endpoint to use ( for instance ovh-eu)"
              },
              "name": {
                "type": "string",
                "description": "Name of the LoadBalancing internal name (ip-X.X.X.X)"
              },
              "weight": {
                "description": "Default: 8\n\nDetermines the weight for this backend",
                "$ref": "#/definitions/ansible_number"
              },
              "probe": {
                "enum": [
                  "none",
                  "http",
                  "icmp",
                  "oco"
                ],
                "type": "string",
                "description": "Default: none\n\nDetermines the type of probe to use for this backend"
              },
              "application_key": {
                "type": "string",
                "description": "The applicationKey to use"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines wether the backend is to be created/modified or deleted"
              },
              "application_secret": {
                "type": "string",
                "description": "The application secret to use"
              },
              "timeout": {
                "description": "Default: 120\n\nThe timeout in seconds used to wait for a task to be completed. Default is 120 seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "consumer_key": {
                "type": "string",
                "description": "The consumer key to use"
              },
              "backend": {
                "type": "string",
                "description": "The IP address of the backend to update / modify / delete"
              }
            }
          },
          "azure_rm_resouregroup_facts": {
            "type": "object",
            "description": "Get facts for a specific resource group or all resource groups.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Limit results to a specific resource group."
              },
              "tags": {
                "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
                "$ref": "#/definitions/ansible_array"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "win_path": {
            "type": "object",
            "description": "Allows element-based ordering, addition, and removal of Windows path environment variables.",
            "properties": {
              "scope": {
                "type": "string",
                "description": "Default: machine\n\nThe level at which the environment variable specified by C(name) should be managed (either for the current user or global machine scope)."
              },
              "state": {
                "type": "string",
                "description": "Whether the path elements specified in C(elements) should be present or absent."
              },
              "elements": {
                "type": "string",
                "description": "A single path element, or a list of path elements (ie, directories) to add or remove.\nWhen multiple elements are included in the list (and C(state) is C(present)), the elements are guaranteed to appear in the same relative order in the resultant path value.\nVariable expansions (eg, C(%VARNAME%)) are allowed, and are stored unexpanded in the target path element.\nAny existing path elements not mentioned in C(elements) are always preserved in their current order.\nNew path elements are appended to the path, and existing path elements may be moved closer to the end to satisfy the requested ordering.\nPaths are compared in a case-insensitive fashion, and trailing backslashes are ignored for comparison purposes. However, note that trailing backslashes in YAML require quotes."
              },
              "name": {
                "type": "string",
                "description": "Default: PATH\n\nTarget path environment variable name"
              }
            }
          },
          "cnos_vlan": {
            "type": "object",
            "description": "This module allows you to work with VLAN related configurations. The operators used are overloaded to ensure control over switch VLAN configurations. The first level of VLAN configuration allows to set up the VLAN range, the VLAN tag persistence, a VLAN access map and access map filter. After passing this level, there are five VLAN arguments that will perform further configurations. They are vlanArg1, vlanArg2, vlanArg3, vlanArg4, and vlanArg5. The value of vlanArg1 will determine the way following arguments will be evaluated. For more details on how to use these arguments, see [Overloaded Variables]. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_vlan.html)",
            "properties": {
              "vlanArg5": {
                "type": "string",
                "description": "This is an overloaded vlan fifth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "vlanArg4": {
                "type": "string",
                "description": "This is an overloaded vlan fourth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "vlanArg3": {
                "type": "string",
                "description": "This is an overloaded vlan third argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "vlanArg2": {
                "type": "string",
                "description": "This is an overloaded vlan second argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "vlanArg1": {
                "type": "string",
                "description": "This is an overloaded vlan first argument. Usage of this argument can be found is the User Guide referenced above."
              }
            }
          },
          "proxmox_template": {
            "required": [
              "api_host",
              "api_user"
            ],
            "type": "object",
            "description": "allows you to upload/delete templates in Proxmox VE cluster",
            "properties": {
              "node": {
                "type": "string",
                "description": "Proxmox VE node, when you will operate with template"
              },
              "src": {
                "type": "string",
                "description": "path to uploaded file\nrequired only for C(state=present)"
              },
              "force": {
                "description": "can be used only with C(state=present), exists template will be overwritten",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_host": {
                "type": "string",
                "description": "the host of the Proxmox VE cluster"
              },
              "api_user": {
                "type": "string",
                "description": "the user to authenticate with"
              },
              "api_password": {
                "type": "string",
                "description": "the password to authenticate with\nyou can use PROXMOX_PASSWORD environment variable"
              },
              "storage": {
                "type": "string",
                "description": "Default: local\n\ntarget storage"
              },
              "timeout": {
                "description": "Default: 30\n\ntimeout for operations",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the template"
              },
              "content_type": {
                "enum": [
                  "vztmpl",
                  "iso"
                ],
                "type": "string",
                "description": "Default: vztmpl\n\ncontent type\nrequired only for C(state=present)"
              },
              "validate_certs": {
                "description": "enable / disable https certificate verification",
                "$ref": "#/definitions/ansible_truth"
              },
              "template": {
                "type": "string",
                "description": "the template name\nrequired only for states C(absent), C(info)"
              }
            }
          },
          "s3_sync": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "The S3 module is great, but it is very slow for a large volume of files- even a dozen will be noticeable. In addition to speed, it handles globbing, inclusions/exclusions, mime types, expiration mapping, recursion, and smart directory mapping.",
            "properties": {
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "exclude": {
                "type": "string",
                "description": "Default: .*\n\nShell pattern-style file matching.\nUsed after include to remove files (for instance, skip \"*.txt\")\nFor multiple patterns, comma-separate them."
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "include": {
                "type": "string",
                "description": "Default: *\n\nShell pattern-style file matching.\nUsed before exclude to determine eligible files (for instance, only \"*.gif\")\nFor multiple patterns, comma-separate them."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "file_change_strategy": {
                "enum": [
                  "force",
                  "checksum",
                  "date_size"
                ],
                "type": "string",
                "description": "Default: date_size\n\nDifference determination method to allow changes-only syncing. Unlike rsync, files are not patched- they are fully skipped or fully uploaded.\ndate_size will upload if file sizes don't match or if local file modified date is newer than s3's version\nchecksum will compare etag values based on s3's implementation of chunked md5s.\nforce will always upload all files."
              },
              "permission": {
                "enum": [
                  "private",
                  "public-read",
                  "public-read-write",
                  "authenticated-read",
                  "aws-exec-read",
                  "bucket-owner-read",
                  "bucket-owner-full-control"
                ],
                "type": "string",
                "description": "Canned ACL to apply to synced files.\nChanging this ACL only changes newly synced files, it does not trigger a full reupload."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "mime_map": {
                "type": "object",
                "description": "Dict entry from extension to MIME type. This will override any default/sniffed MIME type. For example C({\".txt\": \"application/text\", \".yml\": \"appication/text\"})"
              },
              "file_root": {
                "type": "string",
                "description": "File/directory path for synchronization. This is a local path.\nThis root path is scrubbed from the key name, so subdirectories will remain as keys."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "bucket": {
                "type": "string",
                "description": "Bucket name."
              },
              "mode": {
                "enum": [
                  "push"
                ],
                "type": "string",
                "description": "Default: push\n\nsync direction."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "key_prefix": {
                "type": "string",
                "description": "In addition to file path, prepend s3 path with this prefix. Module will add slash at end of prefix if necessary."
              }
            }
          },
          "dellos9_facts": {
            "type": "object",
            "description": "Collects a base set of device facts from a remote device that is running OS9.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module always collects  a base set of facts from the device and can enable or disable collection of additional facts.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen supplied, this argument restricts the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  You can specify a list of values to include a larger subset.  You can also use values with an initial M(!) to specify that a specific subset should not be collected.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "docker_service": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "docker_host",
                        "docker_url"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "key_path",
                        "tls_client_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_version",
                        "docker_api_version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cacert_path",
                        "tls_ca_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cert_path",
                        "tls_client_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Consumes docker compose to start, shutdown and scale services.\nWorks with compose versions 1 and 2.\nCompose can be read from a docker-compose.yml (or .yaml) file or inline using the C(definition) option.\nSee the examples for more details.\nSupports check mode.",
            "properties": {
              "project_src": {
                "type": "string",
                "description": "Path to a directory containing a docker-compose.yml or docker-compose.yaml file.\nMutually exclusive with C(definition).\nRequired when no C(definition) is provided."
              },
              "hostname_check": {
                "description": "Whether or not to check the Docker daemon's hostname against the name provided in the client certificate.",
                "$ref": "#/definitions/ansible_truth"
              },
              "recreate": {
                "enum": [
                  "always",
                  "never",
                  "smart"
                ],
                "type": "string",
                "description": "Default: smart\n\nBy default containers will be recreated when their configuration differs from the service definition.\nSetting to I(never) ignores configuration differences and leaves existing containers unchanged.\nSetting to I(always) forces recreation of all existing containers."
              },
              "docker_api_version": {
                "type": "string",
                "description": ""
              },
              "cacert_path": {
                "type": "string",
                "description": ""
              },
              "remove_images": {
                "enum": [
                  "all",
                  "local"
                ],
                "type": "string",
                "description": "Use with state I(absent) to remove the all images or only local images."
              },
              "tls_client_key": {
                "type": "string",
                "description": ""
              },
              "filter_logger": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "scale": {
                "type": "object",
                "description": "When C(state) is I(present) scale services. Provide a dictionary of key/value pairs where the key is the name of the service and the value is an integer count for the number of containers."
              },
              "nocache": {
                "description": "Use with the build option to ignore the cache during the image build process.",
                "$ref": "#/definitions/ansible_truth"
              },
              "docker_url": {
                "type": "string",
                "description": ""
              },
              "remove_volumes": {
                "description": "Use with state I(absent) to remove data volumes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tls_ca_cert": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the project.\nSpecifying I(present) is the same as running I(docker-compose up).\nSpecifying I(absent) is the same as running I(docker-compose down)."
              },
              "tls_client_cert": {
                "type": "string",
                "description": ""
              },
              "build": {
                "description": "Use with state I(present) to always build images prior to starting the application.\nSame as running docker-compose build with the pull option.\nImages will only be rebuilt if Docker detects a change in the Dockerfile or build directory contents.\nUse the C(nocache) option to ignore the image cache when performing the build.\nIf an existing image is replaced, services using the image will be recreated unless C(recreate) is I(never).",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "key_path": {
                "type": "string",
                "description": ""
              },
              "files": {
                "description": "List of file names relative to C(project_src). Overrides docker-compose.yml or docker-compose.yaml.\nFiles are loaded and merged in the order given.",
                "$ref": "#/definitions/ansible_array"
              },
              "project_name": {
                "type": "string",
                "description": "Provide a project name. If not provided, the project name is taken from the basename of C(project_src).\nRequired when no C(definition) is provided."
              },
              "pull": {
                "description": "Use with state I(present) to always pull images prior to starting the application.\nSame as running docker-compose pull.\nWhen a new image is pulled, services using the image will be recreated unless C(recreate) is I(never).",
                "$ref": "#/definitions/ansible_truth"
              },
              "tls_hostname": {
                "type": "string",
                "description": ""
              },
              "dependencies": {
                "description": "Default: True\n\nWhen C(state) is I(present) specify whether or not to include linked services.",
                "$ref": "#/definitions/ansible_truth"
              },
              "services": {
                "description": "When C(state) is I(present) run I(docker-compose up) on a subset of services.",
                "$ref": "#/definitions/ansible_array"
              },
              "cert_path": {
                "type": "string",
                "description": ""
              },
              "tls": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "definition": {
                "type": "object",
                "description": "Provide docker-compose yaml describing one or more services, networks and volumes.\nMutually exclusive with C(project_src) and C(files)."
              },
              "remove_orphans": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "restarted": {
                "description": "Use with state I(present) to restart all containers.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssl_version": {
                "type": "string",
                "description": ""
              },
              "docker_host": {
                "type": "string",
                "description": ""
              },
              "tls_verify": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "stopped": {
                "description": "Use with state I(present) to leave the containers in an exited or non-running state.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "debug": {
                "description": "Include I(actions) in the return values.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cs_region": {
            "required": [
              "id"
            ],
            "type": "object",
            "description": "Add, update and remove regions.",
            "properties": {
              "endpoint": {
                "type": "string",
                "description": "Endpoint URL of the region.\nRequired if C(state=present)"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the region."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "id": {
                "description": "ID of the region.\nMust be an number (int).",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Name of the region.\nRequired if C(state=present)"
              }
            }
          },
          "ec2_vpc_vgw_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about virtual gateways in AWS.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "vpn_gateway_ids": {
                "description": "Default: None\n\nGet details of a specific Virtual Gateway ID. This value should be provided as a list.",
                "$ref": "#/definitions/ansible_array"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "filters": {
                "type": "object",
                "description": "Default: None\n\nA dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "sf_volume_manager": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "enable512e",
                        "512emulation"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, destroy, or update volumes on SolidFire",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "size": {
                "description": "The size of the volume in (size_unit).\nRequired when C(state = present).",
                "$ref": "#/definitions/ansible_number"
              },
              "enable512e": {
                "description": "Should the volume provide 512-byte sector emulation?\nRequired when C(state=present)",
                "$ref": "#/definitions/ansible_truth"
              },
              "qos": {
                "type": "string",
                "description": "Default: None\n\nInitial quality of service settings for this volume."
              },
              "account_id": {
                "description": "Account ID for the owner of this volume.",
                "$ref": "#/definitions/ansible_number"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "size_unit": {
                "enum": [
                  "bytes",
                  "b",
                  "kb",
                  "mb",
                  "gb",
                  "tb",
                  "pb",
                  "eb",
                  "zb",
                  "yb"
                ],
                "type": "string",
                "description": "Default: gb\n\nThe unit used to interpret the size parameter."
              },
              "access": {
                "enum": [
                  "readOnly",
                  "readWrite",
                  "locked",
                  "replicationTarget"
                ],
                "type": "string",
                "description": "Default: None\n\nAccess allowed for the volume.\nreadOnly: Only read operations are allowed.\nreadWrite: Reads and writes are allowed.\nlocked: No reads or writes are allowed.\nreplicationTarget: Identify a volume as the target volume for a paired set of volumes. If the volume is not paired, the access status is locked.\nIf unspecified, the access settings of the clone will be the same as the source."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified volume should exist or not."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "volume_id": {
                "description": "Default: None\n\nThe ID of the volume to manage or update.\nIn order to create multiple volumes with the same name, but different volume_ids, please declare the I(volume_id) parameter with an arbitary value. However, the specified volume_id will not be assigned to the newly created volume (since it's an auto-generated property).",
                "$ref": "#/definitions/ansible_number"
              },
              "512emulation": {
                "description": "Should the volume provide 512-byte sector emulation?\nRequired when C(state=present)",
                "$ref": "#/definitions/ansible_truth"
              },
              "attributes": {
                "type": "object",
                "description": "Default: None\n\nA YAML dictionary of attributes that you would like to apply on this volume."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the volume to manage."
              }
            }
          },
          "os_image_facts": {
            "type": "object",
            "description": "Retrieve facts about a image image from OpenStack.",
            "properties": {
              "image": {
                "type": "string",
                "description": "Name or ID of the image"
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              }
            }
          },
          "ipadm_addr": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "address",
                        "addr"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create/delete static/dynamic IP addresses on network interfaces on Solaris/illumos systems.\nUp/down static/dynamic IP addresses on network interfaces on Solaris/illumos systems.\nManage IPv6 link-local addresses on network interfaces on Solaris/illumos systems.",
            "properties": {
              "addrtype": {
                "enum": [
                  "static",
                  "dhcp",
                  "addrconf"
                ],
                "type": "string",
                "description": "Default: static\n\nSpecifiies a type of IP address to configure."
              },
              "temporary": {
                "description": "Specifies that the configured IP address is temporary. Temporary IP addresses do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "addr": {
                "type": "string",
                "description": "Specifiies an IP address to configure in CIDR notation."
              },
              "state": {
                "enum": [
                  "absent",
                  "present",
                  "up",
                  "down",
                  "enabled",
                  "disabled",
                  "refreshed"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate/delete/enable/disable an IP address on the network interface."
              },
              "address": {
                "type": "string",
                "description": "Specifiies an IP address to configure in CIDR notation."
              },
              "wait": {
                "type": "string",
                "description": "Default: 60\n\nSpecifies the time in seconds we wait for obtaining address via DHCP."
              },
              "addrobj": {
                "type": "string",
                "description": "Specifies an unique IP address on the system."
              }
            }
          },
          "nxos_vtp_domain": {
            "required": [
              "domain"
            ],
            "type": "object",
            "description": "Manages VTP domain configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "domain": {
                "type": "string",
                "description": "VTP domain name."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "ec2_metric_alarm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Can create or delete AWS metric alarms.\nMetrics you wish to alarm on must already exist.",
            "properties": {
              "metric": {
                "type": "string",
                "description": "Name of the monitored metric (e.g. CPUUtilization)\nMetric must already exist"
              },
              "statistic": {
                "enum": [
                  "SampleCount",
                  "Average",
                  "Sum",
                  "Minimum",
                  "Maximum"
                ],
                "type": "string",
                "description": "Operation applied to the metric\nWorks in conjunction with period and evaluation_periods to determine the comparison value"
              },
              "period": {
                "description": "The time (in seconds) between metric evaluations",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "threshold": {
                "type": "number",
                "description": "Sets the min/max bound for triggering the alarm"
              },
              "unit": {
                "enum": [
                  "Seconds",
                  "Microseconds",
                  "Milliseconds",
                  "Bytes",
                  "Kilobytes",
                  "Megabytes",
                  "Gigabytes",
                  "Terabytes",
                  "Bits",
                  "Kilobits",
                  "Megabits",
                  "Gigabits",
                  "Terabits",
                  "Percent",
                  "Count",
                  "Bytes/Second",
                  "Kilobytes/Second",
                  "Megabytes/Second",
                  "Gigabytes/Second",
                  "Terabytes/Second",
                  "Bits/Second",
                  "Kilobits/Second",
                  "Megabits/Second",
                  "Gigabits/Second",
                  "Terabits/Second",
                  "Count/Second",
                  "None"
                ],
                "type": "string",
                "description": "The threshold's unit of measurement"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "dimensions": {
                "type": "object",
                "description": "Describes to what the alarm is applied"
              },
              "namespace": {
                "type": "string",
                "description": "Name of the appropriate namespace ('AWS/EC2', 'System/Linux', etc.), which determines the category it will appear under in cloudwatch"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "register or deregister the alarm"
              },
              "insufficient_data_actions": {
                "description": "A list of the names of action(s) to take when the alarm is in the 'insufficient_data' status",
                "$ref": "#/definitions/ansible_array"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "ok_actions": {
                "description": "A list of the names of action(s) to take when the alarm is in the 'ok' status",
                "$ref": "#/definitions/ansible_array"
              },
              "description": {
                "type": "string",
                "description": "A longer description of the alarm"
              },
              "evaluation_periods": {
                "description": "The number of times in which the metric is evaluated before final calculation",
                "$ref": "#/definitions/ansible_number"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "comparison": {
                "enum": [
                  "<=",
                  "<",
                  ">",
                  ">="
                ],
                "type": "string",
                "description": "Determines how the threshold value is compared"
              },
              "alarm_actions": {
                "description": "A list of the names action(s) taken when the alarm is in the 'alarm' status",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Unique name for the alarm"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cnos_factory": {
            "type": "object",
            "description": "This module allows you to reset a switch’s startup configuration. The method provides a way to reset the startup configuration to its factory settings. This is helpful when you want to move the switch to another topology as a new network device. This module uses SSH to manage network device configuration. The results of the operation can be viewed in results directory. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_factory.html)",
            "properties": {}
          },
          "vmware_vsan_cluster": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module can be used to configure VSAN clustering on an ESXi host",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "cluster_uuid": {
                "type": "string",
                "description": "Desired cluster UUID"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_permissions_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt permissions.",
            "properties": {
              "authz_name": {
                "type": "string",
                "description": "Authorization provider of the user/group. In previous versions of oVirt known as domain."
              },
              "namespace": {
                "type": "string",
                "description": "Namespace of the authorization provider, where user/group resides."
              },
              "user_name": {
                "type": "string",
                "description": "Username of the the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user."
              },
              "group_name": {
                "type": "string",
                "description": "Name of the the group to manage."
              }
            }
          },
          "quantum_network": {
            "required": [
              "login_password",
              "name"
            ],
            "type": "object",
            "description": "Add or Remove network from OpenStack.",
            "properties": {
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nName of the region"
              },
              "provider_network_type": {
                "enum": [
                  "local",
                  "vlan",
                  "flat",
                  "gre"
                ],
                "type": "string",
                "description": "Default: None\n\nThe type of the network to be created, gre, vlan, local. Available types depend on the plugin. The Quantum service decides if not specified."
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "router_external": {
                "description": "If 'yes', specifies that the virtual network is a external network (public).",
                "$ref": "#/definitions/ansible_truth"
              },
              "tenant_name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the tenant for whom the network is created"
              },
              "admin_state_up": {
                "description": "Default: True\n\nWhether the state should be marked as up or down",
                "$ref": "#/definitions/ansible_truth"
              },
              "provider_physical_network": {
                "type": "string",
                "description": "Default: None\n\nThe physical network which would realize the virtual network for flat and vlan networks."
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: yes\n\nThe tenant name of the login user"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone url for authentication"
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\nPassword of login user"
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "shared": {
                "description": "Whether this network is shared or not",
                "$ref": "#/definitions/ansible_truth"
              },
              "provider_segmentation_id": {
                "type": "string",
                "description": "Default: None\n\nThe id that has to be assigned to the network, in case of vlan networks that would be vlan id and for gre the tunnel id"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nName to be assigned to the network"
              }
            }
          },
          "dellos10_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "OS10 configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with OS10 configuration sections in a deterministic way.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir.  This argument is mutually exclusive with I(lines)."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "This argument causes the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made.  As with I(before), the playbook designer can use this argument  to append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).",
                "$ref": "#/definitions/ansible_array"
              },
              "update": {
                "enum": [
                  "merge",
                  "check"
                ],
                "type": "string",
                "description": "Default: merge\n\nThe I(update) argument controls how the configuration statements are processed on the remote device.  Valid choices for the I(update) argument are I(merge) and I(check).  When you set the argument to I(merge), the configuration changes merge with the current device running configuration.  When you set the argument to I(check), the configuration updates are determined but not actually configured on the remote device."
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "replace": {
                "enum": [
                  "line",
                  "block"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device. If you set the replace argument to I(line), then the modified lines push to the device in configuration mode.  If you set the replace argument to I(block), then the entire command block pushes to the device in configuration mode if any line is not correct."
              },
              "save": {
                "description": "The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If you specify check mode, this argument is ignored.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If you omit the parents argument, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": "The playbook designer can use the C(config) argument to supply the base configuration to be used to validate necessary configuration changes.  If you specify this argument, the module does not download the running-config from the remote node."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If you set match to I(line), commands match line by line.  If you set match to I(strict), command lines match by position.  If you set match to I(exact), command lines must be an equal match.  Finally, if you set match to I(none), the module does not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  The playbook designer can  use this argument to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "cloudwatchevent_rule": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module creates and manages CloudWatch event rules and targets.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "role_arn": {
                "type": "string",
                "description": "The Amazon Resource Name (ARN) of the IAM role associated with the rule"
              },
              "description": {
                "type": "string",
                "description": "A description of the rule"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the rule you are creating, updating or deleting. No spaces or special characters allowed (i.e. must match C([\\.\\-_A-Za-z0-9]+))"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "event_pattern": {
                "type": "string",
                "description": "A string pattern (in valid JSON format) that is used to match against incoming events to determine if the rule should be triggered"
              },
              "schedule_expression": {
                "type": "string",
                "description": "A cron or rate expression that defines the schedule the rule will trigger on. For example, C(cron(0 20 * * ? *)), C(rate(5 minutes))"
              },
              "state": {
                "enum": [
                  "present",
                  "disabled",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the rule is present (and enabled), disabled, or absent"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "targets": {
                "description": "A dictionary array of targets to add to or update for the rule, in the form C({ id: [string], arn: [string], input: [valid JSON string], input_path: [valid JSONPath string] }). I(id) [required] is the unique target assignment ID. I(arn) (required) is the Amazon Resource Name associated with the target. I(input) (optional) is a JSON object that will override the event data when passed to the target.  I(input_path) (optional) is a JSONPath string (e.g. C($.detail)) that specifies the part of the event data to be passed to the target. If neither I(input) nor I(input_path) is specified, then the entire event is passed to the target in JSON form.",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "rax_scaling_policy": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manipulate Rackspace Cloud Autoscale Scaling Policy",
            "properties": {
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "cron": {
                "type": "string",
                "description": "The time when the policy will be executed, as a cron entry. For example, if this is parameter is set to C(1 0 * * *)"
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cooldown": {
                "description": "The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).",
                "$ref": "#/definitions/ansible_number"
              },
              "at": {
                "type": "string",
                "description": "The UTC time when this policy will be executed. The time must be formatted according to C(yyyy-MM-dd'T'HH:mm:ss.SSS) such as C(2013-05-19T08:07:08Z)"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "is_percent": {
                "description": "Whether the value in I(change) is a percent value",
                "$ref": "#/definitions/ansible_truth"
              },
              "desired_capacity": {
                "description": "The desired server capacity of the scaling the group; that is, how many servers should be in the scaling group.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "policy_type": {
                "enum": [
                  "webhook",
                  "schedule"
                ],
                "type": "string",
                "description": "The type of policy that will be executed for the current release."
              },
              "scaling_group": {
                "type": "string",
                "description": "Name of the scaling group that this policy will be added to"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "change": {
                "description": "The change, either as a number of servers or as a percentage, to make in the scaling group. If this is a percentage, you must set I(is_percent) to C(true) also.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Name to give the policy"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "librato_annotation": {
            "required": [
              "title",
              "user",
              "api_key"
            ],
            "type": "object",
            "description": "Create an annotation event on the given annotation stream :name. If the annotation stream does not exist, it will be created automatically",
            "properties": {
              "name": {
                "type": "string",
                "description": "The annotation stream name\nIf the annotation stream does not exist, it will be created automatically"
              },
              "links": {
                "description": "See examples",
                "$ref": "#/definitions/ansible_array"
              },
              "title": {
                "type": "string",
                "description": "The title of an annotation is a string and may contain spaces\nThe title should be a short, high-level summary of the annotation e.g. v45 Deployment"
              },
              "start_time": {
                "description": "The unix timestamp indicating the the time at which the event referenced by this annotation started",
                "$ref": "#/definitions/ansible_number"
              },
              "source": {
                "type": "string",
                "description": "A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population"
              },
              "end_time": {
                "description": "The unix timestamp indicating the the time at which the event referenced by this annotation ended\nFor events that have a duration, this is a useful way to annotate the duration of the event",
                "$ref": "#/definitions/ansible_number"
              },
              "user": {
                "type": "string",
                "description": "Librato account username"
              },
              "api_key": {
                "type": "string",
                "description": "Librato account api key"
              },
              "description": {
                "type": "string",
                "description": "The description contains extra meta-data about a particular annotation\nThe description should contain specifics on the individual annotation e.g. Deployed 9b562b2 shipped new feature foo!"
              }
            }
          },
          "gc_storage": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "expiration",
                        "expiry"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "overwrite",
                        "force"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module allows users to manage their objects/buckets in Google Cloud Storage.  It allows upload and download operations and can set some canned permissions. It also allows retrieval of URLs for objects for use in playbooks, and retrieval of string contents of objects.  This module requires setting the default project in GCS prior to playbook usage.  See U(https://developers.google.com/storage/docs/reference/v1/apiversion1) for information about setting the default project.",
            "properties": {
              "src": {
                "type": "string",
                "description": "The source file path when performing a PUT operation."
              },
              "force": {
                "description": "Default: True\n\nForces an overwrite either locally on the filesystem or remotely with the object/key. Used with PUT and GET operations.",
                "$ref": "#/definitions/ansible_truth"
              },
              "permission": {
                "enum": [
                  "private",
                  "public-read",
                  "authenticated-read"
                ],
                "type": "string",
                "description": "Default: private\n\nThis option let's the user set the canned permissions on the object/bucket that are created. The permissions that can be set are 'private', 'public-read', 'authenticated-read'."
              },
              "gs_secret_key": {
                "type": "string",
                "description": "GS secret key. If not set then the value of the GS_SECRET_ACCESS_KEY environment variable is used."
              },
              "gs_access_key": {
                "type": "string",
                "description": "GS access key. If not set then the value of the GS_ACCESS_KEY_ID environment variable is used."
              },
              "object": {
                "type": "string",
                "description": "Keyname of the object inside the bucket. Can be also be used to create \"virtual directories\" (see examples)."
              },
              "bucket": {
                "type": "string",
                "description": "Bucket name."
              },
              "expiry": {
                "description": "Time limit (in seconds) for the URL generated and returned by GCA when performing a mode=put or mode=get_url operation. This url is only available when public-read is the acl for the object.",
                "$ref": "#/definitions/ansible_number"
              },
              "headers": {
                "type": "object",
                "description": "Default: {}\n\nHeaders to attach to object."
              },
              "dest": {
                "type": "string",
                "description": "The destination file path when downloading an object/key with a GET operation."
              },
              "expiration": {
                "description": "Time limit (in seconds) for the URL generated and returned by GCA when performing a mode=put or mode=get_url operation. This url is only available when public-read is the acl for the object.",
                "$ref": "#/definitions/ansible_number"
              },
              "overwrite": {
                "description": "Default: True\n\nForces an overwrite either locally on the filesystem or remotely with the object/key. Used with PUT and GET operations.",
                "$ref": "#/definitions/ansible_truth"
              },
              "mode": {
                "enum": [
                  "get",
                  "put",
                  "get_url",
                  "get_str",
                  "delete",
                  "create"
                ],
                "type": "string",
                "description": "Switches the module behaviour between upload, download, get_url (return download url) , get_str (download object as string), create (bucket) and delete (bucket)."
              }
            }
          },
          "nxos_user": {
            "type": "object",
            "description": "This module provides declarative management of the local usernames configured on Cisco Nexus devices.  It allows playbooks to manage either individual usernames or the collection of usernames in the current running config.  It also supports purging usernames from the configuration that are not explicitly defined.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "update_password": {
                "enum": [
                  "on_create",
                  "always"
                ],
                "type": "string",
                "description": "Default: always\n\nSince passwords are encrypted in the device running config, this argument will instruct the module when to change the password.  When set to C(always), the password will always be updated in the device and when set to C(on_create) the password will be updated only if the username is created."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "sshkey": {
                "type": "string",
                "description": "The C(sshkey) argument defines the SSH public key to configure for the username.  This argument accepts a valid SSH key value."
              },
              "roles": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe C(state) argument configures the state of the username definition as it relates to the device operational configuration.  When set to I(present), the username(s) should be configured in the device active configuration and when set to I(absent) the username(s) should not be in the device active configuration"
              },
              "purge": {
                "description": "The C(purge) argument instructs the module to consider the resource definition absolute.  It will remove any previously configured usernames on the device with the exception of the `admin` user which cannot be deleted per nxos constraints.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "users": {
                "description": "The set of username objects to be configured on the remote Cisco Nexus device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(name) argument.",
                "$ref": "#/definitions/ansible_array"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The username to be configured on the remote Cisco Nexus device.  This argument accepts a stringv value and is mutually exclusive with the C(users) argument."
              }
            }
          },
          "sefcontext": {
            "type": "object",
            "description": "Manages SELinux file context mapping definitions\nSimilar to the C(semanage fcontext) command",
            "properties": {
              "target": {
                "type": "string",
                "description": "Target path (expression)."
              },
              "selevel": {
                "type": "string",
                "description": "SELinux range for the specified target."
              },
              "seuser": {
                "type": "string",
                "description": "SELinux user for the specified target."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nDesired boolean value."
              },
              "reload": {
                "type": "string",
                "description": "Default: True\n\nReload SELinux policy after commit."
              },
              "setype": {
                "type": "string",
                "description": "SELinux type for the specified target."
              },
              "ftype": {
                "type": "string",
                "description": "Default: a\n\nFile type."
              }
            }
          },
          "na_cdot_user_role": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or destroy user roles",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the role to manage."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "vserver": {
                "type": "string",
                "description": "The name of the vserver to use."
              },
              "access_level": {
                "enum": [
                  "none",
                  "readonly",
                  "all"
                ],
                "type": "string",
                "description": "Default: all\n\nThe name of the role to manage."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified user should exist or not."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "command_directory_name": {
                "type": "string",
                "description": "The command or command directory to which the role has an access."
              }
            }
          },
          "cs_instance_facts": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Gathering facts from the API of an instance.",
            "properties": {
              "account": {
                "type": "string",
                "description": "Account the instance is related to."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "domain": {
                "type": "string",
                "description": "Domain the instance is related to."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Project the instance is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name or display name of the instance."
              }
            }
          },
          "vmware_dvs_host": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove a host from distributed virtual switch",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "If the host should be present or absent attached to the vSwitch"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "esxi_hostname": {
                "type": "string",
                "description": "The ESXi hostname"
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "vmnics": {
                "description": "The ESXi hosts vmnics to use with the Distributed vSwitch",
                "$ref": "#/definitions/ansible_array"
              },
              "switch_name": {
                "type": "string",
                "description": "The name of the Distributed vSwitch"
              }
            }
          },
          "beadm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "be"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "be"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, delete or activate ZFS boot environments.\nMount and unmount ZFS boot environments.",
            "properties": {
              "be": {
                "type": "string",
                "description": "ZFS boot environment name."
              },
              "force": {
                "description": "Specifies if the unmount should be forced.",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "Associate a description with a new boot environment. This option is available only on Solarish platforms."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "activated",
                  "mounted",
                  "unmounted"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete ZFS boot environment."
              },
              "snapshot": {
                "type": "string",
                "description": "If specified, the new boot environment will be cloned from the given snapshot or inactive boot environment."
              },
              "mountpoint": {
                "type": "string",
                "description": "Path where to mount the ZFS boot environment"
              },
              "options": {
                "type": "string",
                "description": "Create the datasets for new BE with specific ZFS properties. Multiple options can be specified. This option is available only on Solarish platforms."
              },
              "name": {
                "type": "string",
                "description": "ZFS boot environment name."
              }
            }
          },
          "s3_bucket": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "s3_url",
                        "S3_URL"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage S3 buckets in AWS, Ceph, Walrus and FakeS3",
            "properties": {
              "force": {
                "description": "When trying to delete a bucket, delete all keys in the bucket first (an s3 bucket must be empty for a successful deletion)",
                "$ref": "#/definitions/ansible_truth"
              },
              "S3_URL": {
                "type": "string",
                "description": "S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc. Otherwise assumes AWS"
              },
              "ceph": {
                "description": "Enable API compatibility with Ceph. It takes into account the S3 API subset working with Ceph in order to provide the same module behaviour where possible.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or remove the s3 bucket"
              },
              "policy": {
                "type": "string",
                "description": "The JSON policy as a string."
              },
              "s3_url": {
                "type": "string",
                "description": "S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc. Otherwise assumes AWS"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "tags dict to apply to bucket"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the s3 bucket"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "requester_pays": {
                "description": "With Requester Pays buckets, the requester instead of the bucket owner pays the cost of the request and the data download from the bucket.",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "versioning": {
                "description": "Whether versioning is enabled or disabled (note that once versioning is enabled, it can only be suspended)",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rabbitmq_policy": {
            "required": [
              "name",
              "tags",
              "pattern"
            ],
            "type": "object",
            "description": "Manage the state of a virtual host in RabbitMQ.",
            "properties": {
              "node": {
                "type": "string",
                "description": "Default: rabbit\n\nErlang node name of the rabbit we wish to configure."
              },
              "name": {
                "type": "string",
                "description": "The name of the policy to manage."
              },
              "tags": {
                "type": "object",
                "description": "A dict or string describing the policy."
              },
              "pattern": {
                "type": "string",
                "description": "A regex of queues to apply the policy to."
              },
              "priority": {
                "type": "string",
                "description": "The priority of the policy."
              },
              "vhost": {
                "type": "string",
                "description": "Default: /\n\nThe name of the vhost to apply to."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state of the policy."
              },
              "apply_to": {
                "enum": [
                  "all",
                  "exchanges",
                  "queues"
                ],
                "type": "string",
                "description": "Default: all\n\nWhat the policy applies to. Requires RabbitMQ 3.2.0 or later."
              }
            }
          },
          "route53_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "resource_id",
                        "resource_ids"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gets various details related to Route53 zone, record set or health check details",
            "properties": {
              "resource_id": {
                "description": "The ID/s of the specified resource/s",
                "$ref": "#/definitions/ansible_array"
              },
              "hosted_zone_id": {
                "type": "string",
                "description": "The Hosted Zone ID of the DNS zone"
              },
              "health_check_id": {
                "type": "string",
                "description": "The ID of the health check"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "query": {
                "enum": [
                  "change",
                  "checker_ip_range",
                  "health_check",
                  "hosted_zone",
                  "record_sets",
                  "reusable_delegation_set"
                ],
                "type": "string",
                "description": "specifies the query action to take"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "resource_ids": {
                "description": "The ID/s of the specified resource/s",
                "$ref": "#/definitions/ansible_array"
              },
              "next_marker": {
                "type": "string",
                "description": "Some requests such as list_command: hosted_zones will return a maximum number of entries - EG 100. If the number of entries exceeds this maximum another request can be sent using the NextMarker entry from the first response to get the next page of results"
              },
              "type": {
                "enum": [
                  "A",
                  "CNAME",
                  "MX",
                  "AAAA",
                  "TXT",
                  "PTR",
                  "SRV",
                  "SPF",
                  "NS"
                ],
                "type": "string",
                "description": "The type of DNS record"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "hosted_zone_method": {
                "enum": [
                  "details",
                  "list",
                  "list_by_name",
                  "count",
                  "tags"
                ],
                "type": "string",
                "description": "Default: list\n\nThis is used in conjunction with query: hosted_zone. It allows for listing details, counts or tags of various hosted zone details."
              },
              "health_check_method": {
                "enum": [
                  "list",
                  "details",
                  "status",
                  "failure_reason",
                  "count",
                  "tags"
                ],
                "type": "string",
                "description": "Default: list\n\nThis is used in conjunction with query: health_check. It allows for listing details, counts or tags of various health check details."
              },
              "delegation_set_id": {
                "type": "string",
                "description": "The DNS Zone delegation set ID"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "start_record_name": {
                "type": "string",
                "description": "The first name in the lexicographic ordering of domain names that you want the list_command: record_sets to start listing from"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "change_id": {
                "type": "string",
                "description": "The ID of the change batch request. The value that you specify here is the value that ChangeResourceRecordSets returned in the Id element when you submitted the request."
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "max_items": {
                "type": "string",
                "description": "Maximum number of items to return for various get/list requests"
              },
              "dns_name": {
                "type": "string",
                "description": "The first name in the lexicographic ordering of domain names that you want the list_command to start listing from"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "homebrew_tap": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "tap"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "tap"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Tap external Homebrew repositories.",
            "properties": {
              "url": {
                "type": "string",
                "description": "The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nstate of the repository."
              },
              "tap": {
                "description": "The GitHub user/organization repository to tap.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "description": "The GitHub user/organization repository to tap.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "ovirt_datacenters": {
            "required": [
              "name",
              "auth"
            ],
            "type": "object",
            "description": "Module to manage data centers in oVirt",
            "properties": {
              "compatibility_version": {
                "type": "string",
                "description": "Compatibility version of the data center."
              },
              "comment": {
                "type": "string",
                "description": "Comment of the data center."
              },
              "name": {
                "type": "string",
                "description": "Name of the the data center to manage."
              },
              "mac_pool": {
                "type": "string",
                "description": "MAC pool to be used by this datacenter.\nIMPORTANT: This option is deprecated in oVirt 4.1. You should use C(mac_pool) in C(ovirt_clusters) module, as MAC pools are set per cluster since 4.1."
              },
              "local": {
                "description": "I(True) if the data center should be local, I(False) if should be shared.\nDefault value is set by engine.",
                "$ref": "#/definitions/ansible_truth"
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the data center be present or absent"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "quota_mode": {
                "enum": [
                  "disabled",
                  "audit",
                  "enabled"
                ],
                "type": "string",
                "description": "Quota mode of the data center. One of I(disabled), I(audit) or I(enabled)"
              },
              "description": {
                "type": "string",
                "description": "Description of the data center."
              }
            }
          },
          "na_cdot_license": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove licenses on NetApp ONTAP.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "remove_unused": {
                "description": "Remove licenses that have no controller affiliation in the cluster.",
                "$ref": "#/definitions/ansible_truth"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "licenses": {
                "type": "object",
                "description": "List of licenses to add or remove.\nPlease note that trying to remove a non-existent license will throw an error."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "remove_expired": {
                "description": "Remove licenses that have expired in the cluster.",
                "$ref": "#/definitions/ansible_truth"
              },
              "serial_number": {
                "type": "string",
                "description": "Default: None\n\nSerial number of the node associated with the license.\nThis parameter is used primarily when removing license for a specific service.\nIf this parameter is not provided, the cluster serial number is used by default."
              },
              "password": {
                "type": "string",
                "description": ""
              }
            }
          },
          "easy_install": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Installs Python libraries, optionally in a I(virtualenv)",
            "properties": {
              "virtualenv": {
                "type": "string",
                "description": "an optional I(virtualenv) directory path to install into. If the I(virtualenv) does not exist, it is created automatically"
              },
              "executable": {
                "type": "string",
                "description": "The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example C(easy_install-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation."
              },
              "name": {
                "type": "string",
                "description": "A Python library name"
              },
              "virtualenv_command": {
                "type": "string",
                "description": "Default: virtualenv\n\nThe command to create the virtual environment with. For example C(pyvenv), C(virtualenv), C(virtualenv2)."
              },
              "virtualenv_site_packages": {
                "description": "Default: no\n\nWhether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "latest"
                ],
                "type": "string",
                "description": "Default: present\n\nThe desired state of the library. C(latest) ensures that the latest version is installed."
              }
            }
          },
          "yum": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "expire-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Installs, upgrade, removes, and lists packages and groups with the I(yum) package manager.",
            "properties": {
              "expire-cache": {
                "description": "Default: no\n\nForce yum to check if cache is out of date and redownload if needed. Has an effect only if state is I(present) or I(latest).",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "Package name, or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: yum -y update. You can also pass a url or a local path to a rpm file (using state=present).  To operate on several packages this can accept a comma separated list of packages or (as of 2.0) a list of packages.",
                "$ref": "#/definitions/ansible_array"
              },
              "list": {
                "type": "string",
                "description": "Package name to run the equivalent of yum list <package> against."
              },
              "disable_gpg_check": {
                "description": "Default: no\n\nWhether to disable the GPG checking of signatures of packages being installed. Has an effect only if state is I(present) or I(latest).",
                "$ref": "#/definitions/ansible_truth"
              },
              "conf_file": {
                "type": "string",
                "description": "The remote yum configuration file to use for the transaction."
              },
              "install_repoquery": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "latest",
                  "absent",
                  "removed"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to install (C(present) or C(installed), C(latest)), or remove (C(absent) or C(removed)) a package."
              },
              "disablerepo": {
                "type": "string",
                "description": "I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\"."
              },
              "update_cache": {
                "description": "Default: no\n\nForce yum to check if cache is out of date and redownload if needed. Has an effect only if state is I(present) or I(latest).",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "Package name, or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: yum -y update. You can also pass a url or a local path to a rpm file (using state=present).  To operate on several packages this can accept a comma separated list of packages or (as of 2.0) a list of packages.",
                "$ref": "#/definitions/ansible_array"
              },
              "enablerepo": {
                "type": "string",
                "description": "I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\"."
              },
              "exclude": {
                "type": "string",
                "description": "Package name(s) to exclude when state=present, or latest"
              },
              "validate_certs": {
                "description": "Default: yes\n\nThis only applies if using a https url as the source of the rpm. e.g. for localinstall. If set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.\nPrior to 2.1 the code worked as if this was set to C(yes).",
                "$ref": "#/definitions/ansible_truth"
              },
              "installroot": {
                "type": "string",
                "description": "Default: /\n\nSpecifies an alternative installroot, relative to which all packages will be installed."
              },
              "skip_broken": {
                "description": "Default: no\n\nResolve depsolve problems by removing packages that are causing problems from the trans‐ action.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rax_mon_notification_plan": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or delete a Rackspace Cloud Monitoring notification plan by associating existing rax_mon_notifications with severity levels. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> rax_mon_notification -> *rax_mon_notification_plan* -> rax_mon_alarm",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "warning_state": {
                "description": "Notification list to use when the alarm state is WARNING. Must be an array of valid rax_mon_notification ids.",
                "$ref": "#/definitions/ansible_array"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "critical_state": {
                "description": "Notification list to use when the alarm state is CRITICAL. Must be an array of valid rax_mon_notification ids.",
                "$ref": "#/definitions/ansible_array"
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "label": {
                "type": "string",
                "description": "Defines a friendly name for this notification plan. String between 1 and 255 characters long."
              },
              "ok_state": {
                "description": "Notification list to use when the alarm state is OK. Must be an array of valid rax_mon_notification ids.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Ensure that the notification plan with this C(label) exists or does not exist."
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "win_owner": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Set owner of files or directories",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": ""
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "lambda": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "zip_file",
                        "src"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Allows for the management of Lambda functions.",
            "properties": {
              "s3_key": {
                "type": "string",
                "description": "The Amazon S3 object (the deployment package) key name you want to upload"
              },
              "s3_object_version": {
                "type": "string",
                "description": "The Amazon S3 object (the deployment package) version you want to upload."
              },
              "memory_size": {
                "description": "Default: 128\n\nThe amount of memory, in MB, your Lambda function is given",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete Lambda function"
              },
              "handler": {
                "type": "string",
                "description": "The function within your code that Lambda calls to begin execution"
              },
              "role": {
                "type": "string",
                "description": "The Amazon Resource Name (ARN) of the IAM role that Lambda assumes when it executes your function to access any other Amazon Web Services (AWS) resources. You may use the bare ARN if the role belongs to the same AWS account."
              },
              "vpc_security_group_ids": {
                "description": "Default: None\n\nList of VPC security group IDs to associate with the Lambda function. Required when vpc_subnet_ids is used.",
                "$ref": "#/definitions/ansible_array"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "A short, user-defined function description. Lambda does not use this value. Assign a meaningful description as you see fit."
              },
              "zip_file": {
                "type": "string",
                "description": "A .zip file containing your deployment package"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "A .zip file containing your deployment package"
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name you want to assign to the function you are uploading. Cannot be changed."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "Default: 3\n\nThe function execution time at which Lambda should terminate the function.",
                "$ref": "#/definitions/ansible_number"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "runtime": {
                "type": "string",
                "description": "The runtime environment for the Lambda function you are uploading. Required when creating a function. Use parameters as described in boto3 docs. Current example runtime environments are nodejs, nodejs4.3, java8 or python2.7"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "s3_bucket": {
                "type": "string",
                "description": "Amazon S3 bucket name where the .zip file containing your deployment package is stored"
              },
              "vpc_subnet_ids": {
                "description": "Default: None\n\nList of subnet IDs to run Lambda function in. Use this option if you need to access resources in your VPC. Leave empty if you don't want to run the function in a VPC.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "route53_health_check": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates and deletes DNS Health checks in Amazons Route53 service\nOnly the port, resource_path, string_match and request_interval are considered when updating existing health-checks.",
            "properties": {
              "request_interval": {
                "description": "Default: 30\n\nThe number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "The port on the endpoint on which you want Amazon Route 53 to perform health checks. Required for TCP checks.",
                "$ref": "#/definitions/ansible_number"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Specifies the action to take."
              },
              "resource_path": {
                "type": "string",
                "description": "The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html.\nRequired for all checks except TCP.\nThe path must begin with a /\nMaximum 255 characters."
              },
              "failure_threshold": {
                "description": "Default: 3\n\nThe number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa.",
                "$ref": "#/definitions/ansible_number"
              },
              "type": {
                "enum": [
                  "HTTP",
                  "HTTPS",
                  "HTTP_STR_MATCH",
                  "HTTPS_STR_MATCH",
                  "TCP"
                ],
                "type": "string",
                "description": "The type of health check that you want to create, which indicates how Amazon Route 53 determines whether an endpoint is healthy."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ip_address": {
                "type": "string",
                "description": "IP address of the end-point to check. Either this or `fqdn` has to be provided."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "fqdn": {
                "type": "string",
                "description": "Domain name of the endpoint to check. Either this or `ip_address` has to be provided. When both are given the `fqdn` is used in the `Host:` header of the HTTP request."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "string_match": {
                "type": "string",
                "description": "If the check type is HTTP_STR_MATCH or HTTP_STR_MATCH, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the first 5120 bytes of the response body, Amazon Route 53 considers the resource healthy."
              }
            }
          },
          "clc_firewall_policy": {
            "required": [
              "location",
              "source_account_alias"
            ],
            "type": "object",
            "description": "Create or delete or update firewall polices on Centurylink Cloud",
            "properties": {
              "destination_account_alias": {
                "type": "string",
                "description": "Default: None\n\nCLC alias for the destination account"
              },
              "destination": {
                "description": "Default: None\n\nThe list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'",
                "$ref": "#/definitions/ansible_array"
              },
              "enabled": {
                "enum": [
                  true,
                  false
                ],
                "type": "string",
                "description": "Default: True\n\nWhether the firewall policy is enabled or disabled"
              },
              "source": {
                "description": "Default: None\n\nThe list  of source addresses for traffic on the originating firewall. This is required when state is 'present\"",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to create or delete the firewall policy"
              },
              "location": {
                "type": "string",
                "description": "Target datacenter for the firewall policy"
              },
              "source_account_alias": {
                "type": "string",
                "description": "CLC alias for the source account"
              },
              "firewall_policy_id": {
                "type": "string",
                "description": "Default: None\n\nId of the firewall policy. This is required to update or delete an existing firewall policy"
              },
              "ports": {
                "description": "Default: None\n\nThe list of ports associated with the policy. TCP and UDP can take in single ports or port ranges.",
                "$ref": "#/definitions/ansible_array"
              },
              "wait": {
                "type": "string",
                "description": "Default: True\n\nWhether to wait for the provisioning tasks to finish before returning."
              }
            }
          },
          "cnos_interface": {
            "type": "object",
            "description": "This module allows you to work with interface related configurations. The operators used are overloaded to ensure control over switch interface configurations. Apart from the regular device connection related attributes, there are seven interface arguments that will perform further configurations. They are interfaceArg1, interfaceArg2, interfaceArg3, interfaceArg4, interfaceArg5, interfaceArg6, and interfaceArg7. For more details on how to use these arguments, see [Overloaded Variables]. Interface configurations are taken care at six contexts in a regular CLI. They are 1. Interface Name - Configurations 2. Ethernet Interface - Configurations 3. Loopback Interface Configurations 4. Management Interface Configurations 5. Port Aggregation - Configurations 6. VLAN Configurations This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_interface.html)",
            "properties": {
              "interfaceOption": {
                "type": "string",
                "description": "This specifies the attribute you specify subsequent to interface command"
              },
              "interfaceRange": {
                "type": "string",
                "description": "This specifies the interface range in which the port aggregation is envisaged"
              },
              "interfaceArg4": {
                "type": "string",
                "description": "This is an overloaded interface fourth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg5": {
                "type": "string",
                "description": "This is an overloaded interface fifth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg6": {
                "type": "string",
                "description": "This is an overloaded interface sixth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg7": {
                "type": "string",
                "description": "This is an overloaded interface seventh argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg1": {
                "type": "string",
                "description": "This is an overloaded interface first argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg2": {
                "type": "string",
                "description": "This is an overloaded interface second argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "interfaceArg3": {
                "type": "string",
                "description": "This is an overloaded interface third argument. Usage of this argument can be found is the User Guide referenced above."
              }
            }
          },
          "ec2_eip": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "public_ip",
                        "ip"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "device_id",
                        "instance_id"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module can allocate or release an EIP.\nThis module can associate/disassociate an EIP with instances or network interfaces.",
            "properties": {
              "release_on_disassociation": {
                "description": "whether or not to automatically release the EIP when it is disassociated",
                "$ref": "#/definitions/ansible_truth"
              },
              "ip": {
                "type": "string",
                "description": "The IP address of a previously allocated EIP.\nIf present and device is specified, the EIP is associated with the device.\nIf absent and device is specified, the EIP is disassociated from the device."
              },
              "public_ip": {
                "type": "string",
                "description": "The IP address of a previously allocated EIP.\nIf present and device is specified, the EIP is associated with the device.\nIf absent and device is specified, the EIP is disassociated from the device."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIf present, allocate an EIP or associate an existing EIP with a device.\nIf absent, disassociate the EIP from the device and optionally release it."
              },
              "device_id": {
                "type": "string",
                "description": "The id of the device for the EIP. Can be an EC2 Instance id or Elastic Network Interface (ENI) id."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "wait_timeout": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "instance_id": {
                "type": "string",
                "description": "The id of the device for the EIP. Can be an EC2 Instance id or Elastic Network Interface (ENI) id."
              },
              "reuse_existing_ip_allowed": {
                "description": "Reuse an EIP that is not associated to a device (when available), instead of allocating a new one.",
                "$ref": "#/definitions/ansible_truth"
              },
              "in_vpc": {
                "description": "allocate an EIP inside a VPC or not",
                "$ref": "#/definitions/ansible_truth"
              },
              "private_ip_address": {
                "type": "string",
                "description": "Default: None\n\nThe primary or secondary private IP address to associate with the Elastic IP address."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_affinity_groups": {
            "required": [
              "cluster",
              "auth",
              "name"
            ],
            "type": "object",
            "description": "This module manage affinity groups in oVirt. It can also manage assignments of those groups to VMs.",
            "properties": {
              "vm_enforcing": {
                "description": "If I(true) VM cannot start if it does not satisfy the C(vm_rule).",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "Description of the affinity group."
              },
              "host_rule": {
                "enum": [
                  "positive",
                  "negative"
                ],
                "type": "string",
                "description": "If I(positive) I(all) VMs in this group should run on the this host.\nIf I(negative) I(no) VMs in this group should run on the this host.\nC(This parameter is support since oVirt 4.1 version.)"
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the affinity group be present or absent."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the the affinity group to manage."
              },
              "cluster": {
                "type": "string",
                "description": "Name of the cluster of the affinity group."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "hosts": {
                "description": "List of the hosts names, which should have assigned this affinity group.\nC(This parameter is support since oVirt 4.1 version.)",
                "$ref": "#/definitions/ansible_array"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "vm_rule": {
                "enum": [
                  "positive",
                  "negative",
                  "disabled"
                ],
                "type": "string",
                "description": "If I(positive) I(all) VMs in this group should run on the host defined by C(host_rule).\nIf I(negative) I(no) VMs in this group should run on the host defined by C(host_rule).\nIf I(disabled) this affinity group doesn't take effect."
              },
              "host_enforcing": {
                "description": "If I(true) VM cannot start on host if it does not satisfy the C(host_rule).\nC(This parameter is support since oVirt 4.1 version.)",
                "$ref": "#/definitions/ansible_truth"
              },
              "vms": {
                "description": "List of the VMs names, which should have assigned this affinity group.",
                "$ref": "#/definitions/ansible_array"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "kibana_plugin": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manages Kibana plugins.",
            "properties": {
              "force": {
                "description": "Delete and re-install the plugin. Can be useful for plugins update",
                "$ref": "#/definitions/ansible_truth"
              },
              "plugin_bin": {
                "type": "string",
                "description": "Default: /opt/kibana/bin/kibana\n\nLocation of the plugin binary"
              },
              "url": {
                "type": "string",
                "description": "Default: None\n\nSet exact URL to download the plugin from. For local file, prefix its absolute path with file://"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of a plugin."
              },
              "version": {
                "type": "string",
                "description": "Default: None\n\nVersion of the plugin to be installed. If plugin exists with previous version, it will NOT be updated if C(force) is not set to yes"
              },
              "timeout": {
                "type": "string",
                "description": "Default: 1m\n\nTimeout setting: 30s, 1m, 1h..."
              },
              "plugin_dir": {
                "type": "string",
                "description": "Default: /opt/kibana/installedPlugins/\n\nYour configured plugin directory specified in Kibana"
              },
              "name": {
                "type": "string",
                "description": "Name of the plugin to install"
              }
            }
          },
          "asa_command": {
            "type": "object",
            "description": "Sends arbitrary commands to an ASA node and returns the results read from the device. The M(asa_command) module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.",
            "properties": {
              "retries": {
                "type": "string",
                "description": "Default: 10\n\nSpecifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions."
              },
              "commands": {
                "type": "string",
                "description": "List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired."
              },
              "wait_for": {
                "type": "string",
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples."
              },
              "match": {
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "interval": {
                "type": "string",
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again."
              }
            }
          },
          "ipa_host": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ns_hardware_platform",
                        "nshardwareplatform"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "user_certificate",
                        "usercertificate"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "fqdn",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "fqdn"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ns_os_version",
                        "nsosversion"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "mac_address",
                        "macaddress"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ns_host_location",
                        "nshostlocation"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify and delete an IPA host using IPA API",
            "properties": {
              "force": {
                "description": "Force host name even if not in DNS.",
                "$ref": "#/definitions/ansible_truth"
              },
              "usercertificate": {
                "description": "List of Base-64 encoded server certificates.\nIf option is omitted certificates will not be checked or changed.\nIf an emtpy list is passed all assigned certificates will be removed.\nCertificates already assigned but not passed will be removed.",
                "$ref": "#/definitions/ansible_array"
              },
              "nsosversion": {
                "type": "string",
                "description": "Host operating system and version (e.g. \"Fedora 9\")"
              },
              "ipa_host": {
                "type": "string",
                "description": "Default: ipa.example.com\n\nIP or hostname of IPA server"
              },
              "ns_hardware_platform": {
                "type": "string",
                "description": "Host hardware platform (e.g. \"Lenovo T61\")"
              },
              "user_certificate": {
                "description": "List of Base-64 encoded server certificates.\nIf option is omitted certificates will not be checked or changed.\nIf an emtpy list is passed all assigned certificates will be removed.\nCertificates already assigned but not passed will be removed.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState to ensure"
              },
              "mac_address": {
                "description": "List of Hardware MAC address(es) off this host.\nIf option is omitted MAC addresses will not be checked or changed.\nIf an empty list is passed all assigned MAC addresses will be removed.\nMAC addresses that are already assigned but not passed will be removed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_pass": {
                "type": "string",
                "description": "Password of administrative user"
              },
              "nshostlocation": {
                "type": "string",
                "description": "Host location (e.g. \"Lab 2\")"
              },
              "description": {
                "type": "string",
                "description": "A description of this host."
              },
              "nshardwareplatform": {
                "type": "string",
                "description": "Host hardware platform (e.g. \"Lenovo T61\")"
              },
              "ip_address": {
                "type": "string",
                "description": "Add the host to DNS with this IP address."
              },
              "macaddress": {
                "description": "List of Hardware MAC address(es) off this host.\nIf option is omitted MAC addresses will not be checked or changed.\nIf an empty list is passed all assigned MAC addresses will be removed.\nMAC addresses that are already assigned but not passed will be removed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_port": {
                "description": "Default: 443\n\nPort of IPA server",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Full qualified domain name.\nCan not be changed as it is the unique identifier."
              },
              "validate_certs": {
                "description": "Default: True\n\nThis only applies if C(ipa_prot) is I(https).\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ipa_prot": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nProtocol used by IPA server"
              },
              "fqdn": {
                "type": "string",
                "description": "Full qualified domain name.\nCan not be changed as it is the unique identifier."
              },
              "ns_os_version": {
                "type": "string",
                "description": "Host operating system and version (e.g. \"Fedora 9\")"
              },
              "ipa_user": {
                "type": "string",
                "description": "Default: admin\n\nAdministrative account used on IPA server"
              },
              "ns_host_location": {
                "type": "string",
                "description": "Host location (e.g. \"Lab 2\")"
              }
            }
          },
          "junos_facts": {
            "type": "object",
            "description": "Collects fact information from a remote device running the Junos operating system.  By default, the module will collect basic fact information from the device to be included with the hostvars. Additional fact information can be collected based on the configured set of arguments.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. To maintain backward compatbility old style facts can be retrieved using all value, this reqires junos-eznc to be installed as a prerequisite.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "config_format": {
                "enum": [
                  "xml",
                  "set",
                  "text",
                  "json"
                ],
                "type": "string",
                "description": "Default: text\n\nThe I(config_format) argument specifies the format of the configuration when serializing output from the device. This argument is applicable only when C(config) value is present in I(gather_subset)."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              }
            }
          },
          "cnos_vlag": {
            "type": "object",
            "description": "This module allows you to work with virtual Link Aggregation Groups (vLAG) related configurations. The operators used are overloaded to ensure control over switch vLAG configurations. Apart from the regular device connection related attributes, there are four vLAG arguments which are overloaded variables that will perform further configurations. They are vlagArg1, vlagArg2, vlagArg3, and vlagArg4. For more details on how to use these arguments, see [Overloaded Variables]. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_vlag.html)",
            "properties": {
              "vlagArg2": {
                "type": "string",
                "description": "This is an overloaded vlag second argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "vlagArg3": {
                "type": "string",
                "description": "This is an overloaded vlag third argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "vlagArg1": {
                "type": "string",
                "description": "This is an overloaded vlag first argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "vlagArg4": {
                "type": "string",
                "description": "This is an overloaded vlag fourth argument. Usage of this argument can be found is the User Guide referenced above."
              }
            }
          },
          "azure_rm_networkinterface": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "virtual_network_name",
                        "virtual_network"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "public_ip_address_name",
                        "public_ip_address",
                        "public_ip_name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "subnet_name",
                        "subnet"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_group_name",
                        "security_group"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, update or delete a network interface. When creating a network interface you must provide the name of an existing virtual network, the name of an existing subnet within the virtual network. A default security group and public IP address will be created automatically, or you can provide the name of an existing security group and public IP address. See the examples below for more details.",
            "properties": {
              "resource_group": {
                "type": "string",
                "description": "Name of a resource group where the network interface exists or will be created."
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "public_ip": {
                "description": "Default: True\n\nWhen creating a network interface, if no public IP address name is provided a default public IP address will be created. Set to false, if you do not want a public IP address automatically created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "public_ip_name": {
                "type": "string",
                "description": "Name of an existing public IP address object to associate with the security group."
              },
              "security_group_name": {
                "type": "string",
                "description": "Name of an existing security group with which to associate the network interface. If not provided, a default security group will be created."
              },
              "security_group": {
                "type": "string",
                "description": "Name of an existing security group with which to associate the network interface. If not provided, a default security group will be created."
              },
              "public_ip_address_name": {
                "type": "string",
                "description": "Name of an existing public IP address object to associate with the security group."
              },
              "subnet": {
                "type": "string",
                "description": "Name of an existing subnet within the specified virtual network. Required when creating a network interface"
              },
              "append_tags": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nAssert the state of the network interface. Use 'present' to create or update an interface and 'absent' to delete an interface."
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "subnet_name": {
                "type": "string",
                "description": "Name of an existing subnet within the specified virtual network. Required when creating a network interface"
              },
              "location": {
                "type": "string",
                "description": "Default: resource_group location\n\nValid azure location. Defaults to location of the resource group."
              },
              "public_ip_allocation_method": {
                "enum": [
                  "Dynamic",
                  "Static"
                ],
                "type": "string",
                "description": "Default: Dynamic\n\nIf a public_ip_address_name is not provided, a default public IP address will be created. The allocation method determines whether or not the public IP address assigned to the network interface is permanent."
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "public_ip_address": {
                "type": "string",
                "description": "Name of an existing public IP address object to associate with the security group."
              },
              "tags": {
                "type": "object",
                "description": ""
              },
              "virtual_network_name": {
                "type": "string",
                "description": "Name of an existing virtual network with which the network interface will be associated. Required when creating a network interface."
              },
              "open_ports": {
                "description": "When a default security group is created for a Linux host a rule will be added allowing inbound TCP connections to the default SSH port 22, and for a Windows host rules will be added allowing inbound access to RDP ports 3389 and 5986. Override the default ports by providing a list of open ports.",
                "$ref": "#/definitions/ansible_array"
              },
              "private_ip_allocation_method": {
                "enum": [
                  "Dynamic",
                  "Static"
                ],
                "type": "string",
                "description": "Default: Dynamic\n\nSpecify whether or not the assigned IP address is permanent. NOTE: when creating a network interface specifying a value of 'Static' requires that a private_ip_address value be provided. You can update the allocation method to 'Static' after a dynamic private ip address has been assigned."
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the network interface."
              },
              "private_ip_address": {
                "type": "string",
                "description": "Valid IPv4 address that falls within the specified subnet."
              },
              "virtual_network": {
                "type": "string",
                "description": "Name of an existing virtual network with which the network interface will be associated. Required when creating a network interface."
              },
              "os_type": {
                "enum": [
                  "Windows",
                  "Linux"
                ],
                "type": "string",
                "description": "Default: Linux\n\nDetermines any rules to be added to a default security group. When creating a network interface, if no security group name is provided, a default security group will be created. If the os_type is 'Windows', a rule will be added allowing RDP access. If the os_type is 'Linux', a rule allowing SSH access will be added."
              }
            }
          },
          "sros_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends arbitrary commands to an SR OS node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.\nThis module does not support running commands in configuration mode. Please use M(sros_config) to configure SR OS devices.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.",
                "$ref": "#/definitions/ansible_number"
              },
              "commands": {
                "description": "List of commands to send to the remote SR OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_for": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "any",
                  "all"
                ],
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "waitfor": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "jabber": {
            "required": [
              "to",
              "user",
              "msg",
              "password"
            ],
            "type": "object",
            "description": "Send a message to jabber",
            "properties": {
              "encoding": {
                "type": "string",
                "description": "message encoding"
              },
              "to": {
                "type": "string",
                "description": "user ID or name of the room, when using room use a slash to indicate your nick."
              },
              "host": {
                "type": "string",
                "description": "host to connect, overrides user info"
              },
              "user": {
                "type": "string",
                "description": "User as which to connect"
              },
              "msg": {
                "type": "string",
                "description": "The message body."
              },
              "password": {
                "type": "string",
                "description": "password for user to connect"
              },
              "port": {
                "type": "string",
                "description": "Default: 5222\n\nport to connect to, overrides default"
              }
            }
          },
          "iam_mfa_device_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "List the MFA (Multi-Factor Authentication) devices registered for a user",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "user_name": {
                "type": "string",
                "description": "The name of the user whose MFA devices will be listed"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "zabbix_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "host_groups",
                        "host_group"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "host_groups"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "host_group"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "server_url",
                        "url"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "server_url"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "url"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create host groups if they do not exist.\nDelete existing host groups if they exist.",
            "properties": {
              "http_login_password": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth password"
              },
              "timeout": {
                "description": "Default: 10\n\nThe timeout of API request(seconds).",
                "$ref": "#/definitions/ansible_number"
              },
              "url": {
                "type": "string",
                "description": "Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url)."
              },
              "login_user": {
                "type": "string",
                "description": "Zabbix user name."
              },
              "http_login_user": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth login"
              },
              "server_url": {
                "type": "string",
                "description": "Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url)."
              },
              "host_group": {
                "description": "List of host groups to create or delete.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete host group."
              },
              "host_groups": {
                "description": "List of host groups to create or delete.",
                "$ref": "#/definitions/ansible_array"
              },
              "login_password": {
                "type": "string",
                "description": "Zabbix user password."
              }
            }
          },
          "sros_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "defaults",
                        "detail"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Nokia SR OS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with SR OS configuration sections in a deterministic way.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines)."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "defaults": {
                "description": "This argument specifies whether or not to collect all defaults when getting the remote device running config.  When enabled, the module will get the current config by issuing the command C(show running-config all).",
                "$ref": "#/definitions/ansible_truth"
              },
              "backup": {
                "description": "This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "detail": {
                "description": "This argument specifies whether or not to collect all defaults when getting the remote device running config.  When enabled, the module will get the current config by issuing the command C(show running-config all).",
                "$ref": "#/definitions/ansible_truth"
              },
              "save": {
                "description": "The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": "The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "line",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device."
              }
            }
          },
          "iam": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Allows for the management of IAM users, user API keys, groups, roles.",
            "properties": {
              "update_password": {
                "enum": [
                  "always",
                  "on_create"
                ],
                "type": "string",
                "description": "Default: always\n\nC(always) will update passwords if they differ.  C(on_create) will only set the password for newly created users."
              },
              "access_key_ids": {
                "description": "A list of the keys that you want impacted by the access_key_state parameter.",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": "When type is user and state is present, define the users login password. Also works with update. Note that always returns changed."
              },
              "new_path": {
                "type": "string",
                "description": "When state is update, will replace the path with new_path on the IAM resource"
              },
              "access_key_state": {
                "enum": [
                  "active",
                  "inactive",
                  "create",
                  "remove",
                  "Active",
                  "Inactive",
                  "Create",
                  "Remove"
                ],
                "type": "string",
                "description": "When type is user, it creates, removes, deactivates or activates a user's access key(s). Note that actions apply only to keys specified."
              },
              "iam_type": {
                "enum": [
                  "user",
                  "group",
                  "role"
                ],
                "type": "string",
                "description": "Type of IAM resource"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "update"
                ],
                "type": "string",
                "description": "Whether to create, delete or update the IAM resource. Note, roles cannot be updated."
              },
              "trust_policy": {
                "type": "object",
                "description": "The inline (JSON or YAML) trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy_filepath)."
              },
              "trust_policy_filepath": {
                "type": "string",
                "description": "The path to the trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy)."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "key_count": {
                "description": "Default: 1\n\nWhen access_key_state is create it will ensure this quantity of keys are present. Defaults to 1.",
                "$ref": "#/definitions/ansible_number"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "groups": {
                "description": "A list of groups the user should belong to. When update, will gracefully remove groups not listed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "new_name": {
                "type": "string",
                "description": "When state is update, will replace name with new_name on IAM resource"
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of IAM resource to create or identify"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": "Default: /\n\nWhen creating or updating, specify the desired path of the resource. If state is present, it will replace the current path to match what is passed in when they do not match."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "proxysql_global_variables": {
            "required": [
              "variable"
            ],
            "type": "object",
            "description": "The M(proxysql_global_variables) module gets or sets the proxysql global variables.",
            "properties": {
              "login_port": {
                "description": "Default: 6032\n\nThe port used to connect to ProxySQL admin interface.",
                "$ref": "#/definitions/ansible_number"
              },
              "config_file": {
                "type": "string",
                "description": "Specify a config file from which login_user and login_password are to be read."
              },
              "login_user": {
                "type": "string",
                "description": "Default: None\n\nThe username used to authenticate to ProxySQL admin interface."
              },
              "login_host": {
                "type": "string",
                "description": "Default: 127.0.0.1\n\nThe host used to connect to ProxySQL admin interface."
              },
              "login_password": {
                "type": "string",
                "description": "Default: None\n\nThe password used to authenticate to ProxySQL admin interface."
              },
              "value": {
                "type": "string",
                "description": "Defines a value the variable specified using I(variable) should be set to."
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "load_to_runtime": {
                "description": "Default: True\n\nDynamically load mysql host config to runtime memory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "save_to_disk": {
                "description": "Default: True\n\nSave mysql host config to sqlite db on disk to persist the configuration.",
                "$ref": "#/definitions/ansible_truth"
              },
              "variable": {
                "type": "string",
                "description": "Defines which variable should be returned, or if I(value) is specified which variable should be updated."
              }
            }
          },
          "vsphere_copy": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "src",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "src"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "dest",
                        "path"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "host",
                        "hostname"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "host"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "hostname"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "login",
                        "username"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "login"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Upload files to a vCenter datastore",
            "properties": {
              "username": {
                "type": "string",
                "description": "The login name to authenticate on the vCenter server."
              },
              "datacenter": {
                "type": "string",
                "description": "The datacenter on the vCenter server that holds the datastore."
              },
              "name": {
                "type": "string",
                "description": "The file to push to vCenter"
              },
              "src": {
                "type": "string",
                "description": "The file to push to vCenter"
              },
              "dest": {
                "type": "string",
                "description": "The file to push to the datastore on the vCenter server."
              },
              "hostname": {
                "type": "string",
                "description": "The vCenter server on which the datastore is available."
              },
              "host": {
                "type": "string",
                "description": "The vCenter server on which the datastore is available."
              },
              "path": {
                "type": "string",
                "description": "The file to push to the datastore on the vCenter server."
              },
              "datastore": {
                "type": "string",
                "description": "The datastore on the vCenter server to push files to."
              },
              "password": {
                "type": "string",
                "description": "The password to authenticate on the vCenter server."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be set to C(no) when no other option exists.",
                "$ref": "#/definitions/ansible_truth"
              },
              "login": {
                "type": "string",
                "description": "The login name to authenticate on the vCenter server."
              }
            }
          },
          "os_client_config": {
            "type": "object",
            "description": "Get I(openstack) client config data from clouds.yaml or environment",
            "properties": {
              "clouds": {
                "description": "List of clouds to limit the return list to. No value means return information on all configured clouds",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "service": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "arguments",
                        "args"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Controls services on remote hosts. Supported init systems include BSD init, OpenRC, SysV, Solaris SMF, systemd, upstart.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the service."
              },
              "pattern": {
                "type": "string",
                "description": "If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.  If the string is found, the service will be assumed to be running."
              },
              "args": {
                "type": "string",
                "description": "Additional arguments provided on the command line"
              },
              "enabled": {
                "description": "Whether the service should start on boot. B(At least one of state and enabled are required.)",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "running",
                  "started",
                  "stopped",
                  "restarted",
                  "reloaded"
                ],
                "type": "string",
                "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary.  C(restarted) will always bounce the service.  C(reloaded) will always reload. B(At least one of state and enabled are required.) Note that reloaded will start the service if it is not already started, even if your chosen init system wouldn't normally."
              },
              "sleep": {
                "description": "If the service is being C(restarted) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.",
                "$ref": "#/definitions/ansible_number"
              },
              "arguments": {
                "type": "string",
                "description": "Additional arguments provided on the command line"
              },
              "runlevel": {
                "type": "string",
                "description": "Default: default\n\nFor OpenRC init scripts (ex: Gentoo) only.  The runlevel that this service belongs to."
              }
            }
          },
          "ec2_elb_lb": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Returns information about the load balancer.\nWill be marked changed when called only if state is changed.",
            "properties": {
              "purge_subnets": {
                "description": "Purge existing subnet on ELB that are not found in subnets",
                "$ref": "#/definitions/ansible_truth"
              },
              "zones": {
                "description": "List of availability zones to enable on this ELB",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "connection_draining_timeout": {
                "description": "Wait a specified timeout allowing connections to drain before terminating an instance",
                "$ref": "#/definitions/ansible_number"
              },
              "security_group_ids": {
                "description": "Default: None\n\nA list of security groups to apply to the elb",
                "$ref": "#/definitions/ansible_array"
              },
              "access_logs": {
                "type": "object",
                "description": "Default: None\n\nAn associative array of access logs configuration settings (see example)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Create or destroy the ELB"
              },
              "purge_listeners": {
                "description": "Default: True\n\nPurge existing listeners on ELB that are not found in listeners",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "subnets": {
                "description": "Default: None\n\nA list of VPC subnets to use when creating ELB. Zones should be empty if using this.",
                "$ref": "#/definitions/ansible_array"
              },
              "health_check": {
                "type": "object",
                "description": "Default: None\n\nAn associative array of health check configuration settings (see example)"
              },
              "tags": {
                "type": "object",
                "description": "An associative array of tags. To delete all tags, supply an empty dict."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "instance_ids": {
                "description": "List of instance ids to attach to this ELB",
                "$ref": "#/definitions/ansible_array"
              },
              "idle_timeout": {
                "description": "ELB connections from clients and to servers are timed out after this amount of time",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_timeout": {
                "description": "Default: 60\n\nUsed in conjunction with wait. Number of seconds to wait for the elb to be terminated. A maximum of 600 seconds (10 minutes) is allowed.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "cross_az_load_balancing": {
                "description": "Default: no\n\nDistribute load across all configured Availability Zones",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "purge_zones": {
                "description": "Purge existing availability zones on ELB that are not found in zones",
                "$ref": "#/definitions/ansible_truth"
              },
              "wait": {
                "description": "When specified, Ansible will check the status of the load balancer to ensure it has been successfully removed from AWS.",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "purge_instance_ids": {
                "description": "Purge existing instance ids on ELB that are not found in instance_ids",
                "$ref": "#/definitions/ansible_truth"
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "scheme": {
                "type": "string",
                "description": "Default: internet-facing\n\nThe scheme to use when creating the ELB. For a private VPC-visible ELB use 'internal'."
              },
              "name": {
                "type": "string",
                "description": "The name of the ELB"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "listeners": {
                "description": "List of ports/protocols for this ELB to listen on (see example)",
                "$ref": "#/definitions/ansible_array"
              },
              "security_group_names": {
                "description": "Default: None\n\nA list of security group names to apply to the elb",
                "$ref": "#/definitions/ansible_array"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "Default: yes\n\nWhen set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
                "$ref": "#/definitions/ansible_truth"
              },
              "stickiness": {
                "type": "object",
                "description": "An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )"
              }
            }
          },
          "dladm_vnic": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "mac",
                        "macaddr"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "vlan",
                        "vlan_id"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or delete VNICs on Solaris/illumos systems.",
            "properties": {
              "macaddr": {
                "type": "string",
                "description": "Sets the VNIC's MAC address. Must be valid unicast MAC address."
              },
              "temporary": {
                "description": "Specifies that the VNIC is temporary. Temporary VNICs do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "VNIC name."
              },
              "vlan": {
                "type": "string",
                "description": "Enable VLAN tagging for this VNIC. The VLAN tag will have id I(vlan)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete Solaris/illumos VNIC."
              },
              "mac": {
                "type": "string",
                "description": "Sets the VNIC's MAC address. Must be valid unicast MAC address."
              },
              "link": {
                "type": "string",
                "description": "VNIC underlying link name."
              },
              "vlan_id": {
                "type": "string",
                "description": "Enable VLAN tagging for this VNIC. The VLAN tag will have id I(vlan)."
              }
            }
          },
          "nxos_facts": {
            "type": "object",
            "description": "Collects facts from Cisco Nexus devices running the NX-OS operating system.  Fact collection is supported over both Cli and Nxapi transports.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, legacy, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "nxos_hsrp": {
            "required": [
              "interface",
              "group"
            ],
            "type": "object",
            "description": "Manages HSRP configuration on NX-OS switches.",
            "properties": {
              "auth_type": {
                "enum": [
                  "text",
                  "md5"
                ],
                "type": "string",
                "description": "Authentication type."
              },
              "preempt": {
                "enum": [
                  "disabled",
                  "enabled"
                ],
                "type": "string",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "group": {
                "type": "string",
                "description": "HSRP group number."
              },
              "priority": {
                "type": "string",
                "description": "HSRP priority."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify desired state of the resource."
              },
              "version": {
                "enum": [
                  "1",
                  "2"
                ],
                "type": "string",
                "description": "Default: 2\n\nHSRP version."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "auth_string": {
                "type": "string",
                "description": "Authentication string."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Full name of interface that is being managed for HSRP."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "vip": {
                "type": "string",
                "description": "HSRP virtual IP address."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "puppet": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "show_diff",
                        "show-diff"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Runs I(puppet) agent or apply in a reliable manner",
            "properties": {
              "logdest": {
                "enum": [
                  "stdout",
                  "syslog"
                ],
                "type": "string",
                "description": "Default: stdout\n\nWhere the puppet logs should go, if puppet apply is being used"
              },
              "execute": {
                "type": "string",
                "description": "Default: None\n\nExecute a specific piece of Puppet code. It has no effect with a puppetmaster."
              },
              "facter_basename": {
                "type": "string",
                "description": "Default: ansible\n\nBasename of the facter output file"
              },
              "tags": {
                "description": "Default: None\n\nA comma-separated list of puppet tags to be used.",
                "$ref": "#/definitions/ansible_array"
              },
              "puppetmaster": {
                "type": "string",
                "description": "Default: None\n\nThe hostname of the puppetmaster to contact."
              },
              "show_diff": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "certname": {
                "type": "string",
                "description": "Default: None\n\nThe name to use when handling certificates."
              },
              "manifest": {
                "type": "string",
                "description": "Default: None\n\nPath to the manifest file to run puppet apply on."
              },
              "show-diff": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "type": "string",
                "description": "Default: 30m\n\nHow long to wait for I(puppet) to finish."
              },
              "facts": {
                "type": "string",
                "description": "Default: None\n\nA dict of values to pass in as persistent external facter facts"
              },
              "environment": {
                "type": "string",
                "description": "Default: None\n\nPuppet environment to be used."
              }
            }
          },
          "ec2_snapshot": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "creates an EC2 snapshot from an existing EBS volume",
            "properties": {
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "snapshot_id": {
                "type": "string",
                "description": "snapshot id to remove"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "snapshot_tags": {
                "type": "object",
                "description": "a hash/dictionary of tags to add to the snapshot"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nwhether to add or create a snapshot"
              },
              "last_snapshot_min_age": {
                "description": "If the volume's most recent snapshot has started less than `last_snapshot_min_age' minutes ago, a new snapshot will not be created.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "Default: True\n\nwait for the snapshot to be ready",
                "$ref": "#/definitions/ansible_truth"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "description to be applied to the snapshot"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "wait_timeout": {
                "description": "how long before wait gives up, in seconds\nspecify 0 to wait forever",
                "$ref": "#/definitions/ansible_number"
              },
              "volume_id": {
                "type": "string",
                "description": "volume from which to take the snapshot"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "device_name": {
                "type": "string",
                "description": "device name of a mounted volume to be snapshotted"
              },
              "instance_id": {
                "type": "string",
                "description": "instance that has the required volume to snapshot mounted"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_clusters_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt clusters.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search cluster X from datacenter Y use following pattern: name=X and datacenter=Y"
              }
            }
          },
          "stacki_host": {
            "required": [
              "stacki_user",
              "stacki_endpoint",
              "stacki_password",
              "name"
            ],
            "type": "object",
            "description": "Use this module to add or remove hosts to a stacki front-end via API\nU(https://github.com/StackIQ/stacki)",
            "properties": {
              "prim_intf_ip": {
                "type": "string",
                "description": "IP Address for the primary network interface."
              },
              "network": {
                "type": "string",
                "description": ""
              },
              "stacki_user": {
                "type": "string",
                "description": "Username for authenticating with Stacki API, but if not specified, the environment variable C(stacki_user) is used instead."
              },
              "stacki_endpoint": {
                "type": "string",
                "description": "URL for the Stacki API Endpoint."
              },
              "prim_intf": {
                "type": "string",
                "description": "Name of the primary network interface."
              },
              "appliance": {
                "type": "string",
                "description": ""
              },
              "rank": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "rack": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "stacki_password": {
                "type": "string",
                "description": "Password for authenticating with Stacki API, but if not specified, the environment variable C(stacki_password) is used instead."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "force_install": {
                "description": "Set value to True to force node into install state if it already exists in stacki.",
                "$ref": "#/definitions/ansible_truth"
              },
              "prim_intf_mac": {
                "type": "string",
                "description": "MAC Address for the primary PXE boot network interface."
              },
              "name": {
                "type": "string",
                "description": "Name of the host to be added to Stacki."
              }
            }
          },
          "nxos_udld_interface": {
            "required": [
              "mode",
              "interface"
            ],
            "type": "object",
            "description": "Manages UDLD interface configuration params.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "mode": {
                "enum": [
                  "enabled",
                  "disabled",
                  "aggressive"
                ],
                "type": "string",
                "description": "Manages UDLD mode for an interface."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "FULL name of the interface, i.e. Ethernet1/1-"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "cloudformation_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gets information about an AWS CloudFormation stack",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "stack_template": {
                "description": "Get stack template body for the stack",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "stack_policy": {
                "description": "Get stack policy for the stack",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "stack_events": {
                "description": "Get stack events for the stack",
                "$ref": "#/definitions/ansible_truth"
              },
              "stack_name": {
                "type": "string",
                "description": "The name or id of the CloudFormation stack"
              },
              "stack_resources": {
                "description": "Get stack resources for the stack",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "all_facts": {
                "description": "Get all stack information for the stack",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "rax_network": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "creates / deletes a Rackspace Public Cloud isolated network.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "label": {
                "type": "string",
                "description": "Label (name) to give the network"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "cidr": {
                "type": "string",
                "description": "cidr of the network being created"
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "iosxr_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends arbitrary commands to an IOS XR node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.\nThis module does not support running commands in configuration mode. Please use M(iosxr_config) to configure iosxr devices.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.",
                "$ref": "#/definitions/ansible_number"
              },
              "commands": {
                "description": "List of commands to send to the remote iosxr device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_for": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "any",
                  "all"
                ],
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "waitfor": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "netapp_e_snapshot_group": {
            "required": [
              "api_password",
              "name",
              "ssid",
              "api_url",
              "state",
              "api_username",
              "base_volume_name"
            ],
            "type": "object",
            "description": "Create, update, delete snapshot groups for NetApp E-series storage arrays",
            "properties": {
              "repo_pct": {
                "description": "Default: 20\n\nThe size of the repository in relation to the size of the base volume",
                "$ref": "#/definitions/ansible_number"
              },
              "ssid": {
                "type": "string",
                "description": ""
              },
              "rollback_priority": {
                "enum": [
                  "highest",
                  "high",
                  "medium",
                  "low",
                  "lowest"
                ],
                "type": "string",
                "description": "Default: medium\n\nThe importance of the rollback operation.\nThis value is overridden by consistency group setting if this snapshot group is associated with a consistency group"
              },
              "delete_limit": {
                "description": "Default: 30\n\nThe automatic deletion indicator.\nIf non-zero, the oldest snapshot image will be automatically deleted when creating a new snapshot image to keep the total number of snapshot images limited to the number specified.\nThis value is overridden by the consistency group setting if this snapshot group is associated with a consistency group.",
                "$ref": "#/definitions/ansible_number"
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "name": {
                "type": "string",
                "description": "The name to give the snapshot group"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether to ensure the group is present or absent."
              },
              "storage_pool_name": {
                "type": "string",
                "description": "The name of the storage pool on which to allocate the repository volume."
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "base_volume_name": {
                "type": "string",
                "description": "The name of the base volume or thin volume to use as the base for the new snapshot group.\nIf a snapshot group with an identical C(name) already exists but with a different base volume an error will be returned."
              },
              "full_policy": {
                "enum": [
                  "unknown",
                  "failbasewrites",
                  "purgepit"
                ],
                "type": "string",
                "description": "Default: purgepit\n\nThe behavior on when the data repository becomes full.\nThis value is overridden by consistency group setting if this snapshot group is associated with a consistency group"
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "warning_threshold": {
                "description": "Default: 80\n\nThe repository utilization warning threshold, as a percentage of the repository volume capacity.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "nxos_ntp_options": {
            "type": "object",
            "description": "Manages NTP options, e.g. authoritative server and logging.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "logging": {
                "description": "Sets whether NTP logging is enabled on the device.",
                "$ref": "#/definitions/ansible_truth"
              },
              "stratum": {
                "type": "string",
                "description": "If C(master=true), an optional stratum can be supplied (1-15). The device default is 8."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "master": {
                "description": "Sets whether the device is an authoritative NTP server.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "cl_bond": {
            "required": [
              "name",
              "slaves"
            ],
            "type": "object",
            "description": "Configures a bond interface on Cumulus Linux To configure a bridge port use the cl_bridge module. To configure any other type of interface use the cl_interface module. Follow the guidelines for bonding found in the Cumulus User Guide at U(http://docs.cumulusnetworks.com).",
            "properties": {
              "lacp_rate": {
                "description": "Default: 1\n\nThe lacp rate.",
                "$ref": "#/definitions/ansible_number"
              },
              "clag_id": {
                "type": "string",
                "description": "Specify a unique clag_id for every dual connected bond on each peer switch. The value must be between 1 and 65535 and must be the same on both peer switches in order for the bond to be considered dual-connected."
              },
              "xmit_hash_policy": {
                "type": "string",
                "description": "Default: layer3+4\n\nTransmit load balancing algorithm. As of Cumulus Linux 2.5 only I(layer3+4) policy is supported."
              },
              "mstpctl_portadminedge": {
                "description": "Enables admin edge port.",
                "$ref": "#/definitions/ansible_truth"
              },
              "min_links": {
                "description": "Default: 1\n\nMinimum number of links.",
                "$ref": "#/definitions/ansible_number"
              },
              "alias_name": {
                "type": "string",
                "description": "Description of the port."
              },
              "mstpctl_bpduguard": {
                "description": "Enables BPDU Guard on a port in vlan-aware mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "location": {
                "type": "string",
                "description": "Default: ['/etc/network/interfaces.d']\n\nInterface directory location."
              },
              "ipv6": {
                "description": "List of IPv6 addresses to configure on the interface. In the form I(X:X:X::X/YYY).",
                "$ref": "#/definitions/ansible_array"
              },
              "vids": {
                "description": "In vlan-aware mode, lists VLANs defined under the interface.",
                "$ref": "#/definitions/ansible_array"
              },
              "mstpctl_portnetwork": {
                "description": "Enables bridge assurance in vlan-aware mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ipv4": {
                "description": "List of IPv4 addresses to configure on the interface. In the form I(X.X.X.X/YY).",
                "$ref": "#/definitions/ansible_array"
              },
              "virtual_ip": {
                "type": "string",
                "description": "Define IPv4 virtual IP used by the Cumulus Linux VRR feature."
              },
              "miimon": {
                "description": "Default: 100\n\nThe mii link monitoring interval.",
                "$ref": "#/definitions/ansible_number"
              },
              "virtual_mac": {
                "type": "string",
                "description": "Define Ethernet mac associated with Cumulus Linux VRR feature."
              },
              "lacp_bypass_all_active": {
                "description": "Activate all interfaces for bypass. It is recommended to configure all_active instead of using bypass_priority.",
                "$ref": "#/definitions/ansible_number"
              },
              "lacp_bypass_period": {
                "description": "Period for enabling LACP bypass. Max value is 900.",
                "$ref": "#/definitions/ansible_number"
              },
              "lacp_bypass_allow": {
                "description": "Enable LACP bypass.",
                "$ref": "#/definitions/ansible_number"
              },
              "lacp_bypass_priority": {
                "description": "List of ports and priorities. Example I(\"swp1=10, swp2=20\").",
                "$ref": "#/definitions/ansible_array"
              },
              "addr_method": {
                "enum": [
                  "",
                  "dhcp"
                ],
                "type": "string",
                "description": "Configures the port to use DHCP. To enable this feature use the option I(dhcp)."
              },
              "name": {
                "type": "string",
                "description": "Name of the interface."
              },
              "mtu": {
                "type": "string",
                "description": "Set MTU. Configure Jumbo Frame by setting MTU to I(9000)."
              },
              "pvid": {
                "type": "string",
                "description": "In vlan-aware mode, defines vlan that is the untagged vlan."
              },
              "mode": {
                "type": "string",
                "description": "Default: 802.3ad\n\nThe bond mode, as of Cumulus Linux 2.5 only LACP bond mode is supported."
              },
              "slaves": {
                "description": "Bond members.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "datadog_event": {
            "required": [
              "text",
              "title",
              "app_key",
              "api_key"
            ],
            "type": "object",
            "description": "Allows to post events to DataDog (www.datadoghq.com) service.\nUses http://docs.datadoghq.com/api/#events API.",
            "properties": {
              "date_happened": {
                "description": "Default: now\n\nPOSIX timestamp of the event.\nDefault value is now.",
                "$ref": "#/definitions/ansible_number"
              },
              "alert_type": {
                "enum": [
                  "error",
                  "warning",
                  "info",
                  "success"
                ],
                "type": "string",
                "description": "Default: info\n\nType of alert."
              },
              "title": {
                "type": "string",
                "description": "The event title."
              },
              "text": {
                "type": "string",
                "description": "The body of the event."
              },
              "tags": {
                "description": "Comma separated list of tags to apply to the event.",
                "$ref": "#/definitions/ansible_array"
              },
              "app_key": {
                "type": "string",
                "description": "Your DataDog app key."
              },
              "priority": {
                "enum": [
                  "normal",
                  "low"
                ],
                "type": "string",
                "description": "Default: normal\n\nThe priority of the event."
              },
              "aggregation_key": {
                "type": "string",
                "description": "An arbitrary string to use for aggregation."
              },
              "api_key": {
                "type": "string",
                "description": "Your DataDog API key."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "sf_volume_access_group_manager": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, destroy, or update volume access groups on SolidFire",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the volume access group. It is not required to be unique, but recommended."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "virtual_network_id": {
                "description": "Default: None\n\nThe ID of the SolidFire Virtual Network ID to associate the volume access group with.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified volume access group should exist or not."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "volumes": {
                "description": "Default: None\n\nList of volumes to initially include in the volume access group. If unspecified, the access group will start without any volumes.",
                "$ref": "#/definitions/ansible_array"
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "initiators": {
                "description": "Default: None\n\nList of initiators to include in the volume access group. If unspecified, the access group will start out without configured initiators.",
                "$ref": "#/definitions/ansible_array"
              },
              "attributes": {
                "type": "object",
                "description": "Default: None\n\nList of Name/Value pairs in JSON object format."
              },
              "virtual_network_tags": {
                "description": "Default: None\n\nThe ID of the VLAN Virtual Network Tag to associate the volume access group with.",
                "$ref": "#/definitions/ansible_array"
              },
              "volume_access_group_id": {
                "description": "Default: None\n\nThe ID of the volume access group to modify or delete.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "cs_resourcelimit": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "limit",
                        "max"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "resource_type",
                        "type"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "resource_type"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "type"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage limits of resources for domains, accounts and projects.",
            "properties": {
              "account": {
                "type": "string",
                "description": "Account the resource is related to."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the resource is related to."
              },
              "limit": {
                "type": "string",
                "description": "Default: -1\n\nMaximum number of the resource.\nDefault is unlimited C(-1)."
              },
              "domain": {
                "type": "string",
                "description": "Domain the resource is related to."
              },
              "max": {
                "type": "string",
                "description": "Default: -1\n\nMaximum number of the resource.\nDefault is unlimited C(-1)."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "type": {
                "enum": [
                  "instance",
                  "ip_address",
                  "volume",
                  "snapshot",
                  "template",
                  "network",
                  "vpc",
                  "cpu",
                  "memory",
                  "primary_storage",
                  "secondary_storage"
                ],
                "type": "string",
                "description": "Type of the resource."
              },
              "resource_type": {
                "enum": [
                  "instance",
                  "ip_address",
                  "volume",
                  "snapshot",
                  "template",
                  "network",
                  "vpc",
                  "cpu",
                  "memory",
                  "primary_storage",
                  "secondary_storage"
                ],
                "type": "string",
                "description": "Type of the resource."
              }
            }
          },
          "ec2": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "group",
                        "groups"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "zone",
                        "aws_zone",
                        "ec2_zone"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "key_name",
                        "keypair"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_ids",
                        "instance_id"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "network_interfaces",
                        "network_interface"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_type",
                        "type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates or terminates ec2 instances.\nC(state=restarted) was added in 2.2",
            "properties": {
              "kernel": {
                "type": "string",
                "description": "kernel I(eki) to use for the instance"
              },
              "count_tag": {
                "type": "string",
                "description": "Used with 'exact_count' to determine how many nodes based on a specific tag criteria should be running.  This can be expressed in multiple ways and is shown in the EXAMPLES section.  For instance, one can request 25 servers that are tagged with \"class=webserver\". The specified tag must already exist or be passed in as the 'instance_tags' option."
              },
              "image": {
                "type": "string",
                "description": "I(ami) ID to use for the instance"
              },
              "user_data": {
                "type": "string",
                "description": "opaque blob of data which is made available to the ec2 instance"
              },
              "instance_initiated_shutdown_behavior": {
                "enum": [
                  "stop",
                  "terminate"
                ],
                "type": "string",
                "description": "Default: stop\n\nSet whether AWS will Stop or Terminate an instance on shutdown"
              },
              "termination_protection": {
                "description": "Enable or Disable the Termination Protection",
                "$ref": "#/definitions/ansible_truth"
              },
              "private_ip": {
                "type": "string",
                "description": "the private ip address to assign the instance (from the vpc subnet)"
              },
              "spot_type": {
                "enum": [
                  "one-time",
                  "persistent"
                ],
                "type": "string",
                "description": "Default: one-time\n\nType of spot request; one of \"one-time\" or \"persistent\". Defaults to \"one-time\" if not supplied."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "id": {
                "type": "string",
                "description": "identifier for this instance or set of instances, so that the module will be idempotent with respect to EC2 instances. This identifier is valid for at least 24 hours after the termination of the instance, and should not be reused for another call later on. For details, see the description of client token at U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html)."
              },
              "source_dest_check": {
                "description": "Default: True\n\nEnable or Disable the Source/Destination checks (for NAT instances and Virtual Routers)",
                "$ref": "#/definitions/ansible_truth"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "spot_wait_timeout": {
                "type": "string",
                "description": "Default: 600\n\nhow long to wait for the spot instance request to be fulfilled"
              },
              "monitoring": {
                "description": "enable detailed monitoring (CloudWatch) for instance",
                "$ref": "#/definitions/ansible_truth"
              },
              "zone": {
                "type": "string",
                "description": "AWS availability zone in which to launch the instance"
              },
              "exact_count": {
                "description": "An integer value which indicates how many instances that match the 'count_tag' parameter should be running. Instances are either created or terminated based on this value.",
                "$ref": "#/definitions/ansible_number"
              },
              "ebs_optimized": {
                "description": "Default: false\n\nwhether instance is using optimized EBS volumes, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html)",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "running",
                  "restarted",
                  "stopped"
                ],
                "type": "string",
                "description": "Default: present\n\ncreate or terminate instances"
              },
              "placement_group": {
                "type": "string",
                "description": "placement group for the instance when using EC2 Clustered Compute"
              },
              "spot_launch_group": {
                "type": "string",
                "description": "Launch group for spot request, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-spot-instances-work.html#spot-launch-group)"
              },
              "ec2_region": {
                "type": "string",
                "description": "The AWS region to use.  Must be specified if ec2_url is not used. If not specified then the value of the EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)"
              },
              "type": {
                "type": "string",
                "description": "instance type to use for the instance, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)"
              },
              "network_interface": {
                "description": "A list of existing network interfaces to attach to the instance at launch. When specifying existing network interfaces, none of the assign_public_ip, private_ip, vpc_subnet_id, group, or group_id parameters may be used. (Those parameters are for creating a new network interface at launch.)",
                "$ref": "#/definitions/ansible_array"
              },
              "ramdisk": {
                "type": "string",
                "description": "ramdisk I(eri) to use for the instance"
              },
              "count": {
                "description": "Default: 1\n\nnumber of instances to launch",
                "$ref": "#/definitions/ansible_number"
              },
              "key_name": {
                "type": "string",
                "description": "key pair to use on the instance"
              },
              "vpc_subnet_id": {
                "type": "string",
                "description": "the subnet ID in which to launch the instance (VPC)"
              },
              "instance_ids": {
                "description": "list of instance ids, currently used for states: absent, running, stopped",
                "$ref": "#/definitions/ansible_array"
              },
              "spot_price": {
                "type": "string",
                "description": "Maximum spot price to bid, If not set a regular on-demand instance is requested. A spot request is made with this maximum bid. When it is filled, the instance is started."
              },
              "tenancy": {
                "type": "string",
                "description": "Default: default\n\nAn instance with a tenancy of \"dedicated\" runs on single-tenant hardware and can only be launched into a VPC. Note that to use dedicated tenancy you MUST specify a vpc_subnet_id as well. Dedicated tenancy is not available for EC2 \"micro\" instances."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "groups": {
                "description": "security group (or list of groups) to use with the instance",
                "$ref": "#/definitions/ansible_array"
              },
              "assign_public_ip": {
                "description": "when provisioning within vpc, assign a public IP address. Boto library must be 2.13.0+",
                "$ref": "#/definitions/ansible_truth"
              },
              "group": {
                "description": "security group (or list of groups) to use with the instance",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "instance_tags": {
                "type": "object",
                "description": "a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{\"key\":\"value\"}' and '{\"key\":\"value\",\"key\":\"value\"}'"
              },
              "wait": {
                "description": "Default: no\n\nwait for the instance to reach its desired state before returning.  Does not wait for SSH, see 'wait_for' example for details.",
                "$ref": "#/definitions/ansible_truth"
              },
              "aws_zone": {
                "type": "string",
                "description": "AWS availability zone in which to launch the instance"
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": "The AWS region to use.  Must be specified if ec2_url is not used. If not specified then the value of the EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "instance_profile_name": {
                "type": "string",
                "description": "Name of the IAM instance profile to use. Boto library must be 2.5.0+"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": "The AWS region to use.  Must be specified if ec2_url is not used. If not specified then the value of the EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)"
              },
              "network_interfaces": {
                "description": "A list of existing network interfaces to attach to the instance at launch. When specifying existing network interfaces, none of the assign_public_ip, private_ip, vpc_subnet_id, group, or group_id parameters may be used. (Those parameters are for creating a new network interface at launch.)",
                "$ref": "#/definitions/ansible_array"
              },
              "keypair": {
                "type": "string",
                "description": "key pair to use on the instance"
              },
              "ec2_zone": {
                "type": "string",
                "description": "AWS availability zone in which to launch the instance"
              },
              "instance_id": {
                "description": "list of instance ids, currently used for states: absent, running, stopped",
                "$ref": "#/definitions/ansible_array"
              },
              "instance_type": {
                "type": "string",
                "description": "instance type to use for the instance, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)"
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 300\n\nhow long before wait gives up, in seconds"
              },
              "volumes": {
                "description": "a list of hash/dictionaries of volumes to add to the new instance; '[{\"key\":\"value\", \"key\":\"value\"}]'; keys allowed are - device_name (str; required), delete_on_termination (bool; False), device_type (deprecated), ephemeral (str), encrypted (bool; False), snapshot (str), volume_type (str), iops (int) - device_type is deprecated use volume_type, iops must be set when volume_type='io1', ephemeral and snapshot are mutually exclusive.",
                "$ref": "#/definitions/ansible_array"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "group_id": {
                "description": "security group id (or list of ids) to use with the instance",
                "$ref": "#/definitions/ansible_array"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "tower_group": {
            "required": [
              "name",
              "inventory"
            ],
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower groups. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "credential": {
                "type": "string",
                "description": "Credential to use for the group."
              },
              "source_vars": {
                "type": "string",
                "description": "Override variables from source with variables from this field."
              },
              "source_script": {
                "type": "string",
                "description": "Inventory script to be used when group type is \"custom\"."
              },
              "description": {
                "type": "string",
                "description": "The description to use for the group."
              },
              "overwrite_vars": {
                "type": "string",
                "description": "Override vars in child groups and hosts with those from external source."
              },
              "source_regions": {
                "type": "string",
                "description": "Regions for cloud provider."
              },
              "inventory": {
                "type": "string",
                "description": "Inventory the group should be made a member of."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "instance_filters": {
                "type": "string",
                "description": "Comma-separated list of filter expressions for matching hosts."
              },
              "group_by": {
                "type": "string",
                "description": "Limit groups automatically created from inventory source."
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "update_on_launch": {
                "description": "Refresh inventory data from its source each time a job is run.",
                "$ref": "#/definitions/ansible_truth"
              },
              "source": {
                "enum": [
                  "manual",
                  "file",
                  "ec2",
                  "rax",
                  "vmware",
                  "gce",
                  "azure",
                  "azure_rm",
                  "openstack",
                  "satellite6",
                  "cloudforms",
                  "custom"
                ],
                "type": "string",
                "description": "Default: null,\n\nThe source to use for this group."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "variables": {
                "type": "string",
                "description": "Variables to use for the group, use '@' for a file."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "overwrite": {
                "description": "Delete child roups and hosts not found in source.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name to use for the group."
              }
            }
          },
          "nova_keypair": {
            "required": [
              "login_password",
              "name"
            ],
            "type": "object",
            "description": "Add or Remove key pair from nova .",
            "properties": {
              "public_key": {
                "type": "string",
                "description": "Default: None\n\nThe public key that would be uploaded to nova and injected to vm's upon creation"
              },
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nName of the region"
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: yes\n\nThe tenant name of the login user"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone url for authentication"
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\nPassword of login user"
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nName that has to be given to the key pair"
              }
            }
          },
          "gcpubsub": {
            "required": [
              "topic"
            ],
            "type": "object",
            "description": "Create and Delete Topics/Subscriptions, Publish and pull messages on PubSub. See U(https://cloud.google.com/pubsub/docs) for an overview.",
            "properties": {
              "service_account_email": {
                "type": "string",
                "description": ""
              },
              "publish": {
                "description": "List of dictionaries describing messages and attributes to be published.  Dictionary is in message(str):attributes(dict) format. Only message is required.",
                "$ref": "#/definitions/ansible_array"
              },
              "topic": {
                "type": "string",
                "description": "GCP pubsub topic name.  Only the name, not the full path, is required."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the topic or queue (absent, present). Applies to the most granular resource. Remove the most granular resource.  If subcription is specified we remove it.  If only topic is specified, that is what is removed. Note that a topic can be removed without first removing the subscription."
              },
              "credentials_file": {
                "type": "string",
                "description": ""
              },
              "project_id": {
                "type": "string",
                "description": ""
              },
              "subscription": {
                "type": "object",
                "description": "Dictionary containing a subscripton name associated with a topic (required), along with optional ack_deadline, push_endpoint and pull. For pulling from a subscription, message_ack (bool), max_messages (int) and return_immediate are available as subfields.  See subfields name, push_endpoint and ack_deadline for more information."
              }
            }
          },
          "bower": {
            "required": [
              "path"
            ],
            "type": "object",
            "description": "Manage bower packages with bower",
            "properties": {
              "name": {
                "type": "string",
                "description": "The name of a bower package to install"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "latest"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state of the bower package"
              },
              "production": {
                "description": "Install with --production flag",
                "$ref": "#/definitions/ansible_truth"
              },
              "version": {
                "type": "string",
                "description": "The version to be installed"
              },
              "relative_execpath": {
                "type": "string",
                "description": "Relative path to bower executable from install path"
              },
              "path": {
                "type": "string",
                "description": "The base path where to install the bower packages"
              },
              "offline": {
                "description": "Install packages from local cache, if the packages were installed before",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "pn_ospfarea": {
            "required": [
              "pn_vrouter_name",
              "pn_clipassword",
              "pn_ospf_area",
              "pn_cliusername",
              "state"
            ],
            "type": "object",
            "description": "Execute vrouter-ospf-add, vrouter-ospf-remove command.\nThis command adds/removes Open Shortest Path First(OSPF) area to/from a virtual router(vRouter) service.",
            "properties": {
              "pn_ospf_area": {
                "type": "string",
                "description": "Specify the OSPF area number."
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Login password."
              },
              "pn_vrouter_name": {
                "type": "string",
                "description": "Specify the name of the vRouter."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Login username."
              },
              "pn_prefix_listin": {
                "type": "string",
                "description": "OSPF prefix list for filtering incoming packets."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "update"
                ],
                "type": "string",
                "description": "State the action to perform. Use 'present' to add ospf-area, 'absent' to remove ospf-area and 'update' to modify ospf-area."
              },
              "pn_prefix_listout": {
                "type": "string",
                "description": "OSPF prefix list for filtering outgoing packets."
              },
              "pn_stub_type": {
                "enum": [
                  "none",
                  "stub",
                  "stub-no-summary",
                  "nssa",
                  "nssa-no-summary"
                ],
                "type": "string",
                "description": "Specify the OSPF stub type."
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch(es) to run the CLI on."
              },
              "pn_quiet": {
                "description": "Default: True\n\nEnable/disable system information.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "netconf_config": {
            "required": [
              "xml",
              "username",
              "host",
              "password"
            ],
            "type": "object",
            "description": "Netconf is a network management protocol developed and standardized by the IETF. It is documented in RFC 6241.\nThis module allows the user to send a configuration XML file to a netconf device, and detects if there was a configuration change.",
            "properties": {
              "xml": {
                "type": "string",
                "description": "the XML content to send to the device"
              },
              "username": {
                "type": "string",
                "description": "the username to authenticate with"
              },
              "host": {
                "type": "string",
                "description": "the hostname or ip address of the netconf device"
              },
              "hostkey_verify": {
                "description": "Default: True\n\nif true, the ssh host key of the device must match a ssh key present on the host\nif false, the ssh host key of the device is not checked",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "password of the user to authenticate with"
              },
              "port": {
                "description": "Default: 830\n\nthe netconf port",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "ovirt_external_providers_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt external providers.",
            "properties": {
              "type": {
                "type": "string",
                "description": "Type of the external provider."
              },
              "name": {
                "type": "string",
                "description": "Name of the external provider, can be used as glob expression."
              }
            }
          },
          "solaris_zone": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, start, stop and delete Solaris zones. This module doesn't currently allow changing of options for a zone that's already been created.",
            "properties": {
              "install_options": {
                "type": "string",
                "description": "Default: empty string\n\nExtra options to the zoneadm(1M) install command. To automate Solaris 11 zone creation, use this to specify the profile XML file, e.g. install_options=\"-c sc_profile.xml\""
              },
              "timeout": {
                "description": "Default: 600\n\nTimeout, in seconds, for zone to boot.",
                "$ref": "#/definitions/ansible_number"
              },
              "create_options": {
                "type": "string",
                "description": "Default: empty string\n\nExtra options to the zonecfg(1M) create command."
              },
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "started",
                  "running",
                  "stopped",
                  "absent",
                  "configured",
                  "attached",
                  "detached"
                ],
                "type": "string",
                "description": "Default: present\n\nC(present), configure and install the zone.\nC(installed), synonym for C(present).\nC(running), if the zone already exists, boot it, otherwise, configure and install the zone first, then boot it.\nC(started), synonym for C(running).\nC(stopped), shutdown a zone.\nC(absent), destroy the zone.\nC(configured), configure the ready so that it's to be attached.\nC(attached), attach a zone, but do not boot it.\nC(detached), shutdown and detach a zone"
              },
              "root_password": {
                "type": "string",
                "description": "The password hash for the root account. If not specified, the zone's root account will not have a password."
              },
              "sparse": {
                "description": "Whether to create a sparse (C(true)) or whole root (C(false)) zone.",
                "$ref": "#/definitions/ansible_truth"
              },
              "path": {
                "type": "string",
                "description": "The path where the zone will be created. This is required when the zone is created, but not used otherwise."
              },
              "config": {
                "type": "string",
                "description": "Default: empty string\n\nThe zonecfg configuration commands for this zone. See zonecfg(1M) for the valid options and syntax. Typically this is a list of options separated by semi-colons or new lines, e.g. \"set auto-boot=true;add net;set physical=bge0;set address=10.1.1.1;end\""
              },
              "attach_options": {
                "type": "string",
                "description": "Default: empty string\n\nExtra options to the zoneadm attach command. For example, this can be used to specify whether a minimum or full update of packages is required and if any packages need to be deleted. For valid values, see zoneadm(1M)"
              },
              "name": {
                "type": "string",
                "description": "Zone name."
              }
            }
          },
          "nxos_reboot": {
            "type": "object",
            "description": "Reboot a network device.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "cs_role": {
            "type": "object",
            "description": "Create, update, delete user roles.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the role."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nState of the role."
              },
              "id": {
                "type": "string",
                "description": "ID of the role.\nIf provided, C(id) is used as key."
              },
              "role_type": {
                "type": "string",
                "description": "Default: User\n\nType of the role.\nOnly considered for creation."
              },
              "description": {
                "type": "string",
                "description": "Description of the role."
              }
            }
          },
          "copy": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "The C(copy) module copies a file from the local or remote machine to a location on the remote machine. Use the M(fetch) module to copy files from remote locations to the local box. If you need variable interpolation in copied files, use the M(template) module.",
            "properties": {
              "src": {
                "type": "string",
                "description": "Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with \"/\", only inside contents of that directory are copied to destination. Otherwise, if it does not end with \"/\", the directory itself with all contents is copied. This behavior is similar to Rsync."
              },
              "directory_mode": {
                "type": "string",
                "description": "When doing a recursive copy set the mode for the directories. If this is not set we will use the system defaults. The mode is only set on directories which are newly created, and will not affect those that already existed."
              },
              "force": {
                "description": "Default: yes\n\nthe default is C(yes), which will replace the remote file when contents are different than the source. If C(no), the file will only be transferred if the destination does not exist.",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "Default: yes\n\nthe default is C(yes), which will replace the remote file when contents are different than the source. If C(no), the file will only be transferred if the destination does not exist.",
                "$ref": "#/definitions/ansible_truth"
              },
              "remote_src": {
                "description": "Default: False\n\nIf False, it will search for src at originating/master machine, if True it will go to the remote/target machine for the src. Default is False.\nCurrently remote_src does not support recursive copying.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dest": {
                "type": "string",
                "description": "Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too."
              },
              "content": {
                "type": "string",
                "description": "When used instead of 'src', sets the contents of a file directly to the specified value. This is for simple values, for anything complex or with formatting please switch to the template module."
              },
              "original_basename": {
                "type": "string",
                "description": ""
              },
              "validate": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "bigip_sys_global": {
            "type": "object",
            "description": "Manage BIG-IP global settings.",
            "properties": {
              "security_banner": {
                "type": "string",
                "description": "Specifies whether the system displays an advisory message on the login screen."
              },
              "net_reboot": {
                "type": "string",
                "description": "Specifies, when C(enabled), that the next time you reboot the system, the system boots to an ISO image on the network, rather than an internal media drive."
              },
              "banner_text": {
                "type": "string",
                "description": "Specifies the text to present in the advisory banner."
              },
              "console_timeout": {
                "type": "string",
                "description": "Specifies the number of seconds of inactivity before the system logs off a user that is logged on."
              },
              "quiet_boot": {
                "type": "string",
                "description": "Specifies, when C(enabled), that the system suppresses informational text on the console during the boot cycle. When C(disabled), the system presents messages and informational text on the console during the boot cycle."
              },
              "mgmt_dhcp": {
                "type": "string",
                "description": "Specifies whether or not to enable DHCP client on the management interface"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nThe state of the variable on the system. When C(present), guarantees that an existing variable is set to C(value)."
              },
              "gui_setup": {
                "type": "string",
                "description": "C(enable) or C(disabled) the Setup utility in the browser-based Configuration utility"
              },
              "lcd_display": {
                "type": "string",
                "description": "Specifies, when C(enabled), that the system menu displays on the LCD screen on the front of the unit. This setting has no effect when used on the VE platform."
              }
            }
          },
          "unarchive": {
            "required": [
              "src",
              "dest"
            ],
            "type": "object",
            "description": "The C(unarchive) module unpacks an archive. By default, it will copy the source file from the local system to the target before unpacking - set remote_src=yes to unpack an archive which already exists on the target..",
            "properties": {
              "src": {
                "type": "string",
                "description": "If remote_src=no (default), local path to archive file to copy to the target server; can be absolute or relative. If remote_src=yes, path on the target server to existing archive file to unpack.\nIf remote_src=yes and src contains ://, the remote machine will download the file from the url first. (version_added 2.0). This is only for simple cases, for full download support look at the M(get_url) module."
              },
              "remote_src": {
                "description": "Default: no\n\nSet to C(yes) to indicate the archived file is already on the remote system and not local to the Ansible controller.\nThis option is mutually exclusive with C(copy).",
                "$ref": "#/definitions/ansible_truth"
              },
              "dest": {
                "type": "string",
                "description": "Remote absolute path where the archive should be unpacked"
              },
              "list_files": {
                "description": "Default: no\n\nIf set to True, return the list of files that are contained in the tarball.",
                "$ref": "#/definitions/ansible_truth"
              },
              "keep_newer": {
                "description": "Do not replace existing files that are newer than files from the archive.",
                "$ref": "#/definitions/ansible_truth"
              },
              "creates": {
                "type": "string",
                "description": "a filename, when it already exists, this step will B(not) be run."
              },
              "original_basename": {
                "type": "string",
                "description": ""
              },
              "exclude": {
                "description": "List the directory and file entries that you would like to exclude from the unarchive action.",
                "$ref": "#/definitions/ansible_array"
              },
              "extra_opts": {
                "description": "Specify additional options by passing in an array.",
                "$ref": "#/definitions/ansible_array"
              },
              "copy": {
                "description": "Default: yes\n\nIf true, the file is copied from local 'master' to the target machine, otherwise, the plugin will look for src archive at the target machine.\nThis option has been deprecated in favor of C(remote_src)\nThis option is mutually exclusive with C(remote_src).",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "Default: yes\n\nThis only applies if using a https url as the source of the file.\nThis should only set to C(no) used on personally controlled sites using self-signed cer\nPrior to 2.2 the code worked as if this was set to C(yes).",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vmware_vm_vss_dvs_migrate": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Migrates a virtual machine from a standard vswitch to distributed",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "vm_name": {
                "type": "string",
                "description": "Name of the virtual machine to migrate to a dvSwitch"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "dvportgroup_name": {
                "type": "string",
                "description": "Name of the portgroup to migrate to the virtual machine to"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "pam_limits": {
            "required": [
              "domain",
              "value",
              "limit_item",
              "limit_type"
            ],
            "type": "object",
            "description": "The M(pam_limits) module modify PAM limits, default in /etc/security/limits.conf. For the full documentation, see man limits.conf(5).",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Comment associated with the limit."
              },
              "use_max": {
                "description": "Default: no\n\nIf set to C(yes), the maximal value will be used or conserved. If the specified value is superior to the value in the file, file content is replaced with the new value, else content is not modified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "domain": {
                "type": "string",
                "description": "A username, @groupname, wildcard, uid/gid range."
              },
              "dest": {
                "type": "string",
                "description": "Default: /etc/security/limits.conf\n\nModify the limits.conf path."
              },
              "value": {
                "type": "string",
                "description": "The value of the limit."
              },
              "use_min": {
                "description": "Default: no\n\nIf set to C(yes), the minimal value will be used or conserved. If the specified value is inferior to the value in the file, file content is replaced with the new value, else content is not modified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "limit_item": {
                "enum": [
                  "core",
                  "data",
                  "fsize",
                  "memlock",
                  "nofile",
                  "rss",
                  "stack",
                  "cpu",
                  "nproc",
                  "as",
                  "maxlogins",
                  "maxsyslogins",
                  "priority",
                  "locks",
                  "sigpending",
                  "msgqueue",
                  "nice",
                  "rtprio",
                  "chroot"
                ],
                "type": "string",
                "description": "The limit to be set"
              },
              "limit_type": {
                "enum": [
                  "hard",
                  "soft",
                  "-"
                ],
                "type": "string",
                "description": "Limit type, see C(man limits) for an explanation"
              },
              "backup": {
                "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "osx_say": {
            "required": [
              "msg"
            ],
            "type": "object",
            "description": "makes an OS computer speak!  Amuse your friends, annoy your coworkers!",
            "properties": {
              "msg": {
                "type": "string",
                "description": "What to say"
              },
              "voice": {
                "type": "string",
                "description": "What voice to use"
              }
            }
          },
          "jenkins_script": {
            "required": [
              "script"
            ],
            "type": "object",
            "description": "The C(jenkins_script) module takes a script plus a dict of values to use within the script and returns the result of the script being run.",
            "properties": {
              "script": {
                "type": "string",
                "description": "The groovy script to be executed. This gets passed as a string Template if args is defined."
              },
              "url": {
                "type": "string",
                "description": "Default: http://localhost:8080\n\nThe jenkins server to execute the script against. The default is a local jenkins instance that is not being proxied through a webserver."
              },
              "args": {
                "type": "object",
                "description": "A dict of key-value pairs used in formatting the script."
              },
              "user": {
                "type": "string",
                "description": "The username to connect to the jenkins server with."
              },
              "password": {
                "type": "string",
                "description": "The password to connect to the jenkins server with."
              },
              "validate_certs": {
                "description": "Default: True\n\nIf set to C(no), the SSL certificates will not be validated. This should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "win_template": {
            "type": "object",
            "description": "Templates are processed by the Jinja2 templating language (U(http://jinja.pocoo.org/docs/)) - documentation on the template formatting can be found in the Template Designer Documentation (U(http://jinja.pocoo.org/docs/templates/)).\nSix additional variables can be used in templates: C(ansible_managed) (configurable via the C(defaults) section of C(ansible.cfg)) contains a string which can be used to describe the template name, host, modification time of the template file and the owner uid, C(template_host) contains the node name of the template's machine, C(template_uid) the owner, C(template_path) the absolute path of the template, C(template_fullpath) is the absolute path of the template, and C(template_run_date) is the date that the template was rendered. Note that including a string that uses a date in the template will result in the template being marked 'changed' each time.",
            "properties": {
              "dest": {
                "type": "string",
                "description": "Location to render the template to on the remote machine."
              },
              "src": {
                "type": "string",
                "description": "Path of a Jinja2 formatted template on the local server. This can be a relative or absolute path."
              }
            }
          },
          "cs_configuration": {
            "required": [
              "value",
              "name"
            ],
            "type": "object",
            "description": "Manages global, zone, account, storage and cluster configurations.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Default: ROOT\n\nDomain the account is related to.\nOnly considered if C(account) is used."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "storage": {
                "type": "string",
                "description": "Ensure the value for corresponding storage pool."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "value": {
                "type": "string",
                "description": "Value of the configuration."
              },
              "cluster": {
                "type": "string",
                "description": "Ensure the value for corresponding cluster."
              },
              "account": {
                "type": "string",
                "description": "Ensure the value for corresponding account."
              },
              "zone": {
                "type": "string",
                "description": "Ensure the value for corresponding zone."
              },
              "name": {
                "type": "string",
                "description": "Name of the configuration."
              }
            }
          },
          "ini_file": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "dest"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage (add, remove, change) individual settings in an INI-style file without having to manage the file as a whole with, say, M(template) or M(assemble). Adds missing sections if they don't exist.\nBefore version 2.0, comments are discarded when the source file is read, and therefore will not show up in the destination file.\nSince version 2.3, this module adds missing ending newlines to files to keep in line with the POSIX standard, even when no other modifications need to be applied.",
            "properties": {
              "option": {
                "type": "string",
                "description": "If set (required for changing a I(value)), this is the name of the option.\nMay be omitted if adding/removing a whole I(section)."
              },
              "dest": {
                "type": "string",
                "description": "Path to the INI-style file; this file is created if required.\nBefore 2.3 this option was only usable as I(dest)."
              },
              "create": {
                "description": "Default: yes\n\nIf set to 'no', the module will fail if the file does not already exist. By default it will create the file if it is missing.",
                "$ref": "#/definitions/ansible_truth"
              },
              "no_extra_spaces": {
                "description": "Do not insert spaces before and after '=' symbol",
                "$ref": "#/definitions/ansible_truth"
              },
              "value": {
                "type": "string",
                "description": "The string value to be associated with an I(option). May be omitted when removing an I(option)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIf set to C(absent) the option or section will be removed if present instead of created."
              },
              "path": {
                "type": "string",
                "description": "Path to the INI-style file; this file is created if required.\nBefore 2.3 this option was only usable as I(dest)."
              },
              "backup": {
                "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              },
              "section": {
                "type": "string",
                "description": "Section name in INI file. This is added if C(state=present) automatically when a single value is being set.\nIf left empty or set to `null`, the I(option) will be placed before the first I(section). Using `null` is also required if the config format does not support sections."
              }
            }
          },
          "vmware_datacenter": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage VMware vSphere Datacenters",
            "properties": {
              "username": {
                "type": "string",
                "description": "The username of the vSphere vCenter"
              },
              "datacenter_name": {
                "type": "string",
                "description": "The name of the datacenter the cluster will be created in."
              },
              "admin": {
                "type": "string",
                "description": "The username of the vSphere vCenter"
              },
              "hostname": {
                "type": "string",
                "description": "The hostname or IP address of the vSphere vCenter API server"
              },
              "pwd": {
                "type": "string",
                "description": "The password of the vSphere vCenter"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIf the datacenter should be present or absent"
              },
              "user": {
                "type": "string",
                "description": "The username of the vSphere vCenter"
              },
              "pass": {
                "type": "string",
                "description": "The password of the vSphere vCenter"
              },
              "password": {
                "type": "string",
                "description": "The password of the vSphere vCenter"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cnos_save": {
            "type": "object",
            "description": "This module allows you to copy the running configuration of a switch over its startup configuration. It is recommended to use this module shortly after any major configuration changes so they persist after a switch restart. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_save.html)",
            "properties": {}
          },
          "ipa_sudocmd": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sudocmd",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "sudocmd"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify or delete sudo command within FreeIPA server using FreeIPA API.",
            "properties": {
              "ipa_port": {
                "description": "Default: 443\n\nPort of IPA server",
                "$ref": "#/definitions/ansible_number"
              },
              "ipa_user": {
                "type": "string",
                "description": "Default: admin\n\nAdministrative account used on IPA server"
              },
              "description": {
                "type": "string",
                "description": "A description of this command."
              },
              "ipa_prot": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nProtocol used by IPA server"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState to ensure"
              },
              "ipa_host": {
                "type": "string",
                "description": "Default: ipa.example.com\n\nIP or hostname of IPA server"
              },
              "sudocmd": {
                "type": "string",
                "description": "Sudo Command."
              },
              "ipa_pass": {
                "type": "string",
                "description": "Password of administrative user"
              },
              "validate_certs": {
                "description": "Default: True\n\nThis only applies if C(ipa_prot) is I(https).\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Sudo Command."
              }
            }
          },
          "tower_organization": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower organizations. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "description": {
                "type": "string",
                "description": "The description to use for the organization."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name to use for the organization."
              }
            }
          },
          "rax_clb": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "creates / deletes a Rackspace Public Cloud load balancer.",
            "properties": {
              "protocol": {
                "enum": [
                  "DNS_TCP",
                  "DNS_UDP",
                  "FTP",
                  "HTTP",
                  "HTTPS",
                  "IMAPS",
                  "IMAPv4",
                  "LDAP",
                  "LDAPS",
                  "MYSQL",
                  "POP3",
                  "POP3S",
                  "SMTP",
                  "TCP",
                  "TCP_CLIENT_FIRST",
                  "UDP",
                  "UDP_STREAM",
                  "SFTP"
                ],
                "type": "string",
                "description": "Default: HTTP\n\nProtocol for the balancer being created"
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "meta": {
                "type": "object",
                "description": "A hash of metadata to associate with the instance"
              },
              "port": {
                "description": "Default: 80\n\nPort for the balancer being created",
                "$ref": "#/definitions/ansible_number"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "type": {
                "enum": [
                  "PUBLIC",
                  "SERVICENET"
                ],
                "type": "string",
                "description": "Default: PUBLIC\n\ntype of interface for the balancer being created"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 300\n\nhow long before wait gives up, in seconds"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name to give the load balancer"
              },
              "vip_id": {
                "type": "string",
                "description": "Virtual IP ID to use when creating the load balancer for purposes of sharing an IP with another load balancer of another protocol"
              },
              "algorithm": {
                "enum": [
                  "RANDOM",
                  "LEAST_CONNECTIONS",
                  "ROUND_ROBIN",
                  "WEIGHTED_LEAST_CONNECTIONS",
                  "WEIGHTED_ROUND_ROBIN"
                ],
                "type": "string",
                "description": "Default: LEAST_CONNECTIONS\n\nalgorithm for the balancer being created"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: no\n\nwait for the balancer to be in state 'running' before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "description": "Default: 30\n\ntimeout for communication between the balancer and the node",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "ec2_lc_find": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "region"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "aws_region"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "ec2_region"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Returns list of matching Launch Configurations for a given name, along with other useful information\nResults can be sorted and sliced\nIt depends on boto\nBased on the work by Tom Bamford (https://github.com/tombamford)",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name_regex": {
                "type": "string",
                "description": "A Launch Configuration to match\nIt'll be compiled as regex"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": "The AWS region to use."
              },
              "aws_region": {
                "type": "string",
                "description": "The AWS region to use."
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "sort_order": {
                "enum": [
                  "ascending",
                  "descending"
                ],
                "type": "string",
                "description": "Default: ascending\n\nOrder in which to sort results."
              },
              "limit": {
                "description": "How many results to show.\nCorresponds to Python slice notation like list[:limit].",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": "The AWS region to use."
              }
            }
          },
          "influxdb_database": {
            "required": [
              "hostname",
              "database_name"
            ],
            "type": "object",
            "description": "Manage InfluxDB databases",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: root\n\nUsername that will be used to authenticate against InfluxDB server"
              },
              "database_name": {
                "type": "string",
                "description": "Name of the database that will be created/destroyed"
              },
              "hostname": {
                "type": "string",
                "description": "The hostname or IP address on which InfluxDB server is listening"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines if the database should be created or destroyed"
              },
              "password": {
                "type": "string",
                "description": "Default: root\n\nPassword that will be used to authenticate against InfluxDB server"
              },
              "port": {
                "description": "Default: 8086\n\nThe port on which InfluxDB server is listening",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "netscaler": {
            "required": [
              "nsc_host",
              "user",
              "password"
            ],
            "type": "object",
            "description": "Manages Citrix NetScaler server and service entities.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Default: hostname\n\nname of the entity"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "nsc_protocol": {
                "type": "string",
                "description": "Default: https\n\nprotocol used to access netscaler"
              },
              "nsc_host": {
                "type": "string",
                "description": "hostname or ip of your netscaler"
              },
              "user": {
                "type": "string",
                "description": "username"
              },
              "action": {
                "enum": [
                  "enable",
                  "disable"
                ],
                "type": "string",
                "description": "Default: disable\n\nthe action you want to perform on the entity"
              },
              "password": {
                "type": "string",
                "description": "password"
              },
              "type": {
                "enum": [
                  "server",
                  "service"
                ],
                "type": "string",
                "description": "Default: server\n\ntype of the entity"
              }
            }
          },
          "cl_interface_policy": {
            "required": [
              "allowed"
            ],
            "type": "object",
            "description": "This module affects the configuration files located in the interfaces folder defined by ifupdown2. Interfaces port and port ranges listed in the \"allowed\" parameter define what interfaces will be available on the switch. If the user runs this module and has an interface configured on the switch, but not found in the \"allowed\" list, this interface will be unconfigured. By default this is `/etc/network/interface.d` For more details go the Configuring Interfaces at U(http://docs.cumulusnetworks.com).",
            "properties": {
              "location": {
                "type": "string",
                "description": "Default: /etc/network/interfaces.d/\n\nDirectory to store interface files."
              },
              "allowed": {
                "description": "List of ports to run initial run at 10G.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "bigip_monitor_tcp": {
            "type": "object",
            "description": "Manages F5 BIG-IP LTM tcp monitors via iControl SOAP API",
            "properties": {
              "interval": {
                "type": "string",
                "description": "Default: none\n\nThe interval specifying how frequently the monitor instance of this template will run. By default, this interval is used for up and down states. The default API setting is 5."
              },
              "name": {
                "type": "string",
                "description": "Monitor name"
              },
              "parent": {
                "type": "string",
                "description": "Default: tcp\n\nThe parent template of this monitor template"
              },
              "receive": {
                "type": "string",
                "description": "Default: none\n\nThe receive string for the monitor call"
              },
              "ip": {
                "type": "string",
                "description": "Default: none\n\nIP address part of the ipport definition. The default API setting is \"0.0.0.0\"."
              },
              "partition": {
                "type": "string",
                "description": "Default: Common\n\nPartition for the monitor"
              },
              "send": {
                "type": "string",
                "description": "Default: none\n\nThe send string for the monitor call"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nMonitor state"
              },
              "time_until_up": {
                "type": "string",
                "description": "Default: none\n\nSpecifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. The default API setting is 0."
              },
              "timeout": {
                "type": "string",
                "description": "Default: none\n\nThe number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. The default API setting is 16."
              },
              "parent_partition": {
                "type": "string",
                "description": "Default: Common\n\nPartition for the parent monitor"
              },
              "type": {
                "type": "string",
                "description": "Default: tcp\n\nThe template type of this monitor template"
              },
              "port": {
                "type": "string",
                "description": "Default: none\n\nPort address part op the ipport definition. The default API setting is 0."
              }
            }
          },
          "junos_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "display",
                        "format",
                        "output"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends an arbitrary set of commands to an JUNOS node and returns the results read from the device.  This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should be tried before it is considered failed.  The command is run on the target device every retry and evaluated against the I(wait_for) conditionals.",
                "$ref": "#/definitions/ansible_number"
              },
              "commands": {
                "description": "The commands to send to the remote junos device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "rpcs": {
                "description": "The C(rpcs) argument accepts a list of RPCs to be executed over a netconf session and the results from the RPC execution is return to the playbook via the modules results dictionary.",
                "$ref": "#/definitions/ansible_array"
              },
              "format": {
                "enum": [
                  "text",
                  "json",
                  "xml"
                ],
                "type": "string",
                "description": "Default: depends on input argument I(rpcs) or I(commands)\n\nEncoding scheme to use when serializing output from the device. This handles how to properly understand the output and apply the conditionals path to the result set. For I(rpcs) argument default display is C(xml) and for I(commands) argument default display is C(text)."
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command.  If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_for": {
                "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "display": {
                "enum": [
                  "text",
                  "json",
                  "xml"
                ],
                "type": "string",
                "description": "Default: depends on input argument I(rpcs) or I(commands)\n\nEncoding scheme to use when serializing output from the device. This handles how to properly understand the output and apply the conditionals path to the result set. For I(rpcs) argument default display is C(xml) and for I(commands) argument default display is C(text)."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "match": {
                "enum": [
                  "any",
                  "all"
                ],
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "output": {
                "enum": [
                  "text",
                  "json",
                  "xml"
                ],
                "type": "string",
                "description": "Default: depends on input argument I(rpcs) or I(commands)\n\nEncoding scheme to use when serializing output from the device. This handles how to properly understand the output and apply the conditionals path to the result set. For I(rpcs) argument default display is C(xml) and for I(commands) argument default display is C(text)."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              },
              "waitfor": {
                "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "bigmon_chain": {
            "required": [
              "controller",
              "name"
            ],
            "type": "object",
            "description": "Create and remove a bigmon inline service chain.",
            "properties": {
              "access_token": {
                "type": "string",
                "description": "Bigmon access token. If this isn't set the the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the service chain should be present or absent."
              },
              "validate_certs": {
                "description": "Default: True\n\nIf C(false), SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "controller": {
                "type": "string",
                "description": "The controller IP address."
              },
              "name": {
                "type": "string",
                "description": "The name of the chain."
              }
            }
          },
          "os_project_facts": {
            "type": "object",
            "description": "Retrieve facts about a one or more OpenStack projects",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Default: None\n\nName or ID of the domain containing the project if the cloud supports domains"
              },
              "name": {
                "type": "string",
                "description": "Name or ID of the project"
              },
              "filters": {
                "type": "string",
                "description": "Default: None\n\nA dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries."
              }
            }
          },
          "osx_defaults": {
            "type": "object",
            "description": "osx_defaults allows users to read, write, and delete Mac OS X user defaults from Ansible scripts. Mac OS X applications and other programs use the defaults system to record user preferences and other information that must be maintained when the applications aren't running (such as default font for new documents, or the position of an Info panel).",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Default: NSGlobalDomain\n\nThe domain is a domain name of the form com.companyname.appname."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state of the user defaults"
              },
              "value": {
                "type": "string",
                "description": "The value to write. Only required when state = present."
              },
              "host": {
                "type": "string",
                "description": "The host on which the preference should apply. The special value \"currentHost\" corresponds to the \"-currentHost\" switch of the defaults commandline tool."
              },
              "key": {
                "type": "string",
                "description": "The key of the user preference"
              },
              "path": {
                "type": "string",
                "description": ""
              },
              "type": {
                "enum": [
                  "array",
                  "bool",
                  "boolean",
                  "date",
                  "float",
                  "int",
                  "integer",
                  "string"
                ],
                "type": "string",
                "description": "Default: string\n\nThe type of value to write."
              },
              "array_add": {
                "description": "Add new elements to the array for a key which has an array as its value.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cs_staticnat": {
            "required": [
              "ip_address"
            ],
            "type": "object",
            "description": "Create, update and remove static NATs.",
            "properties": {
              "vm_guest_ip": {
                "type": "string",
                "description": "VM guest NIC secondary IP address for the static NAT."
              },
              "domain": {
                "type": "string",
                "description": "Domain the static NAT is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "network": {
                "type": "string",
                "description": "Network the IP address is related to."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "vm": {
                "type": "string",
                "description": "Name of virtual machine which we make the static NAT for.\nRequired if C(state=present)."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the static NAT is related to."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the static NAT."
              },
              "account": {
                "type": "string",
                "description": "Account the static NAT is related to."
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the virtual machine is in.\nIf not set, default zone is used."
              },
              "ip_address": {
                "type": "string",
                "description": "Public IP address the static NAT is assigned to."
              },
              "api_url": {
                "type": "string",
                "description": ""
              }
            }
          },
          "omapi_host": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "hostname",
                        "name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, update and remove OMAPI hosts into compatible DHCPd servers.",
            "properties": {
              "macaddr": {
                "type": "string",
                "description": "Sets the lease host MAC address."
              },
              "statements": {
                "description": "Attach a list of OMAPI DHCP statements with host lease (without ending semicolon).",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nSets the host lease hostname (mandatory if state=present)."
              },
              "ip": {
                "type": "string",
                "description": "Default: None\n\nSets the lease host IP address."
              },
              "hostname": {
                "type": "string",
                "description": "Default: None\n\nSets the host lease hostname (mandatory if state=present)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Create or remove OMAPI host."
              },
              "host": {
                "type": "string",
                "description": "Default: localhost\n\nSets OMAPI server host to interact with."
              },
              "ddns": {
                "description": "Enable dynamic DNS updates for this host.",
                "$ref": "#/definitions/ansible_truth"
              },
              "key": {
                "type": "string",
                "description": "Sets the TSIG key content for authenticating against OMAPI server."
              },
              "key_name": {
                "type": "string",
                "description": "Sets the TSIG key name for authenticating against OMAPI server."
              },
              "port": {
                "description": "Default: 7911\n\nSets the OMAPI server port to interact with.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "aos_device": {
            "required": [
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS Device module let you manage your devices in AOS easily. You can approve devices and define in which state the device should be. Currently only the state I(normal) is supported but the goal is to extend this module with additional state. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "name": {
                "type": "string",
                "description": "The device serial-number; i.e. uniquely identifies the device in the AOS system. Only one of I(name) or I(id) can be set."
              },
              "state": {
                "enum": [
                  "normal"
                ],
                "type": "string",
                "description": "Default: normal\n\nDefine in which state the device should be. Currently only I(normal) is supported but the goal is to add I(maint) and I(decomm)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "location": {
                "type": "string",
                "description": "When approving a device using the I(approve) argument, it's possible define the location of the device."
              },
              "approve": {
                "description": "Default: no\n\nThe approve argument instruct the module to convert a device in quarantine mode into approved mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "id": {
                "type": "string",
                "description": "The AOS internal id for a device; i.e. uniquely identifies the device in the AOS system. Only one of I(name) or I(id) can be set."
              }
            }
          },
          "dellos6_facts": {
            "type": "object",
            "description": "Collects a base set of device facts from a remote device that is running OS6.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module always collects a base set of facts from the device and can enable or disable collection of additional facts.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen specified, this argument restricts the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  You can specify a list of values to include a larger subset.  You can also use values with an initial M(!) to specify that a specific subset should not be collected.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "atomic_host": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "revision",
                        "version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage the atomic host platform\nRebooting of Atomic host platform should be done outside this module",
            "properties": {
              "version": {
                "type": "string",
                "description": "Default: latest\n\nThe version number of the atomic host to be deployed. Providing ```latest``` will upgrade to the latest available version."
              },
              "revision": {
                "type": "string",
                "description": "Default: latest\n\nThe version number of the atomic host to be deployed. Providing ```latest``` will upgrade to the latest available version."
              }
            }
          },
          "fail": {
            "type": "object",
            "description": "This module fails the progress with a custom message. It can be useful for bailing out when a certain condition is met using C(when).",
            "properties": {
              "active_connection_states": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "connect_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "delay": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "present",
                  "absent",
                  "drained"
                ],
                "type": "string",
                "description": ""
              },
              "sleep": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "exclude_hosts": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "search_regex": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "lxc_container": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Management of LXC containers",
            "properties": {
              "zfs_root": {
                "type": "string",
                "description": "Create zfs under given zfsroot."
              },
              "clone_name": {
                "type": "string",
                "description": "Name of the new cloned server. This is only used when state is clone."
              },
              "container_config": {
                "type": "string",
                "description": "list of 'key=value' options to use when configuring a container."
              },
              "fs_type": {
                "type": "string",
                "description": "Default: ext4\n\nCreate fstype TYPE."
              },
              "archive": {
                "description": "Create an archive of a container. This will create a tarball of the running container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "container_log": {
                "description": "Enable a container log for host actions to the container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "absent",
                  "restarted",
                  "started",
                  "clone",
                  "frozen",
                  "stopped"
                ],
                "type": "string",
                "description": "Default: started\n\nDefine the state of a container. If you clone a container using `clone_name` the newly cloned container created in a stopped state. The running container will be stopped while the clone operation is happening and upon completion of the clone the original container state will be restored."
              },
              "template": {
                "type": "string",
                "description": "Default: ubuntu\n\nName of the template to use within an LXC create."
              },
              "config": {
                "type": "string",
                "description": "Path to the LXC configuration file."
              },
              "archive_path": {
                "type": "string",
                "description": "Path the save the archived container. If the path does not exist the archive method will attempt to create it."
              },
              "container_log_level": {
                "enum": [
                  "info",
                  "INFO",
                  "Info",
                  "debug",
                  "DEBUG",
                  "Debug",
                  "error",
                  "ERROR",
                  "Error"
                ],
                "type": "string",
                "description": "Default: INFO\n\nSet the log level for a container where *container_log* was set."
              },
              "template_options": {
                "type": "string",
                "description": "Template options when building the container."
              },
              "container_command": {
                "type": "string",
                "description": "Run a command within a container."
              },
              "lxc_path": {
                "type": "string",
                "description": "Place container under PATH"
              },
              "archive_compression": {
                "enum": [
                  "gzip",
                  "bzip2",
                  "none"
                ],
                "type": "string",
                "description": "Default: gzip\n\nType of compression to use when creating an archive of a running container."
              },
              "thinpool": {
                "type": "string",
                "description": "Use LVM thin pool called TP."
              },
              "clone_snapshot": {
                "description": "Create a snapshot a container when cloning. This is not supported by all container storage backends. Enabling this may fail if the backing store does not support snapshots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of a container."
              },
              "lv_name": {
                "type": "string",
                "description": "Default: $CONTAINER_NAME\n\nName of the logical volume, defaults to the container name."
              },
              "fs_size": {
                "type": "string",
                "description": "Default: 5G\n\nFile system Size."
              },
              "backing_store": {
                "enum": [
                  "dir",
                  "lvm",
                  "loop",
                  "btrfs",
                  "overlayfs",
                  "zfs"
                ],
                "type": "string",
                "description": "Default: dir\n\nBackend storage type for the container."
              },
              "vg_name": {
                "type": "string",
                "description": "Default: lxc\n\nIf Backend store is lvm, specify the name of the volume group."
              },
              "directory": {
                "type": "string",
                "description": "Place rootfs directory under DIR."
              }
            }
          },
          "vmware_guest_facts": {
            "required": [
              "datacenter",
              "name"
            ],
            "type": "object",
            "description": "Gather facts about a single Virtual Machine on a VMware ESX cluster",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "datacenter": {
                "type": "string",
                "description": "Destination datacenter for the deploy operation"
              },
              "uuid": {
                "type": "string",
                "description": "UUID of the instance to manage if known, this is VMware's unique identifier.\nThis is required if name is not supplied."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "name_match": {
                "type": "string",
                "description": "Default: first\n\nIf multiple Virtual Machines matching the name, use the first or last found"
              },
              "folder": {
                "type": "string",
                "description": "Default: /vm\n\nDestination folder, absolute or relative path to find an existing guest.\nThis is required if name is supplied.\nThe folder should include the datacenter. ESX's datacenter is ha-datacenter\nExamples:\n   folder: /ha-datacenter/vm\n   folder: ha-datacenter/vm\n   folder: /datacenter1/vm\n   folder: datacenter1/vm\n   folder: /datacenter1/vm/folder1\n   folder: datacenter1/vm/folder1\n   folder: /folder1/datacenter1/vm\n   folder: folder1/datacenter1/vm\n   folder: /folder1/datacenter1/vm/folder2\n   folder: vm/folder2\n   folder: folder2"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the Virtual Machine to work with"
              }
            }
          },
          "eos_eapi": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "http",
                        "enable_http"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "local_http",
                        "enable_local_http"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "socket",
                        "enable_socket"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "https",
                        "enable_https"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Use to enable or disable eAPI access, and set the port and state of http, https, local_http and unix-socket servers.\nWhen enabling eAPI access the default is to enable HTTP on port 80, enable HTTPS on port 443, disable local HTTP, and disable Unix socket server. Use the options listed below to override the default configuration.\nRequires EOS v4.12 or greater.",
            "properties": {
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "https_port": {
                "description": "Default: 443\n\nConfigures the HTTP port that will listen for connections when the HTTP transport protocol is enabled.  This argument accepts integer values in the valid range of 1 to 65535.",
                "$ref": "#/definitions/ansible_number"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "eapi"
                ],
                "type": "string",
                "description": ""
              },
              "local_http_port": {
                "description": "Default: 8080\n\nConfigures the HTTP port that will listen for connections when the HTTP transport protocol is enabled.  This argument accepts integer values in the valid range of 1 to 65535.",
                "$ref": "#/definitions/ansible_number"
              },
              "http_port": {
                "description": "Default: 80\n\nConfigures the HTTP port that will listen for connections when the HTTP transport protocol is enabled.  This argument accepts integer values in the valid range of 1 to 65535.",
                "$ref": "#/definitions/ansible_number"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "started",
                  "stopped"
                ],
                "type": "string",
                "description": "Default: started\n\nThe C(state) argument controls the operational state of eAPI on the remote device.  When this argument is set to C(started), eAPI is enabled to receive requests and when this argument is C(stopped), eAPI is disabled and will not receive requests."
              },
              "https": {
                "description": "Default: True\n\nThe C(https) argument controls the operating state of the HTTPS transport protocol when eAPI is present in the running-config. When the value is set to True, the HTTPS protocol is enabled and when the value is set to False, the HTTPS protocol is disabled. By default, when eAPI is first configured, the HTTPS protocol is enabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "enable_http": {
                "description": "The C(http) argument controls the operating state of the HTTP transport protocol when eAPI is present in the running-config. When the value is set to True, the HTTP protocol is enabled and when the value is set to False, the HTTP protocol is disabled. By default, when eAPI is first configured, the HTTP protocol is disabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "Default: nul\n\nThe module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "enable_socket": {
                "description": "The C(socket) argument controls the operating state of the UNIX Domain Socket used to receive eAPI requests.  When the value of this argument is set to True, the UDS will listen for eAPI requests.  When the value is set to False, the UDS will not be available to handle requests.  By default when eAPI is first configured, the UDS is disabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "http": {
                "description": "The C(http) argument controls the operating state of the HTTP transport protocol when eAPI is present in the running-config. When the value is set to True, the HTTP protocol is enabled and when the value is set to False, the HTTP protocol is disabled. By default, when eAPI is first configured, the HTTP protocol is disabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "vrf": {
                "type": "string",
                "description": "Default: default\n\nThe C(vrf) argument will configure eAPI to listen for connections in the specified VRF.  By default, eAPI transports will listen for connections in the global table.  This value requires the VRF to already be created otherwise the task will fail."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "local_http": {
                "description": "The C(local_http) argument controls the operating state of the local HTTP transport protocol when eAPI is present in the running-config.  When the value is set to True, the HTTP protocol is enabled and restricted to connections from localhost only.  When the value is set to False, the HTTP local protocol is disabled.\nNote is value is independent of the C(http) argument",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "socket": {
                "description": "The C(socket) argument controls the operating state of the UNIX Domain Socket used to receive eAPI requests.  When the value of this argument is set to True, the UDS will listen for eAPI requests.  When the value is set to False, the UDS will not be available to handle requests.  By default when eAPI is first configured, the UDS is disabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "enable_https": {
                "description": "Default: True\n\nThe C(https) argument controls the operating state of the HTTPS transport protocol when eAPI is present in the running-config. When the value is set to True, the HTTPS protocol is enabled and when the value is set to False, the HTTPS protocol is disabled. By default, when eAPI is first configured, the HTTPS protocol is enabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "enable_local_http": {
                "description": "The C(local_http) argument controls the operating state of the local HTTP transport protocol when eAPI is present in the running-config.  When the value is set to True, the HTTP protocol is enabled and restricted to connections from localhost only.  When the value is set to False, the HTTP local protocol is disabled.\nNote is value is independent of the C(http) argument",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "win_file": {
            "type": "object",
            "description": "Creates (empty) files, updates file modification stamps of existing files, and can create or remove directories.\nUnlike M(file), does not modify ownership, permissions or manipulate links.",
            "properties": {
              "path": {
                "type": "string",
                "description": "path to the file being managed.  Aliases: I(dest), I(name)"
              },
              "state": {
                "type": "string",
                "description": "If C(directory), all immediate subdirectories will be created if they do not exist. If C(file), the file will NOT be created if it does not exist, see the M(copy) or M(template) module if you want that behavior.  If C(absent), directories will be recursively deleted, and files will be removed. If C(touch), an empty file will be created if the C(path) does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way C(touch) works from the command line)."
              }
            }
          },
          "stackdriver": {
            "required": [
              "key",
              "event"
            ],
            "type": "object",
            "description": "Send code deploy and annotation events to Stackdriver",
            "properties": {
              "repository": {
                "type": "string",
                "description": "The repository (or project) deployed"
              },
              "level": {
                "enum": [
                  "INFO",
                  "WARN",
                  "ERROR"
                ],
                "type": "string",
                "description": "Default: INFO\n\none of INFO/WARN/ERROR, defaults to INFO if not supplied.  May affect display."
              },
              "annotated_by": {
                "type": "string",
                "description": "Default: Ansible\n\nThe person or robot who the annotation should be attributed to."
              },
              "deployed_by": {
                "type": "string",
                "description": "Default: Ansible\n\nThe person or robot responsible for deploying the code"
              },
              "deployed_to": {
                "type": "string",
                "description": "The environment code was deployed to. (ie: development, staging, production)"
              },
              "instance_id": {
                "type": "string",
                "description": "id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown"
              },
              "key": {
                "type": "string",
                "description": "API key."
              },
              "msg": {
                "type": "string",
                "description": "The contents of the annotation message, in plain text.  Limited to 256 characters. Required for annotation."
              },
              "event_epoch": {
                "type": "string",
                "description": "Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this."
              },
              "revision_id": {
                "type": "string",
                "description": "The revision of the code that was deployed. Required for deploy events"
              },
              "event": {
                "enum": [
                  "annotation",
                  "deploy"
                ],
                "type": "string",
                "description": "The type of event to send, either annotation or deploy"
              }
            }
          },
          "win_updates": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Searches, downloads, and installs Windows updates synchronously by automating the Windows Update client",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: installed\n\nControls whether found updates are returned as a list or actually installed.\nThis module also supports Ansible check mode, which has the same effect as setting state=searched"
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "znode": {
            "required": [
              "hosts",
              "name"
            ],
            "type": "object",
            "description": "",
            "properties": {
              "name": {
                "type": "string",
                "description": "The path of the znode."
              },
              "value": {
                "type": "string",
                "description": "Default: None\n\nThe value assigned to the znode."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: None\n\nThe state to enforce. Mutually exclusive with op."
              },
              "hosts": {
                "type": "string",
                "description": "A list of ZooKeeper servers (format '[server]:[port]')."
              },
              "timeout": {
                "description": "Default: 300\n\nThe amount of time to wait for a node to appear.",
                "$ref": "#/definitions/ansible_number"
              },
              "op": {
                "enum": [
                  "get",
                  "wait",
                  "list"
                ],
                "type": "string",
                "description": "Default: None\n\nAn operation to perform. Mutually exclusive with state."
              },
              "recursive": {
                "description": "Recursively delete node and all its children.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "xattr": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages filesystem user defined extended attributes, requires that they are enabled on the target filesystem and that the setfattr/getfattr utilities are present.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Default: None\n\nThe full path of the file/object to get the facts of.\nBefore 2.3 this option was only usable as I(name)."
              },
              "value": {
                "type": "string",
                "description": "Default: None\n\nThe value to set the named name/key to, it automatically sets the C(state) to 'set'"
              },
              "state": {
                "enum": [
                  "read",
                  "present",
                  "all",
                  "keys",
                  "absent"
                ],
                "type": "string",
                "description": "Default: get\n\ndefines which state you want to do. C(read) retrieves the current value for a C(key) (default) C(present) sets C(name) to C(value), default if value is set C(all) dumps all data C(keys) retrieves all keys C(absent) deletes the key"
              },
              "key": {
                "type": "string",
                "description": "Default: None\n\nThe name of a specific Extended attribute key to set/retrieve"
              },
              "path": {
                "type": "string",
                "description": "Default: None\n\nThe full path of the file/object to get the facts of.\nBefore 2.3 this option was only usable as I(name)."
              },
              "follow": {
                "description": "Default: True\n\nif yes, dereferences symlinks and sets/gets attributes on symlink target, otherwise acts on symlink itself.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "sf_snapshot_schedule_manager": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, destroy, or update accounts on SolidFire",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "time_interval_days": {
                "description": "Default: 1\n\nTime interval in days.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Name for the snapshot schedule."
              },
              "time_interval_minutes": {
                "description": "Time interval in minutes.",
                "$ref": "#/definitions/ansible_number"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "schedule_id": {
                "description": "The schedule ID for the schedule that you want to update or delete.",
                "$ref": "#/definitions/ansible_number"
              },
              "time_interval_hours": {
                "description": "Time interval in hours.",
                "$ref": "#/definitions/ansible_number"
              },
              "paused": {
                "description": "Pause / Resume a schedule.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified schedule should exist or not."
              },
              "snapshot_name": {
                "type": "string",
                "description": "Name for the created snapshots."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "volumes": {
                "description": "Volume IDs that you want to set the snapshot schedule for.\nAt least 1 volume ID is required for creating a new schedule.\nrequired when C(state=present)",
                "$ref": "#/definitions/ansible_array"
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "starting_date": {
                "type": "string",
                "description": "Starting date for the schedule.\nRequired when C(state=present).\nPlease use two '-' in the above format, or you may see an error- TypeError, is not JSON serializable description.\nFormat: C(2016--12--01T00:00:00Z)"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "recurring": {
                "description": "Should the schedule recur?",
                "$ref": "#/definitions/ansible_truth"
              },
              "retention": {
                "type": "string",
                "description": "Retention period for the snapshot.\nFormat is 'HH:mm:ss'."
              }
            }
          },
          "rax": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "key_name",
                        "keypair"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "creates / deletes a Rackspace Public Cloud instance and optionally waits for it to be 'running'.",
            "properties": {
              "files": {
                "type": "object",
                "description": "Files to insert into the instance. remotefilename:localcontent"
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "image": {
                "type": "string",
                "description": "image to use for the instance. Can be an C(id), C(human_id) or C(name). With I(boot_from_volume), a Cloud Block Storage volume will be created with this image"
              },
              "user_data": {
                "type": "string",
                "description": "Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "meta": {
                "type": "object",
                "description": "A hash of metadata to associate with the instance"
              },
              "flavor": {
                "type": "string",
                "description": "flavor to use for the instance"
              },
              "networks": {
                "description": "Default: ['public', 'private']\n\nThe network to attach to the instances. If specified, you must include ALL networks including the public and private interfaces. Can be C(id) or C(label).",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "boot_from_volume": {
                "description": "Default: no\n\nWhether or not to boot the instance from a Cloud Block Storage volume. If C(yes) and I(image) is specified a new volume will be created at boot time. I(boot_volume_size) is required with I(image) to create a new volume at boot time.",
                "$ref": "#/definitions/ansible_truth"
              },
              "group": {
                "type": "string",
                "description": "host group to assign to server, is also used for idempotent operations to ensure a specific number of instances"
              },
              "service": {
                "type": "string",
                "description": ""
              },
              "extra_create_args": {
                "type": "object",
                "description": "A hash of key/value pairs to be used when creating a new server. This is considered an advanced option, use it wisely and with caution."
              },
              "disk_config": {
                "enum": [
                  "auto",
                  "manual"
                ],
                "type": "string",
                "description": "Default: auto\n\nDisk partitioning strategy"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "auto_increment": {
                "description": "Default: True\n\nWhether or not to increment a single number with the name of the created servers. Only applicable when used with the I(group) attribute or meta key.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "config_drive": {
                "description": "Attach read-only configuration drive to server as label config-2",
                "$ref": "#/definitions/ansible_truth"
              },
              "boot_volume_terminate": {
                "description": "Whether the I(boot_volume) or newly created volume from I(image) will be terminated when the server is terminated",
                "$ref": "#/definitions/ansible_truth"
              },
              "key_name": {
                "type": "string",
                "description": "key pair to use on the instance"
              },
              "count_offset": {
                "description": "Default: 1\n\nnumber count to start at",
                "$ref": "#/definitions/ansible_number"
              },
              "instance_ids": {
                "description": "list of instance ids, currently only used when state='absent' to remove instances",
                "$ref": "#/definitions/ansible_array"
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 300\n\nhow long before wait gives up, in seconds"
              },
              "boot_volume": {
                "type": "string",
                "description": "Cloud Block Storage ID or Name to use as the boot volume of the instance"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: no\n\nwait for the instance to be in state 'running' before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "count": {
                "description": "Default: 1\n\nnumber of instances to launch",
                "$ref": "#/definitions/ansible_number"
              },
              "boot_volume_size": {
                "description": "Default: 100\n\nSize of the volume to create in Gigabytes. This is only required with I(image) and I(boot_from_volume).",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Name to give the instance"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "keypair": {
                "type": "string",
                "description": "key pair to use on the instance"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "extra_client_args": {
                "type": "object",
                "description": "A hash of key/value pairs to be used when creating the cloudservers client. This is considered an advanced option, use it wisely and with caution."
              },
              "exact_count": {
                "description": "Explicitly ensure an exact count of instances, used with state=active/present. If specified as C(yes) and I(count) is less than the servers matched, servers will be deleted to match the count. If the number of matched servers is fewer than specified in I(count) additional servers will be added.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vertica_facts": {
            "type": "object",
            "description": "Gathers Vertica database facts.",
            "properties": {
              "login_user": {
                "type": "string",
                "description": "Default: dbadmin\n\nThe username used to authenticate with."
              },
              "cluster": {
                "type": "string",
                "description": "Default: localhost\n\nName of the cluster running the schema."
              },
              "db": {
                "type": "string",
                "description": "Name of the database running the schema."
              },
              "port": {
                "type": "string",
                "description": "Default: 5433\n\nDatabase port to connect to."
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with."
              }
            }
          },
          "cs_ip_address": {
            "type": "object",
            "description": "Acquires and associates a public IP to an account or project. Due to API limitations this is not an idempotent call, so be sure to only conditionally call this when C(state=present)",
            "properties": {
              "account": {
                "type": "string",
                "description": "Account the IP address is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the IP address is related to."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "domain": {
                "type": "string",
                "description": "Domain the IP address is related to."
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the IP address is in.\nIf not set, default zone is used."
              },
              "ip_address": {
                "type": "string",
                "description": "Public IP address.\nRequired if C(state=absent)"
              },
              "vpc": {
                "type": "string",
                "description": "VPC the IP address is related to."
              },
              "network": {
                "type": "string",
                "description": "Network the IP address is related to."
              }
            }
          },
          "avi_healthmonitor": {
            "required": [
              "name",
              "type"
            ],
            "type": "object",
            "description": "This module is used to configure HealthMonitor object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "https_monitor": {
                "type": "object",
                "description": "Healthmonitorhttp settings for healthmonitor."
              },
              "successful_checks": {
                "description": "Number of continuous successful health checks before server is marked up.\nDefault value when not specified in API or module is interpreted by Avi Controller as 2.",
                "$ref": "#/definitions/ansible_number"
              },
              "uuid": {
                "type": "string",
                "description": "Uuid of the health monitor."
              },
              "dns_monitor": {
                "type": "object",
                "description": "Healthmonitordns settings for healthmonitor."
              },
              "failed_checks": {
                "description": "Number of continuous failed health checks before the server is marked down.\nDefault value when not specified in API or module is interpreted by Avi Controller as 2.",
                "$ref": "#/definitions/ansible_number"
              },
              "tcp_monitor": {
                "type": "object",
                "description": "Healthmonitortcp settings for healthmonitor."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "external_monitor": {
                "type": "object",
                "description": "Healthmonitorexternal settings for healthmonitor."
              },
              "type": {
                "type": "string",
                "description": "Type of the health monitor."
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "receive_timeout": {
                "description": "A valid response from the server is expected within the receive timeout window.\nThis timeout must be less than the send interval.\nIf server status is regularly flapping up and down, consider increasing this value.\nDefault value when not specified in API or module is interpreted by Avi Controller as 4.",
                "$ref": "#/definitions/ansible_number"
              },
              "description": {
                "type": "string",
                "description": "User defined description for the object."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "udp_monitor": {
                "type": "object",
                "description": "Healthmonitorudp settings for healthmonitor."
              },
              "http_monitor": {
                "type": "object",
                "description": "Healthmonitorhttp settings for healthmonitor."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "monitor_port": {
                "description": "Use this port instead of the port defined for the server in the pool.\nIf the monitor succeeds to this port, the load balanced traffic will still be sent to the port of the server defined within the pool.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "A user friendly name for this health monitor."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "send_interval": {
                "description": "Frequency, in seconds, that monitors are sent to a server.\nDefault value when not specified in API or module is interpreted by Avi Controller as 10.",
                "$ref": "#/definitions/ansible_number"
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              }
            }
          },
          "mysql_replication": {
            "type": "object",
            "description": "Manages MySQL server replication, slave, master status get and change master host.",
            "properties": {
              "ssl_key": {
                "type": "string",
                "description": ""
              },
              "master_auto_position": {
                "description": "does the host uses GTID based replication or not",
                "$ref": "#/definitions/ansible_truth"
              },
              "master_ssl_cert": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "login_user": {
                "type": "string",
                "description": ""
              },
              "master_port": {
                "description": "same as mysql variable",
                "$ref": "#/definitions/ansible_number"
              },
              "master_host": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "master_ssl_ca": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "master_ssl_cipher": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "relay_log_file": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "master_log_pos": {
                "description": "same as mysql variable",
                "$ref": "#/definitions/ansible_number"
              },
              "connect_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "relay_log_pos": {
                "description": "same as mysql variable",
                "$ref": "#/definitions/ansible_number"
              },
              "master_password": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "config_file": {
                "type": "string",
                "description": ""
              },
              "master_ssl": {
                "description": "same as mysql variable",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_host": {
                "type": "string",
                "description": ""
              },
              "master_ssl_capath": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "master_connect_retry": {
                "description": "same as mysql variable",
                "$ref": "#/definitions/ansible_number"
              },
              "master_user": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "login_password": {
                "type": "string",
                "description": ""
              },
              "master_log_file": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "login_port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "ssl_cert": {
                "type": "string",
                "description": ""
              },
              "ssl_ca": {
                "type": "string",
                "description": ""
              },
              "master_ssl_key": {
                "type": "string",
                "description": "same as mysql variable"
              },
              "mode": {
                "enum": [
                  "getslave",
                  "getmaster",
                  "changemaster",
                  "stopslave",
                  "startslave",
                  "resetslave",
                  "resetslaveall"
                ],
                "type": "string",
                "description": "Default: getslave\n\nmodule operating mode. Could be getslave (SHOW SLAVE STATUS), getmaster (SHOW MASTER STATUS), changemaster (CHANGE MASTER TO), startslave (START SLAVE), stopslave (STOP SLAVE), resetslave (RESET SLAVE), resetslaveall (RESET SLAVE ALL)"
              }
            }
          },
          "ec2_vpc_igw_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about internet gateways in AWS.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "internet_gateway_ids": {
                "description": "Default: None\n\nGet details of specific Internet Gateway ID. Provide this value as a list.",
                "$ref": "#/definitions/ansible_array"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "efs": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module allows create, search and destroy Amazon EFS file systems",
            "properties": {
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "targets": {
                "description": "Default: None\n\nList of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes:\n    - subnet_id - Mandatory. The ID of the subnet to add the mount target in.\n    - ip_address - Optional. A valid IPv4 address within the address range of the specified subnet.\n    - security_groups - Optional. List of security group IDs, of the form \"sg-xxxxxxxx\". These must be for the same VPC as subnet specified\nThis data may be modified for existing EFS using state 'present' and new list of mount targets.\n",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "id": {
                "type": "string",
                "description": "Default: None\n\nID of Amazon EFS. Either name or ID required for delete."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nAllows to create, search and destroy Amazon EFS file system"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "performance_mode": {
                "enum": [
                  "general_purpose",
                  "max_io"
                ],
                "type": "string",
                "description": "Default: general_purpose\n\nFile system's performance mode to use. Only takes effect during creation."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "Default: None\n\nList of tags of Amazon EFS. Should be defined as dictionary\nIn case of 'present' state with list of tags and existing EFS (matched by 'name'), tags of EFS will be replaced with provided data.\n"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "wait_timeout": {
                "description": "How long the module should wait (in seconds) for desired state before returning. Zero means wait as long as necessary.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: no\n\nIn case of 'present' state should wait for EFS 'available' life cycle state (of course, if current state not 'deleting' or 'deleted')\nIn case of 'absent' state should wait for EFS 'deleted' life cycle state\n",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nCreation Token of Amazon EFS file system. Required for create. Either name or ID required for delete."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "zypper_repository": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "autorefresh",
                        "refresh"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove Zypper repositories on SUSE and openSUSE",
            "properties": {
              "repo": {
                "type": "string",
                "description": "Default: none\n\nURI of the repository or .repo file. Required when state=present."
              },
              "autorefresh": {
                "description": "Default: yes\n\nEnable autorefresh of the repository.",
                "$ref": "#/definitions/ansible_truth"
              },
              "auto_import_keys": {
                "description": "Default: no\n\nAutomatically import the gpg signing key of the new or changed repository.\nHas an effect only if state is I(present). Has no effect on existing (unchanged) repositories or in combination with I(absent).\nImplies runrefresh.",
                "$ref": "#/definitions/ansible_truth"
              },
              "enabled": {
                "description": "Default: yes\n\nSet repository to enabled (or disabled).",
                "$ref": "#/definitions/ansible_truth"
              },
              "disable_gpg_check": {
                "description": "Default: no\n\nWhether to disable GPG signature checking of all packages. Has an effect only if state is I(present).\nNeeds zypper version >= 1.6.2.",
                "$ref": "#/definitions/ansible_truth"
              },
              "refresh": {
                "description": "Default: yes\n\nEnable autorefresh of the repository.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Default: none\n\nA name for the repository. Not required when adding repofiles."
              },
              "priority": {
                "description": "Set priority of repository. Packages will always be installed from the repository with the smallest priority number.\nNeeds zypper version >= 1.12.25.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nA source string state."
              },
              "overwrite_multiple": {
                "description": "Default: no\n\nOverwrite multiple repository entries, if repositories with both name and URL already exist.",
                "$ref": "#/definitions/ansible_truth"
              },
              "runrefresh": {
                "description": "Default: no\n\nRefresh the package list of the given repository.\nCan be used with repo=* to refresh all repositories.",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "Default: none\n\nA description of the repository"
              }
            }
          },
          "hpilo_facts": {
            "required": [
              "host"
            ],
            "type": "object",
            "description": "This module gathers facts for a specific system using its HP iLO interface. These facts include hardware and network related information useful for provisioning (e.g. macaddress, uuid).\nThis module requires the hpilo python module.",
            "properties": {
              "login": {
                "type": "string",
                "description": "Default: Administrator\n\nThe login name to authenticate to the HP iLO interface."
              },
              "password": {
                "type": "string",
                "description": "Default: admin\n\nThe password to authenticate to the HP iLO interface."
              },
              "host": {
                "type": "string",
                "description": "The HP iLO hostname/address that is linked to the physical system."
              }
            }
          },
          "aos_login": {
            "required": [
              "server"
            ],
            "type": "object",
            "description": "Obtain the AOS server session token by providing the required username and password credentials.  Upon successful authentication, this module will return the session-token that is required by all subsequent AOS module usage. On success the module will automatically populate ansible facts with the variable I(aos_session) This module is not idempotent and do not support check mode.",
            "properties": {
              "passwd": {
                "type": "string",
                "description": "Default: admin\n\nPassword to use when connecting to the AOS server."
              },
              "server": {
                "type": "string",
                "description": "Address of the AOS Server on which you want to open a connection."
              },
              "port": {
                "description": "Default: 443\n\nPort number to use when connecting to the AOS server.",
                "$ref": "#/definitions/ansible_number"
              },
              "user": {
                "type": "string",
                "description": "Default: admin\n\nLogin username to use when connecting to the AOS server."
              }
            }
          },
          "xbps": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg",
                        "package"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage packages with the XBPS package manager.",
            "properties": {
              "upgrade": {
                "description": "Whether or not to upgrade whole system",
                "$ref": "#/definitions/ansible_truth"
              },
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "Name of the package to install, upgrade, or remove.",
                "$ref": "#/definitions/ansible_array"
              },
              "package": {
                "description": "Name of the package to install, upgrade, or remove.",
                "$ref": "#/definitions/ansible_array"
              },
              "recurse": {
                "description": "When removing a package, also remove its dependencies, provided that they are not required by other packages and were not explicitly installed by a user.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "latest",
                  "absent",
                  "removed"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the package."
              },
              "update_cache": {
                "description": "Default: True\n\nWhether or not to refresh the master package lists. This can be run as part of a package installation or as a separate step.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "Name of the package to install, upgrade, or remove.",
                "$ref": "#/definitions/ansible_array"
              },
              "update-cache": {
                "description": "Default: True\n\nWhether or not to refresh the master package lists. This can be run as part of a package installation or as a separate step.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "os_image": {
            "type": "object",
            "description": "Add or Remove images from the OpenStack Image Repository",
            "properties": {
              "ramdisk": {
                "type": "string",
                "description": "Default: None\n\nThe name of an existing ramdisk image that will be associated with this image"
              },
              "kernel": {
                "type": "string",
                "description": "Default: None\n\nThe name of an existing kernel image that will be associated with this image"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nName that has to be given to the image"
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "container_format": {
                "type": "string",
                "description": "Default: bare\n\nThe format of the container"
              },
              "min_ram": {
                "type": "string",
                "description": "Default: None\n\nThe minimum ram (in MB) required to boot this image"
              },
              "disk_format": {
                "type": "string",
                "description": "Default: qcow2\n\nThe format of the disk that is getting uploaded"
              },
              "filename": {
                "type": "string",
                "description": "Default: None\n\nThe path to the file which has to be uploaded"
              },
              "min_disk": {
                "type": "string",
                "description": "Default: None\n\nThe minimum disk space (in GB) required to boot this image"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "owner": {
                "type": "string",
                "description": "Default: None\n\nThe owner of the image"
              },
              "is_public": {
                "type": "string",
                "description": "Default: yes\n\nWhether the image can be accessed publicly. Note that publicizing an image requires admin role by default."
              },
              "properties": {
                "type": "string",
                "description": "Additional properties to be associated with this image"
              }
            }
          },
          "docker_network": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cacert_path",
                        "tls_ca_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "docker_host",
                        "docker_url"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "connected",
                        "containers"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cert_path",
                        "tls_client_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "network_name",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "network_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "key_path",
                        "tls_client_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "appends",
                        "incremental"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_version",
                        "docker_api_version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create/remove Docker networks and connect containers to them.\nPerforms largely the same function as the \"docker network\" CLI subcommand.",
            "properties": {
              "force": {
                "description": "With state I(absent) forces disconnecting all containers from the network prior to deleting the network. With state I(present) will disconnect all containers, delete the network and re-create the network.  This option is required if you have changed the IPAM or driver options and want an existing network to be updated to use the new options.",
                "$ref": "#/definitions/ansible_truth"
              },
              "docker_host": {
                "type": "string",
                "description": ""
              },
              "tls_verify": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "tls_client_key": {
                "type": "string",
                "description": ""
              },
              "ipam_driver": {
                "type": "string",
                "description": "Specify an IPAM driver."
              },
              "network_name": {
                "type": "string",
                "description": "Name of the network to operate on."
              },
              "filter_logger": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "docker_url": {
                "type": "string",
                "description": ""
              },
              "ipam_options": {
                "type": "object",
                "description": "Dictionary of IPAM options."
              },
              "tls_ca_cert": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nI(absent) deletes the network. If a network has connected containers, it cannot be deleted. Use the C(force) option to disconnect all containers and delete the network.\nI(present) creates the network, if it does not already exist with the specified parameters, and connects the list of containers provided via the connected parameter. Containers not on the list will be disconnected. An empty list will leave no containers connected to the network. Use the C(appends) option to leave existing containers connected. Use the C(force) options to force re-creation of the network."
              },
              "tls_client_cert": {
                "type": "string",
                "description": ""
              },
              "key_path": {
                "type": "string",
                "description": ""
              },
              "appends": {
                "description": "By default the connected list is canonical, meaning containers not on the list are removed from the network. Use C(appends) to leave existing containers connected.",
                "$ref": "#/definitions/ansible_truth"
              },
              "containers": {
                "description": "List of container names or container IDs to connect to a network.",
                "$ref": "#/definitions/ansible_array"
              },
              "cacert_path": {
                "type": "string",
                "description": ""
              },
              "driver": {
                "type": "string",
                "description": "Default: bridge\n\nSpecify the type of network. Docker provides bridge and overlay drivers, but 3rd party drivers can also be used."
              },
              "tls_hostname": {
                "type": "string",
                "description": ""
              },
              "driver_options": {
                "type": "object",
                "description": "Dictionary of network settings. Consult docker docs for valid options and values."
              },
              "connected": {
                "description": "List of container names or container IDs to connect to a network.",
                "$ref": "#/definitions/ansible_array"
              },
              "cert_path": {
                "type": "string",
                "description": ""
              },
              "tls": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the network to operate on."
              },
              "ssl_version": {
                "type": "string",
                "description": ""
              },
              "docker_api_version": {
                "type": "string",
                "description": ""
              },
              "incremental": {
                "description": "By default the connected list is canonical, meaning containers not on the list are removed from the network. Use C(appends) to leave existing containers connected.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rax_keypair": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create a keypair for use with Rackspace Cloud Servers",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "public_key": {
                "type": "string",
                "description": "Public Key string to upload. Can be a file path or string"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of keypair"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "aws_kms": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage role/user access to a KMS key. Not designed for encrypting/decrypting.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "clean_invalid_entries": {
                "description": "Default: True\n\nIf adding/removing a role and invalid grantees are found, remove them. These entries will cause an update to fail in all known cases.\nOnly cleans if changes are being made.",
                "$ref": "#/definitions/ansible_truth"
              },
              "role_arn": {
                "type": "string",
                "description": "ARN of role to allow/deny access. One of C(role_name) or C(role_arn) are required."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "grant_types": {
                "description": "List of grants to give to user/role. Likely \"role,role grant\" or \"role,role grant,admin\". Required when C(mode=grant).",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "key_alias": {
                "type": "string",
                "description": "Alias label to the key. One of C(key_alias) or C(key_arn) are required."
              },
              "role_name": {
                "type": "string",
                "description": "Role to allow/deny access. One of C(role_name) or C(role_arn) are required."
              },
              "mode": {
                "enum": [
                  "grant",
                  "deny"
                ],
                "type": "string",
                "description": "Default: grant\n\nGrant or deny access."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "key_arn": {
                "type": "string",
                "description": "Full ARN to the key. One of C(key_alias) or C(key_arn) are required."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "add_host": {
            "type": "object",
            "description": "Use variables to create new hosts and groups in inventory for use in later plays of the same playbook. Takes variables so you can define the new hosts more fully.",
            "properties": {
              "name": {
                "type": "string",
                "description": "The hostname/ip of the host to add to the inventory, can include a colon and a port number."
              },
              "groups": {
                "type": "string",
                "description": "The groups to add the hostname to, comma separated."
              }
            }
          },
          "dladm_vlan": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "vlan_id",
                        "vid"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or delete VLAN interfaces on Solaris/illumos systems.",
            "properties": {
              "temporary": {
                "description": "Specifies that the VLAN interface is temporary. Temporary VLANs do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "VLAN interface name."
              },
              "vid": {
                "type": "string",
                "description": "VLAN ID value for VLAN interface."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete Solaris/illumos VNIC."
              },
              "link": {
                "type": "string",
                "description": "VLAN underlying link name."
              },
              "vlan_id": {
                "type": "string",
                "description": "VLAN ID value for VLAN interface."
              }
            }
          },
          "win_timezone": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sets machine time to the specified timezone, the module will check if the provided timezone is supported on the machine.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": ""
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "elasticsearch_plugin": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manages Elasticsearch plugins.",
            "properties": {
              "plugin_bin": {
                "type": "string",
                "description": "Default: /usr/share/elasticsearch/bin/plugin\n\nLocation of the plugin binary"
              },
              "proxy_host": {
                "type": "string",
                "description": "Default: None\n\nProxy host to use during plugin installation"
              },
              "url": {
                "type": "string",
                "description": "Default: None\n\nSet exact URL to download the plugin from (Only works for ES 1.x)"
              },
              "proxy_port": {
                "type": "string",
                "description": "Default: None\n\nProxy port to use during plugin installation"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of a plugin."
              },
              "version": {
                "type": "string",
                "description": "Default: None\n\nVersion of the plugin to be installed. If plugin exists with previous version, it will NOT be updated"
              },
              "timeout": {
                "type": "string",
                "description": "Default: 1m\n\nTimeout setting: 30s, 1m, 1h..."
              },
              "plugin_dir": {
                "type": "string",
                "description": "Default: /usr/share/elasticsearch/plugins/\n\nYour configured plugin directory specified in Elasticsearch"
              },
              "name": {
                "type": "string",
                "description": "Name of the plugin to install. In ES 2.x, the name can be an url or file location"
              }
            }
          },
          "bigip_device_ntp": {
            "type": "object",
            "description": "Manage NTP servers on a BIG-IP",
            "properties": {
              "ntp_servers": {
                "type": "string",
                "description": "A list of NTP servers to set on the device. At least one of C(ntp_servers) or C(timezone) is required."
              },
              "timezone": {
                "type": "string",
                "description": "Default: UTC\n\nThe timezone to set for NTP lookups. At least one of C(ntp_servers) or C(timezone) is required."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nThe state of the NTP servers on the system. When C(present), guarantees that the NTP servers are set on the system. When C(absent), removes the specified NTP servers from the device configuration."
              }
            }
          },
          "ec2_eni": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create and optionally attach an Elastic Network Interface (ENI) to an instance. If an ENI ID or private_ip is       provided, the existing ENI (if any) will be modified. The 'attached' parameter controls the attachment status       of the network interface.",
            "properties": {
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "source_dest_check": {
                "description": "By default, interfaces perform source/destination checks. NAT instances however need this check to be disabled. You can only specify this flag when the interface is being modified, not on creation.",
                "$ref": "#/definitions/ansible_truth"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "secondary_private_ip_addresses": {
                "description": "A list of IP addresses to assign as secondary IP addresses to the network interface. This option is mutually exclusive of secondary_private_ip_address_count",
                "$ref": "#/definitions/ansible_array"
              },
              "subnet_id": {
                "type": "string",
                "description": "ID of subnet in which to create the ENI. Only required when state=present."
              },
              "device_index": {
                "description": "The index of the device for the network interface attachment on the instance.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete ENI"
              },
              "security_groups": {
                "description": "List of security groups associated with the interface. Only used when state=present. Since version 2.2, you       can specify security groups by ID or by name or a combination of both. Prior to 2.2, you can specify only by ID.",
                "$ref": "#/definitions/ansible_array"
              },
              "eni_id": {
                "type": "string",
                "description": "The ID of the ENI"
              },
              "delete_on_termination": {
                "description": "Delete the interface when the instance it is attached to is terminated. You can only specify this flag when the interface is being modified, not on creation.",
                "$ref": "#/definitions/ansible_truth"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Optional description of the ENI."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "attached": {
                "description": "Default: True\n\nSpecifies if network interface should be attached or detached from instance. If ommited, attachment status       won't change",
                "$ref": "#/definitions/ansible_truth"
              },
              "force_detach": {
                "description": "Force detachment of the interface. This applies either when explicitly detaching the interface by setting instance_id to None or when deleting an interface with state=absent.",
                "$ref": "#/definitions/ansible_truth"
              },
              "instance_id": {
                "type": "string",
                "description": "Instance ID that you wish to attach ENI to. Since version 2.2, use the 'attached' parameter to attach or       detach an ENI. Prior to 2.2, to detach an ENI from an instance, use 'None'."
              },
              "private_ip_address": {
                "type": "string",
                "description": "Private IP address."
              },
              "secondary_private_ip_address_count": {
                "description": "The number of secondary IP addresses to assign to the network interface. This option is mutually exclusive of secondary_private_ip_addresses",
                "$ref": "#/definitions/ansible_number"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cisco_spark": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "personal_token",
                        "token"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "personal_token"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "token"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "message_type",
                        "type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Send a message to a Cisco Spark Room or Individual with options to control the formatting.",
            "properties": {
              "personal_token": {
                "type": "string",
                "description": "Your personal access token required to validate the Spark API."
              },
              "message_type": {
                "enum": [
                  "text",
                  "markdown"
                ],
                "type": "string",
                "description": "Default: text\n\nSpecifies how you would like the message formatted."
              },
              "token": {
                "type": "string",
                "description": "Your personal access token required to validate the Spark API."
              },
              "recipient_id": {
                "type": "string",
                "description": "The unique identifier associated with the supplied C(recipient_type)."
              },
              "recipient_type": {
                "enum": [
                  "roomId",
                  "toPersonEmail",
                  "toPersonId"
                ],
                "type": "string",
                "description": "The request parameter you would like to send the message to.\nMessages can be sent to either a room or individual (by ID or E-Mail)."
              },
              "message": {
                "type": "string",
                "description": "The message you would like to send."
              },
              "type": {
                "enum": [
                  "text",
                  "markdown"
                ],
                "type": "string",
                "description": "Default: text\n\nSpecifies how you would like the message formatted."
              }
            }
          },
          "ipa_sudorule": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cn",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "cn"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify or delete sudo rule within IPA server using IPA API.",
            "properties": {
              "user": {
                "description": "List of users assigned to the rule.\nIf an empty list is passed all users will be removed from the rule.\nIf option is omitted users will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_port": {
                "description": "Default: 443\n\nPort of IPA server",
                "$ref": "#/definitions/ansible_number"
              },
              "cn": {
                "type": "string",
                "description": "Canonical name.\nCan not be changed as it is the unique identifier."
              },
              "usercategory": {
                "enum": [
                  "all"
                ],
                "type": "string",
                "description": "User category the rule applies to."
              },
              "description": {
                "type": "string",
                "description": ""
              },
              "cmd": {
                "description": "List of commands assigned to the rule.\nIf an empty list is passed all commands will be removed from the rule.\nIf option is omitted commands will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_prot": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nProtocol used by IPA server"
              },
              "host": {
                "description": "List of hosts assigned to the rule.\nIf an empty list is passed all hosts will be removed from the rule.\nIf option is omitted hosts will not be checked or changed.\nOption C(hostcategory) must be omitted to assign hosts.",
                "$ref": "#/definitions/ansible_array"
              },
              "hostgroup": {
                "description": "List of host groups assigned to the rule.\nIf an empty list is passed all host groups will be removed from the rule.\nIf option is omitted host groups will not be checked or changed.\nOption C(hostcategory) must be omitted to assign host groups.",
                "$ref": "#/definitions/ansible_array"
              },
              "sudoopt": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "hostcategory": {
                "enum": [
                  "all"
                ],
                "type": "string",
                "description": "Host category the rule applies to.\nIf 'all' is passed one must omit C(host) and C(hostgroup).\nOption C(host) and C(hostgroup) must be omitted to assign 'all'."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState to ensure"
              },
              "ipa_host": {
                "type": "string",
                "description": "Default: ipa.example.com\n\nIP or hostname of IPA server"
              },
              "ipa_user": {
                "type": "string",
                "description": "Default: admin\n\nAdministrative account used on IPA server"
              },
              "usergroup": {
                "description": "List of user groups assigned to the rule.\nIf an empty list is passed all user groups will be removed from the rule.\nIf option is omitted user groups will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_pass": {
                "type": "string",
                "description": "Password of administrative user"
              },
              "cmdcategory": {
                "enum": [
                  "all"
                ],
                "type": "string",
                "description": "Command category the rule applies to."
              },
              "validate_certs": {
                "description": "Default: True\n\nThis only applies if C(ipa_prot) is I(https).\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Canonical name.\nCan not be changed as it is the unique identifier."
              }
            }
          },
          "proxysql_mysql_users": {
            "required": [
              "username"
            ],
            "type": "object",
            "description": "The M(proxysql_mysql_users) module adds or removes mysql users using the proxysql admin interface.",
            "properties": {
              "default_hostgroup": {
                "description": "If there is no matching rule for the queries sent by this user, the traffic it generates is sent to the specified hostgroup. If omitted the proxysql database default for I(use_ssl) is 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "username": {
                "type": "string",
                "description": "Name of the user connecting to the mysqld or ProxySQL instance."
              },
              "frontend": {
                "description": "Default: True\n\nIf I(frontend) is set to C(True), this (username, password) pair is used for authenticating to the mysqld servers against any hostgroup.",
                "$ref": "#/definitions/ansible_truth"
              },
              "default_schema": {
                "type": "string",
                "description": "The schema to which the connection should change to by default."
              },
              "transaction_persistent": {
                "description": "If this is set for the user with which the MySQL client is connecting to ProxySQL (thus a \"frontend\" user), transactions started within a hostgroup will remain within that hostgroup regardless of any other rules. If omitted the proxysql database default for I(transaction_persistent) is C(False).",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_port": {
                "description": "Default: 6032\n\nThe port used to connect to ProxySQL admin interface.",
                "$ref": "#/definitions/ansible_number"
              },
              "login_user": {
                "type": "string",
                "description": "Default: None\n\nThe username used to authenticate to ProxySQL admin interface."
              },
              "login_host": {
                "type": "string",
                "description": "Default: 127.0.0.1\n\nThe host used to connect to ProxySQL admin interface."
              },
              "login_password": {
                "type": "string",
                "description": "Default: None\n\nThe password used to authenticate to ProxySQL admin interface."
              },
              "use_ssl": {
                "description": "If I(use_ssl) is set to C(True), connections by this user will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).",
                "$ref": "#/definitions/ansible_truth"
              },
              "backend": {
                "description": "Default: True\n\nIf I(backend) is set to C(True), this (username, password) pair is used for authenticating to the ProxySQL instance.",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhen C(present) - adds the user, when C(absent) - removes the user."
              },
              "fast_forward": {
                "description": "If I(fast_forward) is set to C(True), I(fast_forward) will bypass the query processing layer (rewriting, caching) and pass through the query directly as is to the backend server. If omitted the proxysql database default for I(fast_forward) is C(False).",
                "$ref": "#/definitions/ansible_truth"
              },
              "load_to_runtime": {
                "description": "Default: True\n\nDynamically load mysql host config to runtime memory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "save_to_disk": {
                "description": "Default: True\n\nSave mysql host config to sqlite db on disk to persist the configuration.",
                "$ref": "#/definitions/ansible_truth"
              },
              "active": {
                "description": "A user with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures. If omitted the proxysql database default for I(active) is C(True).",
                "$ref": "#/definitions/ansible_truth"
              },
              "config_file": {
                "type": "string",
                "description": "Specify a config file from which login_user and login_password are to be read."
              },
              "password": {
                "type": "string",
                "description": "Password of the user connecting to the mysqld or ProxySQL instance."
              },
              "max_connections": {
                "description": "The maximum number of connections ProxySQL will open to the backend for this user. If omitted the proxysql database default for I(max_connections) is 10000.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "ios_banner": {
            "required": [
              "banner"
            ],
            "type": "object",
            "description": "This will configure both login and motd banners on remote devices running Cisco IOS.  It allows playbooks to add or remote banner text from the active running configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "text": {
                "type": "string",
                "description": "The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string. Requires I(state=present)."
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecifies whether or not the configuration is present in the current devices active running configuration."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "banner": {
                "enum": [
                  "login",
                  "motd"
                ],
                "type": "string",
                "description": "Specifies which banner that should be configured on the remote device."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "ec2_lc": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Can create or delete AWS Autoscaling Configurations\nWorks with the ec2_asg module to manage Autoscaling Groups",
            "properties": {
              "security_token": {
                "type": "string",
                "description": ""
              },
              "ramdisk_id": {
                "type": "string",
                "description": "A RAM disk id for the instances."
              },
              "user_data": {
                "type": "string",
                "description": "opaque blob of data which is made available to the ec2 instance. Mutually exclusive with I(user_data_path)."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "classic_link_vpc_id": {
                "type": "string",
                "description": "Id of ClassicLink enabled VPC"
              },
              "security_groups": {
                "description": "A list of security groups to apply to the instances. For VPC instances, specify security group IDs. For EC2-Classic, specify either security group names or IDs.",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "spot_price": {
                "type": "number",
                "description": "The spot price you are bidding. Only applies for an autoscaling group with spot instances."
              },
              "user_data_path": {
                "type": "string",
                "description": "Path to the file that contains userdata for the ec2 instances. Mutually exclusive with I(user_data)."
              },
              "ebs_optimized": {
                "description": "Specifies whether the instance is optimized for EBS I/O (true) or not (false).",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "register or deregister the instance"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "instance_monitoring": {
                "description": "whether instances in group are launched with detailed monitoring.",
                "$ref": "#/definitions/ansible_truth"
              },
              "kernel_id": {
                "type": "string",
                "description": "Kernel id for the EC2 instance"
              },
              "key_name": {
                "type": "string",
                "description": "The SSH key name to be used for access to managed instances"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "image_id": {
                "type": "string",
                "description": "The AMI unique identifier to be used for the group"
              },
              "assign_public_ip": {
                "description": "Used for Auto Scaling groups that launch instances into an Amazon Virtual Private Cloud. Specifies whether to assign a public IP address to each instance launched in a Amazon VPC.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "classic_link_vpc_security_groups": {
                "description": "A list of security group id's with which to associate the ClassicLink VPC instances.",
                "$ref": "#/definitions/ansible_array"
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Unique name for configuration"
              },
              "instance_profile_name": {
                "type": "string",
                "description": "The name or the Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instances."
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "instance_type": {
                "type": "string",
                "description": "instance type to use for the instance"
              },
              "volumes": {
                "description": "a list of volume dicts, each containing device name and optionally ephemeral id or snapshot id. Size and type (and number of iops for io device type) must be specified for a new volume or a root volume, and may be passed for a snapshot volume. For any volume, a volume size less than 1 will be interpreted as a request not to create the volume.",
                "$ref": "#/definitions/ansible_array"
              },
              "associate_public_ip_address": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "logicmonitor_facts": {
            "required": [
              "target",
              "company",
              "user",
              "password"
            ],
            "type": "object",
            "description": "LogicMonitor is a hosted, full-stack, infrastructure monitoring platform.\nThis module collects facts about hosts abd host groups within your LogicMonitor account.",
            "properties": {
              "displayname": {
                "type": "string",
                "description": "Default: hostname -f\n\nThe display name of a host in your LogicMonitor account or the desired display name of a device to add into monitoring."
              },
              "target": {
                "enum": [
                  "host",
                  "hostgroup"
                ],
                "type": "string",
                "description": "The LogicMonitor object you wish to manage."
              },
              "company": {
                "type": "string",
                "description": "The LogicMonitor account company name. If you would log in to your account at \"superheroes.logicmonitor.com\" you would use \"superheroes\"."
              },
              "hostname": {
                "type": "string",
                "description": "Default: hostname -f\n\nThe hostname of a host in your LogicMonitor account, or the desired hostname of a device to add into monitoring.\nRequired for managing hosts (target=host)."
              },
              "user": {
                "type": "string",
                "description": "A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user."
              },
              "fullpath": {
                "type": "string",
                "description": "The fullpath of the hostgroup object you would like to manage.\nRecommend running on a single ansible host.\nRequired for management of LogicMonitor host groups (target=hostgroup)."
              },
              "password": {
                "type": "string",
                "description": "The password for the chosen LogicMonitor User.\nIf an md5 hash is used, the digest flag must be set to true."
              },
              "collector": {
                "type": "string",
                "description": "The fully qualified domain name of a collector in your LogicMonitor account.\nThis is optional for querying a LogicMonitor host when a displayname is specified.\nThis is required for querying a LogicMonitor host when a displayname is not specified."
              }
            }
          },
          "rax_cdb": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cdb_type",
                        "type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cdb_version",
                        "version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "creates / deletes or resize a Rackspace Cloud Databases instance and optionally waits for it to be 'running'. The name option needs to be unique since it's used to identify the instance.",
            "properties": {
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "flavor": {
                "description": "Default: 1\n\nflavor to use for the instance 1 to 6 (i.e. 512MB to 16GB)",
                "$ref": "#/definitions/ansible_number"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "cdb_type": {
                "type": "string",
                "description": "Default: MySQL\n\ntype of instance (i.e. MySQL, MariaDB, Percona)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "version": {
                "type": "string",
                "description": "version of database (MySQL supports 5.1 and 5.6, MariaDB supports 10, Percona supports 5.6)"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "type": {
                "type": "string",
                "description": "Default: MySQL\n\ntype of instance (i.e. MySQL, MariaDB, Percona)"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "cdb_version": {
                "type": "string",
                "description": "version of database (MySQL supports 5.1 and 5.6, MariaDB supports 10, Percona supports 5.6)"
              },
              "volume": {
                "description": "Default: 2\n\nVolume size of the database 1-150GB",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_timeout": {
                "description": "Default: 300\n\nhow long before wait gives up, in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: no\n\nwait for the instance to be in state 'running' before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the databases server instance"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "cnos_conditional_template": {
            "type": "object",
            "description": "This module allows you to work with the running configuration of a switch. It provides a way to execute a set of CNOS commands on a switch by evaluating the current running configuration and executing the commands only if the specific settings have not been already configured. The configuration source can be a set of commands or a template written in the Jinja2 templating language. This module functions the same as the cnos_template module. The only exception is that the following inventory variable can be specified [“condition = <flag string>”] When this inventory variable is specified as the variable of a task, the template is executed for the network element that matches the flag string. Usually, templates are used when commands are the same across a group of network devices. When there is a requirement to skip the execution of the template on one or more devices, it is recommended to use this module. This module uses SSH to manage network device configuration. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_conditional_template.html)",
            "properties": {
              "flag": {
                "type": "string",
                "description": "If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device."
              },
              "condition": {
                "type": "string",
                "description": "If you specify condition=<flag string> in the inventory file against any device, the template execution is done for that device in case it matches the flag setting for that task."
              },
              "commandfile": {
                "type": "string",
                "description": "This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. The command file must contain the Ansible keyword {{ inventory_hostname }} and the condition flag in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_LP21_commands.txt"
              }
            }
          },
          "netapp_e_facts": {
            "required": [
              "api_url",
              "api_password",
              "api_username",
              "ssid"
            ],
            "type": "object",
            "description": "Return various information about NetApp E-Series storage arrays (eg, configuration, disks)",
            "properties": {
              "ssid": {
                "type": "string",
                "description": "The ID of the array to manage. This value must be unique for each array."
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              }
            }
          },
          "os_project": {
            "type": "object",
            "description": "Manage OpenStack Projects. Projects can be created, updated or deleted using this module. A project will be updated if I(name) matches an existing project and I(state) is present. The value for I(name) cannot be updated without deleting and re-creating the project.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "enabled": {
                "type": "string",
                "description": "Default: True\n\nIs the project enabled"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nDescription for the project"
              },
              "name": {
                "type": "string",
                "description": "Name for the project"
              },
              "domain_id": {
                "type": "string",
                "description": "Default: None\n\nDomain id to create the project in if the cloud supports domains. The domain_id parameter requires shade >= 1.8.0"
              }
            }
          },
          "ec2_snapshot_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about ec2 volume snapshots in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "snapshot_ids": {
                "description": "If you specify one or more snapshot IDs, only snapshots that have the specified IDs are returned.",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "owner_ids": {
                "description": "If you specify one or more snapshot owners, only snapshots from the specified owners and for which you have       access are returned.",
                "$ref": "#/definitions/ansible_array"
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See       U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSnapshots.html) for possible filters. Filter       names and values are case sensitive."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "restorable_by_user_ids": {
                "description": "If you specify a list of restorable users, only snapshots with create snapshot permissions for those users are       returned.",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ce_command": {
            "type": "object",
            "description": "Sends an arbitrary command to an HUAWEI CloudEngine node and returns the results read from the device.  The ce_command module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.",
            "properties": {
              "retries": {
                "type": "string",
                "description": "Default: 10\n\nSpecifies the number of retries a command should by tried before it is considered failed.  The command is run on the target device every retry and evaluated against the I(wait_for) conditionals."
              },
              "commands": {
                "type": "string",
                "description": "The commands to send to the remote HUAWEI CloudEngine device over the configured provider.  The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded."
              },
              "wait_for": {
                "type": "string",
                "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples."
              },
              "match": {
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "interval": {
                "type": "string",
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command.  If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again."
              }
            }
          },
          "nxos_vpc": {
            "required": [
              "domain",
              "auto_recovery",
              "peer_gw"
            ],
            "type": "object",
            "description": "Manages global VPC configuration",
            "properties": {
              "domain": {
                "type": "string",
                "description": "VPC domain"
              },
              "pkl_vrf": {
                "type": "string",
                "description": "Default: management\n\nVRF used for peer keepalive link"
              },
              "delay_restore": {
                "type": "string",
                "description": "manages delay restore command and config value in seconds"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "peer_gw": {
                "description": "Enables/Disables peer gateway",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Manages desired state of the resource"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "pkl_src": {
                "type": "string",
                "description": "Source IP address used for peer keepalive link"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "auto_recovery": {
                "description": "Enables/Disables auto recovery",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "system_priority": {
                "type": "string",
                "description": "System priority device.  Remember they must match between peers."
              },
              "role_priority": {
                "type": "string",
                "description": "Role priority for device. Remember lower is better."
              },
              "pkl_dest": {
                "type": "string",
                "description": "Destination (remote) IP address used for peer keepalive link"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "bigip_device_sshd": {
            "type": "object",
            "description": "Manage the SSHD settings of a BIG-IP",
            "properties": {
              "log_level": {
                "type": "string",
                "description": "Specifies the minimum SSHD message level to include in the system log."
              },
              "banner_text": {
                "type": "string",
                "description": "Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH."
              },
              "allow": {
                "type": "string",
                "description": "Specifies, if you have enabled SSH access, the IP address or address range for other systems that can use SSH to communicate with this system."
              },
              "inactivity_timeout": {
                "type": "string",
                "description": "Specifies the number of seconds before inactivity causes an SSH session to log out."
              },
              "login": {
                "type": "string",
                "description": "Specifies, when checked C(enabled), that the system accepts SSH communications."
              },
              "banner": {
                "type": "string",
                "description": "Whether to enable the banner or not."
              },
              "port": {
                "type": "string",
                "description": "Port that you want the SSH daemon to run on."
              }
            }
          },
          "fireball": {
            "type": "object",
            "description": "Modern SSH clients support ControlPersist which is just as fast as fireball was.  Please enable that in ansible.cfg as a replacement for fireball.\nRemoved in ansible 2.0.",
            "properties": {
              "key": {
                "type": "string",
                "description": ""
              },
              "keyserver": {
                "type": "string",
                "description": ""
              },
              "url": {
                "type": "string",
                "description": ""
              },
              "data": {
                "type": "string",
                "description": ""
              },
              "keyring": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "file": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "id": {
                "type": "string",
                "description": ""
              }
            }
          },
          "bzr": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "parent"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "parent"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage I(bzr) branches to deploy files or software.",
            "properties": {
              "executable": {
                "type": "string",
                "description": "Path to bzr executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
              },
              "force": {
                "description": "Default: no\n\nIf C(yes), any modified files in the working tree will be discarded.  Before 1.9 the default value was \"yes\".",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "SSH or HTTP protocol address of the parent branch."
              },
              "parent": {
                "type": "string",
                "description": "SSH or HTTP protocol address of the parent branch."
              },
              "dest": {
                "type": "string",
                "description": "Absolute path of where the branch should be cloned to."
              },
              "version": {
                "type": "string",
                "description": "Default: head\n\nWhat version of the branch to clone.  This can be the bzr revno or revid."
              }
            }
          },
          "ovirt_external_providers": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tenant_name",
                        "tenant"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "authentication_url",
                        "auth_url"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "type",
                        "provider"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "type"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "provider"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage external providers in oVirt",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username to be used for login to external provider.\nApplicable for all types."
              },
              "read_only": {
                "description": "Specify if the network should be read only.\nApplicable if C(type) is I(network).",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "Description of the external provider."
              },
              "url": {
                "type": "string",
                "description": "URL where external provider is hosted.\nApplicable for those types: I(os_image), I(os_volume), I(network) and I(foreman)."
              },
              "tenant_name": {
                "type": "string",
                "description": "Name of the tenant.\nApplicable for those types: I(os_image), I(os_volume) and I(network)."
              },
              "provider": {
                "enum": [
                  "os_image",
                  "network",
                  "os_volume",
                  "foreman"
                ],
                "type": "string",
                "description": "Type of the external provider."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the external be present or absent"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Name of the the external provider to manage."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "authentication_url": {
                "type": "string",
                "description": "Keystone authentication URL of the openstack provider.\nApplicable for those types: I(os_image), I(os_volume) and I(network)."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "data_center": {
                "type": "string",
                "description": "Name of the data center where provider should be attached.\nApplicable for those type: I(os_volume)."
              },
              "auth_url": {
                "type": "string",
                "description": "Keystone authentication URL of the openstack provider.\nApplicable for those types: I(os_image), I(os_volume) and I(network)."
              },
              "password": {
                "type": "string",
                "description": "Password of the user specified in C(username) parameter.\nApplicable for all types."
              },
              "type": {
                "enum": [
                  "os_image",
                  "network",
                  "os_volume",
                  "foreman"
                ],
                "type": "string",
                "description": "Type of the external provider."
              },
              "network_type": {
                "enum": [
                  "external",
                  "neutron"
                ],
                "type": "string",
                "description": "Default: ['external']\n\nType of the external network provider either external (for example OVN) or neutron.\nApplicable if C(type) is I(network)."
              },
              "tenant": {
                "type": "string",
                "description": "Name of the tenant.\nApplicable for those types: I(os_image), I(os_volume) and I(network)."
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cs_user": {
            "required": [
              "username"
            ],
            "type": "object",
            "description": "Create, update, disable, lock, enable and remove users.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username of the user."
              },
              "domain": {
                "type": "string",
                "description": "Default: ROOT\n\nDomain the user is related to."
              },
              "last_name": {
                "type": "string",
                "description": "Last name of the user.\nRequired on C(state=present)."
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "account": {
                "type": "string",
                "description": "Account the user will be created under.\nRequired on C(state=present)."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled",
                  "locked",
                  "unlocked"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the user.\nC(unlocked) is an alias for C(enabled)."
              },
              "first_name": {
                "type": "string",
                "description": "First name of the user.\nRequired on C(state=present)."
              },
              "timezone": {
                "type": "string",
                "description": "Timezone of the user."
              },
              "password": {
                "type": "string",
                "description": "Password of the user to be created.\nRequired on C(state=present).\nOnly considered on creation and will not be updated if user exists."
              },
              "email": {
                "type": "string",
                "description": "Email of the user.\nRequired on C(state=present)."
              }
            }
          },
          "cs_loadbalancer_rule": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tags",
                        "tag"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ip_address",
                        "public_ip"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "ip_address"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "public_ip"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, update and remove load balancer rules.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain the rule is related to."
              },
              "protocol": {
                "type": "string",
                "description": "The protocol to be used on the load balancer"
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "public_ip": {
                "type": "string",
                "description": "Public IP address from where the network traffic will be load balanced from."
              },
              "private_port": {
                "description": "The private port of the private ip address/virtual machine where the network traffic will be load balanced to.\nRequired when using C(state=present).\nCan not be changed once the rule exists due API limitation.",
                "$ref": "#/definitions/ansible_number"
              },
              "tag": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "poll_async": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the rule shoud be created.\nIf not set, default zone is used."
              },
              "public_port": {
                "description": "The public port from where the network traffic will be load balanced from.\nRequired when using C(state=present).\nCan not be changed once the rule exists due API limitation.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the rule."
              },
              "algorithm": {
                "enum": [
                  "source",
                  "roundrobin",
                  "leastconn"
                ],
                "type": "string",
                "description": "Default: source\n\nLoad balancer algorithm\nRequired when using C(state=present)."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "The description of the load balancer rule."
              },
              "tags": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "cidr": {
                "type": "string",
                "description": "CIDR (full notation) to be used for firewall rule if required."
              },
              "ip_address": {
                "type": "string",
                "description": "Public IP address from where the network traffic will be load balanced from."
              },
              "account": {
                "type": "string",
                "description": "Account the rule is related to."
              },
              "name": {
                "type": "string",
                "description": "The name of the load balancer rule."
              },
              "open_firewall": {
                "description": "Whether the firewall rule for public port should be created, while creating the new rule.\nUse M(cs_firewall) for managing firewall rules.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the load balancer IP address is related to."
              }
            }
          },
          "docker_image": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cacert_path",
                        "tls_ca_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "docker_host",
                        "docker_url"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "build_path"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cert_path",
                        "tls_client_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "key_path",
                        "tls_client_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_version",
                        "docker_api_version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Build, load or pull an image, making the image available for creating containers. Also supports tagging an image into a repository and archiving an image to a .tar file.",
            "properties": {
              "force": {
                "description": "Use with state I(absent) to un-tag and remove all images matching the specified name. Use with state C(present) to build, load or pull an image when the image already exists.",
                "$ref": "#/definitions/ansible_truth"
              },
              "docker_host": {
                "type": "string",
                "description": ""
              },
              "tls_verify": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "tls_client_key": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": "Use with state 'present' to build an image. Will be the path to a directory containing the context and Dockerfile for building an image."
              },
              "filter_logger": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_tls": {
                "enum": [
                  "no",
                  "encrypt",
                  "verify"
                ],
                "type": "string",
                "description": "DEPRECATED. Whether to use tls to connect to the docker server. Set to C(no) when TLS will not be used. Set to C(encrypt) to use TLS. And set to C(verify) to use TLS and verify that the server's certificate is valid for the server. NOTE: If you specify this option, it will set the value of the tls or tls_verify parameters."
              },
              "nocache": {
                "type": "string",
                "description": "Do not use cache when building an image."
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "docker_url": {
                "type": "string",
                "description": ""
              },
              "load_path": {
                "type": "string",
                "description": "Use with state C(present) to load an image from a .tar file."
              },
              "tls_ca_cert": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "absent",
                  "present",
                  "build"
                ],
                "type": "string",
                "description": "Default: present\n\nMake assertions about the state of an image.\nWhen C(absent) an image will be removed. Use the force option to un-tag and remove all images matching the provided name.\nWhen C(present) check if an image exists using the provided name and tag. If the image is not found or the force option is used, the image will either be pulled, built or loaded. By default the image will be pulled from Docker Hub. To build the image, provide a path value set to a directory containing a context and Dockerfile. To load an image, specify load_path to provide a path to an archive file. To tag an image to a repository, provide a repository path. If the name contains a repository path, it will be pushed.\nNOTE: C(build) is DEPRECATED and will be removed in release 2.3. Specifying C(build) will behave the same as C(present)."
              },
              "tls_client_cert": {
                "type": "string",
                "description": ""
              },
              "key_path": {
                "type": "string",
                "description": ""
              },
              "rm": {
                "description": "Default: True\n\nRemove intermediate containers after build.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dockerfile": {
                "type": "string",
                "description": "Default: Dockerfile\n\nUse with state C(present) to provide an alternate name for the Dockerfile to use when building an image."
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "archive_path": {
                "type": "string",
                "description": "Use with state C(present) to archive an image to a .tar file."
              },
              "build_path": {
                "type": "string",
                "description": "Use with state 'present' to build an image. Will be the path to a directory containing the context and Dockerfile for building an image."
              },
              "cacert_path": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "repository": {
                "type": "string",
                "description": "Full path to a repository. Use with state C(present) to tag the image into the repository. Expects format I(repository:tag). If no tag is provided, will use the value of the C(tag) parameter or I(latest)."
              },
              "tls_hostname": {
                "type": "string",
                "description": ""
              },
              "cert_path": {
                "type": "string",
                "description": ""
              },
              "tls": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "pull": {
                "description": "Default: True\n\nWhen building an image downloads any updates to the FROM image in Dockerfile.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Image name. Name format will be one of: name, repository/name, registry_server:port/name. When pushing or pulling an image the name can optionally include the tag by appending ':tag_name'."
              },
              "container_limits": {
                "type": "object",
                "description": "A dictionary of limits applied to each container created by the build process."
              },
              "http_timeout": {
                "description": "Timeout for HTTP requests during the image build operation. Provide a positive integer value for the number of seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "ssl_version": {
                "type": "string",
                "description": ""
              },
              "docker_api_version": {
                "type": "string",
                "description": ""
              },
              "tag": {
                "type": "string",
                "description": "Default: latest\n\nUsed to select an image when pulling. Will be added to the image when pushing, tagging or building. Defaults to I(latest).\nIf C(name) parameter format is I(name:tag), then tag value from C(name) will take precedence."
              },
              "buildargs": {
                "type": "object",
                "description": "Provide a dictionary of C(key:value) build arguments that map to Dockerfile ARG directive.\nDocker expects the value to be a string. For convenience any non-string values will be converted to strings.\nRequires Docker API >= 1.21 and docker-py >= 1.7.0."
              },
              "push": {
                "description": "Push the image to the registry. Specify the registry as part of the I(name) or I(repository) parameter.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vmware_dvswitch": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or remove a distributed vSwitch",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "datacenter_name": {
                "type": "string",
                "description": "The name of the datacenter that will contain the dvSwitch"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "discovery_proto": {
                "enum": [
                  "cdp",
                  "lldp"
                ],
                "type": "string",
                "description": "Link discovery protocol between Cisco and Link Layer discovery"
              },
              "mtu": {
                "description": "The switch maximum transmission unit",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or remove dvSwitch"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "discovery_operation": {
                "enum": [
                  "both",
                  "none",
                  "advertise",
                  "listen"
                ],
                "type": "string",
                "description": "Select the discovery operation"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "switch_name": {
                "type": "string",
                "description": "The name of the switch to create or remove"
              },
              "uplink_quantity": {
                "description": "Quantity of uplink per ESXi host added to the switch",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "cs_firewall": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "start_port",
                        "port"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates and removes firewall rules.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain the firewall rule is related to."
              },
              "protocol": {
                "enum": [
                  "tcp",
                  "udp",
                  "icmp",
                  "all"
                ],
                "type": "string",
                "description": "Default: tcp\n\nProtocol of the firewall rule.\nC(all) is only available if C(type=egress)"
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "end_port": {
                "description": "End port for this rule. Considered if C(protocol=tcp) or C(protocol=udp). If not specified, equal C(start_port).",
                "$ref": "#/definitions/ansible_number"
              },
              "icmp_type": {
                "description": "Type of the icmp message being sent. Considered if C(protocol=icmp).",
                "$ref": "#/definitions/ansible_number"
              },
              "port": {
                "description": "Start port for this rule. Considered if C(protocol=tcp) or C(protocol=udp).",
                "$ref": "#/definitions/ansible_number"
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "network": {
                "type": "string",
                "description": "Network the egress rule is related to.\nRequired if C(type=egress)."
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the virtual machine is in.\nIf not set, default zone is used."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the firewall rule."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "type": {
                "enum": [
                  "ingress",
                  "egress"
                ],
                "type": "string",
                "description": "Default: ingress\n\nType of the firewall rule."
              },
              "icmp_code": {
                "description": "Error code for this icmp message. Considered if C(protocol=icmp).",
                "$ref": "#/definitions/ansible_number"
              },
              "start_port": {
                "description": "Start port for this rule. Considered if C(protocol=tcp) or C(protocol=udp).",
                "$ref": "#/definitions/ansible_number"
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "cidr": {
                "type": "string",
                "description": "Default: 0.0.0.0/0\n\nCIDR (full notation) to be used for firewall rule."
              },
              "ip_address": {
                "type": "string",
                "description": "Public IP address the ingress rule is assigned to.\nRequired if C(type=ingress)."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "account": {
                "type": "string",
                "description": "Account the firewall rule is related to."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the firewall rule is related to."
              }
            }
          },
          "ec2_vpc_subnet": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tags",
                        "resource_tags"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage subnets in AWS virtual private clouds",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "az": {
                "type": "string",
                "description": "The availability zone for the subnet. Only required when state=present."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "A dict of tags to apply to the subnet. Any tags currently applied to the subnet and not present here will be removed."
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "vpc_id": {
                "type": "string",
                "description": "VPC ID of the VPC in which to create the subnet."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or remove the subnet"
              },
              "resource_tags": {
                "type": "object",
                "description": "A dict of tags to apply to the subnet. Any tags currently applied to the subnet and not present here will be removed."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cidr": {
                "type": "string",
                "description": "The CIDR block for the subnet. E.g. 192.0.2.0/24. Only required when state=present."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "os_server_actions": {
            "type": "object",
            "description": "Perform server actions on an existing compute instance from OpenStack. This module does not return any data other than changed true/false. When I(action) is 'rebuild', then I(image) parameter is required.",
            "properties": {
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "image": {
                "type": "string",
                "description": "Image the server should be rebuilt with"
              },
              "server": {
                "type": "string",
                "description": "Name or ID of the instance"
              },
              "timeout": {
                "type": "string",
                "description": "Default: 180\n\nThe amount of time the module should wait for the instance to perform the requested action."
              },
              "action": {
                "type": "string",
                "description": "Default: present\n\nPerform the given action. The lock and unlock actions always return changed as the servers API does not provide lock status."
              },
              "wait": {
                "type": "string",
                "description": "Default: yes\n\nIf the module should wait for the instance action to be performed."
              }
            }
          },
          "rax_clb_nodes": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Adds, modifies and removes nodes from a Rackspace Cloud Load Balancer",
            "properties": {
              "weight": {
                "description": "Weight of node",
                "$ref": "#/definitions/ansible_number"
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "Port number of the load balanced service on the node",
                "$ref": "#/definitions/ansible_number"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "virtualenv": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the node"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "load_balancer_id": {
                "description": "Load balancer id",
                "$ref": "#/definitions/ansible_number"
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "type": {
                "enum": [
                  "primary",
                  "secondary"
                ],
                "type": "string",
                "description": "Type of node"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "wait_timeout": {
                "description": "Default: 30\n\nHow long to wait before giving up and returning an error",
                "$ref": "#/definitions/ansible_number"
              },
              "address": {
                "type": "string",
                "description": "IP address or domain name of the node"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "condition": {
                "enum": [
                  "enabled",
                  "disabled",
                  "draining"
                ],
                "type": "string",
                "description": "Condition for the node, which determines its role within the load balancer"
              },
              "wait": {
                "description": "Default: no\n\nWait for the load balancer to become active before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "node_id": {
                "description": "Node id",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "bigip_gtm_facts": {
            "type": "object",
            "description": "Collect facts from F5 BIG-IP GTM devices.",
            "properties": {
              "filter": {
                "type": "string",
                "description": "Default: None\n\nPerform regex filter of response. Filtering is done on the name of the resource. Valid filters are anything that can be provided to Python's C(re) module."
              },
              "include": {
                "type": "string",
                "description": "Fact category to collect"
              }
            }
          },
          "ovirt_tags_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt tags.",
            "properties": {
              "host": {
                "type": "string",
                "description": "Name of the host, which tags should be listed."
              },
              "name": {
                "type": "string",
                "description": "Name of the tag which should be listed."
              },
              "vm": {
                "type": "string",
                "description": "Name of the VM, which tags should be listed."
              }
            }
          },
          "mysql_db": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "db"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "db"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove MySQL databases from a remote host.",
            "properties": {
              "ssl_key": {
                "type": "string",
                "description": ""
              },
              "login_port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "config_file": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "name of the database to add or remove\nname=all May only be provided if I(state) is C(dump) or C(import).\nif name=all Works like --all-databases option for mysqldump (Added in 2.0)"
              },
              "encoding": {
                "type": "string",
                "description": "Encoding mode to use, examples include C(utf8) or C(latin1_swedish_ci)"
              },
              "login_user": {
                "type": "string",
                "description": ""
              },
              "login_host": {
                "type": "string",
                "description": ""
              },
              "db": {
                "type": "string",
                "description": "name of the database to add or remove\nname=all May only be provided if I(state) is C(dump) or C(import).\nif name=all Works like --all-databases option for mysqldump (Added in 2.0)"
              },
              "ssl_ca": {
                "type": "string",
                "description": ""
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "dump",
                  "import"
                ],
                "type": "string",
                "description": "Default: present\n\nThe database state"
              },
              "ssl_cert": {
                "type": "string",
                "description": ""
              },
              "login_password": {
                "type": "string",
                "description": ""
              },
              "collation": {
                "type": "string",
                "description": "Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL."
              },
              "quick": {
                "description": "Default: True\n\nOption used for dumping large tables",
                "$ref": "#/definitions/ansible_truth"
              },
              "single_transaction": {
                "description": "Execute the dump in a single transaction",
                "$ref": "#/definitions/ansible_truth"
              },
              "connect_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "target": {
                "type": "string",
                "description": "Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) as well as bzip2 (C(.bz2)), gzip (C(.gz)) and xz (Added in 2.0) compressed files are supported."
              }
            }
          },
          "gce_snapshot": {
            "required": [
              "instance_name",
              "snapshot_name"
            ],
            "type": "object",
            "description": "Manages snapshots for GCE instances. This module manages snapshots for the storage volumes of a GCE compute instance. If there are multiple volumes, each snapshot will be prepended with the disk name",
            "properties": {
              "service_account_email": {
                "type": "string",
                "description": "GCP service account email for the project where the instance resides"
              },
              "disks": {
                "description": "Default: all\n\nA list of disks to create snapshots for. If none is provided, all of the volumes will be snapshotted",
                "$ref": "#/definitions/ansible_array"
              },
              "instance_name": {
                "type": "string",
                "description": "The GCE instance to snapshot"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether a snapshot should be C(present) or C(absent)"
              },
              "snapshot_name": {
                "type": "string",
                "description": "The name of the snapshot to manage"
              },
              "credentials_file": {
                "type": "string",
                "description": "The path to the credentials file associated with the service account"
              },
              "project_id": {
                "type": "string",
                "description": "The GCP project ID to use"
              }
            }
          },
          "apt_key": {
            "type": "object",
            "description": "Add or remove an I(apt) key, optionally downloading it",
            "properties": {
              "key": {
                "type": "string",
                "description": ""
              },
              "keyserver": {
                "type": "string",
                "description": "Default: none\n\nkeyserver to retrieve key from."
              },
              "url": {
                "type": "string",
                "description": "Default: none\n\nurl to retrieve key from."
              },
              "data": {
                "type": "string",
                "description": "Default: none\n\nkeyfile contents to add to the keyring"
              },
              "keyring": {
                "type": "string",
                "description": "Default: none\n\npath to specific keyring file in /etc/apt/trusted.gpg.d"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nused to specify if key is being added or revoked"
              },
              "file": {
                "type": "string",
                "description": "Default: none\n\npath to a keyfile on the remote server to add to the keyring"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "id": {
                "type": "string",
                "description": "Default: none\n\nidentifier of key. Including this allows check mode to correctly report the changed state.\nIf specifying a subkey's id be aware that apt-key does not understand how to remove keys via a subkey id.  Specify the primary key's id instead."
              }
            }
          },
          "hponcfg": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "src",
                        "path"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "src"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This modules configures the HP iLO interface using hponcfg.",
            "properties": {
              "src": {
                "type": "string",
                "description": "The XML file as accepted by hponcfg"
              },
              "minfw": {
                "type": "string",
                "description": "The minimum firmware level needed"
              },
              "path": {
                "type": "string",
                "description": "The XML file as accepted by hponcfg"
              }
            }
          },
          "ovirt_snapshots_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt virtual machine snapshots.",
            "properties": {
              "snapshot_id": {
                "type": "string",
                "description": "Id of the snaphost we want to retrieve facts about."
              },
              "description": {
                "type": "string",
                "description": "Description of the snapshot, can be used as glob expression."
              },
              "vm": {
                "type": "string",
                "description": "Name of the VM with snapshot."
              }
            }
          },
          "ipinfoio_facts": {
            "type": "object",
            "description": "Gather IP geolocation facts of a host's IP address using ipinfo.io API",
            "properties": {
              "http_agent": {
                "type": "string",
                "description": "Default: ansible-ipinfoio-module/0.0.1\n\nSet http user agent"
              },
              "timeout": {
                "description": "Default: 10\n\nHTTP connection timeout in seconds",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "runit": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Controls runit services on remote hosts using the sv utility.",
            "properties": {
              "dist": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the service to manage."
              },
              "enabled": {
                "description": "Wheater the service is enabled or not, if disabled it also implies stopped.",
                "$ref": "#/definitions/ansible_truth"
              },
              "service_dir": {
                "type": "string",
                "description": "Default: /var/service\n\ndirectory runsv watches for services"
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "restarted",
                  "killed",
                  "reloaded",
                  "once"
                ],
                "type": "string",
                "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary.  C(restarted) will always bounce the service (sv restart) and C(killed) will always bounce the service (sv force-stop). C(reloaded) will send a HUP (sv reload). C(once) will run a normally downed sv once (sv once), not really an idempotent operation."
              },
              "service_src": {
                "type": "string",
                "description": "Default: /etc/sv\n\ndirectory where services are defined, the source of symlinks to service_dir."
              }
            }
          },
          "cnos_showrun": {
            "type": "object",
            "description": "This module allows you to view the switch running configuration. It executes the display running-config CLI command on a switch and returns a file containing the current running configuration of the target network device. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_showrun.html)",
            "properties": {}
          },
          "taiga_issue": {
            "required": [
              "project",
              "issue_type",
              "subject"
            ],
            "type": "object",
            "description": "Creates/deletes an issue in a Taiga Project Management Platform (U(https://taiga.io)).\nAn issue is identified by the combination of project, issue subject and issue type.\nThis module implements the creation or deletion of issues (not the update).",
            "properties": {
              "status": {
                "type": "string",
                "description": "Default: New\n\nThe issue status. Must exist previously."
              },
              "project": {
                "type": "string",
                "description": "Name of the project containing the issue. Must exist previously."
              },
              "description": {
                "type": "string",
                "description": "The issue description."
              },
              "tags": {
                "description": "A lists of tags to be assigned to the issue.",
                "$ref": "#/definitions/ansible_array"
              },
              "priority": {
                "type": "string",
                "description": "Default: Normal\n\nThe issue priority. Must exist previously."
              },
              "taiga_host": {
                "type": "string",
                "description": "Default: https://api.taiga.io\n\nThe hostname of the Taiga instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the issue should be present or not."
              },
              "attachment": {
                "type": "string",
                "description": "Default: None\n\nPath to a file to be attached to the issue."
              },
              "issue_type": {
                "type": "string",
                "description": "The issue type. Must exist previously."
              },
              "subject": {
                "type": "string",
                "description": "The issue subject."
              },
              "attachment_description": {
                "type": "string",
                "description": "A string describing the file to be attached to the issue."
              },
              "severity": {
                "type": "string",
                "description": "Default: Normal\n\nThe issue severity. Must exist previously."
              }
            }
          },
          "bigip_monitor_http": {
            "type": "object",
            "description": "Manages F5 BIG-IP LTM monitors via iControl SOAP API",
            "properties": {
              "interval": {
                "type": "string",
                "description": "Default: none\n\nThe interval specifying how frequently the monitor instance of this template will run. By default, this interval is used for up and down states. The default API setting is 5."
              },
              "name": {
                "type": "string",
                "description": "Monitor name"
              },
              "parent": {
                "type": "string",
                "description": "Default: http\n\nThe parent template of this monitor template"
              },
              "receive": {
                "type": "string",
                "description": "Default: none\n\nThe receive string for the monitor call"
              },
              "ip": {
                "type": "string",
                "description": "Default: none\n\nIP address part of the ipport definition. The default API setting is \"0.0.0.0\"."
              },
              "partition": {
                "type": "string",
                "description": "Default: Common\n\nPartition for the monitor"
              },
              "send": {
                "type": "string",
                "description": "Default: none\n\nThe send string for the monitor call"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nMonitor state"
              },
              "time_until_up": {
                "type": "string",
                "description": "Default: none\n\nSpecifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. The default API setting is 0."
              },
              "timeout": {
                "type": "string",
                "description": "Default: none\n\nThe number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. The default API setting is 16."
              },
              "parent_partition": {
                "type": "string",
                "description": "Default: Common\n\nPartition for the parent monitor"
              },
              "port": {
                "type": "string",
                "description": "Default: none\n\nPort address part of the ip/port definition. The default API setting is 0."
              },
              "receive_disable": {
                "type": "string",
                "description": "Default: none\n\nThe receive disable string for the monitor call"
              }
            }
          },
          "rax_cbs": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manipulate Rackspace Cloud Block Storage Volumes",
            "properties": {
              "size": {
                "description": "Default: 100\n\nSize of the volume to create in Gigabytes",
                "$ref": "#/definitions/ansible_number"
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "image": {
                "type": "string",
                "description": "image to use for bootable volumes. Can be an C(id), C(human_id) or C(name). This option requires C(pyrax>=1.9.3)"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "meta": {
                "type": "object",
                "description": "A hash of metadata to associate with the volume"
              },
              "snapshot_id": {
                "type": "string",
                "description": "The id of the snapshot to create the volume from"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Description to give the volume being created"
              },
              "wait_timeout": {
                "description": "Default: 300\n\nhow long before wait gives up, in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: no\n\nwait for the volume to be in state 'available' before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name to give the volume being created"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "volume_type": {
                "enum": [
                  "SATA",
                  "SSD"
                ],
                "type": "string",
                "description": "Default: SATA\n\nType of the volume being created"
              }
            }
          },
          "java_cert": {
            "required": [
              "keystore_pass"
            ],
            "type": "object",
            "description": "This is a wrapper module around keytool. Which can be used to import/remove certificates from a given java keystore.",
            "properties": {
              "keystore_create": {
                "description": "Create keystore if it doesn't exist",
                "$ref": "#/definitions/ansible_truth"
              },
              "cert_alias": {
                "type": "string",
                "description": "Imported certificate alias."
              },
              "executable": {
                "type": "string",
                "description": "Default: keytool\n\nPath to keytool binary if not used we search in PATH for it."
              },
              "cert_port": {
                "description": "Default: 443\n\nPort to connect to URL. This will be used to create server URL:PORT",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDefines action which can be either certificate import or removal."
              },
              "keystore_pass": {
                "type": "string",
                "description": "Keystore password."
              },
              "cert_url": {
                "type": "string",
                "description": "Basic URL to fetch SSL certificate from. One of cert_url or cert_path is required to load certificate."
              },
              "cert_path": {
                "type": "string",
                "description": "Local path to load certificate from. One of cert_url or cert_path is required to load certificate."
              },
              "keystore_path": {
                "type": "string",
                "description": "Path to keystore."
              }
            }
          },
          "nxos_bgp_neighbor_af": {
            "required": [
              "safi",
              "asn",
              "afi",
              "neighbor"
            ],
            "type": "object",
            "description": "Manages BGP address-family's neighbors configurations on NX-OS switches.",
            "properties": {
              "default_originate": {
                "description": "Activate the default-originate feature.",
                "$ref": "#/definitions/ansible_truth"
              },
              "suppress_inactive": {
                "description": "suppress-inactive feature.",
                "$ref": "#/definitions/ansible_truth"
              },
              "weight": {
                "type": "string",
                "description": "Weight value. Valid values are an integer value or 'default'."
              },
              "soo": {
                "type": "string",
                "description": "Site-of-origin. Valid values are a string defining a VPN extcommunity or 'default'."
              },
              "next_hop_third_party": {
                "description": "Activate the next-hop-third-party feature.",
                "$ref": "#/definitions/ansible_truth"
              },
              "route_reflector_client": {
                "description": "Router reflector client.",
                "$ref": "#/definitions/ansible_truth"
              },
              "unsuppress_map": {
                "type": "string",
                "description": "unsuppress-map. Valid values are a string defining a route-map name or 'default'."
              },
              "prefix_list_out": {
                "type": "string",
                "description": "Valid values are a string defining a prefix-list name, or 'default'."
              },
              "as_override": {
                "description": "Activate the as-override feature.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "filter_list_out": {
                "type": "string",
                "description": "Valid values are a string defining a filter-list name, or 'default'."
              },
              "additional_paths_send": {
                "enum": [
                  "enable",
                  "disable",
                  "inherit"
                ],
                "type": "string",
                "description": "Valid values are enable for basic command enablement; disable for disabling the command at the neighbor af level (it adds the disable keyword to the basic command); and inherit to remove the command at this level (the command value is inherited from a higher BGP layer)."
              },
              "allowas_in": {
                "description": "Activate allowas-in property",
                "$ref": "#/definitions/ansible_truth"
              },
              "max_prefix_warning": {
                "description": "Optional warning-only keyword. Requires max_prefix_limit.",
                "$ref": "#/definitions/ansible_truth"
              },
              "asn": {
                "type": "string",
                "description": "BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "advertise_map_non_exist": {
                "description": "Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the non-exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_non_exist_map']. This command is mutually exclusive with the advertise_map_exist property.",
                "$ref": "#/definitions/ansible_array"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "default_originate_route_map": {
                "type": "string",
                "description": "Optional route-map for the default_originate property. Can be used independently or in conjunction with C(default_originate). Valid values are a string defining a route-map name, or 'default'."
              },
              "neighbor": {
                "type": "string",
                "description": "Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length."
              },
              "safi": {
                "type": "string",
                "description": "Sub Address Family Identifier."
              },
              "filter_list_in": {
                "type": "string",
                "description": "Valid values are a string defining a filter-list name, or 'default'."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "soft_reconfiguration_in": {
                "enum": [
                  "enable",
                  "always",
                  "inherit"
                ],
                "type": "string",
                "description": "Valid values are 'enable' for basic command enablement; 'always' to add the always keyword to the basic command; and 'inherit' to remove the command at this level (the command value is inherited from a higher BGP layer)."
              },
              "vrf": {
                "type": "string",
                "description": "Default: default\n\nName of the VRF. The name 'default' is a valid VRF representing the global bgp."
              },
              "next_hop_self": {
                "description": "Activate the next-hop-self feature.",
                "$ref": "#/definitions/ansible_truth"
              },
              "max_prefix_limit": {
                "type": "string",
                "description": "maximum-prefix limit value. Valid values are an integer value or 'default'."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "max_prefix_threshold": {
                "type": "string",
                "description": "Optional threshold percentage at which to generate a warning. Valid values are an integer value. Requires max_prefix_limit."
              },
              "route_map_in": {
                "type": "string",
                "description": "Valid values are a string defining a route-map name, or 'default'."
              },
              "afi": {
                "type": "string",
                "description": "Address Family Identifier."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "max_prefix_interval": {
                "type": "string",
                "description": "Optional restart interval. Valid values are an integer. Requires max_prefix_limit."
              },
              "route_map_out": {
                "type": "string",
                "description": "Valid values are a string defining a route-map name, or 'default'."
              },
              "send_community": {
                "enum": [
                  "none",
                  "both",
                  "extended",
                  "standard",
                  "default"
                ],
                "type": "string",
                "description": "send-community attribute."
              },
              "prefix_list_in": {
                "type": "string",
                "description": "Valid values are a string defining a prefix-list name, or 'default'."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "additional_paths_receive": {
                "enum": [
                  "enable",
                  "disable",
                  "inherit"
                ],
                "type": "string",
                "description": "Valid values are enable for basic command enablement; disable for disabling the command at the neighbor af level (it adds the disable keyword to the basic command); and inherit to remove the command at this level (the command value is inherited from a higher BGP layer)."
              },
              "advertise_map_exist": {
                "description": "Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_exist_map']. This command is mutually exclusive with the advertise_map_non_exist property.",
                "$ref": "#/definitions/ansible_array"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "allowas_in_max": {
                "type": "string",
                "description": "Optional max-occurrences value for allowas_in. Valid values are an integer value or 'default'. Can be used independently or in conjunction with allowas_in."
              }
            }
          },
          "zfs": {
            "required": [
              "state",
              "name"
            ],
            "type": "object",
            "description": "Manages ZFS file systems, volumes, clones and snapshots.",
            "properties": {
              "createparent": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether to create (C(present)), or remove (C(absent)) a file system, snapshot or volume. All parents/children will be created/destroyed as needed to reach the desired state."
              },
              "name": {
                "type": "string",
                "description": "File system, snapshot or volume name e.g. C(rpool/myfs)"
              }
            }
          },
          "blockinfile": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "dest",
                        "name",
                        "destfile"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "destfile"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "block",
                        "content"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module will insert/update/remove a block of multi-line text surrounded by customizable marker lines.",
            "properties": {
              "name": {
                "type": "string",
                "description": "The file to modify."
              },
              "insertbefore": {
                "type": "string",
                "description": "Default: None\n\nIf specified, the block will be inserted before the last match of specified regular expression. A special value is available; C(BOF) for inserting the block at the beginning of the file.  If specified regular expresion has no matches, the block will be inserted at the end of the file."
              },
              "dest": {
                "type": "string",
                "description": "The file to modify."
              },
              "create": {
                "description": "Default: no\n\nCreate a new file if it doesn't exist.",
                "$ref": "#/definitions/ansible_truth"
              },
              "destfile": {
                "type": "string",
                "description": "The file to modify."
              },
              "content": {
                "type": "string",
                "description": "The text to insert inside the marker lines. If it's missing or an empty string, the block will be removed as if C(state) were specified to C(absent)."
              },
              "marker": {
                "type": "string",
                "description": "Default: # {mark} ANSIBLE MANAGED BLOCK\n\nThe marker line template. \"{mark}\" will be replaced with \"BEGIN\" or \"END\"."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the block should be there or not."
              },
              "insertafter": {
                "type": "string",
                "description": "Default: EOF\n\nIf specified, the block will be inserted after the last match of specified regular expression. A special value is available; C(EOF) for inserting the block at the end of the file.  If specified regular expresion has no matches, C(EOF) will be used instead."
              },
              "validate": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              },
              "block": {
                "type": "string",
                "description": "The text to insert inside the marker lines. If it's missing or an empty string, the block will be removed as if C(state) were specified to C(absent)."
              }
            }
          },
          "rocketchat": {
            "required": [
              "domain",
              "token"
            ],
            "type": "object",
            "description": "The M(rocketchat) module sends notifications to Rocket Chat via the Incoming WebHook integration",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: Ansible\n\nThis is the sender of the message."
              },
              "domain": {
                "type": "string",
                "description": "The domain for your environment without protocol. (i.e. C(subdomain.domain.com or chat.domain.tld))"
              },
              "protocol": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nSpecify the protocol used to send notification messages before the webhook url. (i.e. http or https)"
              },
              "attachments": {
                "description": "Default: None\n\nDefine a list of attachments.",
                "$ref": "#/definitions/ansible_array"
              },
              "color": {
                "enum": [
                  "normal",
                  "good",
                  "warning",
                  "danger"
                ],
                "type": "string",
                "description": "Default: normal\n\nAllow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message"
              },
              "icon_url": {
                "type": "string",
                "description": "Default: https://www.ansible.com/favicon.ico\n\nURL for the message sender's icon."
              },
              "token": {
                "type": "string",
                "description": "Rocket Chat Incoming Webhook integration token.  This provides authentication to Rocket Chat's Incoming webhook for posting messages."
              },
              "icon_emoji": {
                "type": "string",
                "description": "Default: None\n\nEmoji for the message sender. The representation for the available emojis can be got from Rocket Chat. (for example :thumbsup:) (if I(icon_emoji) is set, I(icon_url) will not be used)"
              },
              "link_names": {
                "description": "Default: 1\n\nAutomatically create links for channels and usernames in I(msg).",
                "$ref": "#/definitions/ansible_number"
              },
              "msg": {
                "type": "string",
                "description": "Default: None\n\nMessage to be sent."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "channel": {
                "type": "string",
                "description": "Default: None\n\nChannel to send the message to. If absent, the message goes to the channel selected for the I(token) specifed during the creation of webhook."
              }
            }
          },
          "bigip_gtm_wide_ip": {
            "type": "object",
            "description": "Manages F5 BIG-IP GTM wide ip",
            "properties": {
              "lb_method": {
                "type": "string",
                "description": "LB method of wide ip"
              },
              "wide_ip": {
                "type": "string",
                "description": "Wide IP name"
              }
            }
          },
          "junos_template": {
            "required": [
              "src"
            ],
            "type": "object",
            "description": "This module will load a candidate configuration from a template file onto a remote device running Junos.  The module will return the differences in configuration if the diff option is specified on the Ansible command line",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Default: configured by junos_template\n\nThe C(comment) argument specifies a text string to be used when committing the configuration.  If the C(confirm) argument is set to False, this argument is silently ignored."
              },
              "src": {
                "type": "string",
                "description": "The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will search for the source file in role or playbook root folder in templates directory."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "confirm": {
                "description": "The C(confirm) argument will configure a time out value for the commit to be confirmed before it is automatically rolled back.  If the C(confirm) argument is set to False, this argument is silently ignored.  If the value for this argument is set to 0, the commit is confirmed immediately.",
                "$ref": "#/definitions/ansible_number"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "action": {
                "enum": [
                  "merge",
                  "overwrite",
                  "replace"
                ],
                "type": "string",
                "description": "Default: merge\n\nThe C(action) argument specifies how the module will apply changes."
              },
              "config_format": {
                "enum": [
                  "text",
                  "xml",
                  "set"
                ],
                "type": "string",
                "description": "The C(format) argument specifies the format of the configuration template specified in C(src).  If the format argument is not specified, the module will attempt to infer the configuration format based of file extension.  Files that end in I(xml) will set the format to xml.  Files that end in I(set) will set the format to set and all other files will default the format to text."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "When this argument is configured true, the module will backup the configuration from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              }
            }
          },
          "pause": {
            "type": "object",
            "description": "Pauses playbook execution for a set amount of time, or until a prompt is acknowledged. All parameters are optional. The default behavior is to pause with a prompt.\nYou can use C(ctrl+c) if you wish to advance a pause earlier than it is set to expire or if you need to abort a playbook run entirely. To continue early: press C(ctrl+c) and then C(c). To abort a playbook: press C(ctrl+c) and then C(a).\nThe pause module integrates into async/parallelized playbooks without any special considerations (see also: Rolling Updates). When using pauses with the C(serial) playbook parameter (as in rolling updates) you are only prompted once for the current group of hosts.",
            "properties": {
              "active_connection_states": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "connect_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "delay": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "present",
                  "absent",
                  "drained"
                ],
                "type": "string",
                "description": ""
              },
              "sleep": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "exclude_hosts": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "search_regex": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "nxos_template": {
            "type": "object",
            "description": "Manages network device configurations over SSH or NXAPI.  This module allows implementers to work with the device running-config.  It provides a way to push a set of commands onto a network device by evaluating the current running-config and only pushing configuration commands that are not already configured.  The config source can be a set of commands or a template.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will search for the source file in role or playbook root folder in templates directory."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "description": "The module, by default, will collect the current device running-config to use as a base for comparisons to the commands in I(src).  Setting this value to true will cause the module to issue the command C(show running-config all) to include all device settings.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "lambda_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "function_name",
                        "function",
                        "name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gathers various details related to Lambda functions, including aliases, versions and event source mappings. Use module M(lambda) to manage the lambda function itself, M(lambda_alias) to manage function aliases and M(lambda_event) to manage lambda event source mappings.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "query": {
                "enum": [
                  "aliases",
                  "all",
                  "config",
                  "mappings",
                  "policy",
                  "versions"
                ],
                "type": "string",
                "description": "Default: all\n\nSpecifies the resource type for which to gather facts.  Leave blank to retrieve all facts."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the lambda function for which facts are requested."
              },
              "function_name": {
                "type": "string",
                "description": "The name of the lambda function for which facts are requested."
              },
              "event_source_arn": {
                "type": "string",
                "description": "For query type 'mappings', this is the Amazon Resource Name (ARN) of the Amazon Kinesis or DynamoDB stream."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "function": {
                "type": "string",
                "description": "The name of the lambda function for which facts are requested."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "influxdb_retention_policy": {
            "required": [
              "database_name",
              "hostname",
              "policy_name",
              "replication",
              "duration"
            ],
            "type": "object",
            "description": "Manage InfluxDB retention policies",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: root\n\nUsername that will be used to authenticate against InfluxDB server"
              },
              "default": {
                "description": "Sets the retention policy as default retention policy",
                "$ref": "#/definitions/ansible_truth"
              },
              "database_name": {
                "type": "string",
                "description": "Name of the database where retention policy will be created"
              },
              "hostname": {
                "type": "string",
                "description": "The hostname or IP address on which InfluxDB server is listening"
              },
              "policy_name": {
                "type": "string",
                "description": "Name of the retention policy"
              },
              "replication": {
                "description": "Determines how many independent copies of each point are stored in the cluster",
                "$ref": "#/definitions/ansible_number"
              },
              "duration": {
                "type": "string",
                "description": "Determines how long InfluxDB should keep the data"
              },
              "password": {
                "type": "string",
                "description": "Default: root\n\nPassword that will be used to authenticate against InfluxDB server"
              },
              "port": {
                "description": "Default: 8086\n\nThe port on which InfluxDB server is listening",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "rhevm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ifaces",
                        "nics",
                        "interfaces"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Allows you to create/remove/update or powermanage virtual machines on a RHEV/oVirt platform.",
            "properties": {
              "vmmem": {
                "type": "string",
                "description": "Default: 1\n\nThe amount of memory you want your VM to use (in GB)."
              },
              "cd_drive": {
                "type": "string",
                "description": "The CD you wish to have mounted on the VM when I(state = 'CD')."
              },
              "image": {
                "type": "string",
                "description": "The template to use for the VM."
              },
              "vmhost": {
                "type": "string",
                "description": "The host you wish your VM to run on."
              },
              "insecure_api": {
                "description": "A boolean switch to make a secure or insecure connection to the server.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cluster": {
                "type": "string",
                "description": "The rhev/ovirt cluster in which you want you VM to start."
              },
              "port": {
                "type": "string",
                "description": "Default: 443\n\nThe port on which the API is reacheable."
              },
              "vm_ha": {
                "type": "string",
                "description": "Default: True\n\nTo make your VM High Available."
              },
              "nics": {
                "type": "string",
                "description": "This option uses complex arguments and is a list of interfaces with the options name and vlan."
              },
              "ifaces": {
                "type": "string",
                "description": "This option uses complex arguments and is a list of interfaces with the options name and vlan."
              },
              "state": {
                "enum": [
                  "ping",
                  "present",
                  "absent",
                  "up",
                  "down",
                  "restarted",
                  "cd",
                  "info"
                ],
                "type": "string",
                "description": "Default: present\n\nThis serves to create/remove/update or powermanage your VM."
              },
              "type": {
                "enum": [
                  "server",
                  "desktop",
                  "host"
                ],
                "type": "string",
                "description": "Default: server\n\nTo define if the VM is a server or desktop."
              },
              "cpu_share": {
                "type": "string",
                "description": "Default: 0\n\nThis parameter is used to configure the cpu share."
              },
              "boot_order": {
                "type": "string",
                "description": "Default: ['network', 'hd']\n\nThis option uses complex arguments and is a list of items that specify the bootorder."
              },
              "interfaces": {
                "type": "string",
                "description": "This option uses complex arguments and is a list of interfaces with the options name and vlan."
              },
              "user": {
                "type": "string",
                "description": "Default: admin@internal\n\nThe user to authenticate with."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "datacenter": {
                "type": "string",
                "description": "Default: Default\n\nThe rhev/ovirt datacenter in which you want you VM to start."
              },
              "name": {
                "type": "string",
                "description": "The name of the VM."
              },
              "disks": {
                "type": "string",
                "description": "This option uses complex arguments and is a list of disks with the options name, size and domain."
              },
              "server": {
                "type": "string",
                "description": "Default: 127.0.0.1\n\nThe name/ip of your RHEV-m/oVirt instance."
              },
              "osver": {
                "type": "string",
                "description": "Default: rhel_6x64\n\nThe operationsystem option in RHEV/oVirt."
              },
              "mempol": {
                "type": "string",
                "description": "Default: 1\n\nThe minimum amount of memory you wish to reserve for this system."
              },
              "timeout": {
                "type": "string",
                "description": "The timeout you wish to define for power actions.\nWhen I(state = 'up')\nWhen I(state = 'down')\nWhen I(state = 'restarted')"
              },
              "del_prot": {
                "description": "Default: True\n\nThis option sets the delete protection checkbox.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vmcpu": {
                "type": "string",
                "description": "Default: 2\n\nThe number of CPUs you want in your VM."
              }
            }
          },
          "layman": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "list_url",
                        "url"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Uses Layman to manage an additional repositories for the Portage package manager on Gentoo Linux. Please note that Layman must be installed on a managed node prior using this module.",
            "properties": {
              "url": {
                "type": "string",
                "description": "An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under C(${overlay_defs})/${name}.xml), where C(overlay_defs) is readed from the Layman's configuration."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "updated"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to install (C(present)), sync (C(updated)), or uninstall (C(absent)) the overlay."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be set to C(no) when no other option exists.  Prior to 1.9.3 the code defaulted to C(no).",
                "$ref": "#/definitions/ansible_truth"
              },
              "list_url": {
                "type": "string",
                "description": "An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under C(${overlay_defs})/${name}.xml), where C(overlay_defs) is readed from the Layman's configuration."
              },
              "name": {
                "type": "string",
                "description": "The overlay id to install, synchronize, or uninstall. Use 'ALL' to sync all of the installed overlays (can be used only when C(state=updated))."
              }
            }
          },
          "tower_team": {
            "required": [
              "organization",
              "name"
            ],
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower teams. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "description": {
                "type": "string",
                "description": ""
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "organization": {
                "type": "string",
                "description": "Organization the team should be made a member of."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name to use for the team."
              }
            }
          },
          "win_iis_webapppool": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, Removes and configures a IIS Web Application Pool",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "State of the binding"
              },
              "names": {
                "type": "string",
                "description": "Names of application pool"
              },
              "name": {
                "type": "string",
                "description": "Names of application pool"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ipa_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "gidnumber",
                        "gid"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cn",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "cn"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify and delete group within IPA server",
            "properties": {
              "ipa_port": {
                "description": "Default: 443\n\nPort of IPA server",
                "$ref": "#/definitions/ansible_number"
              },
              "group": {
                "description": "List of group names assigned to this group.\nIf an empty list is passed all groups will be removed from this group.\nIf option is omitted assigned groups will not be checked or changed.\nGroups that are already assigned but not passed will be removed.",
                "$ref": "#/definitions/ansible_array"
              },
              "description": {
                "type": "string",
                "description": ""
              },
              "external": {
                "description": "Allow adding external non-IPA members from trusted domains.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cn": {
                "type": "string",
                "description": "Canonical name.\nCan not be changed as it is the unique identifier."
              },
              "ipa_prot": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nProtocol used by IPA server"
              },
              "gidnumber": {
                "type": "string",
                "description": "GID (use this option to set it manually)."
              },
              "name": {
                "type": "string",
                "description": "Canonical name.\nCan not be changed as it is the unique identifier."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState to ensure"
              },
              "gid": {
                "type": "string",
                "description": "GID (use this option to set it manually)."
              },
              "user": {
                "description": "List of user names assigned to this group.\nIf an empty list is passed all users will be removed from this group.\nIf option is omitted assigned users will not be checked or changed.\nUsers that are already assigned but not passed will be removed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_user": {
                "type": "string",
                "description": "Default: admin\n\nAdministrative account used on IPA server"
              },
              "ipa_pass": {
                "type": "string",
                "description": "Password of administrative user"
              },
              "validate_certs": {
                "description": "Default: True\n\nThis only applies if C(ipa_prot) is I(https).\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "nonposix": {
                "description": "Create as a non-POSIX group.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ipa_host": {
                "type": "string",
                "description": "Default: ipa.example.com\n\nIP or hostname of IPA server"
              }
            }
          },
          "nxos_evpn_vni": {
            "required": [
              "vni"
            ],
            "type": "object",
            "description": "Manages Cisco Ethernet Virtual Private Network (EVPN) VXLAN Network Identifier (VNI) configurations of a Nexus device.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "route_target_export": {
                "description": "Sets the route-target 'import' extended communities.",
                "$ref": "#/definitions/ansible_array"
              },
              "route_target_both": {
                "description": "Enables/Disables route-target settings for both import and export target communities using a single property.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "vni": {
                "type": "string",
                "description": "The EVPN VXLAN Network Identifier."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "route_distinguisher": {
                "type": "string",
                "description": "The VPN Route Distinguisher (RD). The RD is combined with the IPv4 or IPv6 prefix learned by the PE router to create a globally unique address."
              },
              "route_target_import": {
                "description": "Sets the route-target 'import' extended communities.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "ipmi_boot": {
            "required": [
              "bootdev",
              "name",
              "user",
              "password"
            ],
            "type": "object",
            "description": "Use this module to manage order of boot devices",
            "properties": {
              "bootdev": {
                "enum": [
                  "network",
                  "hd",
                  "safe",
                  "optical",
                  "setup",
                  "default"
                ],
                "type": "string",
                "description": "Set boot device to use on next reboot"
              },
              "name": {
                "type": "string",
                "description": "Hostname or ip address of the BMC."
              },
              "persistent": {
                "description": "If set, ask that system firmware uses this device beyond next boot. Be aware many systems do not honor this.",
                "$ref": "#/definitions/ansible_truth"
              },
              "uefiboot": {
                "description": "If set, request UEFI boot explicitly. Strictly speaking, the spec suggests that if not set, the system should BIOS boot and offers no \"don't care\" option. In practice, this flag not being set does not preclude UEFI boot on any system I've encountered.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to ensure that boot devices is desired."
              },
              "user": {
                "type": "string",
                "description": "Username to use to connect to the BMC."
              },
              "password": {
                "type": "string",
                "description": "Password to connect to the BMC."
              },
              "port": {
                "description": "Default: 623\n\nRemote RMCP port.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "ec2_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module fetches data from the metadata servers in ec2 (aws) as per http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html. The module must be called from within the EC2 instance itself.",
            "properties": {
              "url_password": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_proxy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "url": {
                "type": "string",
                "description": ""
              },
              "force_basic_auth": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "url_username": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "client_key": {
                "type": "string",
                "description": ""
              }
            }
          },
          "iptables": {
            "type": "object",
            "description": "Iptables is used to set up, maintain, and inspect the tables of IP packet filter rules in the Linux kernel. This module does not handle the saving and/or loading of rules, but rather only manipulates the current rules that are present in memory. This is the same as the behaviour of the \"iptables\" and \"ip6tables\" command which this module uses internally.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "This specifies a comment that will be added to the rule"
              },
              "set_counters": {
                "type": "string",
                "description": "This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations)."
              },
              "chain": {
                "type": "string",
                "description": "Chain to operate on. This option can either be the name of a user defined chain or any of the builtin chains: 'INPUT', 'FORWARD', 'OUTPUT', 'PREROUTING', 'POSTROUTING', 'SECMARK', 'CONNSECMARK'."
              },
              "ip_version": {
                "enum": [
                  "ipv4",
                  "ipv6"
                ],
                "type": "string",
                "description": "Default: ipv4\n\nWhich version of the IP protocol this rule should apply to."
              },
              "out_interface": {
                "type": "string",
                "description": "Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the \"!\" argument is used before the interface name, the sense is inverted. If the interface name ends in a \"+\", then any interface which begins with this name will match. If this option is omitted, any interface name will match."
              },
              "limit_burst": {
                "type": "string",
                "description": "Specifies the maximum burst before the above limit kicks in."
              },
              "ctstate": {
                "description": "ctstate is a list of the connection states to match in the conntrack module. Possible states are: 'INVALID', 'NEW', 'ESTABLISHED', 'RELATED', 'UNTRACKED', 'SNAT', 'DNAT'",
                "$ref": "#/definitions/ansible_array"
              },
              "jump": {
                "type": "string",
                "description": "This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).  If this option is omitted in a rule (and the goto paramater is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented."
              },
              "to_ports": {
                "type": "string",
                "description": "This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp."
              },
              "flush": {
                "description": "Flushes the specified table and chain of all rules. If no chain is specified then the entire table is purged. Ignores all other parameters.",
                "$ref": "#/definitions/ansible_truth"
              },
              "table": {
                "enum": [
                  "filter",
                  "nat",
                  "mangle",
                  "raw",
                  "security"
                ],
                "type": "string",
                "description": "Default: filter\n\nThis option specifies the packet matching table which the command should operate on. If the kernel is configured with automatic module loading, an attempt will be made to load the appropriate module for that table if it is not already there."
              },
              "icmp_type": {
                "type": "string",
                "description": "This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'"
              },
              "to_destination": {
                "type": "string",
                "description": "This specifies a destination address to use with DNAT: without this, the destination address is never altered."
              },
              "uid_owner": {
                "type": "string",
                "description": "Specifies the UID or username to use in match by owner rule."
              },
              "set_dscp_mark_class": {
                "type": "string",
                "description": "This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark. Mutually exclusive with C(set_dscp_mark)."
              },
              "destination": {
                "type": "string",
                "description": "Destination specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A \"!\" argument before the address specification inverts the sense of the address."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the rule should be absent or present."
              },
              "protocol": {
                "type": "string",
                "description": "The protocol of the rule or of the packet to check. The specified protocol can be one of tcp, udp, udplite, icmp, esp, ah, sctp or the special keyword \"all\", or it can be a numeric value, representing one of these protocols or a different one. A protocol name from /etc/protocols is also allowed. A \"!\" argument before the protocol inverts the test.  The number zero is equivalent to all. \"all\" will match with all protocols and is taken as default when this option is omitted."
              },
              "source": {
                "type": "string",
                "description": "Source specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A \"!\" argument before the address specification inverts the sense of the address."
              },
              "set_dscp_mark": {
                "type": "string",
                "description": "This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value. Mutually exclusive with C(set_dscp_mark_class)."
              },
              "policy": {
                "enum": [
                  "ACCEPT",
                  "DROP",
                  "QUEUE",
                  "RETURN"
                ],
                "type": "string",
                "description": "Set the policy for the chain to the given target. Valid targets are ACCEPT, DROP, QUEUE, RETURN. Only built in chains can have policies. This parameter requires the chain parameter. Ignores all other parameters."
              },
              "match": {
                "description": "Specifies a match to use, that is, an extension module that tests for a specific property. The set of matches make up the condition under which a target is invoked. Matches are evaluated first to last if specified as an array and work in short-circuit fashion, i.e. if one extension yields false, evaluation will stop.",
                "$ref": "#/definitions/ansible_array"
              },
              "goto": {
                "type": "string",
                "description": "This specifies that the processing should continue in a user specified chain. Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump."
              },
              "fragment": {
                "type": "string",
                "description": "This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the \"!\" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets."
              },
              "to_source": {
                "type": "string",
                "description": "This specifies a source address to use with SNAT: without this, the source address is never altered."
              },
              "action": {
                "enum": [
                  "append",
                  "insert"
                ],
                "type": "string",
                "description": "Default: append\n\nWhether the rule should be appended at the bottom or inserted at the top. If the rule already exists the chain won't be modified."
              },
              "destination_port": {
                "type": "string",
                "description": "Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped."
              },
              "reject_with": {
                "type": "string",
                "description": "Specifies the error packet type to return while rejecting."
              },
              "limit": {
                "type": "string",
                "description": "Specifies the maximum average number of matches to allow per second. The number can specify units explicitly, using `/second', `/minute', `/hour' or `/day', or parts of them (so `5/second' is the same as `5/s')."
              },
              "source_port": {
                "type": "string",
                "description": "Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped."
              },
              "in_interface": {
                "type": "string",
                "description": "Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the \"!\" argument is used before the interface name, the sense is inverted. If the interface name ends in a \"+\", then any interface which begins with this name will match. If this option is omitted, any interface name will match."
              }
            }
          },
          "win_package": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Installs or uninstalls a package.\nOptionally uses a product_id to check if the package needs installing. You can find product ids for installed programs in the windows registry either in C(HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall) or for 32 bit programs C(HKLM:Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall)",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nInstall or Uninstall"
              },
              "names": {
                "type": "string",
                "description": "Name of the package, if name isn't specified the path will be used for log messages"
              },
              "name": {
                "type": "string",
                "description": "Name of the package, if name isn't specified the path will be used for log messages"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rax_scaling_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manipulate Rackspace Cloud Autoscale Groups",
            "properties": {
              "files": {
                "type": "object",
                "description": "Files to insert into the instance. Hash of C(remotepath: localpath)"
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "image": {
                "type": "string",
                "description": "image to use for the instance. Can be an C(id), C(human_id) or C(name)"
              },
              "user_data": {
                "type": "string",
                "description": "Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string"
              },
              "min_entities": {
                "description": "The minimum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.",
                "$ref": "#/definitions/ansible_number"
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cooldown": {
                "description": "The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).",
                "$ref": "#/definitions/ansible_number"
              },
              "flavor": {
                "type": "string",
                "description": "flavor to use for the instance"
              },
              "networks": {
                "description": "Default: ['public', 'private']\n\nThe network to attach to the instances. If specified, you must include ALL networks including the public and private interfaces. Can be C(id) or C(label).",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "max_entities": {
                "description": "The maximum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.",
                "$ref": "#/definitions/ansible_number"
              },
              "server_name": {
                "type": "string",
                "description": "The base name for servers created by Autoscale"
              },
              "loadbalancers": {
                "description": "List of load balancer C(id) and C(port) hashes",
                "$ref": "#/definitions/ansible_array"
              },
              "disk_config": {
                "enum": [
                  "auto",
                  "manual"
                ],
                "type": "string",
                "description": "Default: auto\n\nDisk partitioning strategy"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "config_drive": {
                "description": "Attach read-only configuration drive to server as label config-2",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "key_name": {
                "type": "string",
                "description": "key pair to use on the instance"
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 300\n\nhow long before wait gives up, in seconds"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: no\n\nwait for the scaling group to finish provisioning the minimum amount of servers",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name to give the scaling group"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "meta": {
                "type": "object",
                "description": "A hash of metadata to associate with the instance"
              }
            }
          },
          "redshift_subnet_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "group_subnets",
                        "subnets"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "group_name",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "group_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "group_description",
                        "description"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, modifies, and deletes Redshift cluster subnet groups.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "group_description": {
                "type": "string",
                "description": "Database subnet group description."
              },
              "name": {
                "type": "string",
                "description": "Cluster subnet group name."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "subnets": {
                "description": "List of subnet IDs that make up the cluster subnet group.",
                "$ref": "#/definitions/ansible_array"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "group_name": {
                "type": "string",
                "description": "Cluster subnet group name."
              },
              "description": {
                "type": "string",
                "description": "Database subnet group description."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecifies whether the subnet should be present or absent."
              },
              "group_subnets": {
                "description": "List of subnet IDs that make up the cluster subnet group.",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "rax_mon_entity": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or delete a Rackspace Cloud Monitoring entity, which represents a device to monitor. Entities associate checks and alarms with a target system and provide a convenient, centralized place to store IP addresses. Rackspace monitoring module flow | *rax_mon_entity* -> rax_mon_check -> rax_mon_notification -> rax_mon_notification_plan -> rax_mon_alarm",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "label": {
                "type": "string",
                "description": "Defines a name for this entity. Must be a non-empty string between 1 and 255 characters long."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Ensure that an entity with this C(name) exists or does not exist."
              },
              "agent_id": {
                "type": "string",
                "description": "Rackspace monitoring agent on the target device to which this entity is bound. Necessary to collect C(agent.) rax_mon_checks against this entity."
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "named_ip_addresses": {
                "type": "object",
                "description": "Hash of IP addresses that may be referenced by name by rax_mon_checks added to this entity. Must be a dictionary of with keys that are names between 1 and 64 characters long, and values that are valid IPv4 or IPv6 addresses."
              },
              "metadata": {
                "type": "object",
                "description": "Hash of arbitrary C(name), C(value) pairs that are passed to associated rax_mon_alarms. Names and values must all be between 1 and 255 characters long."
              }
            }
          },
          "cnos_template": {
            "type": "object",
            "description": "This module allows you to work with the running configuration of a switch. It provides a way to execute a set of CNOS commands on a switch by evaluating the current running configuration and executing the commands only if the specific settings have not been already configured. The configuration source can be a set of commands or a template written in the Jinja2 templating language. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_template.html)",
            "properties": {
              "commandfile": {
                "type": "string",
                "description": "This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. Note The command file must contain the Ansible keyword {{ inventory_hostname }} in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_commands.txt"
              }
            }
          },
          "ec2_eni_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about ec2 ENI interfaces in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ldap_attr": {
            "required": [
              "dn",
              "name",
              "values"
            ],
            "type": "object",
            "description": "Add or remove LDAP attribute values.",
            "properties": {
              "dn": {
                "type": "string",
                "description": "The DN of the entry to modify."
              },
              "name": {
                "type": "string",
                "description": "The name of the attribute to modify."
              },
              "server_uri": {
                "type": "string",
                "description": "Default: ldapi:///\n\nA URI to the LDAP server. The default value lets the underlying LDAP client library look for a UNIX domain socket in its default location."
              },
              "start_tls": {
                "description": "Default: no\n\nIf true, we'll use the START_TLS LDAP extension.",
                "$ref": "#/definitions/ansible_truth"
              },
              "bind_dn": {
                "type": "string",
                "description": "A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "exact"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state of the attribute values. If C(present), all given values will be added if they're missing. If C(absent), all given values will be removed if present. If C(exact), the set of values will be forced to exactly those provided and no others. If I(state=exact) and I(value) is empty, all values for this attribute will be removed."
              },
              "params": {
                "type": "object",
                "description": ""
              },
              "bind_pw": {
                "type": "string",
                "description": "The password to use with I(bind_dn)."
              },
              "values": {
                "type": "string",
                "description": "The value(s) to add or remove. This can be a string or a list of strings. The complex argument format is required in order to pass a list of strings (see examples)."
              }
            }
          },
          "webfaction_db": {
            "required": [
              "name",
              "login_password",
              "type",
              "login_name"
            ],
            "type": "object",
            "description": "Add or remove a database on a Webfaction host. Further documentation at http://github.com/quentinsf/ansible-webfaction.",
            "properties": {
              "name": {
                "type": "string",
                "description": "The name of the database"
              },
              "machine": {
                "type": "string",
                "description": "The machine name to use (optional for accounts with only one machine)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the database should exist"
              },
              "login_password": {
                "type": "string",
                "description": "The webfaction password to use"
              },
              "password": {
                "type": "string",
                "description": "Default: None\n\nThe password for the new database user."
              },
              "type": {
                "type": "string",
                "description": "The type of database to create."
              },
              "login_name": {
                "type": "string",
                "description": "The webfaction account to use"
              }
            }
          },
          "pulp_repo": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "repo"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "repo"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove Pulp repos from a remote host.",
            "properties": {
              "feed": {
                "type": "string",
                "description": "Upstream feed URL to receive updates from."
              },
              "repo_type": {
                "type": "string",
                "description": "Default: rpm\n\nRepo plugin type to use (i.e. C(rpm), C(docker))."
              },
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "proxy_port": {
                "type": "string",
                "description": "Proxy port setting for the pulp repository importer."
              },
              "client_key": {
                "type": "string",
                "description": ""
              },
              "importer_ssl_client_key": {
                "type": "string",
                "description": "Private key to the certificate specified in I(importer_ssl_client_cert), assuming it is not included in the certificate file itself. This can be the file content or the path to the file."
              },
              "publish_distributor": {
                "type": "string",
                "description": "Distributor to use when state is C(publish). The default is to publish all distributors."
              },
              "relative_url": {
                "type": "string",
                "description": "Relative URL for the local repository."
              },
              "proxy_host": {
                "type": "string",
                "description": "Proxy url setting for the pulp repository importer. This is in the format scheme://host."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "sync",
                  "publish"
                ],
                "type": "string",
                "description": "Default: present\n\nThe repo state. A state of C(sync) will queue a sync of the repo. This is asynchronous but not delayed like a scheduled sync. A state of C(publish) will use the repository's distributor to publish the content."
              },
              "serve_https": {
                "description": "Default: True\n\nMake the repo available over HTTPS.",
                "$ref": "#/definitions/ansible_truth"
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "pulp_host": {
                "type": "string",
                "description": "Default: http://127.0.0.1\n\nURL of the pulp server to connect to."
              },
              "repo": {
                "type": "string",
                "description": "Name of the repo to add or remove. This correlates to repo-id in Pulp."
              },
              "force_basic_auth": {
                "description": "Default: no\n\nhttplib2, the library used by the M(uri) module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request.",
                "$ref": "#/definitions/ansible_truth"
              },
              "serve_http": {
                "description": "Make the repo available over HTTP.",
                "$ref": "#/definitions/ansible_truth"
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "importer_ssl_client_cert": {
                "type": "string",
                "description": "Certificate used as the client certificate when synchronizing the repository. This is used to communicate authentication information to the feed source. The value to this option must be the full path to the certificate. The specified file may be the certificate itself or a single file containing both the certificate and private key. This can be the file content or the path to the file."
              },
              "wait_for_completion": {
                "description": "Default: no\n\nWait for asynchronous tasks to complete before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "add_export_distributor": {
                "description": "Whether or not to add the export distributor to new C(rpm) repositories.",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_proxy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "url_password": {
                "type": "string",
                "description": "The password for use in HTTP basic authentication to the pulp API. If the I(url_username) parameter is not specified, the I(url_password) parameter will not be used."
              },
              "name": {
                "type": "string",
                "description": "Name of the repo to add or remove. This correlates to repo-id in Pulp."
              },
              "url": {
                "type": "string",
                "description": ""
              },
              "importer_ssl_ca_cert": {
                "type": "string",
                "description": "CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file."
              },
              "url_username": {
                "type": "string",
                "description": "The username for use in HTTP basic authentication to the pulp API."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ordnance_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Ordnance router configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with these configuration sections in a deterministic way.",
            "properties": {
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "multiline_delimiter": {
                "type": "string",
                "description": "Default: @\n\nThis arugment is used when pushing a multiline configuration element to the Ordnance router.  It specifies the character to use as the delimiting character.  This only applies to the configuration action"
              },
              "replace": {
                "enum": [
                  "line",
                  "block"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node."
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "defaults": {
                "description": "This argument specifies whether or not to collect all defaults when getting the remote device running config.  When enabled, the module will get the current config by issuing the command C(show running-config all).",
                "$ref": "#/definitions/ansible_truth"
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines)."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "backup": {
                "description": "This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_auth": {
            "type": "object",
            "description": "This module authenticates to oVirt engine and creates SSO token, which should be later used in all other oVirt modules, so all modules don't need to perform login and logout. This module returns an Ansible fact called I(ovirt_auth). Every module can use this fact as C(auth) parameter, to perform authentication.",
            "properties": {
              "username": {
                "type": "string",
                "description": "The name of the user. For example: I(admin@internal)."
              },
              "ca_file": {
                "type": "string",
                "description": "A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If C(ca_file) parameter is not set, system wide CA certificate store is used."
              },
              "url": {
                "type": "string",
                "description": "A string containing the base URL of the server. For example: I(https://server.example.com/ovirt-engine/api)."
              },
              "insecure": {
                "description": "A boolean flag that indicates if the server TLS certificate and host name should be checked.",
                "$ref": "#/definitions/ansible_truth"
              },
              "kerberos": {
                "description": "A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.",
                "$ref": "#/definitions/ansible_truth"
              },
              "compress": {
                "description": "A boolean flag indicating if the SDK should ask the server to send compressed responses. The default is I(True). Note that this is a hint for the server, and that it may return uncompressed data even when this parameter is set to I(True).",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecifies if a token should be created or revoked."
              },
              "ovirt_auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "The maximum total time to wait for the response, in seconds. A value of zero (the default) means wait forever. If the timeout expires before the response is received an exception will be raised.",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": "The password of the user."
              }
            }
          },
          "twilio": {
            "required": [
              "from_number",
              "msg",
              "auth_token",
              "to_number",
              "account_sid"
            ],
            "type": "object",
            "description": "Sends a text message to a phone number through the Twilio messaging API.",
            "properties": {
              "auth_token": {
                "type": "string",
                "description": "user's Twilio authentication token"
              },
              "to_number": {
                "type": "string",
                "description": "one or more phone numbers to send the text message to, format +15551112222"
              },
              "account_sid": {
                "type": "string",
                "description": "user's Twilio account token found on the account page"
              },
              "from_number": {
                "type": "string",
                "description": "the Twilio number to send the text message from, format +15551112222"
              },
              "msg": {
                "type": "string",
                "description": "the body of the text message"
              },
              "media_url": {
                "type": "string",
                "description": "a URL with a picture, video or sound clip to send with an MMS (multimedia message) instead of a plain SMS"
              }
            }
          },
          "nxos_bgp_neighbor": {
            "required": [
              "asn",
              "neighbor"
            ],
            "type": "object",
            "description": "Manages BGP neighbors configurations on NX-OS switches.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "capability_negotiation": {
                "description": "Configure whether or not to negotiate capability with this neighbor.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pwd_type": {
                "enum": [
                  "cleartext",
                  "3des",
                  "cisco_type_7",
                  "default"
                ],
                "type": "string",
                "description": "Specify the encryption type the password will use. Valid values are '3des' or 'cisco_type_7' encryption."
              },
              "dynamic_capability": {
                "description": "Configure whether or not to enable dynamic capability.",
                "$ref": "#/definitions/ansible_truth"
              },
              "shutdown": {
                "type": "string",
                "description": "Configure to administratively shutdown this neighbor."
              },
              "low_memory_exempt": {
                "description": "Specify whether or not to shut down this neighbor under memory pressure.",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "remove_private_as": {
                "enum": [
                  "enable",
                  "disable",
                  "all",
                  "replace-as"
                ],
                "type": "string",
                "description": "Specify the config to remove private AS number from outbound updates. Valid values are 'enable' to enable this config, 'disable' to disable this config, 'all' to remove all private AS number, or 'replace-as', to replace the private AS number."
              },
              "suppress_4_byte_as": {
                "description": "Configure to suppress 4-byte AS Capability.",
                "$ref": "#/definitions/ansible_truth"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "connected_check": {
                "description": "Configure whether or not to check for directly connected peer.",
                "$ref": "#/definitions/ansible_truth"
              },
              "remote_as": {
                "type": "string",
                "description": "Specify Autonomous System Number of the neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it."
              },
              "ebgp_multihop": {
                "type": "string",
                "description": "Specify multihop TTL for a remote peer. Valid values are integers between 2 and 255, or keyword 'default' to disable this property."
              },
              "asn": {
                "type": "string",
                "description": "BGP autonomous system number. Valid values are string, Integer in ASPLAIN or ASDOT notation."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "timers_holdtime": {
                "type": "string",
                "description": "Specify holdtime timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 180."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "update_source": {
                "type": "string",
                "description": "Specify source interface of BGP session and updates."
              },
              "m_facts": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "Description of the neighbor."
              },
              "local_as": {
                "type": "string",
                "description": "Specify the local-as number for the eBGP neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it."
              },
              "timers_keepalive": {
                "type": "string",
                "description": "Specify keepalive timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 60."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "vrf": {
                "type": "string",
                "description": "Default: default\n\nName of the VRF. The name 'default' is a valid VRF representing the global bgp."
              },
              "log_neighbor_changes": {
                "enum": [
                  "enable",
                  "disable",
                  "inherit"
                ],
                "type": "string",
                "description": "Specify whether or not to enable log messages for neighbor up/down event."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "maximum_peers": {
                "type": "string",
                "description": "Specify Maximum number of peers for this neighbor prefix Valid values are between 1 and 1000, or 'default', which does not impose the limit."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": "Specify the password for neighbor. Valid value is string."
              },
              "transport_passive_only": {
                "description": "Specify whether or not to only allow passive connection setup. Valid values are 'true', 'false', and 'default', which defaults to 'false'. This property can only be configured when the neighbor is in 'ip' address format without prefix length. This property and the transport_passive_mode property are mutually exclusive.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "neighbor": {
                "type": "string",
                "description": "Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "netapp_e_snapshot_volume": {
            "required": [
              "snapshot_image_id",
              "api_url",
              "api_password",
              "name",
              "state",
              "storage_pool_name",
              "api_username",
              "ssid"
            ],
            "type": "object",
            "description": "Create, update, remove snapshot volumes for NetApp E/EF-Series storage arrays.",
            "properties": {
              "ssid": {
                "type": "string",
                "description": "storage array ID"
              },
              "snapshot_image_id": {
                "type": "string",
                "description": "The identifier of the snapshot image used to create the new snapshot volume.\nNote: You'll likely want to use the M(netapp_e_facts) module to find the ID of the image you want."
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Whether to create or remove the snapshot volume"
              },
              "repo_percentage": {
                "description": "Default: 20\n\nThe size of the view in relation to the size of the base volume",
                "$ref": "#/definitions/ansible_number"
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "full_threshold": {
                "description": "Default: 85\n\nThe repository utilization warning threshold percentage",
                "$ref": "#/definitions/ansible_number"
              },
              "view_mode": {
                "enum": [
                  "readOnly",
                  "readWrite",
                  "modeUnknown",
                  "__Undefined"
                ],
                "type": "string",
                "description": "The snapshot volume access mode"
              },
              "storage_pool_name": {
                "type": "string",
                "description": "Name of the storage pool on which to allocate the repository volume."
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name you wish to give the snapshot volume"
              }
            }
          },
          "slack": {
            "required": [
              "token"
            ],
            "type": "object",
            "description": "The M(slack) module sends notifications to U(http://slack.com) via the Incoming WebHook integration",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: Ansible\n\nThis is the sender of the message."
              },
              "domain": {
                "type": "string",
                "description": "Default: None\n\nSlack (sub)domain for your environment without protocol. (i.e. C(future500.slack.com)) In 1.8 and beyond, this is deprecated and may be ignored.  See token documentation for information."
              },
              "attachments": {
                "description": "Default: None\n\nDefine a list of attachments. This list mirrors the Slack JSON API. For more information, see https://api.slack.com/docs/attachments",
                "$ref": "#/definitions/ansible_array"
              },
              "color": {
                "enum": [
                  "normal",
                  "good",
                  "warning",
                  "danger"
                ],
                "type": "string",
                "description": "Default: normal\n\nAllow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message"
              },
              "icon_url": {
                "type": "string",
                "description": "Url for the message sender's icon (default C(https://www.ansible.com/favicon.ico))"
              },
              "parse": {
                "enum": [
                  "full",
                  "none"
                ],
                "type": "string",
                "description": "Default: None\n\nSetting for the message parser at Slack"
              },
              "token": {
                "type": "string",
                "description": "Slack integration token.  This authenticates you to the slack service. Prior to 1.8, a token looked like C(3Ffe373sfhRE6y42Fg3rvf4GlK).  In 1.8 and above, ansible adapts to the new slack API where tokens look like C(G922VJP24/D921DW937/3Ffe373sfhRE6y42Fg3rvf4GlK).  If tokens are in the new format then slack will ignore any value of domain.  If the token is in the old format the domain is required.  Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working."
              },
              "icon_emoji": {
                "type": "string",
                "description": "Default: None\n\nEmoji for the message sender. See Slack documentation for options. (if I(icon_emoji) is set, I(icon_url) will not be used)"
              },
              "link_names": {
                "description": "Default: 1\n\nAutomatically create links for channels and usernames in I(msg).",
                "$ref": "#/definitions/ansible_number"
              },
              "msg": {
                "type": "string",
                "description": "Default: None\n\nMessage to send."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "channel": {
                "type": "string",
                "description": "Default: None\n\nChannel to send the message to. If absent, the message goes to the channel selected for the I(token)."
              }
            }
          },
          "bigip_virtual_server": {
            "type": "object",
            "description": "Manages F5 BIG-IP LTM virtual servers via iControl SOAP API",
            "properties": {
              "partition": {
                "type": "string",
                "description": "Default: Common\n\nPartition"
              },
              "name": {
                "type": "string",
                "description": "Virtual server name"
              },
              "default_persistence_profile": {
                "type": "string",
                "description": "Default: None\n\nDefault Profile which manages the session persistence"
              },
              "destination": {
                "type": "string",
                "description": "Destination IP of the virtual server (only host is currently supported). Required when state=present and vs does not exist."
              },
              "all_profiles": {
                "type": "string",
                "description": "Default: None\n\nList of all Profiles (HTTP,ClientSSL,ServerSSL,etc) that must be used by the virtual server"
              },
              "all_rules": {
                "type": "string",
                "description": "Default: None\n\nList of rules to be applied in priority order"
              },
              "enabled_vlans": {
                "type": "string",
                "description": "Default: None\n\nList of vlans to be enabled. When a VLAN named C(ALL) is used, all VLANs will be allowed."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nVirtual Server state\nAbsent, delete the VS if present\nC(present) (and its synonym enabled), create if needed the VS and set state to enabled\nC(disabled), create if needed the VS and set state to disabled"
              },
              "snat": {
                "type": "string",
                "description": "Default: None\n\nSource network address policy"
              },
              "port": {
                "type": "string",
                "description": "Default: None\n\nPort of the virtual server . Required when state=present and vs does not exist"
              },
              "pool": {
                "type": "string",
                "description": "Default: None\n\nDefault pool for the virtual server"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nVirtual server description"
              }
            }
          },
          "quantum_router": {
            "required": [
              "login_password",
              "name"
            ],
            "type": "object",
            "description": "Create or Delete routers from OpenStack",
            "properties": {
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nName of the region"
              },
              "admin_state_up": {
                "description": "Default: True\n\ndesired admin state of the created router .",
                "$ref": "#/definitions/ansible_truth"
              },
              "tenant_name": {
                "type": "string",
                "description": "Default: None\n\nName of the tenant for which the router has to be created, if none router would be created for the login tenant."
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: yes\n\nThe tenant name of the login user"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone url for authentication"
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\nPassword of login user"
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nName to be give to the router"
              }
            }
          },
          "pagerduty": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "service",
                        "services"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module will let you create PagerDuty maintenance windows",
            "properties": {
              "name": {
                "type": "string",
                "description": "PagerDuty unique subdomain."
              },
              "service": {
                "description": "A comma separated list of PagerDuty service IDs.",
                "$ref": "#/definitions/ansible_array"
              },
              "passwd": {
                "type": "string",
                "description": "PagerDuty user password."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "running",
                  "started",
                  "ongoing",
                  "absent"
                ],
                "type": "string",
                "description": "Create a maintenance window or get a list of ongoing windows."
              },
              "hours": {
                "type": "string",
                "description": "Default: 1\n\nLength of maintenance window in hours."
              },
              "token": {
                "type": "string",
                "description": "A pagerduty token, generated on the pagerduty site. Can be used instead of user/passwd combination."
              },
              "user": {
                "type": "string",
                "description": "PagerDuty user ID."
              },
              "services": {
                "description": "A comma separated list of PagerDuty service IDs.",
                "$ref": "#/definitions/ansible_array"
              },
              "requester_id": {
                "type": "string",
                "description": "ID of user making the request. Only needed when using a token and creating a maintenance_window."
              },
              "minutes": {
                "type": "string",
                "description": "Maintenance window in minutes (this is added to the hours)."
              },
              "desc": {
                "type": "string",
                "description": "Default: Created by Ansible\n\nShort description of maintenance window."
              }
            }
          },
          "ipadm_prop": {
            "required": [
              "property",
              "protocol"
            ],
            "type": "object",
            "description": "Modify protocol properties on Solaris/illumos systems.",
            "properties": {
              "protocol": {
                "enum": [
                  "ipv4",
                  "ipv6",
                  "icmp",
                  "tcp",
                  "udp",
                  "sctp"
                ],
                "type": "string",
                "description": "Specifies the procotol for which we want to manage properties."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "reset"
                ],
                "type": "string",
                "description": "Default: present\n\nSet or reset the property value."
              },
              "property": {
                "type": "string",
                "description": "Specifies the name of property we want to manage."
              },
              "temporary": {
                "description": "Specifies that the property value is temporary. Temporary property values do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "value": {
                "type": "string",
                "description": "Specifies the value we want to set for the property."
              }
            }
          },
          "pkgng": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage binary packages for FreeBSD using 'pkgng' which is available in versions after 9.0.",
            "properties": {
              "autoremove": {
                "description": "Remove automatically installed packages which are no longer needed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "Name of package to install/remove.",
                "$ref": "#/definitions/ansible_array"
              },
              "cached": {
                "description": "Use local package base instead of fetching an updated one.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkgsite": {
                "type": "string",
                "description": "For pkgng versions before 1.1.4, specify packagesite to use for downloading packages. If not specified, use settings from C(/usr/local/etc/pkg.conf).\nFor newer pkgng versions, specify a the name of a repository configured in C(/usr/local/etc/pkg/repos)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the package."
              },
              "rootdir": {
                "type": "string",
                "description": "For pkgng versions 1.5 and later, pkg will install all packages within the specified root directory.\nCan not be used together with I(chroot) option."
              },
              "chroot": {
                "type": "string",
                "description": "Pkg will chroot in the specified environment.\nCan not be used together with I(rootdir) option."
              },
              "pkg": {
                "description": "Name of package to install/remove.",
                "$ref": "#/definitions/ansible_array"
              },
              "annotation": {
                "type": "string",
                "description": "A comma-separated list of keyvalue-pairs of the form C(<+/-/:><key>[=<value>]). A C(+) denotes adding an annotation, a C(-) denotes removing an annotation, and C(:) denotes modifying an annotation. If setting or modifying annotations, a value must be provided."
              }
            }
          },
          "gcpubsub_facts": {
            "type": "object",
            "description": "List Topics/Subscriptions from Google PubSub.  Use the gcpubsub module for topic/subscription management. See U(https://cloud.google.com/pubsub/docs) for an overview.",
            "properties": {
              "service_account_email": {
                "type": "string",
                "description": ""
              },
              "topic": {
                "type": "string",
                "description": "GCP pubsub topic name.  Only the name, not the full path, is required."
              },
              "state": {
                "enum": [
                  "list"
                ],
                "type": "string",
                "description": "list is the only valid option."
              },
              "credentials_file": {
                "type": "string",
                "description": ""
              },
              "project_id": {
                "type": "string",
                "description": ""
              },
              "view": {
                "enum": [
                  "topics",
                  "subscriptions"
                ],
                "type": "string",
                "description": "Choices are 'topics' or 'subscriptions'"
              }
            }
          },
          "patch": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "src",
                        "patchfile"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "src"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "patchfile"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "dest",
                        "originalfile"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Apply patch files using the GNU patch tool.",
            "properties": {
              "src": {
                "type": "string",
                "description": "Path of the patch file as accepted by the GNU patch tool. If C(remote_src) is 'no', the patch source file is looked up from the module's \"files\" directory."
              },
              "patchfile": {
                "type": "string",
                "description": "Path of the patch file as accepted by the GNU patch tool. If C(remote_src) is 'no', the patch source file is looked up from the module's \"files\" directory."
              },
              "remote_src": {
                "description": "Default: no\n\nIf C(no), it will search for src at originating/master machine, if C(yes) it will go to the remote/target machine for the src. Default is C(no).",
                "$ref": "#/definitions/ansible_truth"
              },
              "dest": {
                "type": "string",
                "description": "Path of the file on the remote machine to be patched.\nThe names of the files to be patched are usually taken from the patch file, but if there's just one file to be patched it can specified with this option."
              },
              "basedir": {
                "type": "string",
                "description": "Path of a base directory in which the patch file will be applied. May be ommitted when C(dest) option is specified, otherwise required."
              },
              "strip": {
                "description": "Default: 0\n\nNumber that indicates the smallest prefix containing leading slashes that will be stripped from each file name found in the patch file. For more information see the strip parameter of the GNU patch tool.",
                "$ref": "#/definitions/ansible_number"
              },
              "binary": {
                "description": "Default: no\n\nSetting to C(yes) will disable patch's heuristic for transforming CRLF line endings into LF. Line endings of src and dest must match. If set to C(no), patch will replace CRLF in src files on POSIX.",
                "$ref": "#/definitions/ansible_truth"
              },
              "originalfile": {
                "type": "string",
                "description": "Path of the file on the remote machine to be patched.\nThe names of the files to be patched are usually taken from the patch file, but if there's just one file to be patched it can specified with this option."
              },
              "backup": {
                "description": "Default: no\n\npasses --backup --version-control=numbered to patch, producing numbered backup copies",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ec2_vpc_net": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tags",
                        "resource_tags"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or terminate AWS virtual private clouds.  This module has a dependency on python-boto.",
            "properties": {
              "multi_ok": {
                "description": "By default the module will not create another VPC if there is another VPC with the same name and CIDR block. Specify this as true if you want duplicate VPCs created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "dns_support": {
                "description": "Default: True\n\nWhether to enable AWS DNS support.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state of the VPC. Either absent or present."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "Default: None\n\nThe tags you want attached to the VPC. This is independent of the name value, note if you pass a 'Name' key it would override the Name of the VPC if it's different."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "tenancy": {
                "enum": [
                  "default",
                  "dedicated"
                ],
                "type": "string",
                "description": "Default: default\n\nWhether to be default or dedicated tenancy. This cannot be changed after the VPC has been created."
              },
              "dns_hostnames": {
                "description": "Default: True\n\nWhether to enable AWS hostname support.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "cidr_block": {
                "type": "string",
                "description": "The CIDR of the VPC"
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name to give your VPC. This is used in combination with the cidr_block parameter to determine if a VPC already exists."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "resource_tags": {
                "type": "object",
                "description": "Default: None\n\nThe tags you want attached to the VPC. This is independent of the name value, note if you pass a 'Name' key it would override the Name of the VPC if it's different."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "dhcp_opts_id": {
                "type": "string",
                "description": "the id of the DHCP options to use for this vpc"
              }
            }
          },
          "os_networks_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more networks from OpenStack.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name or ID of the Network"
              },
              "filters": {
                "type": "string",
                "description": "A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              }
            }
          },
          "letsencrypt": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "dest",
                        "cert"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "cert"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "csr",
                        "src"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "csr"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "src"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create and renew SSL certificates with Let's Encrypt. Let’s Encrypt is a free, automated, and open certificate authority (CA), run for the public’s benefit. For details see U(https://letsencrypt.org). The current implementation supports the http-01, tls-sni-02 and dns-01 challenges.\nTo use this module, it has to be executed at least twice. Either as two different tasks in the same run or during multiple runs.\nBetween these two tasks you have to fulfill the required steps for the choosen challenge by whatever means necessary. For http-01 that means creating the necessary challenge file on the destination webserver. For dns-01 the necessary dns record has to be created. tls-sni-02 requires you to create a SSL certificate with the appropriate subjectAlternativeNames. It is I(not) the responsibility of this module to perform these steps.\nFor details on how to fulfill these challenges, you might have to read through U(https://tools.ietf.org/html/draft-ietf-acme-acme-02#section-7)\nAlthough the defaults are choosen so that the module can be used with the Let's Encrypt CA, the module can be used with any service using the ACME protocol.",
            "properties": {
              "acme_directory": {
                "type": "string",
                "description": "Default: https://acme-staging.api.letsencrypt.org/directory\n\nThe ACME directory to use. This is the entry point URL to access CA server API.\nFor safety reasons the default is set to the Let's Encrypt staging server. This will create technically correct, but untrusted certificates."
              },
              "src": {
                "type": "string",
                "description": "File containing the CSR for the new certificate.\nCan be created with C(openssl csr ...).\nThe CSR may contain multiple Subject Alternate Names, but each one will lead to an individual challenge that must be fulfilled for the CSR to be signed."
              },
              "account_email": {
                "type": "string",
                "description": "The email address associated with this account.\nIt will be used for certificate expiration warnings."
              },
              "dest": {
                "type": "string",
                "description": "The destination file for the certificate."
              },
              "remaining_days": {
                "description": "Default: 10\n\nThe number of days the certificate must have left being valid before it will be renewed.",
                "$ref": "#/definitions/ansible_number"
              },
              "challenge": {
                "enum": [
                  "http-01",
                  "dns-01",
                  "tls-sni-02"
                ],
                "type": "string",
                "description": "Default: http-01\n\nThe challenge to be performed."
              },
              "agreement": {
                "type": "string",
                "description": "Default: https://letsencrypt.org/documents/LE-SA-v1.1.1-August-1-2016.pdf\n\nURI to a terms of service document you agree to when using the ACME service at C(acme_directory)."
              },
              "account_key": {
                "type": "string",
                "description": "File containing the the Let's Encrypt account RSA key.\nCan be created with C(openssl rsa ...)."
              },
              "cert": {
                "type": "string",
                "description": "The destination file for the certificate."
              },
              "data": {
                "type": "object",
                "description": "The data to validate ongoing challenges.\nThe value that must be used here will be provided by a previous use of this module."
              },
              "csr": {
                "type": "string",
                "description": "File containing the CSR for the new certificate.\nCan be created with C(openssl csr ...).\nThe CSR may contain multiple Subject Alternate Names, but each one will lead to an individual challenge that must be fulfilled for the CSR to be signed."
              }
            }
          },
          "nexmo": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Send a SMS message via nexmo",
            "properties": {
              "url_password": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_proxy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "src": {
                "description": "Nexmo Number to send from",
                "$ref": "#/definitions/ansible_number"
              },
              "url": {
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": "Nexmo API Secret"
              },
              "force_basic_auth": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "dest": {
                "description": "Phone number(s) to send SMS message to",
                "$ref": "#/definitions/ansible_array"
              },
              "url_username": {
                "type": "string",
                "description": ""
              },
              "msg": {
                "type": "string",
                "description": "Message to text to send. Messages longer than 160 characters will be split into multiple messages"
              },
              "api_key": {
                "type": "string",
                "description": "Nexmo API Key"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "client_key": {
                "type": "string",
                "description": ""
              }
            }
          },
          "dimensiondata_network": {
            "type": "object",
            "description": "Create, update, and delete MCP 1.0 & 2.0 networks",
            "properties": {
              "service_plan": {
                "type": "string",
                "description": "Default: ESSENTIALS\n\nThe service plan, either “ESSENTIALS” or “ADVANCED”.\nMCP 2.0 Only."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "name": {
                "type": "string",
                "description": "The name of the network domain to create."
              },
              "description": {
                "type": "string",
                "description": "Additional description of the network domain."
              }
            }
          },
          "open_iscsi": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "auto_node_startup",
                        "automatic"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "target",
                        "name",
                        "targetname"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "portal",
                        "ip"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "login",
                        "state"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Discover targets on given portal, (dis)connect targets, mark targets to manually or auto start, return device nodes of connected targets.",
            "properties": {
              "auto_node_startup": {
                "description": "whether the target node should be automatically connected at startup",
                "$ref": "#/definitions/ansible_truth"
              },
              "target": {
                "type": "string",
                "description": "the iscsi target name"
              },
              "show_nodes": {
                "description": "whether the list of nodes in the persistent iscsi database should be returned by the module",
                "$ref": "#/definitions/ansible_truth"
              },
              "node_auth": {
                "type": "string",
                "description": "Default: CHAP\n\ndiscovery.sendtargets.auth.authmethod"
              },
              "automatic": {
                "description": "whether the target node should be automatically connected at startup",
                "$ref": "#/definitions/ansible_truth"
              },
              "node_pass": {
                "type": "string",
                "description": "discovery.sendtargets.auth.password"
              },
              "discover": {
                "description": "whether the list of target nodes on the portal should be (re)discovered and added to the persistent iscsi database. Keep in mind that iscsiadm discovery resets configurtion, like node.startup to manual, hence combined with auto_node_startup=yes will allways return a changed state.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "description": "whether the target node should be connected",
                "$ref": "#/definitions/ansible_truth"
              },
              "portal": {
                "type": "string",
                "description": "the ip address of the iscsi target"
              },
              "ip": {
                "type": "string",
                "description": "the ip address of the iscsi target"
              },
              "login": {
                "description": "whether the target node should be connected",
                "$ref": "#/definitions/ansible_truth"
              },
              "node_user": {
                "type": "string",
                "description": "discovery.sendtargets.auth.username"
              },
              "targetname": {
                "type": "string",
                "description": "the iscsi target name"
              },
              "port": {
                "type": "string",
                "description": "Default: 3260\n\nthe port on which the iscsi target process listens"
              },
              "name": {
                "type": "string",
                "description": "the iscsi target name"
              }
            }
          },
          "panos_pg": {
            "required": [
              "pg_name",
              "password",
              "ip_address"
            ],
            "type": "object",
            "description": "Create a security profile group",
            "properties": {
              "wildfire": {
                "type": "string",
                "description": "Default: None\n\nname of the wildfire analysis profile"
              },
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "data_filtering": {
                "type": "string",
                "description": "Default: None\n\nname of the data filtering profile"
              },
              "file_blocking": {
                "type": "string",
                "description": "Default: None\n\nname of the file blocking profile"
              },
              "pg_name": {
                "type": "string",
                "description": "name of the security profile group"
              },
              "vulnerability": {
                "type": "string",
                "description": "Default: None\n\nname of the vulnerability profile"
              },
              "spyware": {
                "type": "string",
                "description": "Default: None\n\nname of the spyware profile"
              },
              "url_filtering": {
                "type": "string",
                "description": "Default: None\n\nname of the url filtering profile"
              },
              "virus": {
                "type": "string",
                "description": "Default: None\n\nname of the anti-virus profile"
              },
              "commit": {
                "description": "Default: True\n\ncommit if changed",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              }
            }
          },
          "a10_service_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "service_group",
                        "service",
                        "pool",
                        "group"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "service_group"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "service"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pool"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "group"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "service_group_protocol",
                        "proto",
                        "protocol"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "servers",
                        "server",
                        "member"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "service_group_method",
                        "method"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage slb service-group objects on A10 Networks devices via aXAPI",
            "properties": {
              "protocol": {
                "enum": [
                  "tcp",
                  "udp"
                ],
                "type": "string",
                "description": "Default: tcp\n\nslb service-group protocol"
              },
              "thirsty": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "servers": {
                "description": "A list of servers to add to the service group. Each list item should be a dictionary which specifies the C(server:) and C(port:), but can also optionally specify the C(status:). See the examples below for details.",
                "$ref": "#/definitions/ansible_array"
              },
              "pass": {
                "type": "string",
                "description": "admin password of your A10 Networks device"
              },
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "client_key": {
                "type": "string",
                "description": ""
              },
              "service_group": {
                "type": "string",
                "description": "slb service-group name"
              },
              "group": {
                "type": "string",
                "description": "slb service-group name"
              },
              "use_proxy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "service": {
                "type": "string",
                "description": "slb service-group name"
              },
              "proto": {
                "enum": [
                  "tcp",
                  "udp"
                ],
                "type": "string",
                "description": "Default: tcp\n\nslb service-group protocol"
              },
              "member": {
                "description": "A list of servers to add to the service group. Each list item should be a dictionary which specifies the C(server:) and C(port:), but can also optionally specify the C(status:). See the examples below for details.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "write_config": {
                "description": "Default: no\n\nIf C(yes), any changes will cause a write of the running configuration to non-volatile memory. This will save I(all) configuration changes, including those that may have been made manually or through other modules, so care should be taken when specifying C(yes).",
                "$ref": "#/definitions/ansible_truth"
              },
              "service_group_method": {
                "enum": [
                  "round-robin",
                  "weighted-rr",
                  "least-connection",
                  "weighted-least-connection",
                  "service-least-connection",
                  "service-weighted-least-connection",
                  "fastest-response",
                  "least-request",
                  "round-robin-strict",
                  "src-ip-only-hash",
                  "src-ip-hash"
                ],
                "type": "string",
                "description": "Default: round-robin\n\nslb service-group loadbalancing method"
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "method": {
                "enum": [
                  "round-robin",
                  "weighted-rr",
                  "least-connection",
                  "weighted-least-connection",
                  "service-least-connection",
                  "service-weighted-least-connection",
                  "fastest-response",
                  "least-request",
                  "round-robin-strict",
                  "src-ip-only-hash",
                  "src-ip-hash"
                ],
                "type": "string",
                "description": "Default: round-robin\n\nslb service-group loadbalancing method"
              },
              "username": {
                "type": "string",
                "description": "admin account of your A10 Networks device"
              },
              "force_basic_auth": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "service_group_protocol": {
                "enum": [
                  "tcp",
                  "udp"
                ],
                "type": "string",
                "description": "Default: tcp\n\nslb service-group protocol"
              },
              "user": {
                "type": "string",
                "description": "admin account of your A10 Networks device"
              },
              "password": {
                "type": "string",
                "description": "admin password of your A10 Networks device"
              },
              "pwd": {
                "type": "string",
                "description": "admin password of your A10 Networks device"
              },
              "pool": {
                "type": "string",
                "description": "slb service-group name"
              },
              "url_password": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": "admin account of your A10 Networks device"
              },
              "host": {
                "type": "string",
                "description": "hostname or ip of your A10 Networks device"
              },
              "server": {
                "description": "A list of servers to add to the service group. Each list item should be a dictionary which specifies the C(server:) and C(port:), but can also optionally specify the C(status:). See the examples below for details.",
                "$ref": "#/definitions/ansible_array"
              },
              "url": {
                "type": "string",
                "description": ""
              },
              "url_username": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "dellos9_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "OS9 configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with OS9 configuration sections in a deterministic way.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir.  This argument is mutually exclusive with I(lines)."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "This argument causes the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. As with I(before), this the playbook designer can append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).",
                "$ref": "#/definitions/ansible_array"
              },
              "update": {
                "enum": [
                  "merge",
                  "check"
                ],
                "type": "string",
                "description": "Default: merge\n\nThe I(update) argument controls how the configuration statements are processed on the remote device.  Valid choices for the I(update) argument are I(merge) and I(check).  When you set this argument to I(merge), the configuration changes merge with the current device running configuration.  When you set this argument to I(check) the configuration updates are determined but not actually configured on the remote device."
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "replace": {
                "enum": [
                  "line",
                  "block"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If you set the replace argument to I(line), then the modified lines push to the device in configuration mode.  If you set the replace argument to I(block), then the entire command block pushes to the device in configuration mode if any line is not correct."
              },
              "save": {
                "description": "The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If you omit the parents argument, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": "The playbook designer can use the  C(config) argument to supply the base configuration to be used to validate necessary configuration changes.  If you provide this argument, the module does not download the running-config from the remote node."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If you set match to I(line), commands match line by line.  If you set match to I(strict), command lines match by position.  If you set match to I(exact), command lines must be an equal match.  Finally, if you set match to I(none), the module does  not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  The playbook designer can use this opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "ovirt_networks_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt networks.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search network starting with string vlan1 use: name=vlan1*"
              }
            }
          },
          "ops_config": {
            "type": "object",
            "description": "OpenSwitch configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with ops configuration sections in a deterministic way.",
            "properties": {
              "src": {
                "type": "string",
                "description": "The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments."
              },
              "force": {
                "type": "string",
                "description": "The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.\nNote this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release."
              },
              "after": {
                "type": "string",
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set."
              },
              "lines": {
                "type": "string",
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser."
              },
              "replace": {
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct."
              },
              "parents": {
                "type": "string",
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands."
              },
              "save": {
                "type": "string",
                "description": "The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored."
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "match": {
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "before": {
                "type": "string",
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system."
              }
            }
          },
          "panos_admpwd": {
            "required": [
              "newpassword",
              "key_filename",
              "ip_address"
            ],
            "type": "object",
            "description": "Change the admin password of PAN-OS via SSH using a SSH key for authentication.\nUseful for AWS instances where the first login should be done via SSH.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for initial authentication"
              },
              "newpassword": {
                "type": "string",
                "description": "password to configure for admin on the PAN-OS device"
              },
              "key_filename": {
                "type": "string",
                "description": "filename of the SSH Key to use for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              }
            }
          },
          "ec2_vpc": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or terminates AWS virtual private clouds.  This module has a dependency on python-boto.",
            "properties": {
              "internet_gateway": {
                "description": "Default: no\n\nToggle whether there should be an Internet gateway attached to the VPC.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "route_tables": {
                "description": "A dictionary array of route tables to add of the form: C({ subnets: [172.22.2.0/24, 172.22.3.0/24,], routes: [{ dest: 0.0.0.0/0, gw: igw},], resource_tags: ... }). Where the subnets list is those subnets the route table should be associated with, and the routes list is a list of routes to be in the table.  The special keyword for the gw of igw specifies that you should the route should go through the internet gateway attached to the VPC. gw also accepts instance-ids, interface-ids, and vpc-peering-connection-ids in addition igw. resource_tags is optional and uses dictionary form: C({ \"Name\": \"public\", ... }). This module is currently unable to affect the \"main\" route table due to some limitations in boto, so you must explicitly define the associated subnets or they will be attached to the main table implicitly. As of 1.8, if the route_tables parameter is not specified, no existing routes will be modified.",
                "$ref": "#/definitions/ansible_array"
              },
              "dns_support": {
                "description": "Default: yes\n\nToggles the \"Enable DNS resolution\" flag.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Create or terminate the VPC."
              },
              "instance_tenancy": {
                "enum": [
                  "default",
                  "dedicated"
                ],
                "type": "string",
                "description": "Default: default\n\nThe supported tenancy options for instances launched into the VPC."
              },
              "resource_tags": {
                "type": "object",
                "description": "A dictionary array of resource tags of the form C({ tag1: value1, tag2: value2 }). - Tags in this list are used in conjunction with CIDR block to uniquely identify a VPC in lieu of vpc_id. Therefore, if CIDR/Tag combination does not exist, a new VPC will be created.  VPC tags not on this list will be ignored. Prior to 1.7, specifying a resource tag was optional."
              },
              "wait": {
                "description": "Default: no\n\nWait for the VPC to be in state 'available' before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "subnets": {
                "description": "A dictionary array of subnets to add of the form C({ cidr: ..., az: ... , resource_tags: ... }).\nWhere C(az) is the desired availability zone of the subnet, optional.\nTags C(resource_tags) use dictionary form C({ \"Environment\":\"Dev\", \"Tier\":\"Web\", ...}), optional.\nC(resource_tags) see resource_tags for VPC below. The main difference is subnet tags not specified here will be deleted.\nAll VPC subnets not in this list will be removed as well.\nAs of 1.8, if the subnets parameter is not specified, no existing subnets will be modified.'",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 300\n\nHow long before wait gives up, in seconds."
              },
              "dns_hostnames": {
                "description": "Default: yes\n\nToggles the \"Enable DNS hostname support for instances\" flag.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "cidr_block": {
                "type": "string",
                "description": "The cidr block representing the VPC, e.g. C(10.0.0.0/16), required when I(state=present)."
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "vpc_id": {
                "type": "string",
                "description": "A VPC id to terminate when I(state=absent)."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "tower_job_template": {
            "required": [
              "job_type",
              "playbook",
              "name",
              "project"
            ],
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower job templates. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "network_credential": {
                "type": "string",
                "description": "The network_credential to use for the job_template."
              },
              "ask_limit": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ask_inventory": {
                "description": "Propmt user for inventory on launch.",
                "$ref": "#/definitions/ansible_truth"
              },
              "job_type": {
                "enum": [
                  "run",
                  "check",
                  "scan"
                ],
                "type": "string",
                "description": "The job_type to use for the job_template."
              },
              "ask_job_type": {
                "description": "Prompt user for job type on launch.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host_config_key": {
                "type": "string",
                "description": "Allow provisioning callbacks using this host config key."
              },
              "skip_tags": {
                "type": "string",
                "description": "The skip_tags to use for the job_template."
              },
              "playbook": {
                "type": "string",
                "description": "Playbook to use for the job_template."
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "job_tags": {
                "type": "string",
                "description": "The job_tags to use for the job_template."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "inventory": {
                "type": "string",
                "description": "Inventory to use for the job_template."
              },
              "extra_vars_path": {
                "type": "string",
                "description": "Path to the extra_vars yaml file."
              },
              "forks": {
                "description": "The number of parallel or simultaneous processes to use while executing the playbook.",
                "$ref": "#/definitions/ansible_number"
              },
              "cloud_credential": {
                "type": "string",
                "description": "Cloud_credential to use for the job_template."
              },
              "become_enabled": {
                "description": "Should become_enabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "Description to use for the job_template."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "machine_credential": {
                "type": "string",
                "description": "Machine_credential to use for the job_template."
              },
              "ask_credential": {
                "description": "Prompt user for credential on launch.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name to use for the job_template."
              },
              "verbosity": {
                "enum": [
                  "verbose",
                  "debug"
                ],
                "type": "string",
                "description": "Control the output level Ansible produces as the playbook runs."
              },
              "project": {
                "type": "string",
                "description": "Project to use for the job_template."
              },
              "ask_extra_vars": {
                "description": "Prompt user for extra_vars on launch.",
                "$ref": "#/definitions/ansible_truth"
              },
              "limit": {
                "type": "string",
                "description": "A host pattern to further constrain the list of hosts managed or affected by the playbook"
              },
              "ask_tags": {
                "description": "Prompt user for job tags on launch.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "tower_label": {
            "required": [
              "name",
              "organization"
            ],
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower labels. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name to use for the label."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "organization": {
                "type": "string",
                "description": "Organization the label should be applied to."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_vxlan_vtep_vni": {
            "required": [
              "vni",
              "interface"
            ],
            "type": "object",
            "description": "Creates a Virtual Network Identifier member (VNI) for an NVE overlay interface.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "Specify to save the running configuration after module operations.",
                "$ref": "#/definitions/ansible_truth"
              },
              "peer_list": {
                "description": "Set the ingress-replication static peer list. Valid values are an array, a space-separated string of ip addresses, or the keyword 'default'.",
                "$ref": "#/definitions/ansible_array"
              },
              "multicast_group": {
                "type": "string",
                "description": "The multicast group (range) of the VNI. Valid values are string and keyword 'default'."
              },
              "suppress_arp": {
                "description": "Suppress arp under layer 2 VNI.",
                "$ref": "#/definitions/ansible_truth"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "vni": {
                "type": "string",
                "description": "ID of the Virtual Network Identifier."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "include_defaults": {
                "type": "string",
                "description": "Default: True\n\nSpecify to use or not the complete running configuration for module operations."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "assoc_vrf": {
                "description": "This attribute is used to identify and separate processing VNIs that are associated with a VRF and used for routing. The VRF and VNI specified with this command must match the configuration of the VNI under the VRF.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "Configuration string to be used for module operations. If not specified, the module will use the current running configuration."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Interface name for the VXLAN Network Virtualization Endpoint."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ingress_replication": {
                "enum": [
                  "bgp",
                  "static",
                  "default"
                ],
                "type": "string",
                "description": "Specifies mechanism for host reachability advertisement."
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "clc_loadbalancer": {
            "required": [
              "alias",
              "location",
              "name"
            ],
            "type": "object",
            "description": "An Ansible module to Create, Delete shared loadbalancers in CenturyLink Cloud.",
            "properties": {
              "status": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enabled\n\nThe status of the loadbalancer"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nA description for the loadbalancer"
              },
              "method": {
                "enum": [
                  "leastConnection",
                  "roundRobin"
                ],
                "type": "string",
                "description": "Default: None\n\n-The balancing method for the load balancer pool"
              },
              "alias": {
                "type": "string",
                "description": "The alias of your CLC Account"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "port_absent",
                  "nodes_present",
                  "nodes_absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to create or delete the load balancer pool"
              },
              "location": {
                "type": "string",
                "description": "The location of the datacenter where the load balancer resides in"
              },
              "nodes": {
                "description": "A list of nodes that needs to be added to the load balancer pool",
                "$ref": "#/definitions/ansible_array"
              },
              "port": {
                "enum": [
                  80,
                  443
                ],
                "type": "string",
                "description": "Default: None\n\nPort to configure on the public-facing side of the load balancer pool"
              },
              "persistence": {
                "enum": [
                  "standard",
                  "sticky"
                ],
                "type": "string",
                "description": "Default: None\n\nThe persistence method for the load balancer"
              },
              "name": {
                "type": "string",
                "description": "The name of the loadbalancer"
              }
            }
          },
          "include_role": {
            "type": "object",
            "description": "Loads and executes a role as a task, this frees roles from the `role:` directive and allows them to be treated more as tasks.",
            "properties": {
              "active_connection_states": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "connect_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "delay": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "present",
                  "absent",
                  "drained"
                ],
                "type": "string",
                "description": ""
              },
              "sleep": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "exclude_hosts": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "search_regex": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "na_cdot_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or destroy users.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the user to manage."
              },
              "authentication_method": {
                "enum": [
                  "community",
                  "password",
                  "publickey",
                  "domain",
                  "nsswitch",
                  "usm"
                ],
                "type": "string",
                "description": "Authentication method for the application.\nNot all authentication methods are valid for an application.\nValid authentication methods for each application are as denoted in I(authentication_choices_description).\npassword for console application\npassword, domain, nsswitch, cert for http application.\npassword, domain, nsswitch, cert for ontapi application.\ncommunity for snmp application (when creating SNMPv1 and SNMPv2 users).\nusm and community for snmp application (when creating SNMPv3 users).\npassword for sp application.\npassword for rsh application.\npassword for telnet application.\npassword, publickey, domain, nsswitch for ssh application."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "vserver": {
                "type": "string",
                "description": "The name of the vserver to use."
              },
              "application": {
                "enum": [
                  "console",
                  "http",
                  "ontapi",
                  "rsh",
                  "snmp",
                  "sp",
                  "ssh",
                  "telnet"
                ],
                "type": "string",
                "description": "Applications to grant access to."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified user should exist or not."
              },
              "role_name": {
                "type": "string",
                "description": "The name of the role. Required when C(state=present)"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "set_password": {
                "type": "string",
                "description": "Default: None\n\nPassword for the user account.\nIt is ignored for creating snmp users, but is required for creating non-snmp users.\nFor an existing user, this value will be used as the new password."
              }
            }
          },
          "nxos_gir": {
            "type": "object",
            "description": "Trigger a graceful removal or insertion (GIR) of the switch.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "system_mode_maintenance_dont_generate_profile": {
                "description": "When C(system_mode_maintenance_dont_generate_profile=true) it prevents the dynamic searching of enabled protocols and executes commands configured in a maintenance-mode profile. Use this option if you want the system to use a maintenance-mode profile that you have created. When C(system_mode_maintenance_dont_generate_profile=false) it prevents the dynamic searching of enabled protocols and executes commands configured in a normal-mode profile. Use this option if you want the system to use a normal-mode profile that you have created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "system_mode_maintenance_shutdown": {
                "description": "Shuts down all protocols, vPC domains, and interfaces except the management interface (using the shutdown command). This option is disruptive while C(system_mode_maintenance) (which uses the isolate command) is not.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "absent",
                  "present",
                  "default"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify desired state of the resource."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "system_mode_maintenance_timeout": {
                "type": "string",
                "description": "Keeps the switch in maintenance mode for a specified number of minutes. Range is 5-65535."
              },
              "system_mode_maintenance_on_reload_reset_reason": {
                "enum": [
                  "hw_error",
                  "svc_failure",
                  "kern_failure",
                  "wdog_timeout",
                  "fatal_error",
                  "lc_failure",
                  "match_any",
                  "manual_reload"
                ],
                "type": "string",
                "description": "Boots the switch into maintenance mode automatically in the event of a specified system crash."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "system_mode_maintenance": {
                "description": "When C(system_mode_maintenance=true) it puts all enabled protocols in maintenance mode (using the isolate command). When C(system_mode_maintenance=false) it puts all enabled protocols in normal mode (using the no isolate command).",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "gce_img": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module can create and delete GCE private images from gzipped compressed tarball containing raw disk data or from existing detached disks in any zone. U(https://cloud.google.com/compute/docs/images)",
            "properties": {
              "description": {
                "type": "string",
                "description": "an optional description"
              },
              "family": {
                "type": "string",
                "description": "an optional family name"
              },
              "service_account_email": {
                "type": "string",
                "description": "service account email"
              },
              "pem_file": {
                "type": "string",
                "description": "path to the pem file associated with the service account email"
              },
              "source": {
                "type": "string",
                "description": "the source disk or the Google Cloud Storage URI to create the image from"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\ndesired state of the image"
              },
              "zone": {
                "type": "string",
                "description": "Default: us-central1-a\n\nthe zone of the disk specified by source"
              },
              "timeout": {
                "description": "Default: 180\n\ntimeout for the operation",
                "$ref": "#/definitions/ansible_number"
              },
              "project_id": {
                "type": "string",
                "description": "your GCE project ID"
              },
              "name": {
                "type": "string",
                "description": "the name of the image to create or delete"
              }
            }
          },
          "rax_clb_ssl": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Set up, reconfigure, or remove SSL termination for an existing load balancer.",
            "properties": {
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "intermediate_certificate": {
                "type": "string",
                "description": "One or more intermediate certificate authorities as a string in PEM\nformat, concatenated into a single string."
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "certificate": {
                "type": "string",
                "description": "The public SSL certificates as a string in PEM format."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIf set to \"present\", SSL termination will be added to this load balancer.\nIf \"absent\", SSL termination will be removed instead."
              },
              "secure_port": {
                "description": "Default: 443\n\nThe port to listen for secure traffic.",
                "$ref": "#/definitions/ansible_number"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "private_key": {
                "type": "string",
                "description": "The private SSL key as a string in PEM format."
              },
              "https_redirect": {
                "description": "If \"true\", the load balancer will redirect HTTP traffic to HTTPS.\nRequires \"secure_traffic_only\" to be true. Incurs an implicit wait if SSL\ntermination is also applied or removed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "wait_timeout": {
                "description": "Default: 300\n\nHow long before \"wait\" gives up, in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Wait for the balancer to be in state \"running\" before turning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "enabled": {
                "description": "Default: True\n\nIf set to \"false\", temporarily disable SSL termination without discarding\nexisting credentials.",
                "$ref": "#/definitions/ansible_truth"
              },
              "secure_traffic_only": {
                "description": "If \"true\", the load balancer will *only* accept secure traffic.",
                "$ref": "#/definitions/ansible_truth"
              },
              "loadbalancer": {
                "type": "string",
                "description": "Name or ID of the load balancer on which to manage SSL termination."
              }
            }
          },
          "pingdom": {
            "required": [
              "passwd",
              "checkid",
              "state",
              "uid",
              "key"
            ],
            "type": "object",
            "description": "This module will let you pause/unpause Pingdom alerts",
            "properties": {
              "passwd": {
                "type": "string",
                "description": "Pingdom user password."
              },
              "checkid": {
                "type": "string",
                "description": "Pingdom ID of the check."
              },
              "state": {
                "enum": [
                  "running",
                  "paused",
                  "started",
                  "stopped"
                ],
                "type": "string",
                "description": "Define whether or not the check should be running or paused."
              },
              "uid": {
                "type": "string",
                "description": "Pingdom user ID."
              },
              "key": {
                "type": "string",
                "description": "Pingdom API key."
              }
            }
          },
          "ec2_asg_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about ec2 Auto Scaling Groups (ASGs) in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The prefix or name of the auto scaling group(s) you are searching for.\nNote: This is a regular expression match with implicit '^' (beginning of string). Append '$' for a complete name match."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the auto scaling group(s) you are searching for."
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "azure_rm_virtualmachine": {
            "type": "object",
            "description": "Create, update, stop and start a virtual machine. Provide an existing storage account and network interface or allow the module to create these for you. If you choose not to provide a network interface, the resource group must contain a virtual network with at least one subnet.\nCurrently requires an image found in the Azure Marketplace. Use azure_rm_virtualmachineimage_facts module to discover the publisher, offer, sku and version of a particular image.",
            "properties": {
              "resource_group": {
                "type": "string",
                "description": "Name of the resource group containing the virtual machine."
              },
              "public_ip_allocation_method": {
                "type": "string",
                "description": "Default: ['Static']\n\nIf a public IP address is created when creating the VM (because a Network Interface was not provided), determines if the public IP address remains permanently associated with the Network Interface. If set to 'Dynamic' the public IP address may change any time the VM is rebooted or power cycled."
              },
              "image": {
                "type": "string",
                "description": "A dictionary describing the Marketplace image used to build the VM. Will contain keys: publisher, offer, sku and version. NOTE: set image.version to 'latest' to get the most recent version of a given image."
              },
              "ssh_public_keys": {
                "type": "string",
                "description": "For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin username>/.ssh/authorized_keys. Set key_data to the actual value of the public key."
              },
              "storage_container_name": {
                "type": "string",
                "description": "Default: vhds\n\nName of the container to use within the storage account to store VHD blobs. If no name is specified a default container will created."
              },
              "allocated": {
                "type": "string",
                "description": "Default: True\n\nToggle that controls if the machine is allocated/deallocated, only useful with state='present'."
              },
              "ssh_password_enabled": {
                "type": "string",
                "description": "Default: True\n\nWhen the os_type is Linux, setting ssh_password_enabled to false will disable SSH password authentication and require use of SSH keys."
              },
              "storage_blob_name": {
                "type": "string",
                "description": "Name fo the storage blob used to hold the VM's OS disk image. If no name is provided, defaults to the VM name + '.vhd'. If you provide a name, it must end with '.vhd'"
              },
              "remove_on_absent": {
                "type": "string",
                "description": "Default: ['all']\n\nWhen removing a VM using state 'absent', also remove associated resources\nIt can be 'all' or a list with any of the following: ['network_interfaces', 'virtual_storage', 'public_ips']\nAny other input will be ignored"
              },
              "short_hostname": {
                "type": "string",
                "description": "Name assigned internally to the host. On a linux VM this is the name returned by the `hostname` command. When creating a virtual machine, short_hostname defaults to name."
              },
              "started": {
                "type": "string",
                "description": "Default: True\n\nUse with state 'present' to start the machine. Set to false to have the machine be 'stopped'."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nAssert the state of the virtual machine.\nState 'present' will check that the machine exists with the requested configuration. If the configuration of the existing machine does not match, the machine will be updated. Use options started, allocated and restarted to change the machine's power state.\nState 'absent' will remove the virtual machine."
              },
              "subnet_name": {
                "type": "string",
                "description": "When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first subnet found in the virtual network. Use this parameter to provide a specific subnet instead."
              },
              "location": {
                "type": "string",
                "description": "Valid Azure location. Defaults to location of the resource group."
              },
              "network_interface_names": {
                "type": "string",
                "description": "List of existing network interface names to add to the VM. If a network interface name is not provided when the VM is created, a default network interface will be created. In order for the module to create a network interface, at least one Virtual Network with one Subnet must exist."
              },
              "admin_password": {
                "type": "string",
                "description": "Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_password_enabled to false."
              },
              "virtual_network_name": {
                "type": "string",
                "description": "When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first virtual network found in the resource group. Use this parameter to provide a specific virtual network instead."
              },
              "open_ports": {
                "type": "string",
                "description": "If a network interface is created when creating the VM, a security group will be created as well. For Linux hosts a rule will be added to the security group allowing inbound TCP connections to the default SSH port 22, and for Windows hosts ports 3389 and 5986 will be opened. Override the default open ports by providing a list of ports."
              },
              "vm_size": {
                "type": "string",
                "description": "Default: Standard_D1\n\nA valid Azure VM size value. For example, 'Standard_D4'. The list of choices varies depending on the subscription and location. Check your subscription for available choices."
              },
              "name": {
                "type": "string",
                "description": "Name of the virtual machine."
              },
              "restarted": {
                "type": "string",
                "description": "Use with state 'present' to restart a running VM."
              },
              "admin_username": {
                "type": "string",
                "description": "Admin username used to access the host after it is created. Required when creating a VM."
              },
              "os_type": {
                "type": "string",
                "description": "Default: ['Linux']\n\nBase type of operating system."
              },
              "storage_account_name": {
                "type": "string",
                "description": "Name of an existing storage account that supports creation of VHD blobs. If not specified for a new VM, a new storage account named <vm name>01 will be created using storage type 'Standard_LRS'."
              },
              "os_disk_caching": {
                "type": "string",
                "description": "Default: ReadOnly\n\nType of OS disk caching."
              }
            }
          },
          "udm_share": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaFakeOplocks",
                        "samba_fake_oplocks"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaDirectorySecurityMode",
                        "samba_directory_security_mode"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaNtAclSupport",
                        "samba_nt_acl_support"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaInheritOwner",
                        "samba_inherit_owner"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaPostexec",
                        "samba_postexec"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaHideFiles",
                        "samba_hide_files"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaName",
                        "samba_name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaValidUsers",
                        "samba_valid_users"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaForceDirectoryMode",
                        "samba_force_directory_mode"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaCustomSettings",
                        "samba_custom_settings"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaCreateMode",
                        "samba_create_mode"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaForceCreateMode",
                        "samba_force_create_mode"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaBrowseable",
                        "samba_browsable"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "nfsCustomSettings",
                        "nfs_custom_settings"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaDosFilemode",
                        "samba_dos_filemode"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaInheritAcls",
                        "samba_inherit_acls"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaPreexec",
                        "samba_preexec"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaHideUnreadable",
                        "samba_hide_unreadable"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaBlockSize",
                        "samba_block_size"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaWriteList",
                        "samba_write_list"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaForceGroup",
                        "samba_force_group"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaInheritPermissions",
                        "samba_inherit_permissions"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaSecurityMode",
                        "samba_security_mode"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaForceSecurityMode",
                        "samba_force_security_mode"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaVFSObjects",
                        "samba_vfs_objects"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaMSDFSRoot",
                        "samba_msdfs_root"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaForceUser",
                        "samba_force_user"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaOplocks",
                        "samba_oplocks"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaWriteable",
                        "samba_writeable"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaStrictLocking",
                        "samba_strict_locking"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaDirectoryMode",
                        "samba_directory_mode"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaHostsDeny",
                        "samba_hosts_deny"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaLocking",
                        "samba_locking"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaBlockingLocks",
                        "samba_blocking_locks"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaInvalidUsers",
                        "samba_invalid_users"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaHostsAllow",
                        "samba_hosts_allow"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaPublic",
                        "samba_public"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaLevel2Oplocks",
                        "samba_level_2_oplocks"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaForceDirectorySecurityMode",
                        "samba_force_directory_security_mode"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sambaCscPolicy",
                        "samba_csc_policy"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module allows to manage samba shares on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.",
            "properties": {
              "samba_hide_files": {
                "type": "string",
                "description": "Default: None\n\nHide files."
              },
              "sambaHostsAllow": {
                "description": "Allowed host/network.",
                "$ref": "#/definitions/ansible_array"
              },
              "sambaCreateMode": {
                "type": "string",
                "description": "Default: 0744\n\nFile mode."
              },
              "group": {
                "type": "string",
                "description": "Default: 0\n\nDirectory owner group of the share's root directory."
              },
              "samba_browsable": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaForceCreateMode": {
                "description": "Default: 0\n\nForce file mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_write_list": {
                "type": "string",
                "description": "Default: None\n\nRestrict write access to these users/groups."
              },
              "samba_inherit_acls": {
                "description": "Default: 1\n\nInherit ACLs.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_msdfs_root": {
                "description": "Default: 0\n\nMSDFS root.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaBlockSize": {
                "type": "string",
                "description": "Default: None\n\nBlocking size."
              },
              "samba_directory_security_mode": {
                "type": "string",
                "description": "Default: 0777\n\nDirectory security mode."
              },
              "samba_force_directory_mode": {
                "description": "Default: 0\n\nForce directory mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaMSDFSRoot": {
                "description": "Default: 0\n\nMSDFS root.",
                "$ref": "#/definitions/ansible_truth"
              },
              "nfsCustomSettings": {
                "description": "Option name in exports file.",
                "$ref": "#/definitions/ansible_array"
              },
              "sambaBlockingLocks": {
                "description": "Default: 1\n\nBlocking locks.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_force_security_mode": {
                "description": "Default: 0\n\nForce security mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name"
              },
              "samba_dos_filemode": {
                "description": "Default: 0\n\nUsers with write access may modify permissions.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_vfs_objects": {
                "type": "string",
                "description": "Default: None\n\nVFS objects."
              },
              "samba_postexec": {
                "type": "string",
                "description": "Default: None\n\nPostexec script."
              },
              "samba_oplocks": {
                "description": "Default: 1\n\nOplocks.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_hosts_deny": {
                "description": "Denied host/network.",
                "$ref": "#/definitions/ansible_array"
              },
              "sambaCscPolicy": {
                "type": "string",
                "description": "Default: manual\n\nClient-side caching policy."
              },
              "sambaFakeOplocks": {
                "description": "Default: 0\n\nFake oplocks.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_name": {
                "type": "string",
                "description": "Default: None\n\nWindows name. Required if C(state=present)."
              },
              "sambaNtAclSupport": {
                "description": "Default: 1\n\nNT ACL support.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sync": {
                "type": "string",
                "description": "Default: sync\n\nNFS synchronisation."
              },
              "sambaInheritOwner": {
                "description": "Default: 0\n\nCreate files/directories with the owner of the parent directory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaPostexec": {
                "type": "string",
                "description": "Default: None\n\nPostexec script."
              },
              "sambaHideFiles": {
                "type": "string",
                "description": "Default: None\n\nHide files."
              },
              "sambaForceDirectoryMode": {
                "description": "Default: 0\n\nForce directory mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_preexec": {
                "type": "string",
                "description": "Default: None\n\nPreexec script."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the share is present or not."
              },
              "sambaPreexec": {
                "type": "string",
                "description": "Default: None\n\nPreexec script."
              },
              "sambaForceGroup": {
                "type": "string",
                "description": "Default: None\n\nForce group."
              },
              "sambaInheritPermissions": {
                "description": "Default: 0\n\nCreate files/directories with permissions of the parent directory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_locking": {
                "description": "Default: 1\n\nLocking.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_security_mode": {
                "type": "string",
                "description": "Default: 0777\n\nSecurity mode."
              },
              "samba_inherit_owner": {
                "description": "Default: 0\n\nCreate files/directories with the owner of the parent directory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_force_directory_security_mode": {
                "description": "Default: 0\n\nForce directory security mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "nfs_hosts": {
                "description": "Only allow access for this host, IP address or network.",
                "$ref": "#/definitions/ansible_array"
              },
              "path": {
                "type": "string",
                "description": "Default: None\n\nDirectory on the providing server, e.g. C(/home). Required if C(state=present)."
              },
              "nfs_custom_settings": {
                "description": "Option name in exports file.",
                "$ref": "#/definitions/ansible_array"
              },
              "sambaHostsDeny": {
                "description": "Denied host/network.",
                "$ref": "#/definitions/ansible_array"
              },
              "sambaInvalidUsers": {
                "type": "string",
                "description": "Default: None\n\nInvalid users or groups."
              },
              "subtree_checking": {
                "description": "Default: 1\n\nSubtree checking.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": "Default: None\n\nHost FQDN (server which provides the share), e.g. C({{ ansible_fqdn }}). Required if C(state=present)."
              },
              "directorymode": {
                "type": "string",
                "description": "Default: 00755\n\nPermissions for the share's root directory."
              },
              "ou": {
                "type": "string",
                "description": "Organisational unit, inside the LDAP Base DN."
              },
              "sambaForceDirectorySecurityMode": {
                "description": "Default: 0\n\nForce directory security mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaLevel2Oplocks": {
                "description": "Default: 1\n\nLevel 2 oplocks.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaDirectorySecurityMode": {
                "type": "string",
                "description": "Default: 0777\n\nDirectory security mode."
              },
              "samba_custom_settings": {
                "description": "Option name in smb.conf and its value.",
                "$ref": "#/definitions/ansible_array"
              },
              "owner": {
                "type": "string",
                "description": "Directory owner of the share's root directory."
              },
              "sambaName": {
                "type": "string",
                "description": "Default: None\n\nWindows name. Required if C(state=present)."
              },
              "sambaValidUsers": {
                "type": "string",
                "description": "Default: None\n\nValid users or groups."
              },
              "samba_strict_locking": {
                "type": "string",
                "description": "Default: Auto\n\nStrict locking."
              },
              "samba_public": {
                "description": "Default: 0\n\nAllow anonymous read-only access with a guest user.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_writeable": {
                "description": "Default: 1\n\nSamba write access.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_valid_users": {
                "type": "string",
                "description": "Default: None\n\nValid users or groups."
              },
              "root_squash": {
                "description": "Default: 1\n\nModify user ID for root user (root squashing).",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaHideUnreadable": {
                "description": "Default: 0\n\nHide unreadable files/directories.",
                "$ref": "#/definitions/ansible_truth"
              },
              "writeable": {
                "description": "Default: 1\n\nNFS write access.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaSecurityMode": {
                "type": "string",
                "description": "Default: 0777\n\nSecurity mode."
              },
              "sambaForceSecurityMode": {
                "description": "Default: 0\n\nForce security mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaStrictLocking": {
                "type": "string",
                "description": "Default: Auto\n\nStrict locking."
              },
              "sambaDirectoryMode": {
                "type": "string",
                "description": "Default: 0755\n\nDirectory mode."
              },
              "samba_force_user": {
                "type": "string",
                "description": "Default: None\n\nForce user."
              },
              "samba_invalid_users": {
                "type": "string",
                "description": "Default: None\n\nInvalid users or groups."
              },
              "samba_directory_mode": {
                "type": "string",
                "description": "Default: 0755\n\nDirectory mode."
              },
              "samba_level_2_oplocks": {
                "description": "Default: 1\n\nLevel 2 oplocks.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_inherit_permissions": {
                "description": "Default: 0\n\nCreate files/directories with permissions of the parent directory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_create_mode": {
                "type": "string",
                "description": "Default: 0744\n\nFile mode."
              },
              "samba_fake_oplocks": {
                "description": "Default: 0\n\nFake oplocks.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaCustomSettings": {
                "description": "Option name in smb.conf and its value.",
                "$ref": "#/definitions/ansible_array"
              },
              "sambaBrowseable": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_nt_acl_support": {
                "description": "Default: 1\n\nNT ACL support.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaDosFilemode": {
                "description": "Default: 0\n\nUsers with write access may modify permissions.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_block_size": {
                "type": "string",
                "description": "Default: None\n\nBlocking size."
              },
              "sambaInheritAcls": {
                "description": "Default: 1\n\nInherit ACLs.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_force_create_mode": {
                "description": "Default: 0\n\nForce file mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_force_group": {
                "type": "string",
                "description": "Default: None\n\nForce group."
              },
              "samba_hide_unreadable": {
                "description": "Default: 0\n\nHide unreadable files/directories.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaWriteList": {
                "type": "string",
                "description": "Default: None\n\nRestrict write access to these users/groups."
              },
              "sambaVFSObjects": {
                "type": "string",
                "description": "Default: None\n\nVFS objects."
              },
              "samba_csc_policy": {
                "type": "string",
                "description": "Default: manual\n\nClient-side caching policy."
              },
              "sambaForceUser": {
                "type": "string",
                "description": "Default: None\n\nForce user."
              },
              "sambaOplocks": {
                "description": "Default: 1\n\nOplocks.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaWriteable": {
                "description": "Default: 1\n\nSamba write access.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaLocking": {
                "description": "Default: 1\n\nLocking.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_blocking_locks": {
                "description": "Default: 1\n\nBlocking locks.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sambaPublic": {
                "description": "Default: 0\n\nAllow anonymous read-only access with a guest user.",
                "$ref": "#/definitions/ansible_truth"
              },
              "samba_hosts_allow": {
                "description": "Allowed host/network.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "aos_logical_device_map": {
            "required": [
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS Logical Device Map module let you manage your Logical Device Map easily. You can create create and delete Logical Device Map by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "content": {
                "type": "string",
                "description": "Datastructure of the Logical Device Map to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value). Only one of I(name), I(id) or I(content) can be set."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the Logical Device Map (present or not)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "id": {
                "type": "string",
                "description": "AOS Id of the Logical Device Map to manage (can't be used to create a new Logical Device Map), Only one of I(name), I(id) or I(content) can be set."
              },
              "name": {
                "type": "string",
                "description": "Name of the Logical Device Map to manage. Only one of I(name), I(id) or I(content) can be set."
              }
            }
          },
          "netapp_e_amg_role": {
            "required": [
              "api_url",
              "name",
              "role",
              "ssid"
            ],
            "type": "object",
            "description": "Update a storage array to become the primary or secondary instance in an asynchronous mirror group",
            "properties": {
              "ssid": {
                "type": "string",
                "description": "The ID of the primary storage array for the async mirror action"
              },
              "force": {
                "description": "Whether to force the role reversal regardless of the online-state of the primary",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "role": {
                "enum": [
                  "primary",
                  "secondary"
                ],
                "type": "string",
                "description": "Whether the array should be the primary or secondary array for the AMG"
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "noSync": {
                "description": "Whether to avoid synchronization prior to role reversal",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": ""
              }
            }
          },
          "user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage user accounts and user attributes.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Optionally sets the description (aka I(GECOS)) of user account."
              },
              "ssh_key_bits": {
                "description": "Default: default set by ssh-keygen\n\nOptionally specify number of bits in SSH key to create.",
                "$ref": "#/definitions/ansible_number"
              },
              "update_password": {
                "enum": [
                  "always",
                  "on_create"
                ],
                "type": "string",
                "description": "Default: always\n\nC(always) will update passwords if they differ.  C(on_create) will only set the password for newly created users."
              },
              "ssh_key_passphrase": {
                "type": "string",
                "description": "Set a passphrase for the SSH key.  If no passphrase is provided, the SSH key will default to having no passphrase."
              },
              "force": {
                "description": "Default: no\n\nWhen used with C(state=absent), behavior is as with C(userdel --force).",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_key_type": {
                "type": "string",
                "description": "Default: rsa\n\nOptionally specify the type of SSH key to generate. Available SSH key types will depend on implementation present on target host."
              },
              "non_unique": {
                "description": "Default: no\n\nOptionally when used with the -u option, this option allows to change the user ID to a non-unique value.",
                "$ref": "#/definitions/ansible_truth"
              },
              "home": {
                "type": "string",
                "description": "Optionally set the user's home directory."
              },
              "skeleton": {
                "type": "string",
                "description": "Optionally set a home skeleton directory. Requires createhome option!"
              },
              "append": {
                "description": "Default: no\n\nIf C(yes), will only add groups, not set them to just the list in I(groups).",
                "$ref": "#/definitions/ansible_truth"
              },
              "uid": {
                "type": "string",
                "description": "Optionally sets the I(UID) of the user."
              },
              "ssh_key_comment": {
                "type": "string",
                "description": "Default: ansible-generated on $HOSTNAME\n\nOptionally define the comment for the SSH key."
              },
              "group": {
                "type": "string",
                "description": "Optionally sets the user's primary group (takes a group name)."
              },
              "system": {
                "description": "Default: no\n\nWhen creating an account, setting this to C(yes) makes the user a system account.  This setting cannot be changed on existing users.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the account should exist or not, taking action if the state is different from what is stated."
              },
              "shell": {
                "type": "string",
                "description": "Optionally set the user's shell."
              },
              "expires": {
                "type": "number",
                "description": "Default: None\n\nAn expiry time for the user in epoch, it will be ignored on platforms that do not support this. Currently supported on Linux and FreeBSD."
              },
              "ssh_key_file": {
                "type": "string",
                "description": "Default: .ssh/id_rsa\n\nOptionally specify the SSH key filename. If this is a relative filename then it will be relative to the user's home directory."
              },
              "user": {
                "type": "string",
                "description": "Name of the user to create, remove or modify."
              },
              "groups": {
                "description": "Puts the user in  list of groups. When set to the empty string ('groups='), the user is removed from all groups except the primary group.\nBefore version 2.3, the only input format allowed was a 'comma separated string', now it should be able to accept YAML lists also.",
                "$ref": "#/definitions/ansible_array"
              },
              "move_home": {
                "description": "Default: no\n\nIf set to C(yes) when used with C(home=), attempt to move the user's home directory to the specified directory if it isn't there already.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "Optionally set the user's password to this crypted value.  See the user example in the github examples directory for what this looks like in a playbook. See U(http://docs.ansible.com/ansible/faq.html#how-do-i-generate-crypted-passwords-for-the-user-module) for details on various ways to generate these password values. Note on Darwin system, this value has to be cleartext. Beware of security issues."
              },
              "seuser": {
                "type": "string",
                "description": "Optionally sets the seuser type (user_u) on selinux enabled systems."
              },
              "name": {
                "type": "string",
                "description": "Name of the user to create, remove or modify."
              },
              "createhome": {
                "description": "Default: yes\n\nUnless set to C(no), a home directory will be made for the user when the account is created or if the home directory does not exist.",
                "$ref": "#/definitions/ansible_truth"
              },
              "remove": {
                "description": "Default: no\n\nWhen used with C(state=absent), behavior is as with C(userdel --remove).",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_class": {
                "type": "string",
                "description": "Optionally sets the user's login class for FreeBSD, OpenBSD and NetBSD systems."
              },
              "generate_ssh_key": {
                "description": "Default: no\n\nWhether to generate a SSH key for the user in question. This will B(not) overwrite an existing SSH key.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_groups_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt groups.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search group X use following pattern: name=X"
              }
            }
          },
          "nxos_snmp_host": {
            "required": [
              "snmp_host"
            ],
            "type": "object",
            "description": "Manages SNMP host configuration parameters.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "vrf_filter": {
                "type": "string",
                "description": "Name of VRF to filter."
              },
              "udp": {
                "type": "string",
                "description": "UDP port number (0-65535)."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "snmp_type": {
                "enum": [
                  "trap",
                  "inform"
                ],
                "type": "string",
                "description": ""
              },
              "src_intf": {
                "type": "string",
                "description": "Source interface."
              },
              "snmp_host": {
                "type": "string",
                "description": "IP address of hostname of target host."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "community": {
                "type": "string",
                "description": "Community string or v3 username."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "version": {
                "enum": [
                  "v2c",
                  "v3"
                ],
                "type": "string",
                "description": "Default: v2c\n\nSNMP version."
              },
              "v3": {
                "enum": [
                  "noauth",
                  "auth",
                  "priv"
                ],
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "vrf": {
                "type": "string",
                "description": "VRF to use to source traffic to source."
              }
            }
          },
          "azure_rm_resourcegroup_facts": {
            "type": "object",
            "description": "Get facts for a specific resource group or all resource groups.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Limit results to a specific resource group."
              },
              "tags": {
                "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
                "$ref": "#/definitions/ansible_array"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "bigip_selfip": {
            "type": "object",
            "description": "Manage Self-IPs on a BIG-IP system",
            "properties": {
              "name": {
                "type": "string",
                "description": "Default: Value of C(address)\n\nThe self IP to create."
              },
              "vlan": {
                "type": "string",
                "description": "The VLAN that the new self IPs will be on."
              },
              "netmask": {
                "type": "string",
                "description": "The netmasks for the self IP."
              },
              "allow_service": {
                "type": "string",
                "description": "Configure port lockdown for the Self IP. By default, the Self IP has a \"default deny\" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain C(protocol):C(port) values."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nThe state of the variable on the system. When C(present), guarantees that the Self-IP exists with the provided attributes. When C(absent), removes the Self-IP from the system."
              },
              "address": {
                "type": "string",
                "description": "The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created."
              },
              "traffic_group": {
                "type": "string",
                "description": "The traffic group for the self IP addresses in an active-active, redundant load balancer configuration."
              }
            }
          },
          "win_user": {
            "type": "object",
            "description": "Manages local Windows user accounts",
            "properties": {
              "update_password": {
                "type": "string",
                "description": "Default: always\n\nC(always) will update passwords if they differ.  C(on_create) will only set the password for newly created users."
              },
              "password_never_expires": {
                "type": "string",
                "description": "C(yes) will set the password to never expire.  C(no) will allow the password to expire."
              },
              "name": {
                "type": "string",
                "description": "Name of the user to create, remove or modify."
              },
              "groups_action": {
                "type": "string",
                "description": "Default: replace\n\nIf C(replace), the user is added as a member of each group in I(groups) and removed from any other groups.  If C(add), the user is added to each group in I(groups) where not already a member.  If C(remove), the user is removed from each group in I(groups)."
              },
              "password_expired": {
                "type": "string",
                "description": "C(yes) will require the user to change their password at next login. C(no) will clear the expired password flag."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhen C(present), creates or updates the user account.  When C(absent), removes the user account if it exists.  When C(query) (new in 1.9), retrieves the user account details without making any changes."
              },
              "groups": {
                "type": "string",
                "description": "Adds or removes the user from this comma-separated lis of groups, depending on the value of I(groups_action). When I(groups_action) is C(replace) and I(groups) is set to the empty string ('groups='), the user is removed from all groups."
              },
              "account_disabled": {
                "type": "string",
                "description": "C(yes) will disable the user account.  C(no) will clear the disabled flag."
              },
              "fullname": {
                "type": "string",
                "description": "Full name of the user"
              },
              "password": {
                "type": "string",
                "description": "Optionally set the user's password to this (plain text) value."
              },
              "account_locked": {
                "type": "string",
                "description": "C(no) will unlock the user account if locked."
              },
              "user_cannot_change_password": {
                "type": "string",
                "description": "C(yes) will prevent the user from changing their password.  C(no) will allow the user to change their password."
              },
              "description": {
                "type": "string",
                "description": "Description of the user"
              }
            }
          },
          "ops_command": {
            "type": "object",
            "description": "Sends arbitrary commands to an OpenSwitch node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.",
            "properties": {
              "retries": {
                "type": "string",
                "description": "Default: 10\n\nSpecifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions."
              },
              "commands": {
                "type": "string",
                "description": "List of commands to send to the remote ops device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired."
              },
              "wait_for": {
                "type": "string",
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples."
              },
              "match": {
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "interval": {
                "type": "string",
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between I(retries) of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again."
              }
            }
          },
          "nxos_overlay_global": {
            "required": [
              "anycast_gateway_mac"
            ],
            "type": "object",
            "description": "Configures anycast gateway MAC of the switch.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "m_facts": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "anycast_gateway_mac": {
                "type": "string",
                "description": "Anycast gateway mac of the switch."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "irc": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "color",
                        "colour"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Send a message to an IRC channel. This is a very simplistic implementation.",
            "properties": {
              "style": {
                "enum": [
                  "underline",
                  "reverse",
                  "bold",
                  "italic",
                  "none"
                ],
                "type": "string",
                "description": "Default: None\n\nText style for the message. Note italic does not work on some clients"
              },
              "timeout": {
                "description": "Default: 30\n\nTimeout to use while waiting for successful registration and join messages, this is to prevent an endless loop",
                "$ref": "#/definitions/ansible_number"
              },
              "passwd": {
                "type": "string",
                "description": "Server password"
              },
              "colour": {
                "enum": [
                  "none",
                  "white",
                  "black",
                  "blue",
                  "green",
                  "red",
                  "brown",
                  "purple",
                  "orange",
                  "yellow",
                  "light_green",
                  "teal",
                  "light_cyan",
                  "light_blue",
                  "pink",
                  "gray",
                  "light_gray"
                ],
                "type": "string",
                "description": "Default: none\n\nText color for the message. (\"none\" is a valid option in 1.6 or later, in 1.6 and prior, the default color is black, not \"none\"). Added 11 more colors in version 2.0."
              },
              "server": {
                "type": "string",
                "description": "Default: localhost\n\nIRC server name/address"
              },
              "topic": {
                "type": "string",
                "description": "Set the channel topic"
              },
              "nick": {
                "type": "string",
                "description": "Default: ansible\n\nNickname to send the message from. May be shortened, depending on server's NICKLEN setting."
              },
              "color": {
                "enum": [
                  "none",
                  "white",
                  "black",
                  "blue",
                  "green",
                  "red",
                  "brown",
                  "purple",
                  "orange",
                  "yellow",
                  "light_green",
                  "teal",
                  "light_cyan",
                  "light_blue",
                  "pink",
                  "gray",
                  "light_gray"
                ],
                "type": "string",
                "description": "Default: none\n\nText color for the message. (\"none\" is a valid option in 1.6 or later, in 1.6 and prior, the default color is black, not \"none\"). Added 11 more colors in version 2.0."
              },
              "part": {
                "description": "Default: True\n\nDesignates whether user should part from channel after sending message or not. Useful for when using a faux bot and not wanting join/parts between messages.",
                "$ref": "#/definitions/ansible_truth"
              },
              "nick_to": {
                "description": "A list of nicknames to send the message to. One of nick_to or channel needs to be set.  When both are defined, the message will be sent to both of them.",
                "$ref": "#/definitions/ansible_array"
              },
              "key": {
                "type": "string",
                "description": "Channel key"
              },
              "msg": {
                "type": "string",
                "description": "The message body."
              },
              "use_ssl": {
                "description": "Designates whether TLS/SSL should be used when connecting to the IRC server",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "Default: 6667\n\nIRC server port number",
                "$ref": "#/definitions/ansible_number"
              },
              "channel": {
                "type": "string",
                "description": "Channel name.  One of nick_to or channel needs to be set.  When both are set, the message will be sent to both of them."
              }
            }
          },
          "vmware_vmkernel": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create a VMware VMkernel Interface",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "portgroup_name": {
                "type": "string",
                "description": "The name of the portgroup for the VMK interface"
              },
              "enable_vsan": {
                "description": "Enable the VMK interface for VSAN traffic",
                "$ref": "#/definitions/ansible_truth"
              },
              "enable_vmotion": {
                "description": "Enable the VMK interface for vMotion traffic",
                "$ref": "#/definitions/ansible_truth"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "enable_mgmt": {
                "description": "Enable the VMK interface for Management traffic",
                "$ref": "#/definitions/ansible_truth"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "mtu": {
                "description": "The MTU for the VMK interface",
                "$ref": "#/definitions/ansible_number"
              },
              "subnet_mask": {
                "type": "string",
                "description": "The Subnet Mask for the VMK interface"
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "vswitch_name": {
                "type": "string",
                "description": "The name of the vswitch where to add the VMK interface"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "ip_address": {
                "type": "string",
                "description": "The IP Address for the VMK interface"
              },
              "vlan_id": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "enable_ft": {
                "description": "Enable the VMK interface for Fault Tolerance traffic",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ipa_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "uid",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "uid"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify and delete user within IPA server",
            "properties": {
              "telephonenumber": {
                "description": "List of telephone numbers assigned to the user.\nIf an empty list is passed all assigned telephone numbers will be deleted.\nIf None is passed telephone numbers will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "sshpubkey": {
                "description": "List of public SSH key.\nIf an empty list is passed all assigned public keys will be deleted.\nIf None is passed SSH public keys will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_port": {
                "description": "Default: 443\n\nPort of IPA server",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": "Password"
              },
              "displayname": {
                "type": "string",
                "description": "Display name"
              },
              "uid": {
                "type": "string",
                "description": "uid of the user"
              },
              "title": {
                "type": "string",
                "description": "Title"
              },
              "loginshell": {
                "type": "string",
                "description": "Login shell"
              },
              "sn": {
                "type": "string",
                "description": "Surname"
              },
              "ipa_prot": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nProtocol used by IPA server"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState to ensure"
              },
              "ipa_host": {
                "type": "string",
                "description": "Default: ipa.example.com\n\nIP or hostname of IPA server"
              },
              "ipa_user": {
                "type": "string",
                "description": "Default: admin\n\nAdministrative account used on IPA server"
              },
              "ipa_pass": {
                "type": "string",
                "description": "Password of administrative user"
              },
              "mail": {
                "description": "List of mail addresses assigned to the user.\nIf an empty list is passed all assigned email addresses will be deleted.\nIf None is passed email addresses will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "givenname": {
                "type": "string",
                "description": "First name"
              },
              "validate_certs": {
                "description": "Default: True\n\nThis only applies if C(ipa_prot) is I(https).\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "uid of the user"
              }
            }
          },
          "pn_show": {
            "required": [
              "pn_clipassword",
              "pn_command",
              "pn_cliusername"
            ],
            "type": "object",
            "description": "Execute show command in the nodes and returns the results read from the device.",
            "properties": {
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_command": {
                "type": "string",
                "description": "The C(pn_command) takes a CLI show command as value."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "pn_parameters": {
                "type": "string",
                "description": "Display output using a specific parameter. Use 'all' to display possible output. List of comma separated parameters."
              },
              "pn_options": {
                "type": "string",
                "description": "Specify formatting options."
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch(es) to run the cli on."
              }
            }
          },
          "ovirt_affinity_labels_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt affinity labels.",
            "properties": {
              "host": {
                "type": "string",
                "description": "Name of the host, which affinity labels should be listed."
              },
              "name": {
                "type": "string",
                "description": "Name of the affinity labels which should be listed."
              },
              "vm": {
                "type": "string",
                "description": "Name of the VM, which affinity labels should be listed."
              }
            }
          },
          "os_network": {
            "type": "object",
            "description": "Add or remove network from OpenStack.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name to be assigned to the network."
              },
              "provider_network_type": {
                "type": "string",
                "description": "Default: None\n\nThe type of physical network that maps to this network resource."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "admin_state_up": {
                "type": "string",
                "description": "Default: True\n\nWhether the state should be marked as up or down."
              },
              "provider_physical_network": {
                "type": "string",
                "description": "Default: None\n\nThe physical network where this network object is implemented."
              },
              "project": {
                "type": "string",
                "description": "Default: None\n\nProject name or ID containing the network (name admin-only)"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource."
              },
              "provider_segmentation_id": {
                "type": "string",
                "description": "Default: None\n\nAn isolated segment on the physical network. The I(network_type) attribute defines the segmentation model. For example, if the I(network_type) value is vlan, this ID is a vlan identifier. If the I(network_type) value is gre, this ID is a gre key."
              },
              "external": {
                "type": "string",
                "description": "Whether this network is externally accessible."
              },
              "shared": {
                "type": "string",
                "description": "Whether this network is shared or not."
              }
            }
          },
          "bigip_device_dns": {
            "type": "object",
            "description": "Manage BIG-IP device DNS settings",
            "properties": {
              "search": {
                "type": "string",
                "description": "A list of domains that the system searches for local domain lookups, to resolve local host names."
              },
              "cache": {
                "type": "string",
                "description": "Default: disable\n\nSpecifies whether the system caches DNS lookups or performs the operation each time a lookup is needed. Please note that this applies only to Access Policy Manager features, such as ACLs, web application rewrites, and authentication."
              },
              "ip_version": {
                "type": "string",
                "description": "Specifies whether the DNS specifies IP addresses using IPv4 or IPv6."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nThe state of the variable on the system. When C(present), guarantees that an existing variable is set to C(value)."
              },
              "forwarders": {
                "type": "string",
                "description": "A list of BIND servers that the system can use to perform DNS lookups"
              },
              "name_servers": {
                "type": "string",
                "description": "A list of name serverz that the system uses to validate DNS lookups"
              }
            }
          },
          "ec2_vol": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "zone",
                        "availability_zone",
                        "aws_zone",
                        "ec2_zone"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "creates an EBS volume and optionally attaches it to an instance. If both an instance ID and a device name is given and the instance has a device at the device name, then no volume is created and no attachment is made. This module has a dependency on python-boto.",
            "properties": {
              "availability_zone": {
                "type": "string",
                "description": "zone in which to create the volume, if unset uses the zone the instance is in (if set)"
              },
              "encrypted": {
                "description": "Enable encryption at rest for this volume.",
                "$ref": "#/definitions/ansible_truth"
              },
              "kms_key_id": {
                "type": "string",
                "description": "Specify the id of the KMS key to use."
              },
              "iops": {
                "type": "string",
                "description": "Default: 100\n\nthe provisioned IOPs you want to associate with this volume (integer)."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_zone": {
                "type": "string",
                "description": "zone in which to create the volume, if unset uses the zone the instance is in (if set)"
              },
              "id": {
                "type": "string",
                "description": "volume id if you wish to attach an existing volume (requires instance) or remove an existing volume"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "zone": {
                "type": "string",
                "description": "zone in which to create the volume, if unset uses the zone the instance is in (if set)"
              },
              "instance": {
                "type": "string",
                "description": "instance ID if you wish to attach the volume. Since 1.9 you can set to None to detach."
              },
              "volume_size": {
                "type": "string",
                "description": "size of volume (in GB) to create."
              },
              "state": {
                "enum": [
                  "absent",
                  "present",
                  "list"
                ],
                "type": "string",
                "description": "Default: present\n\nwhether to ensure the volume is present or absent, or to list existing volumes (The C(list) option was added in version 1.8)."
              },
              "delete_on_termination": {
                "description": "Default: no\n\nWhen set to \"yes\", the volume will be deleted upon instance termination.",
                "$ref": "#/definitions/ansible_truth"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_zone": {
                "type": "string",
                "description": "zone in which to create the volume, if unset uses the zone the instance is in (if set)"
              },
              "tags": {
                "type": "object",
                "description": "tag:value pairs to add to the volume after creation"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "volume Name tag if you wish to attach an existing volume (requires instance)"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "volume_type": {
                "enum": [
                  "standard",
                  "gp2",
                  "io1",
                  "st1",
                  "sc1"
                ],
                "type": "string",
                "description": "Default: standard\n\nType of EBS volume; standard (magnetic), gp2 (SSD), io1 (Provisioned IOPS), st1 (Throughput Optimized HDD), sc1 (Cold HDD). \"Standard\" is the old EBS default and continues to remain the Ansible default for backwards compatibility."
              },
              "device_name": {
                "type": "string",
                "description": "device id to override device mapping. Assumes /dev/sdf for Linux/UNIX and /dev/xvdf for Windows."
              },
              "snapshot": {
                "type": "string",
                "description": "snapshot ID on which to base the volume"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "Default: yes\n\nWhen set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "clc_modify_server": {
            "required": [
              "server_ids"
            ],
            "type": "object",
            "description": "An Ansible module to modify servers in CenturyLink Cloud.",
            "properties": {
              "alert_policy_name": {
                "type": "string",
                "description": "Default: None\n\nThe alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'"
              },
              "anti_affinity_policy_name": {
                "type": "string",
                "description": "Default: None\n\nThe anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_id'"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state to insure that the provided resources are in."
              },
              "anti_affinity_policy_id": {
                "type": "string",
                "description": "Default: None\n\nThe anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_name'"
              },
              "alert_policy_id": {
                "type": "string",
                "description": "Default: None\n\nThe alert policy id to be associated to the server. This is mutually exclusive with 'alert_policy_name'"
              },
              "memory": {
                "type": "string",
                "description": "Default: None\n\nMemory (in GB) to set to the server."
              },
              "server_ids": {
                "description": "A list of server Ids to modify.",
                "$ref": "#/definitions/ansible_array"
              },
              "cpu": {
                "type": "string",
                "description": "Default: None\n\nHow many CPUs to update on the server"
              },
              "wait": {
                "description": "Default: True\n\nWhether to wait for the provisioning tasks to finish before returning.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cnos_reload": {
            "type": "object",
            "description": "This module allows you to restart the switch using the current startup configuration. The module is usually invoked after the running configuration has been saved over the startup configuration. This module uses SSH to manage network device configuration. The results of the operation can be viewed in results directory. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_reload.html)",
            "properties": {}
          },
          "ipa_hbacrule": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cn",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "cn"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify or delete an IPA HBAC rule using IPA API.",
            "properties": {
              "cn": {
                "type": "string",
                "description": "Canonical name.\nCan not be changed as it is the unique identifier."
              },
              "ipa_host": {
                "type": "string",
                "description": "Default: ipa.example.com\n\nIP or hostname of IPA server"
              },
              "usergroup": {
                "description": "List of user group names to assign.\nIf an empty list if passed all assigned user groups will be removed from the rule.\nIf option is omitted user groups will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "servicegroup": {
                "description": "List of service group names to assign.\nIf an empty list is passed all assigned service groups will be removed from the rule.\nIf option is omitted service groups will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "service": {
                "description": "List of service names to assign.\nIf an empty list is passed all services will be removed from the rule.\nIf option is omitted services will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState to ensure"
              },
              "ipa_pass": {
                "type": "string",
                "description": "Password of administrative user"
              },
              "sourcehostcategory": {
                "enum": [
                  "all"
                ],
                "type": "string",
                "description": "Source host category"
              },
              "description": {
                "type": "string",
                "description": "Description"
              },
              "servicecategory": {
                "enum": [
                  "all"
                ],
                "type": "string",
                "description": "Service category"
              },
              "host": {
                "description": "List of host names to assign.\nIf an empty list is passed all hosts will be removed from the rule.\nIf option is omitted hosts will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "user": {
                "description": "List of user names to assign.\nIf an empty list if passed all assigned users will be removed from the rule.\nIf option is omitted users will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_port": {
                "description": "Default: 443\n\nPort of IPA server",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Canonical name.\nCan not be changed as it is the unique identifier."
              },
              "ipa_prot": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nProtocol used by IPA server"
              },
              "hostcategory": {
                "enum": [
                  "all"
                ],
                "type": "string",
                "description": "Host category"
              },
              "hostgroup": {
                "description": "List of hostgroup names to assign.\nIf an empty list is passed all hostgroups will be removed. from the rule\nIf option is omitted hostgroups will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "usercategory": {
                "enum": [
                  "all"
                ],
                "type": "string",
                "description": "User category"
              },
              "ipa_user": {
                "type": "string",
                "description": "Default: admin\n\nAdministrative account used on IPA server"
              },
              "validate_certs": {
                "description": "Default: True\n\nThis only applies if C(ipa_prot) is I(https).\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sourcehostgroup": {
                "description": "List of source host group names to assign.\nIf an empty list if passed all assigned source host groups will be removed from the rule.\nIf option is omitted source host groups will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "sourcehost": {
                "description": "List of source host names to assign.\nIf an empty list if passed all assigned source hosts will be removed from the rule.\nIf option is omitted source hosts will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "rabbitmq_queue": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module uses rabbitMQ Rest API to create/delete queues",
            "properties": {
              "login_port": {
                "type": "string",
                "description": "Default: 15672\n\nrabbitMQ management api port"
              },
              "dead_letter_exchange": {
                "type": "string",
                "description": "Default: None\n\nOptional name of an exchange to which messages will be republished if they\nare rejected or expire"
              },
              "name": {
                "type": "string",
                "description": "Name of the queue to create"
              },
              "login_user": {
                "type": "string",
                "description": "Default: guest\n\nrabbitMQ user for connection"
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nrabbitMQ host for connection"
              },
              "login_password": {
                "type": "string",
                "description": "rabbitMQ password for connection"
              },
              "vhost": {
                "type": "string",
                "description": "Default: /\n\nrabbitMQ virtual host"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the queue should be present or absent\nOnly present implemented atm"
              },
              "max_length": {
                "description": "Default: no limit\n\nHow many messages can the queue contain before it starts rejecting",
                "$ref": "#/definitions/ansible_number"
              },
              "arguments": {
                "type": "object",
                "description": "extra arguments for queue. If defined this argument is a key/value dictionary"
              },
              "auto_delete": {
                "description": "if the queue should delete itself after all queues/queues unbound from it",
                "$ref": "#/definitions/ansible_truth"
              },
              "message_ttl": {
                "description": "Default: forever\n\nHow long a message can live in queue before it is discarded (milliseconds)",
                "$ref": "#/definitions/ansible_number"
              },
              "auto_expires": {
                "description": "Default: forever\n\nHow long a queue can be unused before it is automatically deleted (milliseconds)",
                "$ref": "#/definitions/ansible_number"
              },
              "dead_letter_routing_key": {
                "type": "string",
                "description": "Default: None\n\nOptional replacement routing key to use when a message is dead-lettered.\nOriginal routing key will be used if unset"
              },
              "durable": {
                "description": "Default: True\n\nwhether queue is durable or not",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "netapp_e_host": {
            "required": [
              "host_type_index",
              "api_url",
              "api_password",
              "name",
              "state",
              "api_username",
              "ssid"
            ],
            "type": "object",
            "description": "Create, update, remove hosts on NetApp E-series storage arrays",
            "properties": {
              "ssid": {
                "type": "string",
                "description": "the id of the storage array you wish to act against"
              },
              "group": {
                "type": "string",
                "description": "the group you want the host to be a member of"
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "force_port": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": ""
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "host_type_index": {
                "description": "The index that maps to host type you wish to create. It is recommended to use the M(netapp_e_facts) module to gather this information. Alternatively you can use the WSP portal to retrieve the information.",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "ports": {
                "description": "a list of of dictionaries of host ports you wish to associate with the newly created host",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "If the host doesnt yet exist, the label to assign at creation time.\nIf the hosts already exists, this is what is used to identify the host to apply any desired changes"
              }
            }
          },
          "os_server_group": {
            "type": "object",
            "description": "Add or remove server groups from OpenStack.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource. When I(state) is 'present', then I(policies) is required."
              },
              "name": {
                "type": "string",
                "description": "Server group name."
              },
              "policies": {
                "type": "string",
                "description": "A list of one or more policy names to associate with the server group. The list must contain at least one policy name. The current valid policy names are anti-affinity, affinity, soft-anti-affinity and soft-affinity."
              }
            }
          },
          "postgresql_ext": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "ext",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "ext"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove PostgreSQL extensions from a database.",
            "properties": {
              "name": {
                "type": "string",
                "description": "name of the extension to add or remove"
              },
              "login_user": {
                "type": "string",
                "description": "The username used to authenticate with"
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nHost running the database"
              },
              "db": {
                "type": "string",
                "description": "name of the database to add or remove the extension to/from"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe database extension state"
              },
              "ext": {
                "type": "string",
                "description": "name of the extension to add or remove"
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with"
              },
              "port": {
                "type": "string",
                "description": "Default: 5432\n\nDatabase port to connect to."
              }
            }
          },
          "homebrew": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "install_options",
                        "options"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg",
                        "package",
                        "formula"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_homebrew",
                        "update-brew"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "upgrade_all",
                        "upgrade"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages Homebrew packages",
            "properties": {
              "install_options": {
                "description": "options flags to install a package",
                "$ref": "#/definitions/ansible_array"
              },
              "upgrade": {
                "description": "upgrade all homebrew packages",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "Default: None\n\nname of package to install/remove",
                "$ref": "#/definitions/ansible_array"
              },
              "package": {
                "description": "Default: None\n\nname of package to install/remove",
                "$ref": "#/definitions/ansible_array"
              },
              "update_homebrew": {
                "description": "update homebrew itself first",
                "$ref": "#/definitions/ansible_truth"
              },
              "upgrade_all": {
                "description": "upgrade all homebrew packages",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "latest",
                  "upgraded",
                  "head",
                  "linked",
                  "unlinked",
                  "absent",
                  "removed",
                  "uninstalled"
                ],
                "type": "string",
                "description": "Default: present\n\nstate of the package"
              },
              "update-brew": {
                "description": "update homebrew itself first",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "Default: None\n\nname of package to install/remove",
                "$ref": "#/definitions/ansible_array"
              },
              "path": {
                "type": "string",
                "description": "Default: /usr/local/bin\n\n':' separated list of paths to search for 'brew' executable. Since A package (I(formula) in homebrew parlance) location is prefixed relative to the actual path of I(brew) command, providing an alternative I(brew) path enables managing different set of packages in an alternative location in the system."
              },
              "formula": {
                "description": "Default: None\n\nname of package to install/remove",
                "$ref": "#/definitions/ansible_array"
              },
              "options": {
                "description": "options flags to install a package",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "modprobe": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Add or remove kernel modules.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the module should be present or absent."
              },
              "params": {
                "type": "string",
                "description": "Modules parameters."
              },
              "name": {
                "type": "string",
                "description": "Name of kernel module to manage."
              }
            }
          },
          "postgresql_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "user",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove PostgreSQL users (roles) from a remote host and, optionally, grant the users access to an existing database or tables.\nThe fundamental function of the module is to create, or delete, roles from a PostgreSQL cluster. Privilege assignment, or removal, is an optional step, which works on one database at a time. This allows for the module to be called several times in the same module to modify the permissions on different databases, or to grant permissions to already existing users.\nA user cannot be removed until all the privileges have been stripped from the user. In such situation, if the module tries to remove the user it will fail. To avoid this from happening the fail_on_user option signals the module to try to remove the user, but if not possible keep going; the module will report if changes happened and separately if the user was removed or not.",
            "properties": {
              "ssl_rootcert": {
                "type": "string",
                "description": "Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities."
              },
              "ssl_mode": {
                "enum": [
                  "disable",
                  "allow",
                  "prefer",
                  "require",
                  "verify-ca",
                  "verify-full"
                ],
                "type": "string",
                "description": "Default: prefer\n\nDetermines whether or with what priority a secure SSL TCP/IP connection will be negotiated with the server.\nSee https://www.postgresql.org/docs/current/static/libpq-ssl.html for more information on the modes.\nDefault of C(prefer) matches libpq default."
              },
              "name": {
                "type": "string",
                "description": "name of the user (role) to add or remove"
              },
              "no_password_changes": {
                "description": "Default: no\n\nif C(yes), don't inspect database for password changes. Effective when C(pg_authid) is not accessible (such as AWS RDS). Otherwise, make password changes as necessary.",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_user": {
                "type": "string",
                "description": "Default: postgres\n\nUser (role) used to authenticate with PostgreSQL"
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nHost running PostgreSQL."
              },
              "expires": {
                "type": "string",
                "description": "sets the user's password expiration."
              },
              "db": {
                "type": "string",
                "description": "name of database where permissions will be granted"
              },
              "role_attr_flags": {
                "type": "string",
                "description": "PostgreSQL role attributes string in the format: CREATEDB,CREATEROLE,SUPERUSER"
              },
              "login_unix_socket": {
                "type": "string",
                "description": "Path to a Unix domain socket for local connections"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe user (role) state"
              },
              "encrypted": {
                "description": "whether the password is stored hashed in the database. boolean. Passwords can be passed already hashed or unhashed, and postgresql ensures the stored password is hashed when encrypted is set.",
                "$ref": "#/definitions/ansible_truth"
              },
              "user": {
                "type": "string",
                "description": "name of the user (role) to add or remove"
              },
              "login_password": {
                "type": "string",
                "description": "Password used to authenticate with PostgreSQL"
              },
              "password": {
                "type": "string",
                "description": "set the user's password, before 1.4 this was required.\nWhen passing an encrypted password, the encrypted parameter must also be true, and it must be generated with the format C('str[\"md5\"] + md5[ password + username ]'), resulting in a total of 35 characters.  An easy way to do this is: C(echo \"md5`echo -n \"verysecretpasswordJOE\" | md5`\"). Note that if encrypted is set, the stored password will be hashed whether or not it is pre-encrypted."
              },
              "port": {
                "type": "string",
                "description": "Default: 5432\n\nDatabase port to connect to."
              },
              "fail_on_user": {
                "description": "Default: yes\n\nif C(yes), fail when user can't be removed. Otherwise just log and continue",
                "$ref": "#/definitions/ansible_truth"
              },
              "priv": {
                "type": "string",
                "description": "PostgreSQL privileges string in the format: C(table:priv1,priv2)"
              }
            }
          },
          "rax_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts for Rackspace Cloud Servers.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Server name to retrieve facts for"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "address": {
                "type": "string",
                "description": "Server IP address to retrieve facts for, will match any IP assigned to the server"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "id": {
                "type": "string",
                "description": "Server ID to retrieve facts for"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "dladm_iptun": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "local_address",
                        "local"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "type",
                        "tunnel_type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "remote_address",
                        "remote"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage IP tunnel interfaces on Solaris/illumos systems.",
            "properties": {
              "temporary": {
                "description": "Specifies that the IP tunnel interface is temporary. Temporary IP tunnel interfaces do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "IP tunnel interface name."
              },
              "tunnel_type": {
                "enum": [
                  "ipv4",
                  "ipv6",
                  "6to4"
                ],
                "type": "string",
                "description": "Default: ipv4\n\nSpecifies the type of tunnel to be created."
              },
              "local": {
                "type": "string",
                "description": "Literat IP address or hostname corresponding to the tunnel source."
              },
              "remote_address": {
                "type": "string",
                "description": "Literal IP address or hostname corresponding to the tunnel destination."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete Solaris/illumos VNIC."
              },
              "local_address": {
                "type": "string",
                "description": "Literat IP address or hostname corresponding to the tunnel source."
              },
              "type": {
                "enum": [
                  "ipv4",
                  "ipv6",
                  "6to4"
                ],
                "type": "string",
                "description": "Default: ipv4\n\nSpecifies the type of tunnel to be created."
              },
              "remote": {
                "type": "string",
                "description": "Literal IP address or hostname corresponding to the tunnel destination."
              }
            }
          },
          "profitbricks_volume": {
            "type": "object",
            "description": "Allows you to create or remove a volume from a ProfitBricks datacenter. This module has a dependency on profitbricks >= 1.0.0",
            "properties": {
              "count": {
                "description": "Default: 1\n\nThe number of volumes you wish to create.",
                "$ref": "#/definitions/ansible_number"
              },
              "datacenter": {
                "type": "string",
                "description": "The datacenter in which to create the volumes."
              },
              "ssh_keys": {
                "description": "Public SSH keys allowing access to the virtual machine.",
                "$ref": "#/definitions/ansible_array"
              },
              "subscription_user": {
                "type": "string",
                "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable."
              },
              "image_password": {
                "type": "string",
                "description": "Password set for the administrative user."
              },
              "licence_type": {
                "type": "string",
                "description": "Default: UNKNOWN\n\nThe licence type for the volume. This is used when the image is non-standard."
              },
              "auto_increment": {
                "description": "Default: True\n\nWhether or not to increment a single number in the name for created virtual machines.",
                "$ref": "#/definitions/ansible_truth"
              },
              "image": {
                "type": "string",
                "description": "The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID."
              },
              "instance_ids": {
                "description": "list of instance ids, currently only used when state='absent' to remove instances.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "The name of the volumes. You can enumerate the names using auto_increment."
              },
              "subscription_password": {
                "type": "string",
                "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\ncreate or terminate datacenters"
              },
              "wait_timeout": {
                "description": "Default: 600\n\nhow long before wait gives up, in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "bus": {
                "enum": [
                  "IDE",
                  "VIRTIO"
                ],
                "type": "string",
                "description": "Default: VIRTIO\n\nThe bus type."
              },
              "wait": {
                "description": "Default: yes\n\nwait for the datacenter to be created before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "disk_type": {
                "enum": [
                  "HDD",
                  "SSD"
                ],
                "type": "string",
                "description": "Default: HDD\n\nThe disk type of the volume."
              },
              "server": {
                "type": "string",
                "description": ""
              },
              "size": {
                "description": "Default: 10\n\nThe size of the volume.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "azure_rm_publicipaddress": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "domain_name",
                        "domain_name_label"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, update and delete a Public IP address. Allows setting and updating the address allocation method and domain name label. Use the azure_rm_networkinterface module to associate a Public IP with a network interface.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the Public IP."
              },
              "resource_group": {
                "type": "string",
                "description": "Name of resource group with which the Public IP is associated."
              },
              "tags": {
                "type": "object",
                "description": ""
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "append_tags": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "domain_name": {
                "type": "string",
                "description": "The customizable portion of the FQDN assigned to public IP address. This is an explicit setting. If no value is provided, any existing value will be removed on an existing public IP."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nAssert the state of the Public IP. Use 'present' to create or update a and 'absent' to delete."
              },
              "domain_name_label": {
                "type": "string",
                "description": "The customizable portion of the FQDN assigned to public IP address. This is an explicit setting. If no value is provided, any existing value will be removed on an existing public IP."
              },
              "location": {
                "type": "string",
                "description": "Default: resource_group location\n\nValid azure location. Defaults to location of the resource group."
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "allocation_method": {
                "enum": [
                  "Dynamic",
                  "Static"
                ],
                "type": "string",
                "description": "Default: Dynamic\n\nControl whether the assigned Public IP remains permanently assigned to the object. If not set to 'Static', the IP address my changed anytime an associated virtual machine is power cycled."
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              }
            }
          },
          "eos_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends an arbitrary set of commands to an EOS node and returns the results read from the device.  This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "commands": {
                "description": "The commands to send to the remote EOS device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.",
                "$ref": "#/definitions/ansible_array"
              },
              "waitfor": {
                "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should be tried before it is considered failed.  The command is run on the target device every retry and evaluated against the I(wait_for) conditionals.",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command.  If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "match": {
                "enum": [
                  "any",
                  "all"
                ],
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "wait_for": {
                "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "eapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "vyos_system": {
            "type": "object",
            "description": "Runs one or more commands on remote devices running VyOS. This module can also be introspected to validate key parameters before returning successfully.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "name_server": {
                "description": "A list of name servers to use with the device. Mutually exclusive with I(domain_search)",
                "$ref": "#/definitions/ansible_array"
              },
              "domain_search": {
                "description": "A list of domain names to search. Mutually exclusive with I(name_server)",
                "$ref": "#/definitions/ansible_array"
              },
              "domain_name": {
                "type": "string",
                "description": "The new domain name to apply to the device."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to apply (C(present)) or remove (C(absent)) the settings."
              },
              "host_name": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "junos_package": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "src",
                        "package"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "src"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "package"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module can install new and updated packages on remote devices running Junos.  The module will compare the specified package with the one running on the remote device and install the specified version if there is a mismatch",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "The I(src) argument specifies the path to the source package to be installed on the remote device in the advent of a version mismatch. The I(src) argument can be either a localized path or a full path to the package file to install."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "The I(force) argument instructs the module to bypass the package version check and install the packaged identified in I(src) on the remote device.",
                "$ref": "#/definitions/ansible_truth"
              },
              "package": {
                "type": "string",
                "description": "The I(src) argument specifies the path to the source package to be installed on the remote device in the advent of a version mismatch. The I(src) argument can be either a localized path or a full path to the package file to install."
              },
              "no_copy": {
                "description": "The I(no_copy) argument is responsible for instructing the remote device on where to install the package from.  When enabled, the package is transferred to the remote device prior to installing.",
                "$ref": "#/definitions/ansible_truth"
              },
              "reboot": {
                "description": "Default: True\n\nIn order for a package to take effect, the remote device must be restarted.  When enabled, this argument will instruct the module to reboot the device once the updated package has been installed. If disabled or the remote package does not need to be changed, the device will not be started.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "version": {
                "type": "string",
                "description": "The I(version) argument can be used to explicitly specify the version of the package that should be installed on the remote device.  If the I(version) argument is not specified, then the version is extracts from the I(src) filename."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              }
            }
          },
          "cs_affinitygroup": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create and remove affinity groups.",
            "properties": {
              "account": {
                "type": "string",
                "description": "Account the affinity group is related to."
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Description of the affinity group."
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "affinty_type": {
                "type": "string",
                "description": "Type of the affinity group. If not specified, first found affinity type is used."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the affinity group is related to."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the affinity group."
              },
              "domain": {
                "type": "string",
                "description": "Domain the affinity group is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the affinity group."
              }
            }
          },
          "bigip_pool": {
            "type": "object",
            "description": "Manages F5 BIG-IP LTM pools via iControl SOAP API",
            "properties": {
              "monitors": {
                "type": "string",
                "description": "Monitor template name list. Always use the full path to the monitor."
              },
              "lb_method": {
                "type": "string",
                "description": "Default: round_robin\n\nLoad balancing method"
              },
              "quorum": {
                "type": "string",
                "description": "Monitor quorum value when monitor_type is m_of_n"
              },
              "partition": {
                "type": "string",
                "description": "Default: Common\n\nPartition of pool/pool member"
              },
              "slow_ramp_time": {
                "type": "string",
                "description": "Sets the ramp-up time (in seconds) to gradually ramp up the load on newly added or freshly detected up pool members"
              },
              "host": {
                "type": "string",
                "description": "Pool member IP"
              },
              "service_down_action": {
                "type": "string",
                "description": "Sets the action to take when node goes down in pool"
              },
              "reselect_tries": {
                "type": "string",
                "description": "Sets the number of times the system tries to contact a pool member after a passive failure"
              },
              "monitor_type": {
                "type": "string",
                "description": "Monitor rule type when monitors > 1"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nPool/pool member state"
              },
              "port": {
                "type": "string",
                "description": "Pool member port"
              },
              "name": {
                "type": "string",
                "description": "Pool name"
              }
            }
          },
          "cs_host": {
            "type": "object",
            "description": "Create, update and remove hosts.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username for the host.\nRequired if C(state=present) and host does not yet exist."
              },
              "name": {
                "type": "string",
                "description": "Name of the host."
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the host should be deployed.\nIf not set, default zone is used."
              },
              "host_tags": {
                "type": "string",
                "description": "Tags of the host."
              },
              "url": {
                "type": "string",
                "description": "Url of the host used to create a host.\nIf not provided, C(http://) and param C(name) is used as url.\nOnly considered if C(state=present) and host does not yet exist."
              },
              "hypervisor": {
                "type": "string",
                "description": "Name of the cluster.\nRequired if C(state=present) and host does not yet exist."
              },
              "cluster": {
                "type": "string",
                "description": "Name of the cluster."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nState of the host."
              },
              "pod": {
                "type": "string",
                "description": "Name of the pod.\nRequired if C(state=present) and host does not yet exist."
              },
              "password": {
                "type": "string",
                "description": "Password for the host.\nRequired if C(state=present) and host does not yet exist."
              },
              "allocation_state": {
                "type": "string",
                "description": "Allocation state of the host."
              }
            }
          },
          "panos_restart": {
            "type": "object",
            "description": "Restart a device",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              }
            }
          },
          "ec2_vpc_nat_gateway": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Ensure the state of AWS VPC NAT Gateways based on their id, allocation and subnet ids.",
            "properties": {
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "release_eip": {
                "description": "Default: True\n\nDeallocate the EIP from the VPC.\nOption is only valid with the absent state.\nYou should use this with the wait option. Since you can not release an address while a delete operation is happening.",
                "$ref": "#/definitions/ansible_truth"
              },
              "nat_gateway_id": {
                "type": "string",
                "description": "Default: None\n\nThe id AWS dynamically allocates to the NAT Gateway on creation. This is required when the absent option is present."
              },
              "subnet_id": {
                "type": "string",
                "description": "Default: None\n\nThe id of the subnet to create the NAT Gateway in. This is required with the present option."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nEnsure NAT Gateway is present or absent."
              },
              "wait": {
                "description": "Wait for operation to complete before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "eip_address": {
                "type": "string",
                "description": "The elastic IP address of the EIP you want attached to this NAT Gateway. If this is not passed and the allocation_id is not passed, an EIP is generated for this NAT Gateway."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "if_exist_do_not_create": {
                "description": "if a NAT Gateway exists already in the subnet_id, then do not create a new one.",
                "$ref": "#/definitions/ansible_truth"
              },
              "wait_timeout": {
                "description": "Default: 300\n\nHow many seconds to wait for an operation to complete before timing out.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "client_token": {
                "type": "string",
                "description": "Optional unique token to be used during create to ensure idempotency. When specifying this option, ensure you specify the eip_address parameter as well otherwise any subsequent runs will fail."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "allocation_id": {
                "type": "string",
                "description": "Default: None\n\nThe id of the elastic IP allocation. If this is not passed and the eip_address is not passed. An EIP is generated for this NAT Gateway."
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_mtu": {
            "type": "object",
            "description": "Manages MTU settings on Nexus switch.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "sysmtu": {
                "type": "string",
                "description": "System jumbo MTU. Must be an even number between 576 and 9216."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify desired state of the resource."
              },
              "mtu": {
                "type": "string",
                "description": "MTU for a specific interface. Must be an even number between 576 and 9216."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Full name of interface, i.e. Ethernet1/1."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "profitbricks": {
            "type": "object",
            "description": "Create, destroy, update, start, stop, and reboot a ProfitBricks virtual machine. When the virtual machine is created it can optionally wait for it to be 'running' before returning. This module has a dependency on profitbricks >= 1.0.0",
            "properties": {
              "image": {
                "type": "string",
                "description": "The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8."
              },
              "ram": {
                "description": "Default: 2048\n\nThe amount of memory to allocate to the virtual machine.",
                "$ref": "#/definitions/ansible_number"
              },
              "subscription_password": {
                "type": "string",
                "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable."
              },
              "ssh_keys": {
                "description": "Public SSH keys allowing access to the virtual machine.",
                "$ref": "#/definitions/ansible_array"
              },
              "subscription_user": {
                "type": "string",
                "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable."
              },
              "volume_size": {
                "description": "Default: 10\n\nThe size in GB of the boot volume.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\ncreate or terminate instances"
              },
              "location": {
                "enum": [
                  "us/las",
                  "de/fra",
                  "de/fkb"
                ],
                "type": "string",
                "description": "Default: us/las\n\nThe datacenter location. Use only if you want to create the Datacenter or else this value is ignored."
              },
              "assign_public_ip": {
                "description": "This will assign the machine to the public LAN. If no LAN exists with public Internet access it is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "auto_increment": {
                "description": "Default: True\n\nWhether or not to increment a single number in the name for created virtual machines.",
                "$ref": "#/definitions/ansible_truth"
              },
              "lan": {
                "description": "Default: 1\n\nThe ID of the LAN you wish to add the servers to.",
                "$ref": "#/definitions/ansible_number"
              },
              "image_password": {
                "type": "string",
                "description": "Password set for the administrative user."
              },
              "bus": {
                "enum": [
                  "IDE",
                  "VIRTIO"
                ],
                "type": "string",
                "description": "Default: VIRTIO\n\nThe bus type for the volume."
              },
              "instance_ids": {
                "description": "list of instance ids, currently only used when state='absent' to remove instances.",
                "$ref": "#/definitions/ansible_array"
              },
              "wait_timeout": {
                "description": "Default: 600\n\nhow long before wait gives up, in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "cpu_family": {
                "enum": [
                  "AMD_OPTERON",
                  "INTEL_XEON"
                ],
                "type": "string",
                "description": "Default: AMD_OPTERON\n\nThe CPU family type to allocate to the virtual machine."
              },
              "disk_type": {
                "enum": [
                  "HDD",
                  "SSD"
                ],
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: yes\n\nwait for the instance to be in state 'running' before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "count": {
                "description": "Default: 1\n\nThe number of virtual machines to create.",
                "$ref": "#/definitions/ansible_number"
              },
              "datacenter": {
                "type": "string",
                "description": "The datacenter to provision this virtual machine."
              },
              "remove_boot_volume": {
                "description": "Default: yes\n\nremove the bootVolume of the virtual machine you're destroying.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name of the virtual machine."
              },
              "cores": {
                "description": "Default: 2\n\nThe number of CPU cores to allocate to the virtual machine.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "gcdns_zone": {
            "type": "object",
            "description": "Creates or removes managed zones in Google Cloud DNS.",
            "properties": {
              "description": {
                "type": "string",
                "description": "An arbitrary text string to use for the zone description."
              },
              "zone": {
                "type": "string",
                "description": "The DNS domain name of the zone.\nThis is NOT the Google Cloud DNS zone ID (e.g., example-com). If you attempt to specify a zone ID, this module will attempt to create a TLD and will fail."
              },
              "service_account_email": {
                "type": "string",
                "description": "The e-mail address for a service account with access to Google Cloud DNS."
              },
              "pem_file": {
                "type": "string",
                "description": "The path to the PEM file associated with the service account email.\nThis option is deprecated and may be removed in a future release. Use I(credentials_file) instead."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhether the given zone should or should not be present."
              },
              "credentials_file": {
                "type": "string",
                "description": "The path to the JSON file associated with the service account email."
              },
              "project_id": {
                "type": "string",
                "description": "The Google Cloud Platform project ID to use."
              }
            }
          },
          "slackpkg": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage binary packages for Slackware using 'slackpkg' which is available in versions after 12.2.",
            "properties": {
              "state": {
                "enum": [
                  "installed",
                  "removed",
                  "absent",
                  "present",
                  "latest"
                ],
                "type": "string",
                "description": "Default: present\n\nstate of the package, you can use \"installed\" as an alias for C(present) and removed as one for c(absent)."
              },
              "update_cache": {
                "description": "update the package database first",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "name of package to install/remove",
                "$ref": "#/definitions/ansible_array"
              },
              "update-cache": {
                "description": "update the package database first",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "name of package to install/remove",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "rabbitmq_vhost": {
            "type": "object",
            "description": "Manage the state of a virtual host in RabbitMQ",
            "properties": {
              "node": {
                "type": "string",
                "description": "Default: rabbit\n\nerlang node name of the rabbit we wish to configure"
              },
              "tracing": {
                "type": "string",
                "description": "Default: no\n\nEnable/disable tracing for a vhost"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nThe state of vhost"
              },
              "name": {
                "type": "string",
                "description": "The name of the vhost to manage"
              }
            }
          },
          "nxos_vpc_interface": {
            "required": [
              "portchannel"
            ],
            "type": "object",
            "description": "Manages interface VPC configuration",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Manages desired state of the resource."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "portchannel": {
                "type": "string",
                "description": "Group number of the portchannel that will be configured."
              },
              "peer_link": {
                "description": "Set to true/false for peer link config on associated portchannel.",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "vpc": {
                "type": "string",
                "description": "VPC group/id that will be configured on associated portchannel."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "elasticache_snapshot": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage cache snapshots in Amazon Elasticache.\nReturns information about the specified snapshot.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "replication_id": {
                "type": "string",
                "description": "The name of the existing replication group to make the snapshot."
              },
              "target": {
                "type": "string",
                "description": "The name of a snapshot copy"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "bucket": {
                "type": "string",
                "description": "The s3 bucket to which the snapshot is exported"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the snapshot we want to create, copy, delete"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "copy"
                ],
                "type": "string",
                "description": "Actions that will create, destroy, or copy a snapshot."
              },
              "cluster_id": {
                "type": "string",
                "description": "The name of an existing cache cluster in the replication group to make the snapshot."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "os_ironic_node": {
            "type": "object",
            "description": "Deploy to nodes controlled by Ironic.",
            "properties": {
              "timeout": {
                "type": "string",
                "description": "An integer value representing the number of seconds to wait for the node activation or deactivation to complete."
              },
              "uuid": {
                "type": "string",
                "description": "Default: None\n\nglobally unique identifier (UUID) to be given to the resource."
              },
              "power": {
                "type": "string",
                "description": "Default: present\n\nA setting to allow power state to be asserted allowing nodes that are not yet deployed to be powered on, and nodes that are deployed to be powered off."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "deploy": {
                "type": "string",
                "description": "Default: True\n\nIndicates if the resource should be deployed. Allows for deployment logic to be disengaged and control of the node power or maintenance state to be changed."
              },
              "ironic_url": {
                "type": "string",
                "description": "Default: None\n\nIf noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with \"auth\" and \"auth_type\" settings set to None."
              },
              "maintenance_reason": {
                "type": "string",
                "description": "Default: None\n\nA string expression regarding the reason a node is in a maintenance mode."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicates desired state of the resource"
              },
              "maintenance": {
                "type": "string",
                "description": "A setting to allow the direct control if a node is in maintenance mode."
              },
              "wait": {
                "type": "string",
                "description": "A boolean value instructing the module to wait for node activation or deactivation to complete before returning."
              },
              "instance_info": {
                "type": "string",
                "description": "Definition of the instance information which is used to deploy the node.  This information is only required when an instance is set to present."
              },
              "config_drive": {
                "type": "string",
                "description": "Default: None\n\nA configdrive file or HTTP(S) URL that will be passed along to the node."
              }
            }
          },
          "nsupdate": {
            "required": [
              "zone",
              "server",
              "record"
            ],
            "type": "object",
            "description": "Create, update and remove DNS records using DDNS updates\nDDNS works well with both bind and Microsoft DNS (see https://technet.microsoft.com/en-us/library/cc961412.aspx)",
            "properties": {
              "key_algorithm": {
                "enum": [
                  "HMAC-MD5.SIG-ALG.REG.INT",
                  "hmac-md5",
                  "hmac-sha1",
                  "hmac-sha224",
                  "hmac-sha256",
                  "hamc-sha384",
                  "hmac-sha512"
                ],
                "type": "string",
                "description": "Default: hmac-md5\n\nSpecify key algorithm used by C(key_secret)."
              },
              "zone": {
                "type": "string",
                "description": "DNS record will be modified on this C(zone)."
              },
              "key_name": {
                "type": "string",
                "description": "Use TSIG key name to authenticate against DNS C(server)"
              },
              "value": {
                "type": "string",
                "description": "Default: None\n\nSets the record value."
              },
              "server": {
                "type": "string",
                "description": "Apply DNS modification on this server."
              },
              "record": {
                "type": "string",
                "description": "Sets the DNS record to modify."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage DNS record."
              },
              "ttl": {
                "description": "Default: 3600\n\nSets the record TTL.",
                "$ref": "#/definitions/ansible_number"
              },
              "type": {
                "type": "string",
                "description": "Default: A\n\nSets the record type."
              },
              "key_secret": {
                "type": "string",
                "description": "Use TSIG key secret, associated with C(key_name), to authenticate against C(server)"
              }
            }
          },
          "ipa_role": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cn",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "cn"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify and delete a role within FreeIPA server using FreeIPA API",
            "properties": {
              "ipa_port": {
                "description": "Default: 443\n\nPort of IPA server",
                "$ref": "#/definitions/ansible_number"
              },
              "group": {
                "description": "List of group names assign to this role.\nIf an empty list is passed all assigned groups will be unassigned from the role.\nIf option is omitted groups will not be checked or changed.\nIf option is passed all assigned groups that are not passed will be unassigned from the role.",
                "$ref": "#/definitions/ansible_array"
              },
              "description": {
                "type": "string",
                "description": "A description of this role-group."
              },
              "service": {
                "description": "List of service names to assign.\nIf an empty list is passed all assigned services will be removed from the role.\nIf option is omitted services will not be checked or changed.\nIf option is passed all assigned services that are not passed will be removed from the role.",
                "$ref": "#/definitions/ansible_array"
              },
              "cn": {
                "type": "string",
                "description": "Role name.\nCan not be changed as it is the unique identifier."
              },
              "ipa_prot": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nProtocol used by IPA server"
              },
              "host": {
                "description": "List of host names to assign.\nIf an empty list is passed all assigned hosts will be unassigned from the role.\nIf option is omitted hosts will not be checked or changed.\nIf option is passed all assigned hosts that are not passed will be unassigned from the role.",
                "$ref": "#/definitions/ansible_array"
              },
              "hostgroup": {
                "description": "List of host group names to assign.\nIf an empty list is passed all assigned host groups will be removed from the role.\nIf option is omitted host groups will not be checked or changed.\nIf option is passed all assigned hostgroups that are not passed will be unassigned from the role.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Role name.\nCan not be changed as it is the unique identifier."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState to ensure"
              },
              "user": {
                "description": "List of user names to assign.\nIf an empty list is passed all assigned users will be removed from the role.\nIf option is omitted users will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_user": {
                "type": "string",
                "description": "Default: admin\n\nAdministrative account used on IPA server"
              },
              "ipa_pass": {
                "type": "string",
                "description": "Password of administrative user"
              },
              "validate_certs": {
                "description": "Default: True\n\nThis only applies if C(ipa_prot) is I(https).\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ipa_host": {
                "type": "string",
                "description": "Default: ipa.example.com\n\nIP or hostname of IPA server"
              }
            }
          },
          "ovirt_users": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "authz_name",
                        "domain"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "authz_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "domain"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage users in oVirt.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Authorization provider of the user. In previous versions of oVirt known as domain."
              },
              "name": {
                "type": "string",
                "description": "Name of the the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the user be present/absent."
              },
              "namespace": {
                "type": "string",
                "description": ""
              },
              "authz_name": {
                "type": "string",
                "description": "Authorization provider of the user. In previous versions of oVirt known as domain."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ec2_vpc_net_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about ec2 VPCs in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "virt_net": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "network"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage I(libvirt) networks.",
            "properties": {
              "xml": {
                "type": "string",
                "description": "XML document used with the define command."
              },
              "name": {
                "type": "string",
                "description": "name of the network being managed. Note that network must be previously defined with xml."
              },
              "uri": {
                "type": "string",
                "description": "Default: qemu:///system\n\nlibvirt connection uri."
              },
              "state": {
                "enum": [
                  "active",
                  "inactive",
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "specify which state you want a network to be in. If 'active', network will be started. If 'present', ensure that network is present but do not change its state; if it's missing, you need to specify xml argument. If 'inactive', network will be stopped. If 'undefined' or 'absent', network will be removed from I(libvirt) configuration."
              },
              "command": {
                "enum": [
                  "define",
                  "create",
                  "start",
                  "stop",
                  "destroy",
                  "undefine",
                  "get_xml",
                  "list_nets",
                  "facts",
                  "info",
                  "status",
                  "modify"
                ],
                "type": "string",
                "description": "in addition to state management, various non-idempotent commands are available. See examples. Modify was added in version 2.1"
              },
              "autostart": {
                "description": "Specify if a given storage pool should be started automatically on system boot.",
                "$ref": "#/definitions/ansible_truth"
              },
              "network": {
                "type": "string",
                "description": "name of the network being managed. Note that network must be previously defined with xml."
              }
            }
          },
          "ovirt_vms": {
            "required": [
              "auth"
            ],
            "type": "object",
            "description": "This module manages whole lifecycle of the Virtual Machine(VM) in oVirt. Since VM can hold many states in oVirt, this see notes to see how the states of the VM are handled.",
            "properties": {
              "memory_guaranteed": {
                "type": "string",
                "description": "Amount of minimal guaranteed memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).\nC(memory_guaranteed) parameter can't be lower than C(memory) parameter. Default value is set by engine."
              },
              "force": {
                "description": "Please check to I(Synopsis) to more detailed description of force parameter, it can behave differently in different situations.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cluster": {
                "type": "string",
                "description": "Name of the cluster, where Virtual Machine should be created. Required if creating VM."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "id": {
                "type": "string",
                "description": "ID of the the Virtual Machine to manage."
              },
              "cpu_sockets": {
                "description": "Number of virtual CPUs sockets of the Virtual Machine. Default value is set by oVirt engine.",
                "$ref": "#/definitions/ansible_number"
              },
              "high_availability": {
                "description": "If I(True) Virtual Machine will be set as highly available.\nIf I(False) Virtual Machine won't be set as highly available.\nIf no value is passed, default value is set by oVirt engine.",
                "$ref": "#/definitions/ansible_truth"
              },
              "nics": {
                "description": "List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary:\nC(name) - Name of the NIC.\nC(profile_name) - Profile name where NIC should be attached.\nC(interface) -  Type of the network interface. One of following: I(virtio), I(e1000), I(rtl8139), default is I(virtio).\nC(mac_address) - Custom MAC address of the network interface, by default it's obtained from MAC pool.\nC(Note:)\nThis parameter is used only when C(state) is I(running) or I(present) and is able to only create NICs. To manage NICs of the VM in more depth please use M(ovirt_nics) module instead.",
                "$ref": "#/definitions/ansible_array"
              },
              "sysprep": {
                "type": "object",
                "description": "Dictionary with values for Windows Virtual Machine initialization using sysprep:\nC(host_name) - Hostname to be set to Virtual Machine when deployed.\nC(active_directory_ou) - Active Directory Organizational Unit, to be used for login of user.\nC(org_name) - Organization name to be set to Windows Virtual Machine.\nC(domain) - Domain to be set to Windows Virtual Machine.\nC(timezone) - Timezone to be set to Windows Virtual Machine.\nC(ui_language) - UI language of the Windows Virtual Machine.\nC(system_locale) - System localization of the Windows Virtual Machine.\nC(input_locale) - Input localization of the Windows Virtual Machine.\nC(windows_license_key) - License key to be set to Windows Virtual Machine.\nC(user_name) - Username to be used for set password to Windows Virtual Machine.\nC(root_password) - Password to be set for username to Windows Virtual Machine."
              },
              "cpu_cores": {
                "description": "Number of virtual CPUs cores of the Virtual Machine. Default value is set by oVirt engine.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "running",
                  "stopped",
                  "present",
                  "absent",
                  "suspended",
                  "next_run"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the Virtual Machine be running/stopped/present/absent/suspended/next_run.\nI(present) and I(running) are equal states.\nI(next_run) state updates the VM and if the VM has next run configuration it will be rebooted.\nPlease check I(notes) to more detailed description of states."
              },
              "template": {
                "type": "string",
                "description": "Name of the template, which should be used to create Virtual Machine. Required if creating VM.\nIf template is not specified and VM doesn't exist, VM will be created from I(Blank) template."
              },
              "memory": {
                "type": "string",
                "description": "Amount of memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).\nDefault value is set by engine."
              },
              "cd_iso": {
                "type": "string",
                "description": "ISO file from ISO storage domain which should be attached to Virtual Machine.\nIf you pass empty string the CD will be ejected from VM.\nIf used with C(state) I(running) or I(present) and VM is running the CD will be attached to VM.\nIf used with C(state) I(running) or I(present) and VM is down the CD will be attached to VM persistently."
              },
              "clone_permissions": {
                "description": "If I(True) then the permissions of the template (only the direct ones, not the inherited ones) will be copied to the created virtual machine.\nThis parameter is used only when C(state) is I(running) or I(present) and VM didn't exist before.",
                "$ref": "#/definitions/ansible_truth"
              },
              "type": {
                "enum": [
                  "server",
                  "desktop"
                ],
                "type": "string",
                "description": "Type of the Virtual Machine. Default value is set by oVirt engine."
              },
              "delete_protected": {
                "description": "If I(True) Virtual Machine will be set as delete protected.\nIf I(False) Virtual Machine won't be set as delete protected.\nIf no value is passed, default value is set by oVirt engine.",
                "$ref": "#/definitions/ansible_truth"
              },
              "clone": {
                "description": "If I(True) then the disks of the created virtual machine will be cloned and independent of the template.\nThis parameter is used only when C(state) is I(running) or I(present) and VM didn't exist before.",
                "$ref": "#/definitions/ansible_truth"
              },
              "boot_devices": {
                "description": "List of boot devices which should be used to boot. Choices I(network), I(hd) and I(cdrom).\nFor example: ['cdrom', 'hd']. Default value is set by oVirt engine.",
                "$ref": "#/definitions/ansible_array"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": "Specify host where Virtual Machine should be running. By default the host is chosen by engine scheduler.\nThis parameter is used only when C(state) is I(running) or I(present)."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "stateless": {
                "description": "If I(True) Virtual Machine will be set as stateless.\nIf I(False) Virtual Machine will be unset as stateless.\nIf no value is passed, default value is set by oVirt engine.",
                "$ref": "#/definitions/ansible_truth"
              },
              "operating_system": {
                "enum": [
                  "rhel_6_ppc64",
                  "other",
                  "freebsd",
                  "windows_2003x64",
                  "windows_10",
                  "rhel_6x64",
                  "rhel_4x64",
                  "windows_2008x64",
                  "windows_2008R2x64",
                  "debian_7",
                  "windows_2012x64",
                  "ubuntu_14_04",
                  "ubuntu_12_04",
                  "ubuntu_13_10",
                  "windows_8x64",
                  "other_linux_ppc64",
                  "windows_2003",
                  "other_linux",
                  "windows_10x64",
                  "windows_2008",
                  "rhel_3",
                  "rhel_5",
                  "rhel_4",
                  "other_ppc64",
                  "sles_11",
                  "rhel_6",
                  "windows_xp",
                  "rhel_7x64",
                  "freebsdx64",
                  "rhel_7_ppc64",
                  "windows_7",
                  "rhel_5x64",
                  "ubuntu_14_04_ppc64",
                  "sles_11_ppc64",
                  "windows_8",
                  "windows_2012R2x64",
                  "windows_2008r2x64",
                  "ubuntu_13_04",
                  "ubuntu_12_10",
                  "windows_7x64"
                ],
                "type": "string",
                "description": "Operating system of the Virtual Machine. Default value is set by oVirt engine."
              },
              "name": {
                "type": "string",
                "description": "Name of the the Virtual Machine to manage. If VM don't exists C(name) is required. Otherwise C(id) or C(name) can be used."
              },
              "cloud_init": {
                "type": "object",
                "description": "Dictionary with values for Unix-like Virtual Machine initialization using cloud init:\nC(host_name) - Hostname to be set to Virtual Machine when deployed.\nC(timezone) - Timezone to be set to Virtual Machine when deployed.\nC(user_name) - Username to be used to set password to Virtual Machine when deployed.\nC(root_password) - Password to be set for user specified by C(user_name) parameter.\nC(authorized_ssh_keys) - Use this SSH keys to login to Virtual Machine.\nC(regenerate_ssh_keys) - If I(True) SSH keys will be regenerated on Virtual Machine.\nC(custom_script) - Cloud-init script which will be executed on Virtual Machine when deployed.\nC(dns_servers) - DNS servers to be configured on Virtual Machine.\nC(dns_search) - DNS search domains to be configured on Virtual Machine.\nC(nic_boot_protocol) - Set boot protocol of the network interface of Virtual Machine. Can be one of None, DHCP or Static.\nC(nic_ip_address) - If boot protocol is static, set this IP address to network interface of Virtual Machine.\nC(nic_netmask) - If boot protocol is static, set this netmask to network interface of Virtual Machine.\nC(nic_gateway) - If boot protocol is static, set this gateway to network interface of Virtual Machine.\nC(nic_name) - Set name to network interface of Virtual Machine.\nC(nic_on_boot) - If I(True) network interface will be set to start on boot."
              },
              "disks": {
                "description": "List of disks, which should be attached to Virtual Machine. Disk is described by following dictionary:\nC(name) - Name of the disk. Either C(name) or C(id) is reuqired.\nC(id) - ID of the disk. Either C(name) or C(id) is reuqired.\nC(interface) - Interface of the disk, either I(virtio) or I(IDE), default is I(virtio).\nC(bootable) - I(True) if the disk should be bootable, default is non bootable.\nC(activate) - I(True) if the disk should be activated, default is activated.\nC(Note:)\nThis parameter is used only when C(state) is I(running) or I(present) and is able to only attach disks. To manage disks of the VM in more depth please use M(ovirt_disks) module instead.",
                "$ref": "#/definitions/ansible_array"
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "cpu_shares": {
                "description": "Set a CPU shares for this Virtual Machine. Default value is set by oVirt engine.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "pamd": {
            "required": [
              "control",
              "module_path",
              "type",
              "name"
            ],
            "type": "object",
            "description": "Edit PAM service's type, control, module path and module arguments. In order for a PAM rule to be modified, the type, control and module_path must match an existing rule.  See man(5) pam.d for details.",
            "properties": {
              "control": {
                "type": "string",
                "description": "The control of the PAM rule being modified.  This may be a complicated control with brackets.  If this is the case, be sure to put \"[bracketed controls]\" in quotes.  The type, control and module_path all must match a rule to be modified."
              },
              "new_module_path": {
                "type": "string",
                "description": "The control to assign to the new rule."
              },
              "module_arguments": {
                "description": "When state is 'updated', the module_arguments will replace existing module_arguments.  When state is 'args_absent' args matching those listed in module_arguments will be removed.  When state is 'args_present' any args listed in module_arguments are added if missing from the existing rule.  Furthermore, if the module argument takes a value denoted by '=', the value will be changed to that specified in module_arguments.",
                "$ref": "#/definitions/ansible_array"
              },
              "new_type": {
                "enum": [
                  "account",
                  "auth",
                  "password",
                  "session"
                ],
                "type": "string",
                "description": "The type to assign to the new rule."
              },
              "state": {
                "enum": [
                  "updated",
                  "before",
                  "after",
                  "args_present",
                  "args_absent"
                ],
                "type": "string",
                "description": "Default: updated\n\nThe default of 'updated' will modify an existing rule if type, control and module_path all match an existing rule.  With 'before', the new rule will be inserted before a rule matching type, control and module_path.  Similarly, with 'after', the new rule will be inserted after an existing rule matching type, control and module_path.  With either 'before' or 'after' new_type, new_control, and new_module_path must all be specified.  If state is 'args_absent' or 'args_present', new_type, new_control, and new_module_path will be ignored."
              },
              "new_control": {
                "type": "string",
                "description": "The control to assign to the new rule."
              },
              "module_path": {
                "type": "string",
                "description": "The module path of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified."
              },
              "path": {
                "type": "string",
                "description": "Default: /etc/pam.d/\n\nThis is the path to the PAM service files"
              },
              "type": {
                "enum": [
                  "account",
                  "auth",
                  "password",
                  "session"
                ],
                "type": "string",
                "description": "The type of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified."
              },
              "name": {
                "type": "string",
                "description": "The name generally refers to the PAM service file to change, for example system-auth."
              }
            }
          },
          "digital_ocean": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_token",
                        "API_TOKEN"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "id",
                        "droplet_id"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create/delete a droplet in DigitalOcean and optionally wait for it to be 'running', or deploy an SSH key.",
            "properties": {
              "unique_name": {
                "description": "Default: no\n\nBool, require unique hostnames.  By default, DigitalOcean allows multiple hosts with the same name.  Setting this to \"yes\" allows only one host per name.  Useful for idempotence.",
                "$ref": "#/definitions/ansible_truth"
              },
              "virtio": {
                "description": "Default: yes\n\nBool, turn on virtio driver in droplet for improved network and storage I/O.",
                "$ref": "#/definitions/ansible_truth"
              },
              "droplet_id": {
                "description": "Numeric, the droplet id you want to operate on.",
                "$ref": "#/definitions/ansible_number"
              },
              "region_id": {
                "type": "string",
                "description": "This is the slug of the region you would like your server to be created in."
              },
              "ipv6": {
                "description": "Default: no\n\nOptional, Boolean, enable IPv6 for your droplet.",
                "$ref": "#/definitions/ansible_truth"
              },
              "size_id": {
                "type": "string",
                "description": "This is the slug of the size you would like the droplet created with."
              },
              "API_TOKEN": {
                "type": "string",
                "description": "DigitalOcean api token."
              },
              "backups_enabled": {
                "description": "Default: no\n\nOptional, Boolean, enables backups for your droplet.",
                "$ref": "#/definitions/ansible_truth"
              },
              "user_data": {
                "type": "string",
                "description": "Default: None\n\nopaque blob of data which is made available to the droplet"
              },
              "ssh_pub_key": {
                "type": "string",
                "description": "The public SSH key you want to add to your account."
              },
              "name": {
                "type": "string",
                "description": "String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key."
              },
              "image_id": {
                "type": "string",
                "description": "This is the slug of the image you would like the droplet created with."
              },
              "state": {
                "enum": [
                  "present",
                  "active",
                  "absent",
                  "deleted"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the target."
              },
              "wait_timeout": {
                "description": "Default: 300\n\nHow long before wait gives up, in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "command": {
                "enum": [
                  "droplet",
                  "ssh"
                ],
                "type": "string",
                "description": "Default: droplet\n\nWhich target you want to operate on."
              },
              "ssh_key_ids": {
                "description": "Optional, array of SSH key (numeric) ID that you would like to be added to the server.",
                "$ref": "#/definitions/ansible_array"
              },
              "api_token": {
                "type": "string",
                "description": "DigitalOcean api token."
              },
              "private_networking": {
                "description": "Default: no\n\nBool, add an additional, private network interface to droplet for inter-droplet communication.",
                "$ref": "#/definitions/ansible_truth"
              },
              "id": {
                "description": "Numeric, the droplet id you want to operate on.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "Default: yes\n\nWait for the droplet to be in state 'running' before returning.  If wait is \"no\" an ip_address may not be returned.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cs_securitygroup_rule": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "start_port",
                        "port"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add and remove security group rules.",
            "properties": {
              "icmp_code": {
                "description": "Error code for this icmp message. Required if C(protocol=icmp).",
                "$ref": "#/definitions/ansible_number"
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "start_port": {
                "description": "Start port for this rule. Required if C(protocol=tcp) or C(protocol=udp).",
                "$ref": "#/definitions/ansible_number"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "user_security_group": {
                "type": "string",
                "description": "Security group this rule is based of."
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "end_port": {
                "description": "End port for this rule. Required if C(protocol=tcp) or C(protocol=udp), but C(start_port) will be used if not set.",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the security group to be created in."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the security group rule."
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "security_group": {
                "type": "string",
                "description": "Name of the security group the rule is related to. The security group must be existing."
              },
              "protocol": {
                "enum": [
                  "tcp",
                  "udp",
                  "icmp",
                  "ah",
                  "esp",
                  "gre"
                ],
                "type": "string",
                "description": "Default: tcp\n\nProtocol of the security group rule."
              },
              "cidr": {
                "type": "string",
                "description": "Default: 0.0.0.0/0\n\nCIDR (full notation) to be used for security group rule."
              },
              "icmp_type": {
                "description": "Type of the icmp message being sent. Required if C(protocol=icmp).",
                "$ref": "#/definitions/ansible_number"
              },
              "type": {
                "enum": [
                  "ingress",
                  "egress"
                ],
                "type": "string",
                "description": "Default: ingress\n\nIngress or egress security group rule."
              },
              "port": {
                "description": "Start port for this rule. Required if C(protocol=tcp) or C(protocol=udp).",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "atomic_image": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manage the container images on the atomic host platform\nAllows to execute the commands on the container images",
            "properties": {
              "started": {
                "description": "Default: True\n\nStart or Stop the continer",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "latest"
                ],
                "type": "string",
                "description": "Default: latest\n\nThe state of the container image.\nThe state ```latest``` will ensure container image is upgraded to the latest version and forcefully restart container, if running."
              },
              "name": {
                "type": "string",
                "description": "Name of the container image"
              }
            }
          },
          "cnos_bgp": {
            "type": "object",
            "description": "This module allows you to work with Border Gateway Protocol (BGP) related configurations. The operators used are overloaded to ensure control over switch BGP configurations. This module is invoked using method with asNumber as one of its arguments. The first level of the BGP configuration allows to set up an AS number, with the following attributes going into various configuration operations under the context of BGP. After passing this level, there are eight BGP arguments that will perform further configurations. They are bgpArg1, bgpArg2, bgpArg3, bgpArg4, bgpArg5, bgpArg6, bgpArg7, and bgpArg8. For more details on how to use these arguments, see [Overloaded Variables]. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_bgp.html)",
            "properties": {
              "bgpArg8": {
                "type": "string",
                "description": "This is an overloaded bgp eigth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "asNum": {
                "type": "string",
                "description": "AS number"
              },
              "bgpArg4": {
                "type": "string",
                "description": "This is an overloaded bgp fourth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "bgpArg5": {
                "type": "string",
                "description": "This is an overloaded bgp fifth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "bgpArg6": {
                "type": "string",
                "description": "This is an overloaded bgp sixth argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "bgpArg7": {
                "type": "string",
                "description": "This is an overloaded bgp seventh argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "bgpArg1": {
                "type": "string",
                "description": "This is an overloaded bgp first argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "bgpArg2": {
                "type": "string",
                "description": "This is an overloaded bgp second argument. Usage of this argument can be found is the User Guide referenced above."
              },
              "bgpArg3": {
                "type": "string",
                "description": "This is an overloaded bgp third argument. Usage of this argument can be found is the User Guide referenced above."
              }
            }
          },
          "nxos_acl": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manages access list entries for ACLs.",
            "properties": {
              "protocol": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": ""
              },
              "precedence": {
                "enum": [
                  "critical",
                  "flash",
                  "flash-override",
                  "immediate",
                  "internet",
                  "network",
                  "priority",
                  "routine"
                ],
                "type": "string",
                "description": "Match packets with given precedence."
              },
              "time_range": {
                "type": "string",
                "description": ""
              },
              "dest_port_op": {
                "type": "string",
                "description": "Destination port operands such as eq, neq, gt, lt, range."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "established": {
                "enum": [
                  "enable"
                ],
                "type": "string",
                "description": "Match established connections."
              },
              "log": {
                "enum": [
                  "enable"
                ],
                "type": "string",
                "description": "Log matches against this entry."
              },
              "proto": {
                "type": "string",
                "description": "Port number or protocol (as supported by the switch)."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "delete_acl"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify desired state of the resource."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "fragments": {
                "enum": [
                  "enable"
                ],
                "type": "string",
                "description": "Check non-initial fragments."
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "fin": {
                "enum": [
                  "enable"
                ],
                "type": "string",
                "description": "Match on the FIN bit."
              },
              "src_port2": {
                "type": "string",
                "description": "Second (end) port when using range operand."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "src_port_op": {
                "type": "string",
                "description": "Source port operands such as eq, neq, gt, lt, range."
              },
              "psh": {
                "enum": [
                  "enable"
                ],
                "type": "string",
                "description": "Match on the PSH bit."
              },
              "dest": {
                "type": "string",
                "description": "Destination ip and mask using IP/MASK notation and supports the keyword 'any'."
              },
              "syn": {
                "enum": [
                  "enable"
                ],
                "type": "string",
                "description": "Match on the SYN bit."
              },
              "dscp": {
                "enum": [
                  "af11",
                  "af12",
                  "af13",
                  "af21",
                  "af22",
                  "af23",
                  "af31",
                  "af32",
                  "af33",
                  "af41",
                  "af42",
                  "af43",
                  "cs1",
                  "cs2",
                  "cs3",
                  "cs4",
                  "cs5",
                  "cs6",
                  "cs7",
                  "default",
                  "ef"
                ],
                "type": "string",
                "description": "Match packets with given dscp value."
              },
              "src_port1": {
                "type": "string",
                "description": "Port/protocol and also first (lower) port when using range operand."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "urg": {
                "enum": [
                  "enable"
                ],
                "type": "string",
                "description": "Match on the URG bit."
              },
              "rst": {
                "enum": [
                  "enable"
                ],
                "type": "string",
                "description": "Match on the RST bit."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "seq": {
                "type": "string",
                "description": "Sequence number of the entry (ACE)."
              },
              "src": {
                "type": "string",
                "description": "Source ip and mask using IP/MASK notation and supports keyword 'any'."
              },
              "remark": {
                "type": "string",
                "description": "If action is set to remark, this is the description."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Case sensitive name of the access list (ACL)."
              },
              "ack": {
                "enum": [
                  "enable"
                ],
                "type": "string",
                "description": "Match on the ACK bit."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "action": {
                "enum": [
                  "permit",
                  "deny",
                  "remark"
                ],
                "type": "string",
                "description": "Action of the ACE."
              },
              "dest_port1": {
                "type": "string",
                "description": "Port/protocol and also first (lower) port when using range operand."
              },
              "dest_port2": {
                "type": "string",
                "description": "Second (end) port when using range operand."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "pkgutil": {
            "required": [
              "state",
              "name"
            ],
            "type": "object",
            "description": "Manages CSW packages (SVR4 format) on Solaris 10 and 11.\nThese were the native packages on Solaris <= 10 and are available as a legacy feature in Solaris 11.\nPkgutil is an advanced packaging system, which resolves dependency on installation. It is designed for CSW packages.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "latest"
                ],
                "type": "string",
                "description": "Whether to install (C(present)), or remove (C(absent)) a package.\nThe upgrade (C(latest)) operation will update/install the package to the latest version available.\nNote: The module has a limitation that (C(latest)) only works for one package, not lists of them."
              },
              "site": {
                "type": "string",
                "description": "Specifies the repository path to install the package from.\nIts global definition is done in C(/etc/opt/csw/pkgutil.conf)."
              },
              "name": {
                "type": "string",
                "description": "Package name, e.g. (C(CSWnrpe))"
              },
              "update_catalog": {
                "description": "If you want to refresh your catalog from the mirror, set this to (C(yes)).",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cs_zone_facts": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Gathering facts from the API of a zone.",
            "properties": {
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the zone."
              }
            }
          },
          "nxos_nxapi": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "http",
                        "enable_http"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "sandbox",
                        "enable_sandbox"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "https",
                        "enable_https"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Configures the NXAPI feature on devices running Cisco NXOS.  The NXAPI feature is absent from the configuration by default.  Since this module manages the NXAPI feature it only supports the use of the C(Cli) transport.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "http": {
                "description": "Default: True\n\nControls the operating state of the HTTP protocol as one of the underlying transports for NXAPI.  By default, NXAPI will enable the HTTP transport when the feature is first configured.  To disable the use of the HTTP transport, set the value of this argument to False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "https_port": {
                "description": "Default: 443\n\nConfigure the port with which the HTTPS server will listen on for requests.  By default, NXAPI will bind the HTTPS service to the standard HTTPS port 443.  This argument accepts valid port values in the range of 1 to 65535.",
                "$ref": "#/definitions/ansible_number"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "enable_sandbox": {
                "description": "The NXAPI feature provides a web base UI for developers for entering commands.  This feature is initially disabled when the NXAPI feature is configured for the first time.  When the C(sandbox) argument is set to True, the developer sandbox URL will accept requests and when the value is set to False, the sandbox URL is unavailable.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe C(state) argument controls whether or not the NXAPI feature is configured on the remote device.  When the value is C(present) the NXAPI feature configuration is present in the device running-config.  When the values is C(absent) the feature configuration is removed from the running-config."
              },
              "enable_https": {
                "description": "Controls the operating state of the HTTPS protocol as one of the underlying transports for NXAPI.  By default, NXAPI will disable the HTTPS transport when the feature is first configured.  To enable the use of the HTTPS transport, set the value of this argument to True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sandbox": {
                "description": "The NXAPI feature provides a web base UI for developers for entering commands.  This feature is initially disabled when the NXAPI feature is configured for the first time.  When the C(sandbox) argument is set to True, the developer sandbox URL will accept requests and when the value is set to False, the sandbox URL is unavailable.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "http_port": {
                "description": "Default: 80\n\nConfigure the port with which the HTTP server will listen on for requests.  By default, NXAPI will bind the HTTP service to the standard HTTP port 80.  This argument accepts valid port values in the range of 1 to 65535.",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "https": {
                "description": "Controls the operating state of the HTTPS protocol as one of the underlying transports for NXAPI.  By default, NXAPI will disable the HTTPS transport when the feature is first configured.  To enable the use of the HTTPS transport, set the value of this argument to True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "enable_http": {
                "description": "Default: True\n\nControls the operating state of the HTTP protocol as one of the underlying transports for NXAPI.  By default, NXAPI will enable the HTTP transport when the feature is first configured.  To disable the use of the HTTP transport, set the value of this argument to False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "fortios_ipv4_policy": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "service",
                        "services"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "policy_action",
                        "action"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module provides management of firewall IPv4 policies on FortiOS devices.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "free text to describe policy."
              },
              "application_list": {
                "type": "string",
                "description": "Specifies Application Control name."
              },
              "service_negate": {
                "description": "Negate policy service(s) defined in service value.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ips_sensor": {
                "type": "string",
                "description": "Specifies IPS Sensor profile name."
              },
              "backup_filename": {
                "type": "string",
                "description": ""
              },
              "id": {
                "description": "Policy ID. Warning: policy ID number is different than Policy sequence number. The policy ID is the number assigned at policy creation. The sequence number represents the order in which the Fortigate will evaluate the rule for policy enforcement, and also the order in which rules are listed in the GUI and CLI. These two numbers do not necessarily correlate: this module is based off policy ID. TIP: policy ID can be viewed in the GUI by adding 'ID' to the display columns",
                "$ref": "#/definitions/ansible_number"
              },
              "fixedport": {
                "description": "Use fixed port for nat.",
                "$ref": "#/definitions/ansible_truth"
              },
              "src_addr": {
                "description": "Specifies source address (or group) object name(s). Required when I(state=present).",
                "$ref": "#/definitions/ansible_array"
              },
              "service": {
                "description": "Specifies policy service(s), could be a list (ex: ['MAIL','DNS']). Required when I(state=present).",
                "$ref": "#/definitions/ansible_array"
              },
              "poolname": {
                "type": "string",
                "description": "Specifies NAT pool name."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecifies if policy I(id) need to be added or deleted."
              },
              "nat": {
                "description": "Enable or disable Nat.",
                "$ref": "#/definitions/ansible_truth"
              },
              "src_addr_negate": {
                "description": "Negate source address param.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "config_file": {
                "type": "string",
                "description": ""
              },
              "file_mode": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "schedule": {
                "type": "string",
                "description": "Default: always\n\ndefines policy schedule."
              },
              "src_intf": {
                "type": "string",
                "description": "Default: any\n\nSpecifies source interface name."
              },
              "dst_addr_negate": {
                "description": "Negate destination address param.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "services": {
                "description": "Specifies policy service(s), could be a list (ex: ['MAIL','DNS']). Required when I(state=present).",
                "$ref": "#/definitions/ansible_array"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "vdom": {
                "type": "string",
                "description": ""
              },
              "webfilter_profile": {
                "type": "string",
                "description": "Specifies Webfilter profile name."
              },
              "backup_path": {
                "type": "string",
                "description": ""
              },
              "policy_action": {
                "enum": [
                  "accept",
                  "deny"
                ],
                "type": "string",
                "description": "Specifies accept or deny action policy. Required when I(state=present)."
              },
              "dst_intf": {
                "type": "string",
                "description": "Default: any\n\nSpecifies destination interface name."
              },
              "av_profile": {
                "type": "string",
                "description": "Specifies Antivirus profile name."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "action": {
                "enum": [
                  "accept",
                  "deny"
                ],
                "type": "string",
                "description": "Specifies accept or deny action policy. Required when I(state=present)."
              },
              "backup": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "dst_addr": {
                "description": "Specifies destination address (or group) object name(s). Required when I(state=present).",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "win_regmerge": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Wraps the reg.exe command to import the contents of a registry file.\nSuitable for use with registry files created using M(win_template).\nWindows registry files have a specific format and must be constructed correctly with carriage return and line feed line endings otherwise they will not be merged.\nExported registry files often start with a Byte Order Mark which must be removed if the file is to templated using M(win_template).\nRegistry file format is described at U(https://support.microsoft.com/en-us/kb/310516)\nSee also M(win_template), M(win_regedit)",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": ""
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "sts_session_token": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Obtain a session token from the AWS Security Token Service",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "duration_seconds": {
                "description": "The duration, in seconds, of the session token. See http://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html#API_GetSessionToken_RequestParameters for acceptable and default values.",
                "$ref": "#/definitions/ansible_number"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "mfa_token": {
                "type": "string",
                "description": "The value provided by the MFA device, if the trust policy of the user requires MFA."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "mfa_serial_number": {
                "type": "string",
                "description": "The identification number of the MFA device that is associated with the user who is making the GetSessionToken call."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "boundary_meter": {
            "required": [
              "apiid",
              "apikey",
              "state"
            ],
            "type": "object",
            "description": "This module manages boundary meters",
            "properties": {
              "apiid": {
                "type": "string",
                "description": "Organizations boundary API ID"
              },
              "apikey": {
                "type": "string",
                "description": "Organizations boundary API KEY"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "meter name"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: True\n\nWhether to create or remove the client from boundary"
              }
            }
          },
          "os_port_facts": {
            "type": "object",
            "description": "Retrieve facts about ports from OpenStack.",
            "properties": {
              "port": {
                "type": "string",
                "description": "Unique name or ID of a port."
              },
              "filters": {
                "type": "string",
                "description": "A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries."
              }
            }
          },
          "sensu_subscription": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manage which I(sensu channels) a machine should subscribe to",
            "properties": {
              "path": {
                "type": "string",
                "description": "Default: /etc/sensu/conf.d/subscriptions.json\n\nPath to the subscriptions json file"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the machine should subscribe or unsubscribe from the channel"
              },
              "backup": {
                "description": "Create a backup file (if yes), including the timestamp information so you\ncan get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name of the channel"
              }
            }
          },
          "nxos_static_route": {
            "required": [
              "prefix",
              "next_hop"
            ],
            "type": "object",
            "description": "Manages static route configuration",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "next_hop": {
                "type": "string",
                "description": "Next hop address or interface of static route. If interface, it must be the fully-qualified interface name."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Manage the state of the resource."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "pref": {
                "type": "string",
                "description": "Preference or administrative difference of route (range 1-255)."
              },
              "route_name": {
                "type": "string",
                "description": "Name of the route. Used with the name parameter on the CLI."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "prefix": {
                "type": "string",
                "description": "Destination prefix of static route."
              },
              "tag": {
                "type": "string",
                "description": "Route tag value (numeric)."
              },
              "vrf": {
                "type": "string",
                "description": "Default: default\n\nVRF for static route."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "nxos_system": {
            "type": "object",
            "description": "This module provides declarative management of node system attributes on Cisco NXOS devices.  It provides an option to configure host system parameters or remove those parameters from the device active configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the configuration values in the device's current active configuration.  When set to I(present), the values should be configured in the device active configuration and when set to I(absent) the values should not be in the device active configuration"
              },
              "domain_search": {
                "description": "Configures a list of domain name suffixes to search when performing DNS name resolution. This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name.  See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "hostname": {
                "type": "string",
                "description": "Configure the device hostname parameter. This option takes an ASCII string value."
              },
              "system_mtu": {
                "description": "Specifies the mtu, must be an integer.",
                "$ref": "#/definitions/ansible_number"
              },
              "domain_name": {
                "description": "Configures the default domain name suffix to be used when referencing this node by its FQDN.  This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name.  See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "domain_lookup": {
                "description": "Enables or disables the DNS lookup feature in Cisco NXOS.  This argument accepts boolean values.  When enabled, the system will try to resolve hostnames using DNS and when disabled, hostnames will not be resolved.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "name_servers": {
                "description": "List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "sf_check_connections": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Used to test the management connection to the cluster.\nThe test pings the MVIP and SVIP, and executes a simple API method to verify connectivity.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "skip": {
                "enum": [
                  "svip",
                  "mvip"
                ],
                "type": "string",
                "description": "Default: None\n\nSkip checking connection to SVIP or MVIP."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "svip": {
                "type": "string",
                "description": "Default: None\n\nOptionally, use to test connection of a different SVIP.\nThis is not needed to test the connection to the target cluster."
              },
              "mvip": {
                "type": "string",
                "description": "Default: None\n\nOptionally, use to test connection of a different MVIP.\nThis is not needed to test the connection to the target cluster."
              },
              "password": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ec2_elb_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about EC2 Elastic Load Balancers in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "names": {
                "description": "List of ELB names to gather facts about. Pass this option to gather facts about a set of ELBs, otherwise, all ELBs are returned.",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "imgadm": {
            "required": [
              "state"
            ],
            "type": "object",
            "description": "Manage SmartOS virtual machine images through imgadm(1M)",
            "properties": {
              "force": {
                "description": "Force a given operation (where supported by imgadm(1M)).",
                "$ref": "#/definitions/ansible_truth"
              },
              "uuid": {
                "type": "string",
                "description": "Image UUID. Can either be a full UUID or C(*) for all images."
              },
              "source": {
                "type": "string",
                "description": "URI for the image source."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "deleted",
                  "imported",
                  "updated",
                  "vacuumed"
                ],
                "type": "string",
                "description": "State the object operated on should be in. C(imported) is an alias for for C(present) and C(deleted) for C(absent). When set to C(vacuumed) and C(uuid) to C(*), it will remove all unused images."
              },
              "type": {
                "enum": [
                  "imgapi",
                  "docker",
                  "dsapi"
                ],
                "type": "string",
                "description": "Default: imgapi\n\nType for image sources."
              },
              "pool": {
                "type": "string",
                "description": "Default: zones\n\nzpool to import to or delete images from."
              }
            }
          },
          "nxos_interface": {
            "type": "object",
            "description": "Manages physical attributes of interfaces of NX-OS switches.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Interface description."
              },
              "ip_forward": {
                "enum": [
                  "enable",
                  "disable"
                ],
                "type": "string",
                "description": "Enable/Disable ip forward feature on SVIs."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "interface_type": {
                "enum": [
                  "loopback",
                  "portchannel",
                  "svi",
                  "nve"
                ],
                "type": "string",
                "description": "Interface type to be unconfigured from the device."
              },
              "fabric_forwarding_anycast_gateway": {
                "description": "Associate SVI with anycast gateway under VLAN configuration mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "default"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify desired state of the resource."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "admin_state": {
                "enum": [
                  "up",
                  "down"
                ],
                "type": "string",
                "description": "Default: up\n\nAdministrative state of the interface."
              },
              "mode": {
                "enum": [
                  "layer2",
                  "layer3"
                ],
                "type": "string",
                "description": "Manage Layer 2 or Layer 3 state of the interface."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Full name of interface, i.e. Ethernet1/1, port-channel10."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "zypper": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "refresh"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage packages on SUSE and openSUSE using the zypper and rpm tools.",
            "properties": {
              "force": {
                "description": "Default: no\n\nAdds C(--force) option to I(zypper). Allows to downgrade packages and change vendor or architecture.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "Package name C(name) or package specifier.\nCan include a version like C(name=1.0), C(name>3.4) or C(name<=2.7). If a version is given, C(oldpackage) is implied and zypper is allowed to update the package within the version range given.\nYou can also pass a url or a local path to a rpm file.\nWhen using state=latest, this can be '*', which updates all installed packages.",
                "$ref": "#/definitions/ansible_array"
              },
              "disable_gpg_check": {
                "description": "Default: no\n\nWhether to disable to GPG signature checking of the package signature being installed. Has an effect only if state is I(present) or I(latest).",
                "$ref": "#/definitions/ansible_truth"
              },
              "refresh": {
                "description": "Default: no\n\nRun the equivalent of C(zypper refresh) before the operation.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "absent",
                  "installed",
                  "latest",
                  "present",
                  "removed"
                ],
                "type": "string",
                "description": "Default: present\n\nC(present) will make sure the package is installed. C(latest)  will make sure the latest version of the package is installed. C(absent)  will make sure the specified package is not installed."
              },
              "oldpackage": {
                "description": "Default: no\n\nAdds C(--oldpackage) option to I(zypper). Allows to downgrade packages with less side-effects than force. This is implied as soon as a version is specified as part of the package name.",
                "$ref": "#/definitions/ansible_truth"
              },
              "update_cache": {
                "description": "Default: no\n\nRun the equivalent of C(zypper refresh) before the operation.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "Package name C(name) or package specifier.\nCan include a version like C(name=1.0), C(name>3.4) or C(name<=2.7). If a version is given, C(oldpackage) is implied and zypper is allowed to update the package within the version range given.\nYou can also pass a url or a local path to a rpm file.\nWhen using state=latest, this can be '*', which updates all installed packages.",
                "$ref": "#/definitions/ansible_array"
              },
              "disable_recommends": {
                "description": "Default: yes\n\nCorresponds to the C(--no-recommends) option for I(zypper). Default behavior (C(yes)) modifies zypper's default behavior; C(no) does install recommended packages.",
                "$ref": "#/definitions/ansible_truth"
              },
              "type": {
                "enum": [
                  "package",
                  "patch",
                  "pattern",
                  "product",
                  "srcpackage",
                  "application"
                ],
                "type": "string",
                "description": "Default: package\n\nThe type of package to be operated on."
              }
            }
          },
          "assert": {
            "type": "object",
            "description": "This module asserts that given expressions are true with an optional custom message.",
            "properties": {
              "active_connection_states": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "connect_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "delay": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "present",
                  "absent",
                  "drained"
                ],
                "type": "string",
                "description": ""
              },
              "sleep": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "exclude_hosts": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "search_regex": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "ldap_entry": {
            "required": [
              "dn"
            ],
            "type": "object",
            "description": "Add or remove LDAP entries. This module only asserts the existence or non-existence of an LDAP entry, not its attributes. To assert the attribute values of an entry, see M(ldap_attr).",
            "properties": {
              "dn": {
                "type": "string",
                "description": "The DN of the entry to add or remove."
              },
              "objectClass": {
                "type": "string",
                "description": "If I(state=present), value or list of values to use when creating the entry. It can either be a string or an actual list of strings."
              },
              "start_tls": {
                "description": "Default: no\n\nIf true, we'll use the START_TLS LDAP extension.",
                "$ref": "#/definitions/ansible_truth"
              },
              "bind_dn": {
                "type": "string",
                "description": "A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind."
              },
              "server_uri": {
                "type": "string",
                "description": "Default: ldapi:///\n\nA URI to the LDAP server. The default value lets the underlying LDAP client library look for a UNIX domain socket in its default location."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe target state of the entry."
              },
              "params": {
                "type": "object",
                "description": "List of options which allows to overwrite any of the task or the I(attributes) options. To remove an option, set the value of the option to C(null)."
              },
              "bind_pw": {
                "type": "string",
                "description": "The password to use with I(bind_dn)."
              },
              "attributes": {
                "type": "object",
                "description": "If I(state=present), attributes necessary to create an entry. Existing entries are never modified. To assert specific attribute values on an existing entry, use M(ldap_attr) module instead."
              }
            }
          },
          "ovirt_quotas": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cluster_grace",
                        "cluster_hard_limit"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "storage_grace",
                        "storage_hard_limit"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "storage_threshold",
                        "storage_soft_limit"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cluster_threshold",
                        "cluster_soft_limit"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage datacenter quotas in oVirt",
            "properties": {
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "description": {
                "type": "string",
                "description": "Description of the the quota to manage."
              },
              "name": {
                "type": "string",
                "description": "Name of the the quota to manage."
              },
              "storage_soft_limit": {
                "description": "Storage threshold(soft limit) defined in percentage (0-100).",
                "$ref": "#/definitions/ansible_number"
              },
              "cluster_grace": {
                "description": "Cluster grace(hard limit) defined in percentage (1-100).",
                "$ref": "#/definitions/ansible_number"
              },
              "cluster_threshold": {
                "description": "Cluster threshold(soft limit) defined in percentage (0-100).",
                "$ref": "#/definitions/ansible_number"
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the quota be present/absent."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "storage_hard_limit": {
                "description": "Storage grace(hard limit) defined in percentage (1-100).",
                "$ref": "#/definitions/ansible_number"
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "storage_grace": {
                "description": "Storage grace(hard limit) defined in percentage (1-100).",
                "$ref": "#/definitions/ansible_number"
              },
              "cluster_hard_limit": {
                "description": "Cluster grace(hard limit) defined in percentage (1-100).",
                "$ref": "#/definitions/ansible_number"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "storage_threshold": {
                "description": "Storage threshold(soft limit) defined in percentage (0-100).",
                "$ref": "#/definitions/ansible_number"
              },
              "data_center": {
                "type": "string",
                "description": "Name of the datacenter where quota should be managed."
              },
              "clusters": {
                "description": "List of dictionary of cluster limits, which is valid to specific cluster.\nIf cluster isn't spefied it's valid to all clusters in system:\nC(cluster) - Name of the cluster.\nC(memory) - Memory limit (in GiB).\nC(cpu) - CPU limit.",
                "$ref": "#/definitions/ansible_array"
              },
              "storages": {
                "description": "List of dictionary of storage limits, which is valid to specific storage.\nIf storage isn't spefied it's valid to all storages in system:\nC(storage) - Name of the storage.\nC(size) - Size limit (in GiB).",
                "$ref": "#/definitions/ansible_array"
              },
              "cluster_soft_limit": {
                "description": "Cluster threshold(soft limit) defined in percentage (0-100).",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ec2_lc_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about AWS Autoscaling Launch Configurations",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "sort_end": {
                "type": "string",
                "description": "Which result to end with (when sorting).\nCorresponds to Python slice notation."
              },
              "name": {
                "description": "A name or a list of name to match.",
                "$ref": "#/definitions/ansible_array"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "sort_start": {
                "type": "string",
                "description": "Which result to start with (when sorting).\nCorresponds to Python slice notation."
              },
              "sort": {
                "enum": [
                  "launch_configuration_name",
                  "image_id",
                  "created_time",
                  "instance_type",
                  "kernel_id",
                  "ramdisk_id",
                  "key_name"
                ],
                "type": "string",
                "description": "Optional attribute which with to sort the results."
              },
              "sort_order": {
                "enum": [
                  "ascending",
                  "descending"
                ],
                "type": "string",
                "description": "Default: ascending\n\nOrder in which to sort results.\nOnly used when the 'sort' parameter is specified."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "junos_user": {
            "type": "object",
            "description": "This module manages locally configured user accounts on remote network devices running the JUNOS operating system.  It provides a set of arguments for creating, removing and updating locally defined accounts",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "sshkey": {
                "type": "string",
                "description": "The C(sshkey) argument defines the public SSH key to be configured for the user account on the remote system.  This argument must be a valid SSH key"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe C(state) argument configures the state of the user definitions as it relates to the device operational configuration.  When set to I(present), the user should be configured in the device active configuration and when set to I(absent) the user should not be in the device active configuration"
              },
              "full_name": {
                "type": "string",
                "description": "The C(full_name) argument provides the full name of the user account to be created on the remote device.  This argument accepts any text string value."
              },
              "name": {
                "type": "string",
                "description": "The C(name) argument defines the username of the user to be created on the system.  This argument must follow appropriate usernaming conventions for the target device running JUNOS.  This argument is mutually exclusive with the C(users) argument."
              },
              "purge": {
                "description": "The C(purge) argument instructs the module to consider the users definition absolute.  It will remove any previously configured users on the device with the exception of the current defined set of users.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "role": {
                "enum": [
                  "operator",
                  "read-only",
                  "super-user",
                  "unauthorized"
                ],
                "type": "string",
                "description": "Default: read-only\n\nThe C(role) argument defines the role of the user account on the remote system.  User accounts can have more than one role configured."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              },
              "users": {
                "description": "The C(users) argument defines a list of users to be configured on the remote device.  The list of users will be compared against the current users and only changes will be added or removed from the device configuration.  This argument is mutually exclusive with the name argument.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "ovirt_storage_domains": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "domain_function",
                        "type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage storage domains in oVirt",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Comment of the storage domain."
              },
              "fcp": {
                "type": "object",
                "description": "Dictionary with values for fibre channel storage type:\nC(address) - Address of the fibre channel storage server.\nC(port) - Port of the fibre channel storage server.\nC(lun_id) - LUN id.\nNote that these parameters are not idempotent."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "description": {
                "type": "string",
                "description": "Description of the storage domain."
              },
              "glusterfs": {
                "type": "object",
                "description": "Dictionary with values for GlusterFS storage type:\nC(address) - Address of the Gluster server. E.g.: myserver.mydomain.com\nC(path) - Path of the mount point. E.g.: /path/to/my/data\nC(mount_options) - Option which will be passed when mounting storage.\nNote that these parameters are not idempotent."
              },
              "format": {
                "description": "If I(True) storage domain will be formatted after removing it from oVirt.\nThis parameter is relevant only when C(state) is I(absent).",
                "$ref": "#/definitions/ansible_truth"
              },
              "iscsi": {
                "type": "object",
                "description": "Dictionary with values for iSCSI storage type:\nC(address) - Address of the iSCSI storage server.\nC(port) - Port of the iSCSI storage server.\nC(target) - The target IQN for the storage device.\nC(lun_id) - LUN id.\nC(username) - A CHAP user name for logging into a target.\nC(password) - A CHAP password for logging into a target.\nC(override_luns) - If I(True) ISCSI storage domain luns will be overriden before adding.\nNote that these parameters are not idempotent."
              },
              "posixfs": {
                "type": "object",
                "description": "Dictionary with values for PosixFS storage type:\nC(path) - Path of the mount point. E.g.: /path/to/my/data\nC(vfs_type) - Virtual File System type.\nC(mount_options) - Option which will be passed when mounting storage.\nNote that these parameters are not idempotent."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": "Host to be used to mount storage."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Name of the the storage domain to manage."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "maintenance",
                  "unattached"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the storage domain be present/absent/maintenance/unattached"
              },
              "nfs": {
                "type": "object",
                "description": "Dictionary with values for NFS storage type:\nC(address) - Address of the NFS server. E.g.: myserver.mydomain.com\nC(path) - Path of the mount point. E.g.: /path/to/my/data\nC(version) - NFS version. One of: I(auto), I(v3), I(v4) or I(v4_1).\nC(timeout) - The time in tenths of a second to wait for a response before retrying NFS requests. Range 0 to 65535.\nC(retrans) - The number of times to retry a request before attempting further recovery actions. Range 0 to 65535.\nNote that these parameters are not idempotent."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "domain_function": {
                "enum": [
                  "data",
                  "iso",
                  "export"
                ],
                "type": "string",
                "description": "Default: data\n\nFunction of the storage domain.\nThis parameter isn't idempotent, it's not possible to change domain function of storage domain."
              },
              "data_center": {
                "type": "string",
                "description": "Data center name where storage domain should be attached.\nThis parameter isn't idempotent, it's not possible to change data center of storage domain."
              },
              "destroy": {
                "description": "Logical remove of the storage domain. If I(true) retains the storage domain's data for import.\nThis parameter is relevant only when C(state) is I(absent).",
                "$ref": "#/definitions/ansible_truth"
              },
              "type": {
                "enum": [
                  "data",
                  "iso",
                  "export"
                ],
                "type": "string",
                "description": "Default: data\n\nFunction of the storage domain.\nThis parameter isn't idempotent, it's not possible to change domain function of storage domain."
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rhn_channel": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Adds or removes Red Hat software channels",
            "properties": {
              "sysname": {
                "type": "string",
                "description": "name of the system as it is known in RHN/Satellite"
              },
              "name": {
                "type": "string",
                "description": "name of the software channel"
              },
              "url": {
                "type": "string",
                "description": "The full url to the RHN/Satellite api"
              },
              "pwd": {
                "type": "string",
                "description": "the user's password"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nwhether the channel should be present or not"
              },
              "user": {
                "type": "string",
                "description": "RHN/Satellite user"
              },
              "password": {
                "type": "string",
                "description": "the user's password"
              }
            }
          },
          "apache2_module": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Enables or disables a specified module of the Apache2 webserver.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nindicate the desired state of the resource"
              },
              "force": {
                "description": "force disabling of default modules and override Debian warnings",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "name of the module to enable/disable"
              },
              "ignore_configcheck": {
                "description": "Ignore configuration checks about inconsistent module configuration. Especially for mpm_* modules.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "mount": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module controls active and configured mount points in C(/etc/fstab).",
            "properties": {
              "src": {
                "type": "string",
                "description": "Device to be mounted on I(path). Required when I(state) set to C(present) or C(mounted)."
              },
              "name": {
                "type": "string",
                "description": "Path to the mount point (e.g. C(/mnt/files)).\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "dump": {
                "type": "string",
                "description": "Dump (see fstab(5)). Note that if set to C(null) and I(state) set to C(present), it will cease to work and duplicate entries will be made with subsequent runs.\nHas no effect on Solaris systems."
              },
              "boot": {
                "enum": [
                  "yes",
                  "no"
                ],
                "type": "string",
                "description": "Default: True\n\nDetermines if the filesystem should be mounted on boot.\nOnly applies to Solaris systems."
              },
              "fstab": {
                "type": "string",
                "description": "Default: /etc/fstab (/etc/vfstab on Solaris)\n\nFile to use instead of C(/etc/fstab). You shouldn't use this option unless you really know what you are doing. This might be useful if you need to configure mountpoints in a chroot environment.  OpenBSD does not allow specifying alternate fstab files with mount so do not use this on OpenBSD with any state that operates on the live filesystem."
              },
              "passno": {
                "type": "string",
                "description": "Passno (see fstab(5)). Note that if set to C(null) and I(state) set to C(present), it will cease to work and duplicate entries will be made with subsequent runs.\nDeprecated on Solaris systems."
              },
              "fstype": {
                "type": "string",
                "description": "Filesystem type. Required when I(state) is C(present) or C(mounted)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "mounted",
                  "unmounted"
                ],
                "type": "string",
                "description": "If C(mounted) or C(unmounted), the device will be actively mounted or unmounted as needed and appropriately configured in I(fstab).\nC(absent) and C(present) only deal with I(fstab) but will not affect current mounting.\nIf specifying C(mounted) and the mount point is not present, the mount point will be created.\nSimilarly, specifying C(absent) will remove the mount point directory."
              },
              "path": {
                "type": "string",
                "description": "Path to the mount point (e.g. C(/mnt/files)).\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "opts": {
                "type": "string",
                "description": "Mount options (see fstab(5), or vfstab(4) on Solaris)."
              }
            }
          },
          "apache2_mod_proxy": {
            "required": [
              "balancer_vhost"
            ],
            "type": "object",
            "description": "Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool, using HTTP POST and GET requests. The httpd mod_proxy balancer-member status page has to be enabled and accessible, as this module relies on parsing this page. This module supports ansible check_mode, and requires BeautifulSoup python module.",
            "properties": {
              "tls": {
                "description": "Use https to access balancer management page.",
                "$ref": "#/definitions/ansible_truth"
              },
              "balancer_vhost": {
                "type": "string",
                "description": "Default: None\n\n(ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool."
              },
              "balancer_url_suffix": {
                "type": "string",
                "description": "Default: /balancer-manager/\n\nSuffix of the balancer pool url required to access the balancer pool status page (e.g. balancer_vhost[:port]/balancer_url_suffix)."
              },
              "member_host": {
                "type": "string",
                "description": "Default: None\n\n(ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes."
              },
              "state": {
                "type": "string",
                "description": "Default: None\n\nDesired state of the member host. (absent|disabled),drained,hot_standby,ignore_errors can be simultaneously invoked by separating them with a comma (e.g. state=drained,ignore_errors)."
              },
              "validate_certs": {
                "description": "Default: True\n\nValidate ssl/tls certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "avi_analyticsprofile": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure AnalyticsProfile object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "hs_event_throttle_window": {
                "description": "Time window (in secs) within which only unique health change events should occur.\nDefault value when not specified in API or module is interpreted by Avi Controller as 1209600.",
                "$ref": "#/definitions/ansible_number"
              },
              "apdex_rtt_tolerated_factor": {
                "type": "number",
                "description": "Tolerated client to avi round trip time(rtt) factor.\nIt is a multiple of apdex_rtt_tolerated_factor.\nDefault value when not specified in API or module is interpreted by Avi Controller as 4.0."
              },
              "disable_se_analytics": {
                "description": "Disable node (service engine) level analytics forvs metrics.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "conn_server_lossy_timeo_rexmt_threshold": {
                "description": "A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted due to timeout.\nDefault value when not specified in API or module is interpreted by Avi Controller as 20.",
                "$ref": "#/definitions/ansible_number"
              },
              "apdex_server_rtt_tolerated_factor": {
                "type": "number",
                "description": "Tolerated client to avi round trip time(rtt) factor.\nIt is a multiple of apdex_rtt_tolerated_factor.\nDefault value when not specified in API or module is interpreted by Avi Controller as 4.0."
              },
              "hs_security_encalgo_score_rc4": {
                "type": "number",
                "description": "Score assigned when rc4 algorithm is used for encryption.\nDefault value when not specified in API or module is interpreted by Avi Controller as 2.5."
              },
              "hs_security_tls12_score": {
                "type": "number",
                "description": "Score assigned when supporting tls1.2 encryption protocol.\nDefault value when not specified in API or module is interpreted by Avi Controller as 5.0."
              },
              "exclude_server_tcp_reset_as_error": {
                "description": "Exclude server tcp reset from errors.\nIt is common for applications like ms exchange.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "hs_min_dos_rate": {
                "description": "Dos connection rate below which the dos security assessment will not kick in.\nDefault value when not specified in API or module is interpreted by Avi Controller as 1000.",
                "$ref": "#/definitions/ansible_number"
              },
              "exclude_no_dns_record_as_error": {
                "description": "Exclude queries to domains that did not have configured services/records from the list of errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "exclude_invalid_dns_query_as_error": {
                "description": "Exclude invalid dns queries from the list of errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "hs_max_resources_penalty": {
                "description": "Maximum penalty that may be deducted from health score for high resource utilization.\nDefault value when not specified in API or module is interpreted by Avi Controller as 25.",
                "$ref": "#/definitions/ansible_number"
              },
              "conn_lossy_total_rexmt_threshold": {
                "description": "A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted.\nDefault value when not specified in API or module is interpreted by Avi Controller as 50.",
                "$ref": "#/definitions/ansible_number"
              },
              "hs_pscore_traffic_threshold_l4_client": {
                "type": "number",
                "description": "Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.\nDefault value when not specified in API or module is interpreted by Avi Controller as 10.0."
              },
              "hs_security_weak_signature_algo_penalty": {
                "type": "number",
                "description": "Penalty for allowing weak signature algorithm(s).\nDefault value when not specified in API or module is interpreted by Avi Controller as 1.0."
              },
              "exclude_no_valid_gs_member_as_error": {
                "description": "Exclude queries to gslb services that have no available members from the list of errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "apdex_server_response_threshold": {
                "description": "A server http response is considered satisfied if latency is less than the satisfactory latency threshold.\nThe response is considered tolerated when it is greater than satisfied but less than the tolerated latency factor * s_latency.\nGreater than this number and the server response is considered frustrated.\nDefault value when not specified in API or module is interpreted by Avi Controller as 400.",
                "$ref": "#/definitions/ansible_number"
              },
              "hs_security_cipherscore_ge128b": {
                "type": "number",
                "description": "Score assigned when the minimum cipher strength is greater than equal to 128 bits.\nDefault value when not specified in API or module is interpreted by Avi Controller as 5.0."
              },
              "resp_code_block": {
                "description": "Block of http response codes to be excluded from being classified as an error.",
                "$ref": "#/definitions/ansible_array"
              },
              "hs_performance_boost": {
                "description": "Adds free performance score credits to health score.\nIt can be used for compensating health score for known slow applications.\nDefault value when not specified in API or module is interpreted by Avi Controller as 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "uuid": {
                "type": "string",
                "description": "Uuid of the analytics profile."
              },
              "exclude_invalid_dns_domain_as_error": {
                "description": "Exclude dns queries to domains outside the domains configured in the dns application profile from the list of errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "exclude_http_error_codes": {
                "description": "List of http status codes to be excluded from being classified as an error.\nError connections or responses impacts health score, are included as significant logs, and may be classified as part of a dos attack.",
                "$ref": "#/definitions/ansible_array"
              },
              "hs_max_anomaly_penalty": {
                "description": "Maximum penalty that may be deducted from health score for anomalies.\nDefault value when not specified in API or module is interpreted by Avi Controller as 10.",
                "$ref": "#/definitions/ansible_number"
              },
              "hs_security_tls11_score": {
                "type": "number",
                "description": "Score assigned when supporting tls1.1 encryption protocol.\nDefault value when not specified in API or module is interpreted by Avi Controller as 5.0."
              },
              "apdex_rum_tolerated_factor": {
                "type": "number",
                "description": "Virtual service threshold factor for tolerated page load time (plt) as multiple of apdex_rum_threshold.\nDefault value when not specified in API or module is interpreted by Avi Controller as 4.0."
              },
              "exclude_gs_down_as_error": {
                "description": "Exclude queries to gslb services that are operationally down from the list of errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "apdex_server_response_tolerated_factor": {
                "type": "number",
                "description": "Server tolerated response latency factor.\nServermust response within this factor times the satisfactory threshold (apdex_server_response_threshold) to be considered tolerated.\nDefault value when not specified in API or module is interpreted by Avi Controller as 4.0."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "disable_server_analytics": {
                "description": "Disable analytics on backend servers.\nThis may be desired in container environment when there are large number of  ephemeral servers.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "exclude_persistence_change_as_error": {
                "description": "Exclude persistence server changed while load balancing' from the list of errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "exclude_client_close_before_request_as_error": {
                "description": "Exclude client closed connection before an http request could be completed from being classified as an error.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "hs_security_nonpfs_penalty": {
                "type": "number",
                "description": "Penalty for allowing non-pfs handshakes.\nDefault value when not specified in API or module is interpreted by Avi Controller as 1.0."
              },
              "hs_security_hsts_penalty": {
                "type": "number",
                "description": "Penalty for not enabling hsts.\nDefault value when not specified in API or module is interpreted by Avi Controller as 1.0."
              },
              "hs_security_selfsignedcert_penalty": {
                "type": "number",
                "description": "Deprecated.\nDefault value when not specified in API or module is interpreted by Avi Controller as 1.0."
              },
              "conn_server_lossy_total_rexmt_threshold": {
                "description": "A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted.\nDefault value when not specified in API or module is interpreted by Avi Controller as 50.",
                "$ref": "#/definitions/ansible_number"
              },
              "conn_lossy_timeo_rexmt_threshold": {
                "description": "A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted due to timeout.\nDefault value when not specified in API or module is interpreted by Avi Controller as 20.",
                "$ref": "#/definitions/ansible_number"
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "hs_security_certscore_gt30d": {
                "type": "number",
                "description": "Score assigned when the certificate expires in more than 30 days.\nDefault value when not specified in API or module is interpreted by Avi Controller as 5.0."
              },
              "description": {
                "type": "string",
                "description": "User defined description for the object."
              },
              "hs_security_ssl30_score": {
                "type": "number",
                "description": "Score assigned when supporting ssl3.0 encryption protocol.\nDefault value when not specified in API or module is interpreted by Avi Controller as 3.5."
              },
              "conn_server_lossy_ooo_threshold": {
                "description": "A connection between avi and server is considered lossy when more than this percentage of out of order packets are received.\nDefault value when not specified in API or module is interpreted by Avi Controller as 50.",
                "$ref": "#/definitions/ansible_number"
              },
              "client_log_config": {
                "type": "object",
                "description": "Clientlogconfiguration settings for analyticsprofile."
              },
              "hs_security_cipherscore_eq000b": {
                "type": "number",
                "description": "Score assigned when the minimum cipher strength is 0 bits.\nDefault value when not specified in API or module is interpreted by Avi Controller as 0.0."
              },
              "hs_security_certscore_le30d": {
                "type": "number",
                "description": "Score assigned when the certificate expires in less than or equal to 30 days.\nDefault value when not specified in API or module is interpreted by Avi Controller as 4.0."
              },
              "hs_pscore_traffic_threshold_l4_server": {
                "type": "number",
                "description": "Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.\nDefault value when not specified in API or module is interpreted by Avi Controller as 10.0."
              },
              "exclude_syn_retransmit_as_error": {
                "description": "Exclude 'server unanswered syns' from the list of errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ranges": {
                "description": "List of http status code ranges to be excluded from being classified as an error.",
                "$ref": "#/definitions/ansible_array"
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "apdex_server_rtt_threshold": {
                "description": "Satisfactory client to avi round trip time(rtt).\nDefault value when not specified in API or module is interpreted by Avi Controller as 125.",
                "$ref": "#/definitions/ansible_number"
              },
              "exclude_server_dns_error_as_error": {
                "description": "Exclude server dns error response from the list of errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "hs_security_certscore_le07d": {
                "type": "number",
                "description": "Score assigned when the certificate expires in less than or equal to 7 days.\nDefault value when not specified in API or module is interpreted by Avi Controller as 2.0."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "conn_lossy_zero_win_size_event_threshold": {
                "description": "A client connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.\nDefault value when not specified in API or module is interpreted by Avi Controller as 2.",
                "$ref": "#/definitions/ansible_number"
              },
              "apdex_rum_threshold": {
                "description": "If a client is able to load a page in less than the satisfactory latency threshold, the pageload is considered satisfied.\nIt is considered tolerated if it is greater than satisfied but less than the tolerated latency multiplied by satisifed latency.\nGreater than this number and the client's request is considered frustrated.\nA pageload includes the time for dns lookup, download of all http objects, and page render time.\nDefault value when not specified in API or module is interpreted by Avi Controller as 5000.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "The name of the analytics profile."
              },
              "hs_security_chain_invalidity_penalty": {
                "type": "number",
                "description": "Penalty for allowing certificates with invalid chain.\nDefault value when not specified in API or module is interpreted by Avi Controller as 1.0."
              },
              "hs_security_encalgo_score_none": {
                "type": "number",
                "description": "Score assigned when no algorithm is used for encryption.\nDefault value when not specified in API or module is interpreted by Avi Controller as 0.0."
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "apdex_response_tolerated_factor": {
                "type": "number",
                "description": "Client tolerated response latency factor.\nClient must receive a response within this factor times the satisfactory threshold (apdex_response_threshold) to be considered tolerated.\nDefault value when not specified in API or module is interpreted by Avi Controller as 4.0."
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "exclude_tcp_reset_as_error": {
                "description": "Exclude tcp resets by client from the list of potential errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "hs_max_security_penalty": {
                "description": "Maximum penalty that may be deducted from health score based on security assessment.\nDefault value when not specified in API or module is interpreted by Avi Controller as 100.",
                "$ref": "#/definitions/ansible_number"
              },
              "conn_server_lossy_zero_win_size_event_threshold": {
                "description": "A server connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.\nDefault value when not specified in API or module is interpreted by Avi Controller as 2.",
                "$ref": "#/definitions/ansible_number"
              },
              "conn_lossy_ooo_threshold": {
                "description": "A connection between client and avi is considered lossy when more than this percentage of out of order packets are received.\nDefault value when not specified in API or module is interpreted by Avi Controller as 50.",
                "$ref": "#/definitions/ansible_number"
              },
              "hs_security_cipherscore_lt128b": {
                "type": "number",
                "description": "Score assigned when the minimum cipher strength is less than 128 bits.\nDefault value when not specified in API or module is interpreted by Avi Controller as 3.5."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "hs_security_tls10_score": {
                "type": "number",
                "description": "Score assigned when supporting tls1.0 encryption protocol.\nDefault value when not specified in API or module is interpreted by Avi Controller as 5.0."
              },
              "hs_security_certscore_expired": {
                "type": "number",
                "description": "Score assigned when the certificate has expired.\nDefault value when not specified in API or module is interpreted by Avi Controller as 0.0."
              },
              "apdex_response_threshold": {
                "description": "If a client receives an http response in less than the satisfactory latency threshold, the request is considered satisfied.\nIt is considered tolerated if it is not satisfied and less than tolerated latency factor multiplied by the satisfactory latency threshold.\nGreater than this number and the client's request is considered frustrated.\nDefault value when not specified in API or module is interpreted by Avi Controller as 500.",
                "$ref": "#/definitions/ansible_number"
              },
              "apdex_rtt_threshold": {
                "description": "Satisfactory client to avi round trip time(rtt).\nDefault value when not specified in API or module is interpreted by Avi Controller as 250.",
                "$ref": "#/definitions/ansible_number"
              },
              "exclude_unsupported_dns_query_as_error": {
                "description": "Exclude unsupported dns queries from the list of errors.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "iosxr_system": {
            "type": "object",
            "description": "This module provides declarative management of node system attributes on Cisco IOS XR devices.  It provides an option to configure host system parameters or remove those parameters from the device active configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "lookup_source": {
                "type": "string",
                "description": "The C(lookup_source) argument provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device."
              },
              "domain_search": {
                "description": "Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.",
                "$ref": "#/definitions/ansible_array"
              },
              "hostname": {
                "type": "string",
                "description": "Configure the device hostname parameter. This option takes an ASCII string value."
              },
              "domain_name": {
                "type": "string",
                "description": "Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the configuration values in the device's current active configuration.  When set to I(present), the values should be configured in the device active configuration and when set to I(absent) the values should not be in the device active configuration"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "name_servers": {
                "description": "The C(name_serves) argument accepts a list of DNS name servers by way of either FQDN or IP address to use to perform name resolution lookups.  This argument accepts wither a list of DNS servers See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "lookup_enabled": {
                "description": "Provides administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "authorized_key": {
            "required": [
              "user",
              "key"
            ],
            "type": "object",
            "description": "Adds or removes SSH authorized keys for particular user accounts",
            "properties": {
              "exclusive": {
                "description": "Default: no\n\nWhether to remove all other non-specified keys from the authorized_keys file. Multiple keys can be specified in a single C(key) string value by separating them by newlines.\nThis option is not loop aware, so if you use C(with_) , it will be exclusive per iteration of the loop, if you want multiple keys in the file you need to pass them all to C(key) in a single batch as mentioned above.",
                "$ref": "#/definitions/ansible_truth"
              },
              "key_options": {
                "type": "string",
                "description": "A string of ssh key options to be prepended to the key in the authorized_keys file"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the given key (with the given key_options) should or should not be in the file"
              },
              "user": {
                "type": "string",
                "description": "The username on the remote host whose authorized_keys file will be modified"
              },
              "key": {
                "type": "string",
                "description": "The SSH public key(s), as a string or (since 1.9) url (https://github.com/username.keys)"
              },
              "path": {
                "type": "string",
                "description": "Default: (homedir)+/.ssh/authorized_keys\n\nAlternate path to the authorized_keys file"
              },
              "unique": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "Default: yes\n\nThis only applies if using a https url as the source of the keys. If set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.\nPrior to 2.1 the code worked as if this was set to C(yes).",
                "$ref": "#/definitions/ansible_truth"
              },
              "manage_dir": {
                "description": "Default: yes\n\nWhether this module should manage the directory of the authorized key file.  If set, the module will create the directory, as well as set the owner and permissions of an existing directory. Be sure to set C(manage_dir=no) if you are using an alternate directory for authorized_keys, as set with C(path), since you could lock yourself out of SSH access. See the example below.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_feature": {
            "required": [
              "feature"
            ],
            "type": "object",
            "description": "Offers ability to enable and disable features in NX-OS.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "feature": {
                "type": "string",
                "description": "Name of feature."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enabled\n\nDesired state of the feature."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "openssl_publickey": {
            "required": [
              "path"
            ],
            "type": "object",
            "description": "This module allows one to (re)generate OpenSSL public keys from their private keys. It uses the pyOpenSSL python library to interact with openssl. Keys are generated in PEM format. This module works only if the version of PyOpenSSL is recent enough (> 16.0.0)",
            "properties": {
              "path": {
                "type": "string",
                "description": "Name of the file in which the generated TLS/SSL public key will be written."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the public key should exist or not, taking action if the state is different from what is stated."
              },
              "force": {
                "description": "Should the key be regenerated even it it already exists",
                "$ref": "#/definitions/ansible_truth"
              },
              "privatekey_path": {
                "type": "string",
                "description": "Path to the TLS/SSL private key from which to genereate the public key."
              }
            }
          },
          "vmware_dns_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage VMware ESXi DNS Configuration",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "dns_servers": {
                "description": "The DNS servers that the host should be configured to use.",
                "$ref": "#/definitions/ansible_array"
              },
              "domainname": {
                "type": "string",
                "description": "The domain the ESXi host should be apart of."
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "change_hostname_to": {
                "type": "string",
                "description": "The hostname that an ESXi host should be changed to."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_ospf_vrf": {
            "required": [
              "ospf"
            ],
            "type": "object",
            "description": "Manages a VRF for an OSPF router.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "timer_throttle_lsa_max": {
                "type": "string",
                "description": "Specify the max interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'."
              },
              "timer_throttle_spf_max": {
                "type": "string",
                "description": "Specify the maximum wait time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'."
              },
              "timer_throttle_lsa_hold": {
                "type": "string",
                "description": "Specify the hold interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "auto_cost": {
                "type": "string",
                "description": "Specifies the reference bandwidth used to assign OSPF cost. Valid values are an integer, in Mbps, or the keyword 'default'."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "router_id": {
                "type": "string",
                "description": "Router Identifier (ID) of the OSPF router VRF instance."
              },
              "default_metric": {
                "type": "string",
                "description": "Specify the default Metric value. Valid values are an integer or the keyword 'default'."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "vrf": {
                "type": "string",
                "description": "Default: default\n\nName of the resource instance. Valid value is a string. The name 'default' is a valid VRF representing the global OSPF."
              },
              "timer_throttle_spf_start": {
                "type": "string",
                "description": "Specify initial Shortest Path First (SPF) schedule delay. Valid values are an integer, in milliseconds, or the keyword 'default'."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "timer_throttle_spf_hold": {
                "type": "string",
                "description": "Specify minimum hold time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "ospf": {
                "type": "string",
                "description": "Name of the OSPF instance."
              },
              "log_adjacency": {
                "enum": [
                  "log",
                  "detail",
                  "default"
                ],
                "type": "string",
                "description": "Controls the level of log messages generated whenever a neighbor changes state. Valid values are 'log', 'detail', and 'default'."
              },
              "timer_throttle_lsa_start": {
                "type": "string",
                "description": "Specify the start interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "packet_device": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "hostnames",
                        "name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "create, destroy, update, start, stop, and reboot a Packet Host machine. When the machine is created it can optionally wait for it to have an IP address before returning. This module has a dependency on packet >= 1.0.\nAPI is documented at U(https://www.packet.net/help/api/#page:devices,header:devices-devices-post).",
            "properties": {
              "count": {
                "description": "The number of devices to create. Count number can be included in hostname via the %d string formatter.",
                "$ref": "#/definitions/ansible_number"
              },
              "operating_system": {
                "type": "string",
                "description": "OS slug for device creation. See Packet docs or API for current list."
              },
              "locked": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "features": {
                "type": "object",
                "description": "Dict with \"features\" for device creation. See Packet API docs for details."
              },
              "facility": {
                "type": "string",
                "description": "Facility slug for device creation. As of 2016, it should be one of [ewr1, sjc1, ams1, nrt1]."
              },
              "auth_token": {
                "type": "string",
                "description": "Packet api token. You can also supply it in env var C(PACKET_API_TOKEN)."
              },
              "device_ids": {
                "description": "List of device IDs on which to operate.",
                "$ref": "#/definitions/ansible_array"
              },
              "user_data": {
                "type": "string",
                "description": "Default: None\n\nUserdata blob made available to the machine"
              },
              "wait": {
                "description": "Whether to wait for the instance to be assigned IP address before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "count_offset": {
                "description": "From which number to start the count.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "active",
                  "inactive",
                  "rebooted"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the device."
              },
              "wait_timeout": {
                "description": "Default: 60\n\nHow long to wait for IP address of new devices before quitting. In seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "plan": {
                "type": "string",
                "description": "Plan slug for device creation. See Packet docs or API for current list."
              },
              "project_id": {
                "type": "string",
                "description": "ID of project of the device."
              },
              "hostnames": {
                "description": "A hostname of a device, or a list of hostnames.\nIf given string or one-item list, you can use the C(\"%d\") Python string format to expand numbers from count.\nIf only one hostname, it might be expanded to list if count>1.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "description": "A hostname of a device, or a list of hostnames.\nIf given string or one-item list, you can use the C(\"%d\") Python string format to expand numbers from count.\nIf only one hostname, it might be expanded to list if count>1.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "cl_bridge": {
            "required": [
              "name",
              "ports"
            ],
            "type": "object",
            "description": "Configures a bridge interface on Cumulus Linux To configure a bond port use the cl_bond module. To configure any other type of interface use the cl_interface module. Follow the guidelines for bridging found in the Cumulus User Guide at U(http://docs.cumulusnetworks.com)",
            "properties": {
              "addr_method": {
                "enum": [
                  "",
                  "dhcp"
                ],
                "type": "string",
                "description": "Configures the port to use DHCP. To enable this feature use the option I(dhcp)."
              },
              "name": {
                "type": "string",
                "description": "Name of the interface."
              },
              "vlan_aware": {
                "description": "Enables vlan-aware mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "mstpctl_treeprio": {
                "type": "string",
                "description": "Set spanning tree root priority. Must be a multiple of 4096."
              },
              "virtual_mac": {
                "type": "string",
                "description": "Define Ethernet mac associated with Cumulus Linux VRR feature."
              },
              "mtu": {
                "type": "string",
                "description": "Set MTU. Configure Jumbo Frame by setting MTU to I(9000)."
              },
              "pvid": {
                "type": "string",
                "description": "In vlan-aware mode, defines vlan that is the untagged vlan."
              },
              "ipv4": {
                "description": "List of IPv4 addresses to configure on the interface. In the form I(X.X.X.X/YY).",
                "$ref": "#/definitions/ansible_array"
              },
              "stp": {
                "description": "Default: yes\n\nEnables spanning tree Protocol. As of Cumulus Linux 2.5 the default bridging mode, only per vlan RSTP or 802.1d is supported. For the vlan aware mode, only common instance STP is supported",
                "$ref": "#/definitions/ansible_truth"
              },
              "virtual_ip": {
                "type": "string",
                "description": "Define IPv4 virtual IP used by the Cumulus Linux VRR feature."
              },
              "ipv6": {
                "description": "List of IPv6 addresses to configure on the interface. In the form I(X:X:X::X/YYY).",
                "$ref": "#/definitions/ansible_array"
              },
              "vids": {
                "description": "In vlan-aware mode, lists VLANs defined under the interface.",
                "$ref": "#/definitions/ansible_array"
              },
              "alias_name": {
                "type": "string",
                "description": "Description of the port."
              },
              "ports": {
                "description": "List of bridge members.",
                "$ref": "#/definitions/ansible_array"
              },
              "location": {
                "type": "string",
                "description": "Default: ['/etc/network/interfaces.d']\n\nInterface directory location."
              }
            }
          },
          "flowdock": {
            "required": [
              "token",
              "msg",
              "type"
            ],
            "type": "object",
            "description": "Send a message to a flowdock team inbox or chat using the push API (see https://www.flowdock.com/api/team-inbox and https://www.flowdock.com/api/chat)",
            "properties": {
              "from_name": {
                "type": "string",
                "description": "(inbox only) Name of the message sender"
              },
              "from_address": {
                "type": "string",
                "description": "(inbox only - required) Email address of the message sender"
              },
              "tags": {
                "type": "string",
                "description": "tags of the message, separated by commas"
              },
              "type": {
                "enum": [
                  "inbox",
                  "chat"
                ],
                "type": "string",
                "description": "Whether to post to 'inbox' or 'chat'"
              },
              "external_user_name": {
                "type": "string",
                "description": "(chat only - required) Name of the \"user\" sending the message"
              },
              "project": {
                "type": "string",
                "description": "(inbox only) Human readable identifier for more detailed message categorization"
              },
              "source": {
                "type": "string",
                "description": "(inbox only - required) Human readable identifier of the application that uses the Flowdock API"
              },
              "token": {
                "type": "string",
                "description": "API token."
              },
              "link": {
                "type": "string",
                "description": "(inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox."
              },
              "reply_to": {
                "type": "string",
                "description": "(inbox only) Email address for replies"
              },
              "subject": {
                "type": "string",
                "description": "(inbox only - required) Subject line of the message"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "msg": {
                "type": "string",
                "description": "Content of the message"
              }
            }
          },
          "bigip_routedomain": {
            "type": "object",
            "description": "Manage route domains on a BIG-IP",
            "properties": {
              "flow_eviction_policy": {
                "type": "string",
                "description": "The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain."
              },
              "service_policy": {
                "type": "string",
                "description": "Service policy to associate with the route domain."
              },
              "description": {
                "type": "string",
                "description": "Specifies descriptive text that identifies the route domain."
              },
              "parent": {
                "type": "string",
                "description": "Specifies the route domain the system searches when it cannot\nfind a route in the configured domain.\n"
              },
              "connection_limit": {
                "type": "string",
                "description": "The maximum number of concurrent connections allowed for the route domain. Setting this to C(0) turns off connection limits."
              },
              "strict": {
                "type": "string",
                "description": "Specifies whether the system enforces cross-routing restrictions or not."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhether the route domain should exist or not."
              },
              "routing_protocol": {
                "type": "string",
                "description": "Dynamic routing protocols for the system to use in the route domain."
              },
              "bwc_policy": {
                "type": "string",
                "description": "The bandwidth controller for the route domain."
              },
              "vlans": {
                "type": "string",
                "description": "VLANs for the system to use in the route domain"
              },
              "id": {
                "type": "string",
                "description": "The unique identifying integer representing the route domain."
              }
            }
          },
          "locale_gen": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manages locales by editing /etc/locale.gen and invoking locale-gen.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the locale shall be present."
              },
              "name": {
                "type": "string",
                "description": "Name and encoding of the locale, such as \"en_GB.UTF-8\"."
              }
            }
          },
          "cs_domain": {
            "required": [
              "path"
            ],
            "type": "object",
            "description": "Create, update and remove domains.",
            "properties": {
              "api_key": {
                "type": "string",
                "description": ""
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "clean_up": {
                "description": "Clean up all domain resources like child domains and accounts.\nConsidered on C(state=absent).",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the domain."
              },
              "path": {
                "type": "string",
                "description": "Path of the domain.\nPrefix C(ROOT/) or C(/ROOT/) in path is optional."
              },
              "network_domain": {
                "type": "string",
                "description": "Network domain for networks in the domain."
              }
            }
          },
          "win_msi": {
            "type": "object",
            "description": "Installs or uninstalls a Windows MSI file that is already located on the target server",
            "properties": {
              "extra_args": {
                "type": "string",
                "description": "Additional arguments to pass to the msiexec.exe command"
              },
              "path": {
                "type": "string",
                "description": "File system path to the MSI file to install"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhether the MSI file should be installed or uninstalled"
              },
              "creates": {
                "type": "string",
                "description": "Path to a file created by installing the MSI to prevent from attempting to reinstall the package on every run"
              },
              "wait": {
                "type": "string",
                "description": "Specify whether to wait for install or uninstall to complete before continuing."
              }
            }
          },
          "rax_cdb_database": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "create / delete a database in the Cloud Databases.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name to give to the database"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "collate": {
                "type": "string",
                "description": "Default: utf8_general_ci\n\nSet of rules for comparing characters in a character set"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "cdb_id": {
                "type": "string",
                "description": "The databases server UUID"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "character_set": {
                "type": "string",
                "description": "Default: utf8\n\nSet of symbols and encodings"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "cronvar": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Use this module to manage crontab variables. This module allows you to create, update, or delete cron variable definitions.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the crontab variable."
              },
              "insertbefore": {
                "type": "string",
                "description": "Used with C(state=present). If specified, the variable will be inserted just before the variable specified."
              },
              "cron_file": {
                "type": "string",
                "description": "If specified, uses this file instead of an individual user's crontab. Without a leading /, this is assumed to be in /etc/cron.d.  With a leading /, this is taken as absolute."
              },
              "value": {
                "type": "string",
                "description": "The value to set this variable to.  Required if state=present."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to ensure that the variable is present or absent."
              },
              "user": {
                "type": "string",
                "description": "Default: root\n\nThe specific user whose crontab should be modified."
              },
              "insertafter": {
                "type": "string",
                "description": "Used with C(state=present). If specified, the variable will be inserted after the variable specified."
              },
              "backup": {
                "description": "If set, create a backup of the crontab before it is modified. The location of the backup is returned in the C(backup) variable by this module.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "virt": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "guest"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages virtual machines supported by I(libvirt).",
            "properties": {
              "xml": {
                "type": "string",
                "description": "XML document used with the define command"
              },
              "guest": {
                "type": "string",
                "description": "name of the guest VM being managed. Note that VM must be previously defined with xml."
              },
              "uri": {
                "type": "string",
                "description": "libvirt connection uri"
              },
              "state": {
                "enum": [
                  "running",
                  "shutdown",
                  "destroyed",
                  "paused"
                ],
                "type": "string",
                "description": "Default: no\n\nNote that there may be some lag for state requests like C(shutdown) since these refer only to VM states. After starting a guest, it may not be immediately accessible."
              },
              "command": {
                "enum": [
                  "create",
                  "status",
                  "start",
                  "stop",
                  "pause",
                  "unpause",
                  "shutdown",
                  "undefine",
                  "destroy",
                  "get_xml",
                  "autostart",
                  "freemem",
                  "list_vms",
                  "info",
                  "nodeinfo",
                  "virttype",
                  "define"
                ],
                "type": "string",
                "description": "in addition to state management, various non-idempotent commands are available. See examples"
              },
              "name": {
                "type": "string",
                "description": "name of the guest VM being managed. Note that VM must be previously defined with xml."
              }
            }
          },
          "nxos_ping": {
            "required": [
              "dest"
            ],
            "type": "object",
            "description": "Tests reachability using ping from switch to a remote destination.",
            "properties": {
              "count": {
                "type": "string",
                "description": "Default: 2\n\nNumber of packets to send."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "source": {
                "type": "string",
                "description": "Source IP Address."
              },
              "dest": {
                "type": "string",
                "description": "IP address or hostname (resolvable by switch) of remote node."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "vrf": {
                "type": "string",
                "description": "Outgoing VRF."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "win_msg": {
            "type": "object",
            "description": "Wraps the msg.exe command in order to send messages to Windows hosts.",
            "properties": {
              "msg": {
                "type": "string",
                "description": "Default: Hello world!\n\nThe text of the message to be displayed."
              },
              "to": {
                "type": "string",
                "description": "Default: *\n\nWho to send the message to. Can be a username, sessionname or sessionid."
              },
              "wait": {
                "type": "string",
                "description": "Whether to wait for users to respond.  Module will only wait for the number of seconds specified in display_seconds or 10 seconds if not specified. However, if I(wait) is true, the message is sent to each logged on user in turn, waiting for the user to either press 'ok' or for the timeout to elapse before moving on to the next user."
              },
              "display_seconds": {
                "type": "string",
                "description": "Default: 10\n\nHow long to wait for receiver to acknowledge message, in seconds."
              }
            }
          },
          "pagerduty_alert": {
            "required": [
              "name",
              "state",
              "service_key",
              "api_key"
            ],
            "type": "object",
            "description": "This module will let you trigger, acknowledge or resolve a PagerDuty incident by sending events",
            "properties": {
              "client_url": {
                "type": "string",
                "description": "The URL of the monitoring client that is triggering this event."
              },
              "name": {
                "type": "string",
                "description": "PagerDuty unique subdomain."
              },
              "state": {
                "enum": [
                  "triggered",
                  "acknowledged",
                  "resolved"
                ],
                "type": "string",
                "description": "Type of event to be sent."
              },
              "incident_key": {
                "type": "string",
                "description": "Identifies the incident to which this I(state) should be applied.\nFor C(triggered) I(state) - If there's no open (i.e. unresolved) incident with this key, a new one will be created. If there's already an open incident with a matching key, this event will be appended to that incident's log. The event key provides an easy way to \"de-dup\" problem reports.\nFor C(acknowledged) or C(resolved) I(state) - This should be the incident_key you received back when the incident was first opened by a trigger event. Acknowledge events referencing resolved or nonexistent incidents will be discarded."
              },
              "client": {
                "type": "string",
                "description": "The name of the monitoring client that is triggering this event."
              },
              "service_key": {
                "type": "string",
                "description": "The GUID of one of your \"Generic API\" services.\nThis is the \"service key\" listed on a Generic API's service detail page."
              },
              "api_key": {
                "type": "string",
                "description": "The pagerduty API key (readonly access), generated on the pagerduty site."
              },
              "desc": {
                "type": "string",
                "description": "Default: Created via Ansible\n\nFor C(triggered) I(state) - Required. Short description of the problem that led to this trigger. This field (or a truncated version) will be used when generating phone calls, SMS messages and alert emails. It will also appear on the incidents tables in the PagerDuty UI. The maximum length is 1024 characters.\nFor C(acknowledged) or C(resolved) I(state) - Text that will appear in the incident's log associated with this event."
              }
            }
          },
          "github_key": {
            "required": [
              "token",
              "name"
            ],
            "type": "object",
            "description": "Creates, removes, or updates GitHub access keys.",
            "properties": {
              "pubkey": {
                "type": "string",
                "description": "Default: none\n\nSSH public key value. Required when C(state=present)."
              },
              "token": {
                "type": "string",
                "description": "GitHub Access Token with permission to list and create public keys."
              },
              "force": {
                "description": "Default: yes\n\nThe default is C(yes), which will replace the existing remote key if it's different than C(pubkey). If C(no), the key will only be set if no key with the given C(name) exists.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "SSH key name"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to remove a key, ensure that it exists, or update its value."
              }
            }
          },
          "cs_template": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Register a template from URL, create a template from a ROOT volume of a stopped VM or its snapshot, extract and delete templates.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain the template, snapshot or VM is related to."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "vm": {
                "type": "string",
                "description": "VM name the template will be created from its volume or alternatively from a snapshot.\nVM must be in stopped state if created from its volume.\nMutually exclusive with C(url)."
              },
              "is_extractable": {
                "description": "True if the template or its derivatives are extractable.",
                "$ref": "#/definitions/ansible_truth"
              },
              "hypervisor": {
                "enum": [
                  "KVM",
                  "kvm",
                  "VMware",
                  "vmware",
                  "BareMetal",
                  "baremetal",
                  "XenServer",
                  "xenserver",
                  "LXC",
                  "lxc",
                  "HyperV",
                  "hyperv",
                  "UCS",
                  "ucs",
                  "OVM",
                  "ovm",
                  "Simulator",
                  "simulator"
                ],
                "type": "string",
                "description": "Name the hypervisor to be used for creating the new template.\nRelevant when using C(state=present)."
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone you wish the template to be registered or deleted from.\nIf not specified, first found zone will be used."
              },
              "sshkey_enabled": {
                "description": "True if the template supports the sshkey upload feature.",
                "$ref": "#/definitions/ansible_truth"
              },
              "is_dynamically_scalable": {
                "description": "Register the template having XS/VMWare tools installed in order to support dynamic scaling of VM CPU/memory.\nOnly used if C(state) is present.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "extracted"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the template."
              },
              "is_ready": {
                "description": "This flag is used for searching existing templates.\nIf set to C(true), it will only list template ready for deployment e.g. successfully downloaded and installed.\nRecommended to set it to C(false).",
                "$ref": "#/definitions/ansible_truth"
              },
              "details": {
                "type": "string",
                "description": "Template details in key/value pairs."
              },
              "is_routing": {
                "description": "True if the template type is routing i.e., if template is used to deploy router.\nOnly considered if C(url) is used.",
                "$ref": "#/definitions/ansible_truth"
              },
              "is_featured": {
                "description": "Register the template to be featured.\nOnly used if C(state) is present.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "bits": {
                "description": "Default: 64\n\n32 or 64 bits support.",
                "$ref": "#/definitions/ansible_number"
              },
              "format": {
                "enum": [
                  "QCOW2",
                  "RAW",
                  "VHD",
                  "OVA"
                ],
                "type": "string",
                "description": "The format for the template.\nRelevant when using C(state=present)."
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "is_public": {
                "description": "Register the template to be publicly available to all users.\nOnly used if C(state) is present.",
                "$ref": "#/definitions/ansible_truth"
              },
              "requires_hvm": {
                "description": "true if this template requires HVM.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password_enabled": {
                "description": "True if the template supports the password reset feature.",
                "$ref": "#/definitions/ansible_truth"
              },
              "display_text": {
                "type": "string",
                "description": "Display text of the template."
              },
              "account": {
                "type": "string",
                "description": "Account the template, snapshot or VM is related to."
              },
              "template_tag": {
                "type": "string",
                "description": "the tag for this template."
              },
              "name": {
                "type": "string",
                "description": "Name of the template."
              },
              "url": {
                "type": "string",
                "description": "URL of where the template is hosted on C(state=present).\nURL to which the template would be extracted on C(state=extracted).\nMutually exclusive with C(vm)."
              },
              "template_filter": {
                "enum": [
                  "featured",
                  "self",
                  "selfexecutable",
                  "sharedexecutable",
                  "executable",
                  "community"
                ],
                "type": "string",
                "description": "Default: self\n\nName of the filter used to search for the template."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "cross_zones": {
                "description": "Whether the template should be synced or removed across zones.\nOnly used if C(state) is present or absent.",
                "$ref": "#/definitions/ansible_truth"
              },
              "project": {
                "type": "string",
                "description": "Name of the project the template to be registered in."
              },
              "snapshot": {
                "type": "string",
                "description": "Name of the snapshot, created from the VM ROOT volume, the template will be created from.\nC(vm) is required together with this argument."
              },
              "mode": {
                "enum": [
                  "http_download",
                  "ftp_upload"
                ],
                "type": "string",
                "description": "Default: http_download\n\nMode for the template extraction.\nOnly used if C(state=extracted)."
              },
              "checksum": {
                "type": "string",
                "description": "The MD5 checksum value of this template.\nIf set, we search by checksum instead of name."
              },
              "os_type": {
                "type": "string",
                "description": "OS type that best represents the OS of this template."
              }
            }
          },
          "profitbricks_volume_attachments": {
            "type": "object",
            "description": "Allows you to attach or detach a volume from a ProfitBricks server. This module has a dependency on profitbricks >= 1.0.0",
            "properties": {
              "datacenter": {
                "type": "string",
                "description": "The datacenter in which to operate."
              },
              "subscription_user": {
                "type": "string",
                "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable."
              },
              "server": {
                "type": "string",
                "description": "The name of the server you wish to detach or attach the volume."
              },
              "volume": {
                "type": "string",
                "description": "The volume name or ID."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "wait_timeout": {
                "description": "Default: 600\n\nhow long before wait gives up, in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "subscription_password": {
                "type": "string",
                "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable."
              },
              "wait": {
                "description": "Default: yes\n\nwait for the operation to complete before returning",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "os_auth": {
            "type": "object",
            "description": "Retrieve an auth token from an OpenStack Cloud",
            "properties": {
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              }
            }
          },
          "aos_external_router": {
            "required": [
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS External Router module let you manage your External Router easily. You can create create and delete External Router by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the External Router to manage. Only one of I(name), I(id) or I(content) can be set."
              },
              "loopback": {
                "type": "string",
                "description": "IP address of the Loopback interface of the external_router."
              },
              "id": {
                "type": "string",
                "description": "AOS Id of the External Router to manage (can't be used to create a new External Router), Only one of I(name), I(id) or I(content) can be set."
              },
              "content": {
                "type": "string",
                "description": "Datastructure of the External Router to create. The format is defined by the I(content_format) parameter. It's the same datastructure that is returned on success in I(value)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the External Router (present or not)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "asn": {
                "type": "string",
                "description": "ASN id of the external_router."
              }
            }
          },
          "cs_vpc": {
            "type": "object",
            "description": "Create, update and delete VPCs.",
            "properties": {
              "display_text": {
                "type": "string",
                "description": "Display text of the VPC.\nIf not set, C(name) will be used for creating."
              },
              "vpc_offering": {
                "type": "string",
                "description": "Name of the VPC offering.\nIf not set, default VPC offering is used."
              },
              "poll_async": {
                "type": "string",
                "description": "Default: True\n\nPoll async jobs until job has finished."
              },
              "name": {
                "type": "string",
                "description": "Name of the VPC."
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone.\nIf not set, default zone is used."
              },
              "tags": {
                "type": "string",
                "description": "List of tags. Tags are a list of dictionaries having keys C(key) and C(value).\nFor deleting all tags, set an empty list e.g. C(tags: [])."
              },
              "domain": {
                "type": "string",
                "description": "Domain the VPC is related to."
              },
              "project": {
                "type": "string",
                "description": "Name of the project the VPC is related to."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nState of the VPC."
              },
              "account": {
                "type": "string",
                "description": "Account the VPC is related to."
              },
              "cidr": {
                "type": "string",
                "description": "CIDR of the VPC, e.g. 10.1.0.0/16\nAll VPC guest networks' CIDRs must be within this CIDR.\nRequired on C(state=present)."
              },
              "network_domain": {
                "type": "string",
                "description": "Network domain for the VPC.\nAll networks inside the VPC will belong to this domain."
              }
            }
          },
          "mongodb_parameter": {
            "required": [
              "param",
              "value"
            ],
            "type": "object",
            "description": "Change an administrative parameter on a MongoDB server.",
            "properties": {
              "login_port": {
                "description": "Default: 27017\n\nThe port to connect to",
                "$ref": "#/definitions/ansible_number"
              },
              "login_user": {
                "type": "string",
                "description": "The username used to authenticate with"
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nThe host running the database"
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with"
              },
              "param": {
                "type": "string",
                "description": "MongoDB administrative parameter to modify"
              },
              "ssl": {
                "description": "Whether to use an SSL connection when connecting to the database",
                "$ref": "#/definitions/ansible_truth"
              },
              "param_type": {
                "enum": [
                  "str",
                  "int"
                ],
                "type": "string",
                "description": "Default: str\n\nDefine the parameter value (str, int)"
              },
              "value": {
                "type": "string",
                "description": "MongoDB administrative parameter value to set"
              },
              "login_database": {
                "type": "string",
                "description": "The database where login credentials are stored"
              },
              "replica_set": {
                "type": "string",
                "description": "Replica set to connect to (automatically connects to primary for writes)"
              }
            }
          },
          "rollbar_deployment": {
            "required": [
              "environment",
              "token",
              "revision"
            ],
            "type": "object",
            "description": "Notify Rollbar about app deployments (see https://rollbar.com/docs/deploys_other/)",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Deploy comment (e.g. what is being deployed)."
              },
              "rollbar_user": {
                "type": "string",
                "description": "Rollbar username of the user who deployed."
              },
              "url": {
                "type": "string",
                "description": "Default: https://api.rollbar.com/api/1/deploy/\n\nOptional URL to submit the notification to."
              },
              "environment": {
                "type": "string",
                "description": "Name of the environment being deployed, e.g. 'production'."
              },
              "token": {
                "type": "string",
                "description": "Your project access token."
              },
              "user": {
                "type": "string",
                "description": "User who deployed."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "revision": {
                "type": "string",
                "description": "Revision number/sha being deployed."
              }
            }
          },
          "ios_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Cisco IOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with IOS configuration sections in a deterministic way.",
            "properties": {
              "multiline_delimiter": {
                "type": "string",
                "description": "Default: @\n\nThis argument is used when pushing a multiline configuration element to the IOS device.  It specifies the character to use as the delimiting character.  This only applies to the configuration action."
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "force": {
                "description": "The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.\nNote this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release.",
                "$ref": "#/definitions/ansible_truth"
              },
              "replace": {
                "enum": [
                  "line",
                  "block"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node."
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines)."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "defaults": {
                "description": "This argument specifies whether or not to collect all defaults when getting the remote device running config.  When enabled, the module will get the current config by issuing the command C(show running-config all).",
                "$ref": "#/definitions/ansible_truth"
              },
              "backup": {
                "description": "This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "win_stat": {
            "type": "object",
            "description": "Returns information about a Windows file",
            "properties": {
              "path": {
                "type": "string",
                "description": "The full path of the file/object to get the facts of; both forward and back slashes are accepted."
              },
              "get_md5": {
                "type": "string",
                "description": "Default: True\n\nWhether to return the checksum sum of the file. Between Ansible 1.9 and 2.2 this is no longer an MD5, but a SHA1 instead. As of Ansible 2.3 this is back to an MD5. Will return None if host is unable to use specified algorithm.\nThis option is deprecated in Ansible 2.3 and is replaced with C(checksum_algorithm=md5)."
              },
              "get_checksum": {
                "type": "string",
                "description": "Default: True\n\nWhether to return a checksum of the file (default sha1)"
              },
              "checksum_algorithm": {
                "type": "string",
                "description": "Default: sha1\n\nAlgorithm to determine checksum of file. Will throw an error if the host is unable to use specified algorithm."
              }
            }
          },
          "avi_sslkeyandcertificate": {
            "required": [
              "name",
              "certificate"
            ],
            "type": "object",
            "description": "This module is used to configure SSLKeyAndCertificate object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "hardwaresecuritymodulegroup_ref": {
                "type": "string",
                "description": "It is a reference to an object of type hardwaresecuritymodulegroup."
              },
              "key_params": {
                "type": "object",
                "description": "Sslkeyparams settings for sslkeyandcertificate."
              },
              "uuid": {
                "type": "string",
                "description": "Unique object identifier of the object."
              },
              "certificate": {
                "type": "object",
                "description": "Sslcertificate settings for sslkeyandcertificate."
              },
              "enckey_name": {
                "type": "string",
                "description": "Name of the encrypted private key (e.g.\nThose generated by an hsm such as thales nshield)."
              },
              "created_by": {
                "type": "string",
                "description": "Creator name."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "type": {
                "type": "string",
                "description": "Type of sslkeyandcertificate.\nDefault value when not specified in API or module is interpreted by Avi Controller as SSL_CERTIFICATE_TYPE_VIRTUALSERVICE."
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "status": {
                "type": "string",
                "description": "Status of sslkeyandcertificate.\nDefault value when not specified in API or module is interpreted by Avi Controller as SSL_CERTIFICATE_FINISHED."
              },
              "certificate_management_profile_ref": {
                "type": "string",
                "description": "It is a reference to an object of type certificatemanagementprofile."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "key": {
                "type": "string",
                "description": "Private key."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "enckey_base64": {
                "type": "string",
                "description": "Encrypted private key corresponding to the private key (e.g.\nThose generated by an hsm such as thales nshield)."
              },
              "name": {
                "type": "string",
                "description": "Name of the object."
              },
              "dynamic_params": {
                "description": "Dynamic parameters needed for certificate management profile.",
                "$ref": "#/definitions/ansible_array"
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "ca_certs": {
                "description": "Ca certificates in certificate chain.",
                "$ref": "#/definitions/ansible_array"
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              }
            }
          },
          "panos_lic": {
            "required": [
              "password",
              "ip_address"
            ],
            "type": "object",
            "description": "Apply an authcode to a device.\nThe authcode should have been previously registered on the Palo Alto Networks support portal.\nThe device should have Internet access.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "force": {
                "description": "Default: false\n\nwhether to apply authcode even if device is already licensed",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth_code": {
                "type": "string",
                "description": "authcode to be applied"
              }
            }
          },
          "aos_asn_pool": {
            "required": [
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS ASN Pool module let you manage your ASN Pool easily. You can create and delete ASN Pool by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "ranges": {
                "description": "List of ASNs ranges to add to the ASN Pool. Each range must have 2 values.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Name of the ASN Pool to manage. Only one of I(name), I(id) or I(content) can be set."
              },
              "content": {
                "type": "string",
                "description": "Datastructure of the ASN Pool to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the ASN Pool (present or not)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "id": {
                "type": "string",
                "description": "AOS Id of the ASN Pool to manage. Only one of I(name), I(id) or I(content) can be set."
              }
            }
          },
          "make": {
            "required": [
              "chdir"
            ],
            "type": "object",
            "description": "Run targets in a Makefile.",
            "properties": {
              "chdir": {
                "type": "string",
                "description": "cd into this directory before running make"
              },
              "params": {
                "type": "object",
                "description": "Default: none\n\nAny extra parameters to pass to make"
              },
              "target": {
                "type": "string",
                "description": "Default: none\n\nThe target to run"
              }
            }
          },
          "profitbricks_datacenter": {
            "type": "object",
            "description": "This is a simple module that supports creating or removing vDCs. A vDC is required before you can create servers. This module has a dependency on profitbricks >= 1.0.0",
            "properties": {
              "description": {
                "type": "string",
                "description": "The description of the virtual datacenter."
              },
              "subscription_user": {
                "type": "string",
                "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable."
              },
              "name": {
                "type": "string",
                "description": "The name of the virtual datacenter."
              },
              "subscription_password": {
                "type": "string",
                "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\ncreate or terminate datacenters"
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 600\n\nhow long before wait gives up, in seconds"
              },
              "location": {
                "enum": [
                  "us/las",
                  "de/fra",
                  "de/fkb"
                ],
                "type": "string",
                "description": "Default: us/las\n\nThe datacenter location."
              },
              "wait": {
                "description": "Default: yes\n\nwait for the datacenter to be created before returning",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "archive": {
            "required": [
              "path"
            ],
            "type": "object",
            "description": "Packs an archive. It is the opposite of M(unarchive). By default, it assumes the compression source exists on the target. It will not copy the source file from the local system to the target before archiving. Source files can be deleted after archival by specifying I(remove=True).",
            "properties": {
              "dest": {
                "type": "string",
                "description": "The file name of the destination archive. This is required when C(path) refers to multiple files by either specifying a glob, a directory or multiple paths in a list."
              },
              "path": {
                "description": "Remote absolute path, glob, or list of paths or globs for the file or files to compress or archive.",
                "$ref": "#/definitions/ansible_array"
              },
              "remove": {
                "description": "Remove any added source files and trees after adding to archive.",
                "$ref": "#/definitions/ansible_truth"
              },
              "format": {
                "enum": [
                  "gz",
                  "bz2",
                  "zip",
                  "tar"
                ],
                "type": "string",
                "description": "Default: gz\n\nThe type of compression to use."
              }
            }
          },
          "vmware_portgroup": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create a VMware portgroup",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "portgroup_name": {
                "type": "string",
                "description": "Portgroup name to add"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "network_policy": {
                "type": "object",
                "description": "Network policy specifies layer 2 security settings for a portgroup such as promiscuous mode, where guest adapter listens to all the packets, MAC address changes and forged transmits. Settings are promiscuous_mode, forged_transmits, mac_changes"
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "switch_name": {
                "type": "string",
                "description": "vSwitch to modify"
              },
              "vlan_id": {
                "description": "VLAN ID to assign to portgroup",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "nclu": {
            "type": "object",
            "description": "Interface to the Network Command Line Utility, developed to make it easier to configure operating systems running ifupdown2 and Quagga, such as Cumulus Linux. Command documentation is available at U(https://docs.cumulusnetworks.com/display/DOCS/Network+Command+Line+Utility)",
            "properties": {
              "commands": {
                "description": "A list of strings containing the net commands to run. Mutually exclusive with I(template).",
                "$ref": "#/definitions/ansible_array"
              },
              "description": {
                "type": "string",
                "description": "Default: Ansible-originated commit\n\nCommit description that will be recorded to the commit log if I(commit) or I(atomic) are true."
              },
              "abort": {
                "description": "Boolean. When true, perform a 'net abort' before the block. This cleans out any uncommitted changes in the buffer. Mutually exclusive with I(atomic).",
                "$ref": "#/definitions/ansible_truth"
              },
              "atomic": {
                "description": "When true, equivalent to both I(commit) and I(abort) being true. Mutually exclusive with I(commit) and I(atomic).",
                "$ref": "#/definitions/ansible_truth"
              },
              "template": {
                "type": "string",
                "description": "A single, multi-line string with jinja2 formatting. This string will be broken by lines, and each line will be run through net. Mutually exclusive with I(commands)."
              },
              "commit": {
                "description": "When true, performs a 'net commit' at the end of the block. Mutually exclusive with I(atomic).",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "azure_rm_networkinterface_facts": {
            "type": "object",
            "description": "Get facts for a specific network interface or all network interfaces within a resource group.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Only show results for a specific network interface."
              },
              "resource_group": {
                "type": "string",
                "description": "Name of the resource group containing the network interface(s). Required when searching by name."
              },
              "tags": {
                "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
                "$ref": "#/definitions/ansible_array"
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "nxos_igmp_interface": {
            "required": [
              "interface"
            ],
            "type": "object",
            "description": "Manages IGMP interface configuration settings.",
            "properties": {
              "startup_query_interval": {
                "type": "string",
                "description": "Query interval used when the IGMP process starts up. The range is from 1 to 18000. The default is 31."
              },
              "oif_routemap": {
                "type": "string",
                "description": "Configure a routemap for static outgoing interface (OIF)."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "last_member_query_count": {
                "type": "string",
                "description": "Sets the number of times that the software sends an IGMP query in response to a host leave message. Values can range from 1 to 5. The default is 2."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "report_llg": {
                "description": "Configures report-link-local-groups. Enables sending reports for groups in 224.0.0.0/24. Reports are always sent for nonlink local groups. By default, reports are not sent for link local groups.",
                "$ref": "#/definitions/ansible_truth"
              },
              "last_member_qrt": {
                "type": "string",
                "description": "Sets the query interval waited after sending membership reports before the software deletes the group state. Values can range from 1 to 25 seconds. The default is 1 second."
              },
              "startup_query_count": {
                "type": "string",
                "description": "Query count used when the IGMP process starts up. The range is from 1 to 10. The default is 2."
              },
              "immediate_leave": {
                "description": "Enables the device to remove the group entry from the multicast routing table immediately upon receiving a leave message for the group. Use this command to minimize the leave latency of IGMPv2 group memberships on a given IGMP interface because the device does not send group-specific queries. The default is disabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "default"
                ],
                "type": "string",
                "description": "Default: present\n\nManages desired state of the resource."
              },
              "version": {
                "type": "string",
                "description": "IGMP version. It can be 2 or 3."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "group_timeout": {
                "type": "string",
                "description": "Sets the group membership timeout for IGMPv2. Values can range from 3 to 65,535 seconds. The default is 260 seconds."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "oif_prefix": {
                "type": "string",
                "description": "Configure a prefix for static outgoing interface (OIF)."
              },
              "interface": {
                "type": "string",
                "description": "The full interface name for IGMP configuration. e.g. I(Ethernet1/2)."
              },
              "querier_timeout": {
                "type": "string",
                "description": "Sets the querier timeout that the software uses when deciding to take over as the querier. Values can range from 1 to 65535 seconds. The default is 255 seconds."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "restart": {
                "description": "Restart IGMP.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "robustness": {
                "type": "string",
                "description": "Sets the robustness variable. Values can range from 1 to 7. The default is 2."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "oif_source": {
                "type": "string",
                "description": "Configure a source for static outgoing interface (OIF)."
              },
              "query_interval": {
                "type": "string",
                "description": "Sets the frequency at which the software sends IGMP host query messages. Values can range from 1 to 18000 seconds. he default is 125 seconds."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "query_mrt": {
                "type": "string",
                "description": "Sets the response time advertised in IGMP queries. Values can range from 1 to 25 seconds. The default is 10 seconds."
              }
            }
          },
          "sros_rollback": {
            "type": "object",
            "description": "Configure the rollback feature on remote Nokia devices running the SR OS operating system.  this module provides a stateful implementation for managing the configuration of the rollback feature",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "local_max_checkpoints": {
                "description": "The I(local_max_checkpoints) argument configures the maximum number of rollback files that can be saved on the devices local compact flash.  Valid values for this argument are in the range of 1 to 50",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe I(state) argument specifies the state of the configuration entries in the devices active configuration.  When the state value is set to C(true) the configuration is present in the devices active configuration.  When the state value is set to C(false) the configuration values are removed from the devices active configuration."
              },
              "rollback_location": {
                "type": "string",
                "description": "The I(rollback_location) specifies the location and filename of the rollback checkpoint files.   This argument supports any valid local or remote URL as specified in SR OS"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "rescue_location": {
                "type": "string",
                "description": "The I(rescue_location) specifies the location of the rescue file.  This argument supports any valid local or remote URL as specified in SR OS"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "remote_max_checkpoints": {
                "description": "The I(remote_max_checkpoints) argument configures the maximum number of rollback files that can be transferred and saved to a remote location.  Valid values for this argument are in the range of 1 to 50",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "clc_group": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create or delete Server Groups at Centurylink Centurylink Cloud",
            "properties": {
              "name": {
                "type": "string",
                "description": "The name of the Server Group"
              },
              "parent": {
                "type": "string",
                "description": "The parent group of the server group. If parent is not provided, it creates the group at top level."
              },
              "description": {
                "type": "string",
                "description": "A description of the Server Group"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to create or delete the group"
              },
              "location": {
                "type": "string",
                "description": "Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account"
              },
              "wait": {
                "description": "Default: True\n\nWhether to wait for the tasks to finish before returning.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "udm_dns_record": {
            "type": "object",
            "description": "This module allows to manage dns records on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.",
            "properties": {
              "data": {
                "type": "string",
                "description": "Additional data for this record, e.g. ['a': '192.0.2.1']. Required if C(state=present)."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhether the dns record is present or not."
              },
              "type": {
                "type": "string",
                "description": "Define the record type. C(host_record) is a A or AAAA record, C(alias) is a CNAME, C(ptr_record) is a PTR record, C(srv_record) is a SRV record and C(txt_record) is a TXT record."
              },
              "name": {
                "type": "string",
                "description": "Name of the record, this is also the DNS record. E.g. www for www.example.com."
              },
              "zone": {
                "type": "string",
                "description": "Corresponding DNS zone for this record, e.g. example.com."
              }
            }
          },
          "panos_address": {
            "required": [
              "address_name",
              "password",
              "ip_address"
            ],
            "type": "object",
            "description": "Create address service object of different types [IP Range, FQDN, or IP Netmask].",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nUsername credentials to use for authentication."
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nDescription of the address object."
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device being configured."
              },
              "tag": {
                "type": "string",
                "description": "Default: None\n\nTag of the address object."
              },
              "address_name": {
                "type": "string",
                "description": "Default: None\n\nHuman readable name of the address."
              },
              "address": {
                "type": "string",
                "description": "Default: None\n\nIP address with or without mask, range, or FQDN."
              },
              "commit": {
                "description": "Default: True\n\nCommit configuration to the Firewall if it is changed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "Password credentials to use for authentication."
              },
              "type": {
                "enum": [
                  "ip-netmask",
                  "fqdn",
                  "ip-range"
                ],
                "type": "string",
                "description": "Default: ip-nemask\n\nThis is the type of the object created."
              }
            }
          },
          "panos_dag": {
            "required": [
              "dag_name",
              "password",
              "ip_address",
              "dag_filter"
            ],
            "type": "object",
            "description": "Create a dynamic address group object in the firewall used for policy rules",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "dag_name": {
                "type": "string",
                "description": "name of the dynamic address group"
              },
              "commit": {
                "description": "Default: True\n\ncommit if changed",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              },
              "dag_filter": {
                "type": "string",
                "description": "dynamic filter user by the dynamic address group"
              }
            }
          },
          "na_cdot_svm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or destroy svm on NetApp cDOT",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "root_volume_aggregate": {
                "type": "string",
                "description": "The aggregate on which the root volume will be created.\nRequired when C(state=present)."
              },
              "name": {
                "type": "string",
                "description": "The name of the SVM to manage."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "root_volume_security_style": {
                "enum": [
                  "unix",
                  "ntfs",
                  "mixed",
                  "unified"
                ],
                "type": "string",
                "description": "Security Style of the root volume.\nWhen specified as part of the vserver-create, this field represents the security style for the Vserver root volume.\nWhen specified as part of vserver-get-iter call, this will return the list of matching Vservers.\nPossible values are 'unix', 'ntfs', 'mixed'.\nThe 'unified' security style, which applies only to Infinite Volumes, cannot be applied to a Vserver's root volume.\nValid options are \"unix\" for NFS, \"ntfs\" for CIFS, \"mixed\" for Mixed, \"unified\" for Unified.\nRequired when C(state=present)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified SVM should exist or not."
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "root_volume": {
                "type": "string",
                "description": "Root volume of the SVM. Required when C(state=present)."
              }
            }
          },
          "azure_rm_securitygroup_facts": {
            "required": [
              "resource_group"
            ],
            "type": "object",
            "description": "Get facts for a specific security group or all security groups within a resource group.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Only show results for a specific security group."
              },
              "resource_group": {
                "type": "string",
                "description": "Name of the resource group to use."
              },
              "tags": {
                "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
                "$ref": "#/definitions/ansible_array"
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "openssl_privatekey": {
            "required": [
              "path"
            ],
            "type": "object",
            "description": "This module allows one to (re)generate OpenSSL private keys. It uses the pyOpenSSL python library to interact with openssl. One can generate either RSA or DSA private keys. Keys are generated in PEM format.",
            "properties": {
              "path": {
                "type": "string",
                "description": "Name of the file in which the generated TLS/SSL private key will be written. It will have 0600 mode."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the private key should exist or not, taking action if the state is different from what is stated."
              },
              "size": {
                "description": "Default: 4096\n\nSize (in bits) of the TLS/SSL key to generate",
                "$ref": "#/definitions/ansible_number"
              },
              "force": {
                "description": "Should the key be regenerated even it it already exists",
                "$ref": "#/definitions/ansible_truth"
              },
              "type": {
                "enum": [
                  "RSA",
                  "DSA"
                ],
                "type": "string",
                "description": "Default: RSA\n\nThe algorithm used to generate the TLS/SSL private key"
              }
            }
          },
          "ordnance_facts": {
            "required": [
              "host"
            ],
            "type": "object",
            "description": "Collects a base set of device facts from an Ordnance Virtual router over SSH. This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.",
            "properties": {
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              }
            }
          },
          "quantum_router_gateway": {
            "required": [
              "router_name",
              "login_password",
              "network_name"
            ],
            "type": "object",
            "description": "Creates/Removes a gateway interface from the router, used to associate a external network with a router to route external traffic.",
            "properties": {
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nName of the region"
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "network_name": {
                "type": "string",
                "description": "Default: None\n\nName of the external network which should be attached to the router."
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: yes\n\nThe tenant name of the login user"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone URL for authentication"
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\nPassword of login user"
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "router_name": {
                "type": "string",
                "description": "Default: None\n\nName of the router to which the gateway should be attached."
              }
            }
          },
          "ovirt_hosts_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt hosts.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search host X from datacenter Y use following pattern: name=X and datacenter=Y"
              }
            }
          },
          "bigip_snat_pool": {
            "type": "object",
            "description": "Manage SNAT pools on a BIG-IP.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhether the SNAT pool should exist or not."
              },
              "members": {
                "type": "string",
                "description": "Default: None\n\nList of members to put in the SNAT pool. When a C(state) of present is provided, this parameter is required. Otherwise, it is optional."
              },
              "append": {
                "type": "string",
                "description": "When C(yes), will only add members to the SNAT pool. When C(no), will replace the existing member list with the provided member list."
              },
              "name": {
                "type": "string",
                "description": "The name of the SNAT pool."
              }
            }
          },
          "rax_dns": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage domains on Rackspace Cloud DNS",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "comment": {
                "type": "string",
                "description": "Brief description of the domain. Maximum length of 160 characters"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Domain name to create"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "ttl": {
                "description": "Default: 3600\n\nTime to live of domain in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "email": {
                "type": "string",
                "description": "Email address of the domain administrator"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "pn_vrouterif": {
            "required": [
              "pn_interface_ip",
              "pn_vrouter_name",
              "state"
            ],
            "type": "object",
            "description": "Execute vrouter-interface-add, vrouter-interface-remove, vrouter-interface-modify command.\nYou configure interfaces to vRouter services on a fabric, cluster, standalone switch or virtual network(VNET).",
            "properties": {
              "pn_nic_enable": {
                "description": "Specify if the NIC is enabled or not",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_exclusive": {
                "description": "Specify if the interface is exclusive to the configuration. Exclusive means that other configurations cannot use the interface. Exclusive is specified when you configure the interface as span interface and allows higher throughput through the interface.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_nic_str": {
                "type": "string",
                "description": "Specify the type of NIC. Used for vrouter-interface remove/modify."
              },
              "pn_vrrp_id": {
                "description": "Specify the ID for the VRRP interface. The IDs on both vRouters must be the same IS number.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_vrrp_adv_int": {
                "type": "string",
                "description": "Specify a VRRP advertisement interval in milliseconds. The range is from 30 to 40950 with a default value of 1000."
              },
              "pn_vrrp_priority": {
                "description": "Specify the priority for the VRRP interface. This is a value between 1 (lowest) and 255 (highest).",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_alias": {
                "type": "string",
                "description": "Specify an alias for the interface."
              },
              "pn_secondary_macs": {
                "type": "string",
                "description": "Specify a secondary MAC address for the interface."
              },
              "pn_vrouter_name": {
                "type": "string",
                "description": "Specify the name of the vRouter interface."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "pn_interface_ip": {
                "type": "string",
                "description": "Specify the IP address of the interface in x.x.x.x/n format."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "State the action to perform. Use 'present' to add vrouter interface, 'absent' to remove vrouter interface and 'update' to modify vrouter interface."
              },
              "pn_vlan": {
                "description": "Specify the VLAN identifier. This is a value between 1 and 4092.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_interface": {
                "enum": [
                  "mgmt",
                  "data",
                  "span"
                ],
                "type": "string",
                "description": "Specify if the interface is management, data or span interface."
              },
              "pn_l3port": {
                "type": "string",
                "description": "Specify a Layer 3 port for the interface."
              },
              "pn_vxlan": {
                "description": "Specify the VXLAN identifier. This is a value between 1 and 16777215.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch to run the cli on."
              },
              "pn_assignment": {
                "enum": [
                  "none",
                  "dhcp",
                  "dhcpv6",
                  "autov6"
                ],
                "type": "string",
                "description": "Specify the DHCP method for IP address assignment."
              }
            }
          },
          "panos_commit": {
            "type": "object",
            "description": "PanOS module that will commit firewall's candidate configuration on\nthe device. The new configuration will become active immediately.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "interval": {
                "type": "string",
                "description": "Default: 0.5\n\ninterval for checking commit job"
              },
              "sync": {
                "description": "Default: True\n\nif commit should be synchronous",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "type": "string",
                "description": "Default: None\n\ntimeout for commit job"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              }
            }
          },
          "webfaction_site": {
            "required": [
              "host",
              "login_password",
              "login_name",
              "name"
            ],
            "type": "object",
            "description": "Add or remove a website on a Webfaction host.  Further documentation at http://github.com/quentinsf/ansible-webfaction.",
            "properties": {
              "site_apps": {
                "description": "A mapping of URLs to apps",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the website should exist"
              },
              "subdomains": {
                "description": "A list of subdomains associated with this site.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": "The webfaction host on which the site should be created."
              },
              "https": {
                "description": "Default: false\n\nWhether or not to use HTTPS",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_password": {
                "type": "string",
                "description": "The webfaction password to use"
              },
              "login_name": {
                "type": "string",
                "description": "The webfaction account to use"
              },
              "name": {
                "type": "string",
                "description": "The name of the website"
              }
            }
          },
          "uri": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "url_password",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "url_username",
                        "user"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Interacts with HTTP and HTTPS web services and supports Digest, Basic and WSSE HTTP authentication mechanisms.",
            "properties": {
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "follow_redirects": {
                "enum": [
                  "all",
                  "safe",
                  "none",
                  "yes",
                  "no"
                ],
                "type": "string",
                "description": "Default: safe\n\nWhether or not the URI module should follow redirects. C(all) will follow all redirects. C(safe) will follow only \"safe\" redirects, where \"safe\" means that the client is only doing a GET or HEAD on the URI to which it is being redirected. C(none) will not follow any redirects. Note that C(yes) and C(no) choices are accepted for backwards compatibility, where C(yes) is the equivalent of C(all) and C(no) is the equivalent of C(safe). C(yes) and C(no) are deprecated and will be removed in some future version of Ansible."
              },
              "body_format": {
                "enum": [
                  "raw",
                  "json"
                ],
                "type": "string",
                "description": "Default: raw\n\nThe serialization format of the body. When set to json, encodes the body argument, if needed, and automatically sets the Content-Type header accordingly. As of C(2.3) it is possible to override the `Content-Type` header, when set to json via the I(headers) option."
              },
              "client_key": {
                "type": "string",
                "description": ""
              },
              "use_proxy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "status_code": {
                "description": "Default: 200\n\nA valid, numeric, HTTP status code that signifies success of the request. Can also be comma separated list of status codes.",
                "$ref": "#/definitions/ansible_array"
              },
              "return_content": {
                "description": "Default: no\n\nWhether or not to return the body of the response as a \"content\" key in the dictionary result. If the reported Content-type is \"application/json\", then the JSON is additionally loaded into a key called C(json) in the dictionary results.",
                "$ref": "#/definitions/ansible_truth"
              },
              "method": {
                "enum": [
                  "GET",
                  "POST",
                  "PUT",
                  "HEAD",
                  "DELETE",
                  "OPTIONS",
                  "PATCH",
                  "TRACE",
                  "CONNECT",
                  "REFRESH"
                ],
                "type": "string",
                "description": "Default: GET\n\nThe HTTP method of the request or response. It MUST be uppercase."
              },
              "body": {
                "type": "string",
                "description": "The body of the http request/response to the web service. If C(body_format) is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON."
              },
              "timeout": {
                "description": "Default: 30\n\nThe socket level timeout in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "dest": {
                "type": "string",
                "description": "path of where to download the file to (if desired). If I(dest) is a directory, the basename of the file on the remote server will be used."
              },
              "force_basic_auth": {
                "description": "Default: no\n\nThe library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request.",
                "$ref": "#/definitions/ansible_truth"
              },
              "removes": {
                "type": "string",
                "description": "a filename, when it does not exist, this step will not be run."
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": "username for the module to use for Digest, Basic or WSSE authentication."
              },
              "password": {
                "type": "string",
                "description": "password for the module to use for Digest, Basic or WSSE authentication."
              },
              "url_password": {
                "type": "string",
                "description": "password for the module to use for Digest, Basic or WSSE authentication."
              },
              "url": {
                "type": "string",
                "description": "HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path"
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "creates": {
                "type": "string",
                "description": "a filename, when it already exists, this step will not be run."
              },
              "headers": {
                "type": "object",
                "description": "Add custom HTTP headers to a request in the format of a YAML hash. As of C(2.3) supplying C(Content-Type) here will override the header generated by supplying C(json) for I(body_format)."
              },
              "url_username": {
                "type": "string",
                "description": "username for the module to use for Digest, Basic or WSSE authentication."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated.  This should only set to C(no) used on personally controlled sites using self-signed certificates.  Prior to 1.9.2 the code defaulted to C(no).",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "panos_admin": {
            "type": "object",
            "description": "PanOS module that allows changes to the user account passwords by doing API calls to the Firewall using pan-api as the protocol.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "admin_username": {
                "type": "string",
                "description": "Default: admin\n\nusername for admin user"
              },
              "role": {
                "type": "string",
                "description": "role for admin user"
              },
              "admin_password": {
                "type": "string",
                "description": "password for admin user"
              },
              "commit": {
                "description": "Default: True\n\ncommit if changed",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              }
            }
          },
          "debconf": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "question",
                        "setting",
                        "selection"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "value",
                        "answer"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Configure a .deb package using debconf-set-selections. Or just query existing selections.",
            "properties": {
              "selection": {
                "type": "string",
                "description": "A debconf configuration setting"
              },
              "name": {
                "type": "string",
                "description": "Name of package to configure."
              },
              "question": {
                "type": "string",
                "description": "A debconf configuration setting"
              },
              "value": {
                "type": "string",
                "description": "Value to set the configuration to"
              },
              "vtype": {
                "enum": [
                  "string",
                  "password",
                  "boolean",
                  "select",
                  "multiselect",
                  "note",
                  "error",
                  "title",
                  "text",
                  "seen"
                ],
                "type": "string",
                "description": "The type of the value supplied.\nC(seen) was added in 2.2."
              },
              "pkg": {
                "type": "string",
                "description": "Name of package to configure."
              },
              "unseen": {
                "description": "Do not set 'seen' flag when pre-seeding",
                "$ref": "#/definitions/ansible_truth"
              },
              "answer": {
                "type": "string",
                "description": "Value to set the configuration to"
              },
              "setting": {
                "type": "string",
                "description": "A debconf configuration setting"
              }
            }
          },
          "panos_loadcfg": {
            "required": [
              "password",
              "ip_address"
            ],
            "type": "object",
            "description": "Load configuration on PAN-OS device",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "commit": {
                "description": "Default: True\n\ncommit if changed",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              },
              "file": {
                "type": "string",
                "description": "Default: None\n\nconfiguration file to load"
              }
            }
          },
          "bigip_node": {
            "type": "object",
            "description": "Manages F5 BIG-IP LTM nodes via iControl SOAP API",
            "properties": {
              "session_state": {
                "type": "string",
                "description": "Set new session availability status for node"
              },
              "name": {
                "type": "string",
                "description": "Node name"
              },
              "monitor_state": {
                "type": "string",
                "description": "Set monitor availability status for node"
              },
              "description": {
                "type": "string",
                "description": "Node description."
              },
              "partition": {
                "type": "string",
                "description": "Default: Common\n\nPartition"
              },
              "host": {
                "type": "string",
                "description": "Node IP. Required when state=present and node does not exist. Error when state=absent."
              },
              "monitors": {
                "type": "string",
                "description": "Monitor template name list. Always use the full path to the monitor."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nPool member state"
              },
              "monitor_type": {
                "type": "string",
                "description": "Monitor rule type when monitors > 1"
              },
              "quorum": {
                "type": "string",
                "description": "Monitor quorum value when monitor_type is m_of_n"
              }
            }
          },
          "maven_artifact": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "aws_secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "aws_secret_access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Downloads an artifact from a maven repository given the maven coordinates provided to the module. Can retrieve\nsnapshots or release versions of the artifact and will resolve the latest available version if one is not\navailable.",
            "properties": {
              "username": {
                "type": "string",
                "description": "The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3"
              },
              "aws_secret_key": {
                "type": "string",
                "description": "The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3"
              },
              "group_id": {
                "type": "string",
                "description": "The Maven groupId coordinate"
              },
              "artifact_id": {
                "type": "string",
                "description": "The maven artifactId coordinate"
              },
              "extension": {
                "type": "string",
                "description": "Default: jar\n\nThe maven type/extension coordinate"
              },
              "dest": {
                "type": "string",
                "description": "The path where the artifact should be written to"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe desired state of the artifact"
              },
              "version": {
                "type": "string",
                "description": "Default: latest\n\nThe maven version coordinate"
              },
              "aws_secret_access_key": {
                "type": "string",
                "description": "The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3"
              },
              "repository_url": {
                "type": "string",
                "description": "Default: http://repo1.maven.org/maven2\n\nThe URL of the Maven Repository to download from.\nUse s3://... if the repository is hosted on Amazon S3, added in version 2.2."
              },
              "password": {
                "type": "string",
                "description": "The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be set to C(no) when no other option exists.",
                "$ref": "#/definitions/ansible_truth"
              },
              "classifier": {
                "type": "string",
                "description": "The maven classifier coordinate"
              }
            }
          },
          "avi_certificatemanagementprofile": {
            "required": [
              "script_path",
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure CertificateManagementProfile object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "script_params": {
                "description": "List of customparams.",
                "$ref": "#/definitions/ansible_array"
              },
              "uuid": {
                "type": "string",
                "description": "Unique object identifier of the object."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "script_path": {
                "type": "string",
                "description": "Script_path of certificatemanagementprofile."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the pki profile."
              }
            }
          },
          "pkg5": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "accept_licenses",
                        "accept_licences",
                        "accept"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "IPS packages are the native packages in Solaris 11 and higher.",
            "properties": {
              "accept_licenses": {
                "description": "Accept any licences.",
                "$ref": "#/definitions/ansible_truth"
              },
              "accept_licences": {
                "description": "Accept any licences.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "latest",
                  "absent",
                  "uninstalled",
                  "removed"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to install (I(present), I(latest)), or remove (I(absent)) a package."
              },
              "name": {
                "description": "An FRMI of the package(s) to be installed/removed/updated.\nMultiple packages may be specified, separated by C(,).",
                "$ref": "#/definitions/ansible_array"
              },
              "accept": {
                "description": "Accept any licences.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rax_files": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manipulate Rackspace Cloud Files Containers",
            "properties": {
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "private": {
                "description": "Used to set a container as private, removing it from the CDN.  B(Warning!) Private containers, if previously made public, can have live objects available until the TTL on cached objects expires",
                "$ref": "#/definitions/ansible_truth"
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "clear_meta": {
                "description": "Default: no\n\nOptionally clear existing metadata when applying metadata to existing containers. Selecting this option is only appropriate when setting type=meta",
                "$ref": "#/definitions/ansible_truth"
              },
              "ttl": {
                "description": "In seconds, set a container-wide TTL for all objects cached on CDN edge nodes. Setting a TTL is only appropriate for containers that are public",
                "$ref": "#/definitions/ansible_number"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "container": {
                "type": "string",
                "description": "The container to use for container or metadata operations."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "list"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "web_error": {
                "type": "string",
                "description": "Sets an object to be presented as the HTTP error page when accessed by the CDN URL"
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "type": {
                "enum": [
                  "container",
                  "meta"
                ],
                "type": "string",
                "description": "Default: file\n\nType of object to do work on, i.e. metadata object or a container object"
              },
              "public": {
                "description": "Used to set a container as public, available via the Cloud Files CDN",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "web_index": {
                "type": "string",
                "description": "Sets an object to be presented as the HTTP index page when accessed by the CDN URL"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": "Default: DFW\n\nRegion to create an instance in"
              },
              "meta": {
                "type": "object",
                "description": "A hash of items to set as metadata values on a container"
              }
            }
          },
          "netapp_e_snapshot_images": {
            "type": "object",
            "description": "Create and delete snapshots images on snapshot groups for NetApp E-series storage arrays.\nOnly the oldest snapshot image can be deleted so consistency is preserved.\nRelated: Snapshot volumes are created from snapshot images.",
            "properties": {
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "state": {
                "type": "string",
                "description": "Whether a new snapshot image should be created or oldest be deleted."
              },
              "snapshot_group": {
                "type": "string",
                "description": "The name of the snapshot group in which you want to create a snapshot image."
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "validate_certs": {
                "type": "string",
                "description": "Default: True\n\nShould https certificates be validated?"
              }
            }
          },
          "filesystem": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "dev",
                        "device"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "dev"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "device"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "fstype",
                        "type"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "fstype"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "type"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module creates file system.",
            "properties": {
              "force": {
                "description": "Default: no\n\nIf yes, allows to create new filesystem on devices that already has filesystem.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dev": {
                "type": "string",
                "description": "Target block device."
              },
              "fstype": {
                "type": "string",
                "description": "File System type to be created.\nreiserfs support was added in 2.2."
              },
              "resizefs": {
                "description": "Default: no\n\nIf yes, if the block device and filessytem size differ, grow the filesystem into the space. Note, XFS Will only grow if mounted.",
                "$ref": "#/definitions/ansible_truth"
              },
              "device": {
                "type": "string",
                "description": "Target block device."
              },
              "type": {
                "type": "string",
                "description": "File System type to be created.\nreiserfs support was added in 2.2."
              },
              "opts": {
                "type": "string",
                "description": "List of options to be passed to mkfs command."
              }
            }
          },
          "docker": {
            "required": [
              "image"
            ],
            "type": "object",
            "description": "This is the original Ansible module for managing the Docker container life cycle.\nNOTE: Additional and newer modules are available. For the latest on orchestrating containers with Ansible visit our Getting Started with Docker Guide at https://github.com/ansible/ansible/blob/devel/docsite/rst/guide_docker.rst.",
            "properties": {
              "publish_all_ports": {
                "description": "Publish all exposed ports to the host interfaces.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tty": {
                "description": "Allocate a pseudo-tty within the container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "log_opt": {
                "type": "object",
                "description": "Additional options to pass to the logging driver selected above. See Docker `log-driver <https://docs.docker.com/reference/logging/overview/>` documentation for more information. Requires docker >=1.7.0."
              },
              "insecure_registry": {
                "description": "Use insecure private registry by HTTP instead of HTTPS. Needed for docker-py >= 0.5.0.",
                "$ref": "#/definitions/ansible_truth"
              },
              "links": {
                "description": "List of other containers to link within this container with an optional\nalias. Use docker CLI-style syntax: C(redis:myredis).",
                "$ref": "#/definitions/ansible_array"
              },
              "domainname": {
                "type": "string",
                "description": "Container domain name."
              },
              "docker_url": {
                "type": "string",
                "description": "Default: ${DOCKER_HOST} or unix://var/run/docker.sock\n\nURL of the host running the docker daemon. This will default to the env var DOCKER_HOST if unspecified."
              },
              "image": {
                "type": "string",
                "description": "Container image used to match and launch containers."
              },
              "labels": {
                "type": "object",
                "description": "Set container labels. Requires docker >= 1.6 and docker-py >= 1.2.0."
              },
              "pid": {
                "type": "string",
                "description": "Default: None\n\nSet the PID namespace mode for the container (currently only supports 'host'). Requires docker-py >= 1.0.0 and docker >= 1.5.0"
              },
              "docker_api_version": {
                "type": "string",
                "description": "Default: docker-py default remote API version\n\nRemote API version to use. This defaults to the current default as specified by docker-py."
              },
              "stop_timeout": {
                "description": "Default: 10\n\nHow many seconds to wait for the container to stop before killing it.",
                "$ref": "#/definitions/ansible_number"
              },
              "tls_client_key": {
                "type": "string",
                "description": "Default: ${DOCKER_CERT_PATH}/key.pem\n\nPath to the PEM-encoded key used to authenticate docker client. If specified tls_client_cert must be valid"
              },
              "env_file": {
                "type": "string",
                "description": "Pass in a path to a file with environment variable (FOO=BAR). If a key value is present in both explicitly presented (i.e. as 'env') and in the environment file, the explicit value will override. Requires docker-py >= 1.4.0."
              },
              "read_only": {
                "description": "Mount the container's root filesystem as read only",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_tls": {
                "enum": [
                  "no",
                  "encrypt",
                  "verify"
                ],
                "type": "string",
                "description": "Whether to use tls to connect to the docker server.  \"no\" means not to use tls (and ignore any other tls related parameters). \"encrypt\" means to use tls to encrypt the connection to the server.  \"verify\" means to also verify that the server's certificate is valid for the server (this both verifies the certificate against the CA and that the certificate was issued for that host. If this is unspecified, tls will only be used if one of the other tls options require it."
              },
              "password": {
                "type": "string",
                "description": "Remote API password."
              },
              "hostname": {
                "type": "string",
                "description": "Container hostname."
              },
              "lxc_conf": {
                "description": "LXC configuration parameters, such as C(lxc.aa_profile:unconfined).",
                "$ref": "#/definitions/ansible_array"
              },
              "tls_ca_cert": {
                "type": "string",
                "description": "Default: ${DOCKER_CERT_PATH}/ca.pem\n\nPath to a PEM-encoded certificate authority to secure the Docker connection. This has no effect if use_tls is encrypt."
              },
              "state": {
                "enum": [
                  "present",
                  "started",
                  "reloaded",
                  "restarted",
                  "stopped",
                  "killed",
                  "absent",
                  "running"
                ],
                "type": "string",
                "description": "Default: started\n\nAssert the container's desired state. \"present\" only asserts that the matching containers exist. \"started\" asserts that the matching containers both exist and are running, but takes no action if any configuration has changed. \"reloaded\" (added in Ansible 1.9) asserts that all matching containers are running and restarts any that have any images or configuration out of date. \"restarted\" unconditionally restarts (or starts) the matching containers. \"stopped\" and '\"killed\" stop and kill all matching containers. \"absent\" stops and then' removes any matching containers."
              },
              "tls_client_cert": {
                "type": "string",
                "description": "Default: ${DOCKER_CERT_PATH}/cert.pem\n\nPath to the PEM-encoded certificate used to authenticate docker client. If specified tls_client_key must be valid"
              },
              "entrypoint": {
                "type": "string",
                "description": "Corresponds to ``--entrypoint`` option of ``docker run`` command and ``ENTRYPOINT`` directive of Dockerfile. Used to match and launch containers."
              },
              "dns": {
                "description": "List of custom DNS servers for the container.",
                "$ref": "#/definitions/ansible_array"
              },
              "volumes_from": {
                "description": "List of names of containers to mount volumes from.",
                "$ref": "#/definitions/ansible_array"
              },
              "net": {
                "type": "string",
                "description": "Network mode for the launched container: bridge, none, container:<name|id>\nor host. Requires docker >= 0.11."
              },
              "privileged": {
                "description": "Whether the container should run in privileged mode or not.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": "Remote API username."
              },
              "docker_user": {
                "type": "string",
                "description": "Username or UID to use within the container"
              },
              "extra_hosts": {
                "type": "object",
                "description": "Dict of custom host-to-IP mappings to be defined in the container"
              },
              "log_driver": {
                "enum": [
                  "json-file",
                  "none",
                  "syslog",
                  "journald",
                  "gelf",
                  "fluentd",
                  "awslogs"
                ],
                "type": "string",
                "description": "Default: json-file\n\nYou can specify a different logging driver for the container than for the daemon. \"json-file\" Default logging driver for Docker. Writes JSON messages to file. docker logs command is available only for this logging driver. \"none\" disables any logging for the container. \"syslog\" Syslog logging driver for Docker. Writes log messages to syslog. docker logs command is not available for this logging driver. \"journald\" Journald logging driver for Docker. Writes log messages to \"journald\". \"gelf\" Graylog Extended Log Format (GELF) logging driver for Docker. Writes log messages to a GELF endpoint likeGraylog or Logstash. \"fluentd\" Fluentd logging driver for Docker. Writes log messages to \"fluentd\" (forward input). \"awslogs\" (added in 2.1) Awslogs logging driver for Docker. Writes log messages to AWS Cloudwatch Logs. If not defined explicitly, the Docker daemon's default (\"json-file\") will apply. Requires docker >= 1.6.0."
              },
              "expose": {
                "description": "List of additional container ports to expose for port mappings or links. If the port is already exposed using EXPOSE in a Dockerfile, you don't need to expose it again.",
                "$ref": "#/definitions/ansible_array"
              },
              "stdin_open": {
                "description": "Keep stdin open after a container is launched.",
                "$ref": "#/definitions/ansible_truth"
              },
              "memory_limit": {
                "type": "string",
                "description": "RAM allocated to the container as a number of bytes or as a human-readable string like \"512MB\". Leave as \"0\" to specify no limit."
              },
              "tls_hostname": {
                "type": "string",
                "description": "Default: Taken from docker_url\n\nA hostname to check matches what's supplied in the docker server's certificate.  If unspecified, the hostname is taken from the docker_url."
              },
              "registry": {
                "type": "string",
                "description": "Default: DockerHub\n\nRemote registry URL to pull images from."
              },
              "volumes": {
                "description": "List of volumes to mount within the container\nUse docker CLI-style syntax: C(/host:/container[:mode])\nYou can specify a read mode for the mount with either C(ro) or C(rw). Starting at version 2.1, SELinux hosts can additionally use C(z) or C(Z) mount options to use a shared or private label for the volume.",
                "$ref": "#/definitions/ansible_array"
              },
              "detach": {
                "description": "Default: True\n\nEnable detached mode to leave the container running in background. If disabled, fail unless the process exits cleanly.",
                "$ref": "#/definitions/ansible_truth"
              },
              "memory_swap": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "cpu_set": {
                "type": "string",
                "description": "CPUs in which to allow execution. Requires docker-py >= 0.6.0."
              },
              "pull": {
                "enum": [
                  "missing",
                  "always"
                ],
                "type": "string",
                "description": "Default: missing\n\nControl when container images are updated from the C(docker_url) registry. If \"missing,\" images will be pulled only when missing from the host; if '\"always,\" the registry will be checked for a newer version of the image' each time the task executes."
              },
              "name": {
                "type": "string",
                "description": "Name used to match and uniquely name launched containers. Explicit names are used to uniquely identify a single container or to link among containers. Mutually exclusive with a \"count\" other than \"1\"."
              },
              "env": {
                "type": "object",
                "description": "Pass a dict of environment variables to the container."
              },
              "signal": {
                "type": "string",
                "description": "Default: KILL\n\nWith the state \"killed\", you can alter the signal sent to the container."
              },
              "cap_add": {
                "description": "Add capabilities for the container. Requires docker-py >= 0.5.0.",
                "$ref": "#/definitions/ansible_array"
              },
              "restart_policy": {
                "enum": [
                  "no",
                  "on-failure",
                  "always",
                  "unless-stopped"
                ],
                "type": "string",
                "description": "Container restart policy.\nThe 'unless-stopped' choice is only available starting in Ansible 2.1 and for Docker 1.9 and above."
              },
              "count": {
                "description": "Default: 1\n\nNumber of matching containers that should be in the desired state.",
                "$ref": "#/definitions/ansible_number"
              },
              "devices": {
                "description": "List of host devices to expose to container",
                "$ref": "#/definitions/ansible_array"
              },
              "email": {
                "type": "string",
                "description": "Remote API email."
              },
              "command": {
                "type": "string",
                "description": "Command used to match and launch containers."
              },
              "restart_policy_retry": {
                "description": "Maximum number of times to restart a container. Leave as \"0\" for unlimited retries.",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "Default: 60\n\nDocker daemon response timeout in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cap_drop": {
                "description": "Drop capabilities for the container. Requires docker-py >= 0.5.0.",
                "$ref": "#/definitions/ansible_array"
              },
              "ports": {
                "description": "List containing private to public port mapping specification. Use docker 'CLI-style syntax: C(8000), C(9000:8000), or C(0.0.0.0:9000:8000)' where 8000 is a container port, 9000 is a host port, and 0.0.0.0 is - a host interface. The container ports need to be exposed either in the Dockerfile or via the C(expose) option.",
                "$ref": "#/definitions/ansible_array"
              },
              "ulimits": {
                "description": "ulimits, list ulimits with name, soft and optionally hard limit separated by colons. e.g. nofile:1024:2048 Requires docker-py >= 1.2.0 and docker >= 1.6.0",
                "$ref": "#/definitions/ansible_array"
              },
              "cpu_shares": {
                "description": "CPU shares (relative weight). Requires docker-py >= 0.6.0.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "aos_blueprint_param": {
            "required": [
              "blueprint",
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS Blueprint Parameter module let you manage your Blueprint Parameter easily. You can create access, define and delete Blueprint Parameter. The list of Parameters supported is different per Blueprint. The option I(get_param_list) can help you to access the list of supported Parameters for your blueprint. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "blueprint": {
                "type": "string",
                "description": "Blueprint Name or Id as defined in AOS."
              },
              "name": {
                "type": "string",
                "description": "Name of blueprint parameter, as defined by AOS design template. You can use the option I(get_param_list) to get the complete list of supported parameters for your blueprint."
              },
              "value": {
                "type": "object",
                "description": "Blueprint parameter value.  This value may be transformed by using the I(param_map) field; used when the the blueprint parameter requires an AOS unique ID value."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the Blueprint Parameter (present or not)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "param_map": {
                "type": "string",
                "description": "Defines the aos-pyez collection that will is used to map the user-defined item name into the AOS unique ID value.  For example, if the caller provides an IP address pool I(param_value) called \"Server-IpAddrs\", then the aos-pyez collection is 'IpPools'. Some I(param_map) are already defined by default like I(logical_device_maps)."
              },
              "get_param_list": {
                "description": "Get the complete list of supported parameters for this blueprint and the description of those parameters.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "pn_vlan": {
            "required": [
              "pn_vlanid",
              "state"
            ],
            "type": "object",
            "description": "Execute vlan-create or vlan-delete command.\nVLANs are used to isolate network traffic at Layer 2.The VLAN identifiers 0 and 4095 are reserved and cannot be used per the IEEE 802.1Q standard. The range of configurable VLAN identifiers is 2 through 4092.",
            "properties": {
              "pn_scope": {
                "enum": [
                  "fabric",
                  "local"
                ],
                "type": "string",
                "description": "Specify a scope for the VLAN.\nRequired for vlan-create."
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "pn_vlanid": {
                "description": "Specify a VLAN identifier for the VLAN. This is a value between 2 and 4092.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "State the action to perform. Use 'present' to create vlan and 'absent' to delete vlan."
              },
              "pn_ports": {
                "type": "string",
                "description": "Specifies the switch network data port number, list of ports, or range of ports. Port numbers must ne in the range of 1 to 64."
              },
              "pn_untagged_ports": {
                "type": "string",
                "description": "Specifies the ports that should have untagged packets mapped to the VLAN. Untagged packets are packets that do not contain IEEE 802.1Q VLAN tags."
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch(es) to run the cli on."
              },
              "pn_stats": {
                "description": "Specify if you want to collect statistics for a VLAN. Statistic collection is enabled by default.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_description": {
                "type": "string",
                "description": "Specify a description for the VLAN."
              }
            }
          },
          "quantum_floating_ip_associate": {
            "required": [
              "instance_name",
              "login_password",
              "ip_address"
            ],
            "type": "object",
            "description": "Associates or disassociates a specific floating IP with a particular instance",
            "properties": {
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nname of the region"
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "instance_name": {
                "type": "string",
                "description": "Default: None\n\nname of the instance to which the public IP should be assigned"
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: True\n\nthe tenant name of the login user"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nindicates the desired state of the resource"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nthe keystone url for authentication"
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\npassword of login user"
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "ip_address": {
                "type": "string",
                "description": "Default: None\n\nfloating ip that should be assigned to the instance"
              }
            }
          },
          "azure_rm_subnet": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "virtual_network_name",
                        "virtual_network"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "virtual_network_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "virtual_network"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_group_name",
                        "security_group"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "address_prefix_cidr",
                        "address_prefix"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, update or delete a subnet within a given virtual network. Allows setting and updating the address prefix CIDR, which must be valid within the context of the virtual network. Use the azure_rm_networkinterface module to associate interfaces with the subnet and assign specific IP addresses.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the subnet."
              },
              "resource_group": {
                "type": "string",
                "description": "Name of resource group."
              },
              "tags": {
                "type": "object",
                "description": ""
              },
              "virtual_network_name": {
                "type": "string",
                "description": "Name of an existing virtual network with which the subnet is or will be associated."
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "append_tags": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "security_group_name": {
                "type": "string",
                "description": "Name of an existing security group with which to associate the subnet."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nAssert the state of the subnet. Use 'present' to create or update a subnet and 'absent' to delete a subnet."
              },
              "address_prefix": {
                "type": "string",
                "description": "CIDR defining the IPv4 address space of the subnet. Must be valid within the context of the virtual network."
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "address_prefix_cidr": {
                "type": "string",
                "description": "CIDR defining the IPv4 address space of the subnet. Must be valid within the context of the virtual network."
              },
              "security_group": {
                "type": "string",
                "description": "Name of an existing security group with which to associate the subnet."
              },
              "virtual_network": {
                "type": "string",
                "description": "Name of an existing virtual network with which the subnet is or will be associated."
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "statusio_maintenance": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "components",
                        "component"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "containers",
                        "container"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates a maintenance window for status.io\nDeletes a maintenance window for status.io",
            "properties": {
              "maintenance_notify_72_hr": {
                "description": "Notify subscribers 72 hours before maintenance start time",
                "$ref": "#/definitions/ansible_truth"
              },
              "maintenance_notify_1_hr": {
                "description": "Notify subscribers 1 hour before maintenance start time",
                "$ref": "#/definitions/ansible_truth"
              },
              "container": {
                "description": "Default: None\n\nThe given name of your container (data center)",
                "$ref": "#/definitions/ansible_array"
              },
              "title": {
                "type": "string",
                "description": "Default: A new maintenance window\n\nA descriptive title for the maintenance window"
              },
              "maintenance_notify_now": {
                "description": "Notify subscribers now",
                "$ref": "#/definitions/ansible_truth"
              },
              "start_time": {
                "type": "string",
                "description": "Default: None\n\nTime maintenance is expected to start (Hour:Minutes) (UTC)\nEnd Time is worked out from start_time + minutes"
              },
              "component": {
                "description": "Default: None\n\nThe given name of your component (server name)",
                "$ref": "#/definitions/ansible_array"
              },
              "api_id": {
                "type": "string",
                "description": "Your unique API ID from status.io"
              },
              "automation": {
                "description": "Automatically start and end the maintenance window",
                "$ref": "#/definitions/ansible_truth"
              },
              "maintenance_notify_24_hr": {
                "description": "Notify subscribers 24 hours before maintenance start time",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the package."
              },
              "all_infrastructure_affected": {
                "description": "If it affects all components and containers",
                "$ref": "#/definitions/ansible_truth"
              },
              "url": {
                "type": "string",
                "description": "Default: https://api.status.io\n\nStatus.io API URL. A private apiary can be used instead."
              },
              "components": {
                "description": "Default: None\n\nThe given name of your component (server name)",
                "$ref": "#/definitions/ansible_array"
              },
              "statuspage": {
                "type": "string",
                "description": "Your unique StatusPage ID from status.io"
              },
              "maintenance_id": {
                "type": "string",
                "description": "Default: None\n\nThe maintenance id number when deleting a maintenance window"
              },
              "api_key": {
                "type": "string",
                "description": "Your unique API Key from status.io"
              },
              "minutes": {
                "description": "Default: 10\n\nThe length of time in UTC that the maintenance will run             (starting from playbook runtime)",
                "$ref": "#/definitions/ansible_number"
              },
              "start_date": {
                "type": "string",
                "description": "Default: None\n\nDate maintenance is expected to start (Month/Day/Year) (UTC)\nEnd Date is worked out from start_date + minutes"
              },
              "containers": {
                "description": "Default: None\n\nThe given name of your container (data center)",
                "$ref": "#/definitions/ansible_array"
              },
              "desc": {
                "type": "string",
                "description": "Default: Created by Ansible\n\nMessage describing the maintenance window"
              }
            }
          },
          "telegram": {
            "required": [
              "msg",
              "token",
              "chat_id"
            ],
            "type": "object",
            "description": "Send notifications via telegram bot, to a verified group or user",
            "properties": {
              "msg": {
                "type": "string",
                "description": "What message you wish to send."
              },
              "token": {
                "type": "string",
                "description": "Token identifying your telegram bot."
              },
              "chat_id": {
                "type": "string",
                "description": "Telegram group or user chat_id"
              }
            }
          },
          "django_manage": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "virtualenv",
                        "virtual_env"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "testrunner",
                        "test_runner"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "pythonpath",
                        "python_path"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "liveserver",
                        "live_server"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "failfast",
                        "fail_fast"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages a Django application using the I(manage.py) application frontend to I(django-admin). With the I(virtualenv) parameter, all management commands will be executed by the given I(virtualenv) installation.",
            "properties": {
              "virtualenv": {
                "type": "string",
                "description": "An optional path to a I(virtualenv) installation to use while running the manage application."
              },
              "app_path": {
                "type": "string",
                "description": "The path to the root of the Django application where B(manage.py) lives."
              },
              "virtual_env": {
                "type": "string",
                "description": "An optional path to a I(virtualenv) installation to use while running the manage application."
              },
              "test_runner": {
                "type": "string",
                "description": ""
              },
              "database": {
                "type": "string",
                "description": "The database to target. Used by the 'createcachetable', 'flush', 'loaddata', and 'syncdb' commands."
              },
              "skip": {
                "description": "Will skip over out-of-order missing migrations, you can only use this parameter with I(migrate)",
                "$ref": "#/definitions/ansible_truth"
              },
              "clear": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "settings": {
                "type": "string",
                "description": "The Python path to the application's settings module, such as 'myapp.settings'."
              },
              "apps": {
                "type": "string",
                "description": "A list of space-delimited apps to target. Used by the 'test' command."
              },
              "testrunner": {
                "type": "string",
                "description": ""
              },
              "cache_table": {
                "type": "string",
                "description": "The name of the table used for database-backed caching. Used by the 'createcachetable' command."
              },
              "pythonpath": {
                "type": "string",
                "description": "A directory to add to the Python path. Typically used to include the settings module if it is located external to the application directory."
              },
              "python_path": {
                "type": "string",
                "description": "A directory to add to the Python path. Typically used to include the settings module if it is located external to the application directory."
              },
              "link": {
                "description": "Will create links to the files instead of copying them, you can only use this parameter with 'collectstatic' command",
                "$ref": "#/definitions/ansible_truth"
              },
              "merge": {
                "description": "Will run out-of-order or missing migrations as they are not rollback migrations, you can only use this parameter with 'migrate' command",
                "$ref": "#/definitions/ansible_truth"
              },
              "command": {
                "type": "string",
                "description": "The name of the Django management command to run. Built in commands are cleanup, collectstatic, flush, loaddata, migrate, runfcgi, syncdb, test, and validate.\nOther commands can be entered, but will fail if they're unknown to Django.  Other commands that may prompt for user input should be run with the I(--noinput) flag."
              },
              "fixtures": {
                "type": "string",
                "description": "A space-delimited list of fixture file names to load in the database. B(Required) by the 'loaddata' command."
              },
              "fail_fast": {
                "description": "Default: no\n\nFail the command immediately if a test fails. Used by the 'test' command.",
                "$ref": "#/definitions/ansible_truth"
              },
              "liveserver": {
                "type": "string",
                "description": ""
              },
              "failfast": {
                "description": "Default: no\n\nFail the command immediately if a test fails. Used by the 'test' command.",
                "$ref": "#/definitions/ansible_truth"
              },
              "live_server": {
                "type": "string",
                "description": ""
              }
            }
          },
          "dladm_etherstub": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create or delete etherstubs on Solaris/illumos systems.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete Solaris/illumos etherstub."
              },
              "temporary": {
                "description": "Specifies that the etherstub is temporary. Temporary etherstubs do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Etherstub name."
              }
            }
          },
          "pn_vrouter": {
            "required": [
              "pn_name",
              "state"
            ],
            "type": "object",
            "description": "Execute vrouter-create, vrouter-delete, vrouter-modify command.\nEach fabric, cluster, standalone switch, or virtual network (VNET) can provide its tenants with a virtual router (vRouter) service that forwards traffic between networks and implements Layer 3 protocols.\nC(vrouter-create) creates a new vRouter service.\nC(vrouter-delete) deletes a vRouter service.\nC(vrouter-modify) modifies a vRouter service.",
            "properties": {
              "pn_ospf_redistribute": {
                "enum": [
                  "static",
                  "connected",
                  "bgp",
                  "rip"
                ],
                "type": "string",
                "description": "Specify how OSPF routes are redistributed."
              },
              "pn_name": {
                "type": "string",
                "description": "Specify the name of the vRouter."
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch(es) to run the CLI on."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "update"
                ],
                "type": "string",
                "description": "State the action to perform. Use 'present' to create vrouter, 'absent' to delete vrouter and 'update' to modify vrouter."
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_bgp_redistribute": {
                "enum": [
                  "static",
                  "connected",
                  "rip",
                  "ospf"
                ],
                "type": "string",
                "description": "Specify how BGP routes are redistributed."
              },
              "pn_router_type": {
                "enum": [
                  "hardware",
                  "software"
                ],
                "type": "string",
                "description": "Specify if the vRouter uses software or hardware.\nNote that if you specify hardware as router type, you cannot assign IP addresses using DHCP. You must specify a static IP address."
              },
              "pn_hw_vrrp_id": {
                "description": "Specifies the VRRP ID for a hardware vrouter.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_vnet": {
                "type": "string",
                "description": "Specify the name of the VNET.\nRequired for vrouter-create."
              },
              "pn_ospf_options": {
                "type": "string",
                "description": "Specify other OSPF options as a whitespaces separated string within single quotes ''."
              },
              "pn_rip_redistribute": {
                "enum": [
                  "static",
                  "connected",
                  "ospf",
                  "bgp"
                ],
                "type": "string",
                "description": "Specify how RIP routes are redistributed."
              },
              "pn_bgp_options": {
                "type": "string",
                "description": "Specify other BGP options as a whitespaces separated string within single quotes ''."
              },
              "pn_router_id": {
                "type": "string",
                "description": "Specify the vRouter IP address."
              },
              "pn_bgp_max_paths": {
                "description": "Specify the maximum number of paths for BGP. This is a number between 1 and 255 or 0 to unset.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_service_state": {
                "enum": [
                  "enable",
                  "disable"
                ],
                "type": "string",
                "description": "Specify to enable or disable vRouter service."
              },
              "pn_service_type": {
                "enum": [
                  "dedicated",
                  "shared"
                ],
                "type": "string",
                "description": "Specify if the vRouter is a dedicated or shared VNET service."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "pn_vrrp_track_port": {
                "type": "string",
                "description": ""
              },
              "pn_bgp_as": {
                "description": "Specify the Autonomous System Number(ASN) if the vRouter runs Border Gateway Protocol(BGP).",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "honeybadger_deployment": {
            "required": [
              "environment",
              "token"
            ],
            "type": "object",
            "description": "Notify Honeybadger.io about app deployments (see http://docs.honeybadger.io/article/188-deployment-tracking)",
            "properties": {
              "repo": {
                "type": "string",
                "description": "Default: None\n\nURL of the project repository"
              },
              "url": {
                "type": "string",
                "description": "Default: https://api.honeybadger.io/v1/deploys\n\nOptional URL to submit the notification to."
              },
              "environment": {
                "type": "string",
                "description": "The environment name, typically 'production', 'staging', etc."
              },
              "token": {
                "type": "string",
                "description": "API token."
              },
              "user": {
                "type": "string",
                "description": "Default: None\n\nThe username of the person doing the deployment"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "revision": {
                "type": "string",
                "description": "Default: None\n\nA hash, number, tag, or other identifier showing what revision was deployed"
              }
            }
          },
          "ec2_asg": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Can create or delete AWS Autoscaling Groups\nWorks with the ec2_lc module to manage Launch Configurations",
            "properties": {
              "default_cooldown": {
                "description": "Default: 300 seconds\n\nThe number of seconds after a scaling activity completes before another can begin.",
                "$ref": "#/definitions/ansible_number"
              },
              "health_check_period": {
                "description": "Default: 500 seconds\n\nLength of time in seconds after a new EC2 instance comes into service that Auto Scaling starts checking its health.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "lc_check": {
                "description": "Default: True\n\nCheck to make sure instances that are being replaced with replace_instances do not already have the current launch_config.",
                "$ref": "#/definitions/ansible_truth"
              },
              "availability_zones": {
                "description": "List of availability zone names in which to create the group.  Defaults to all the availability zones in the region if vpc_zone_identifier is not set.",
                "$ref": "#/definitions/ansible_array"
              },
              "replace_batch_size": {
                "description": "Default: 1\n\nNumber of instances you'd like to replace at a time.  Used with replace_all_instances.",
                "$ref": "#/definitions/ansible_number"
              },
              "suspend_processes": {
                "description": "A list of scaling processes to suspend.",
                "$ref": "#/definitions/ansible_array"
              },
              "replace_instances": {
                "description": "Default: None\n\nList of instance_ids belonging to the named ASG that you would like to terminate and be replaced with instances matching the current launch configuration.",
                "$ref": "#/definitions/ansible_array"
              },
              "desired_capacity": {
                "description": "Desired number of instances in group, if unspecified then the current group value will be used.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nregister or deregister the instance"
              },
              "health_check_type": {
                "enum": [
                  "EC2",
                  "ELB"
                ],
                "type": "string",
                "description": "Default: EC2\n\nThe service you want the health status from, Amazon EC2 or Elastic Load Balancer."
              },
              "launch_config_name": {
                "type": "string",
                "description": "Name of the Launch configuration to use for the group. See the ec2_lc module for managing these."
              },
              "placement_group": {
                "type": "string",
                "description": "Default: None\n\nPhysical location of your cluster placement group created in Amazon EC2."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "description": "Default: None\n\nA list of tags to add to the Auto Scale Group. Optional key is 'propagate_at_launch', which defaults to true.",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "min_size": {
                "description": "Minimum number of instances in group, if unspecified then the current group value will be used.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_timeout": {
                "description": "Default: 300\n\nhow long before wait instances to become viable when replaced.  Used in conjunction with instance_ids option.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "load_balancers": {
                "description": "List of ELB names to use for the group",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "max_size": {
                "description": "Maximum number of instances in group, if unspecified then the current group value will be used.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Unique name for group to be created or deleted"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "termination_policies": {
                "description": "Default: Default\n\nAn ordered list of criteria used for selecting instances to be removed from the Auto Scaling group when reducing capacity.\nFor 'Default', when used to create a new autoscaling group, the \"Default\"i value is used. When used to change an existent autoscaling group, the current termination policies are maintained.",
                "$ref": "#/definitions/ansible_array"
              },
              "replace_all_instances": {
                "description": "In a rolling fashion, replace all instances with an old launch configuration with one from the current launch configuration.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vpc_zone_identifier": {
                "description": "Default: None\n\nList of VPC subnets to use",
                "$ref": "#/definitions/ansible_array"
              },
              "notification_topic": {
                "type": "string",
                "description": "Default: None\n\nA SNS topic ARN to send auto scaling notifications to."
              },
              "notification_types": {
                "description": "Default: ['autoscaling:EC2_INSTANCE_LAUNCH', 'autoscaling:EC2_INSTANCE_LAUNCH_ERROR', 'autoscaling:EC2_INSTANCE_TERMINATE', 'autoscaling:EC2_INSTANCE_TERMINATE_ERROR']\n\nA list of auto scaling events to trigger notifications on.",
                "$ref": "#/definitions/ansible_array"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "wait_for_instances": {
                "description": "Default: True\n\nWait for the ASG instances to be in a ready state before exiting.  If instances are behind an ELB, it will wait until the ELB determines all instances have a lifecycle_state of  \"InService\" and  a health_status of \"Healthy\".",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "azure_rm_storageblob": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "container",
                        "container_name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "container"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "container_name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "storage_account_name",
                        "account_name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "storage_account_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "account_name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "blob",
                        "blob_name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, update and delete blob containers and blob objects. Use to upload a file and store it as a blob object, or download a blob object to a file.",
            "properties": {
              "force": {
                "description": "Overwrite existing blob or file when uploading or downloading. Force deletion of a container that contains blobs.",
                "$ref": "#/definitions/ansible_truth"
              },
              "content_type": {
                "type": "string",
                "description": "Set the blob content-type header. For example, 'image/png'."
              },
              "resource_group": {
                "type": "string",
                "description": "Name of the resource group to use."
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "content_language": {
                "type": "string",
                "description": "Set the blob content-language header."
              },
              "account_name": {
                "type": "string",
                "description": "Name of the storage account to use."
              },
              "container": {
                "type": "string",
                "description": "Name of a blob container within the storage account."
              },
              "append_tags": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nAssert the state of a container or blob.\nUse state 'absent' with a container value only to delete a container. Include a blob value to remove a specific blob. A container will not be deleted, if it contains blobs. Use the force option to override, deleting the container and all associated blobs.\nUse state 'present' to create or update a container and upload or download a blob. If the container does not exist, it will be created. If it exists, it will be updated with configuration options. Provide a blob name and either src or dest to upload or download. Provide a src path to upload and a dest path to download. If a blob (uploading) or a file (downloading) already exists, it will not be overwritten unless the force parameter is true."
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "content_encoding": {
                "type": "string",
                "description": "Set the blob encoding header."
              },
              "content_md5": {
                "type": "string",
                "description": "Set the blob md5 hash value."
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "content_disposition": {
                "type": "string",
                "description": "Set the blob content-disposition header."
              },
              "cache_control": {
                "type": "string",
                "description": "Set the blob cache-control header."
              },
              "blob": {
                "type": "string",
                "description": "Name of a blob object within the container."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "tags": {
                "type": "object",
                "description": ""
              },
              "dest": {
                "type": "string",
                "description": "Destination file path. Use with state 'present' to download a blob."
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "container_name": {
                "type": "string",
                "description": "Name of a blob container within the storage account."
              },
              "public_access": {
                "enum": [
                  "container",
                  "blob"
                ],
                "type": "string",
                "description": "Determine a container's level of public access. By default containers are private. Can only be set at time of container creation."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "blob_name": {
                "type": "string",
                "description": "Name of a blob object within the container."
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "Source file path. Use with state 'present' to upload a blob."
              },
              "storage_account_name": {
                "type": "string",
                "description": "Name of the storage account to use."
              }
            }
          },
          "netapp_e_auth": {
            "required": [
              "api_url",
              "new_password",
              "set_admin"
            ],
            "type": "object",
            "description": "Sets or updates the password for a storage array.  When the password is updated on the storage array, it must be updated on the SANtricity Web Services proxy. Note, all storage arrays do not have a Monitor or RO role.",
            "properties": {
              "ssid": {
                "type": "string",
                "description": "the identifier of the storage array in the Web Services Proxy."
              },
              "api_url": {
                "type": "string",
                "description": "The full API url.\nExample: http://ENDPOINT:8080/devmgr/v2\nThis can optionally be set via an environment variable, API_URL"
              },
              "new_password": {
                "type": "string",
                "description": "The password you would like to set. Cannot be more than 30 characters."
              },
              "api_password": {
                "type": "string",
                "description": "The password used to authenticate against the API\nThis can optionally be set via an environment variable, API_PASSWORD"
              },
              "current_password": {
                "type": "string",
                "description": "The current admin password. This is not required if the password hasn't been set before."
              },
              "api_username": {
                "type": "string",
                "description": "The username used to authenticate against the API\nThis can optionally be set via an environment variable, API_USERNAME"
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "set_admin": {
                "description": "Boolean value on whether to update the admin password. If set to false then the RO account is updated.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead."
              }
            }
          },
          "proxmox_kvm": {
            "required": [
              "api_host",
              "api_user"
            ],
            "type": "object",
            "description": "Allows you to create/delete/stop Qemu(KVM) Virtual Machines in Proxmox VE cluster.",
            "properties": {
              "storage": {
                "type": "string",
                "description": "Target storage for full clone."
              },
              "force": {
                "description": "Allow to force stop VM.\nCan be used only with states C(stopped), C(restarted).",
                "$ref": "#/definitions/ansible_truth"
              },
              "revert": {
                "type": "string",
                "description": "Revert a pending change."
              },
              "numa": {
                "type": "object",
                "description": "A hash/dictionaries of NUMA topology. C(numa='{\"key\":\"value\", \"key\":\"value\"}').\nKeys allowed are - C(numa[n]) where 0 ≤ n ≤ N.\nValues allowed are - C(\"cpu=\"<id[-id];...>\",hostnodes=\"<id[-id];...>\",memory=\"number\",policy=\"(bind|interleave|preferred)\"\").\nC(cpus) CPUs accessing this NUMA node.\nC(hostnodes) Host NUMA nodes to use.\nC(memory) Amount of memory this NUMA node provides.\nC(policy) NUMA allocation policy."
              },
              "scsihw": {
                "enum": [
                  "lsi",
                  "lsi53c810",
                  "virtio-scsi-pci",
                  "virtio-scsi-single",
                  "megasas",
                  "pvscsi"
                ],
                "type": "string",
                "description": "Specifies the SCSI controller model."
              },
              "startup": {
                "type": "string",
                "description": "Startup and shutdown behavior. C([[order=]\\d+] [,up=\\d+] [,down=\\d+]).\nOrder is a non-negative number defining the general startup order.\nShutdown in done with reverse ordering."
              },
              "migrate_speed": {
                "description": "Sets maximum speed (in MB/s) for migrations.\nA value of 0 is no limit.",
                "$ref": "#/definitions/ansible_number"
              },
              "freeze": {
                "description": "Specify if PVE should freeze CPU at startup (use 'c' monitor command to start execution).",
                "$ref": "#/definitions/ansible_truth"
              },
              "full": {
                "description": "Default: True\n\nCreate a full copy of all disk. This is always done when you clone a normal VM.\nFor VM templates, we try to create a linked clone by default.\nUsed only with clone",
                "$ref": "#/definitions/ansible_truth"
              },
              "keyboard": {
                "type": "string",
                "description": "Sets the keyboard layout for VNC server."
              },
              "skiplock": {
                "description": "Ignore locks\nOnly root is allowed to use this option.",
                "$ref": "#/definitions/ansible_truth"
              },
              "watchdog": {
                "type": "string",
                "description": "Creates a virtual hardware watchdog device."
              },
              "serial": {
                "type": "object",
                "description": "A hash/dictionary of serial device to create inside the VM. C('{\"key\":\"value\", \"key\":\"value\"}').\nKeys allowed are - serial[n](str; required) where 0 ≤ n ≤ 3.\nValues allowed are - C((/dev/.+|socket)).\n/!\\ If you pass through a host serial device, it is no longer possible to migrate such machines - use with special care."
              },
              "numa_enabled": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "sockets": {
                "description": "Default: 1\n\nSets the number of CPU sockets. (1 - N).",
                "$ref": "#/definitions/ansible_number"
              },
              "digest": {
                "type": "string",
                "description": "Specify if to prevent changes if current configuration file has different SHA1 digest.\nThis can be used to prevent concurrent modifications."
              },
              "description": {
                "type": "string",
                "description": "Specify the description for the VM. Only used on the configuration web interface.\nThis is saved as comment inside the configuration file."
              },
              "startdate": {
                "type": "string",
                "description": "Sets the initial date of the real time clock.\nValid format for date are C('now') or C('2016-09-25T16:01:21') or C('2016-09-25')."
              },
              "tablet": {
                "description": "Default: no\n\nEnables/disables the USB tablet device.",
                "$ref": "#/definitions/ansible_truth"
              },
              "bios": {
                "enum": [
                  "seabios",
                  "ovmf"
                ],
                "type": "string",
                "description": "Specify the BIOS implementation."
              },
              "cpu": {
                "type": "string",
                "description": "Default: kvm64\n\nSpecify emulated CPU type."
              },
              "balloon": {
                "description": "Specify the amount of RAM for the VM in MB.\nUsing zero disables the balloon driver.",
                "$ref": "#/definitions/ansible_number"
              },
              "format": {
                "enum": [
                  "cloop",
                  "cow",
                  "qcow",
                  "qcow2",
                  "qed",
                  "raw",
                  "vmdk"
                ],
                "type": "string",
                "description": "Default: qcow2\n\nTarget drive’s backing file’s data format.\nUsed only with clone"
              },
              "boot": {
                "type": "string",
                "description": "Default: cnd\n\nSpecify the boot order -> boot on floppy C(a), hard disk C(c), CD-ROM C(d), or network C(n).\nYou can combine to set order."
              },
              "vga": {
                "enum": [
                  "std",
                  "cirrus",
                  "vmware",
                  "qxl",
                  "serial0",
                  "serial1",
                  "serial2",
                  "serial3",
                  "qxl2",
                  "qxl3",
                  "qxl4"
                ],
                "type": "string",
                "description": "Default: std\n\nSelect VGA type. If you want to use high resolution modes (>= 1280x1024x16) then you should use option 'std' or 'vmware'."
              },
              "shares": {
                "description": "Rets amount of memory shares for auto-ballooning. (0 - 50000).\nThe larger the number is, the more memory this VM gets.\nThe number is relative to weights of all other running VMs.\nUsing 0 disables auto-ballooning, this means no limit.",
                "$ref": "#/definitions/ansible_number"
              },
              "machine": {
                "type": "string",
                "description": "Specifies the Qemu machine type.\ntype => C((pc|pc(-i440fx)?-\\d+\\.\\d+(\\.pxe)?|q35|pc-q35-\\d+\\.\\d+(\\.pxe)?))"
              },
              "hostpci": {
                "type": "object",
                "description": "Specify a hash/dictionary of map host pci devices into guest. C(hostpci='{\"key\":\"value\", \"key\":\"value\"}').\nKeys allowed are - C(hostpci[n]) where 0 ≤ n ≤ N.\nValues allowed are -  C(\"host=\"HOSTPCIID[;HOSTPCIID2...]\",pcie=\"1|0\",rombar=\"1|0\",x-vga=\"1|0\"\").\nThe C(host) parameter is Host PCI device pass through. HOSTPCIID syntax is C(bus:dev.func) (hexadecimal numbers).\nC(pcie=boolean) I(default=0) Choose the PCI-express bus (needs the q35 machine model).\nC(rombar=boolean) I(default=1) Specify whether or not the device’s ROM will be visible in the guest’s memory map.\nC(x-vga=boolean) I(default=0) Enable vfio-vga device support.\n/!\\ This option allows direct access to host hardware. So it is no longer possible to migrate such machines - use with special care."
              },
              "state": {
                "enum": [
                  "present",
                  "started",
                  "absent",
                  "stopped",
                  "restarted",
                  "current"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicates desired state of the instance.\nIf C(current), the current state of the VM will be fecthed. You can access it with C(results.status)"
              },
              "autostart": {
                "description": "Default: no\n\nSpecify, if the VM should be automatically restarted after crash (currently ignored in PVE API).",
                "$ref": "#/definitions/ansible_truth"
              },
              "memory": {
                "description": "Default: 512\n\nMemory size in MB for instance.",
                "$ref": "#/definitions/ansible_number"
              },
              "net": {
                "type": "object",
                "description": "A hash/dictionary of network interfaces for the VM. C(net='{\"key\":\"value\", \"key\":\"value\"}').\nKeys allowed are - C(net[n]) where 0 ≤ n ≤ N.\nValues allowed are - C(\"model=\"XX:XX:XX:XX:XX:XX\",brigde=\"value\",rate=\"value\",tag=\"value\",firewall=\"1|0\",trunks=\"vlanid\"\").\nModel is one of C(e1000 e1000-82540em e1000-82544gc e1000-82545em i82551 i82557b i82559er ne2k_isa ne2k_pci pcnet rtl8139 virtio vmxnet3).\nC(XX:XX:XX:XX:XX:XX) should be an unique MAC address. This is automatically generated if not specified.\nThe C(bridge) parameter can be used to automatically add the interface to a bridge device. The Proxmox VE standard bridge is called 'vmbr0'.\nOption C(rate) is used to limit traffic bandwidth from and to this interface. It is specified as floating point number, unit is 'Megabytes per second'.\nIf you specify no bridge, we create a kvm 'user' (NATed) network device, which provides DHCP and DNS services."
              },
              "target": {
                "type": "string",
                "description": "Target node. Only allowed if the original VM is on shared storage.\nUsed only with clone"
              },
              "migrate_downtime": {
                "description": "Sets maximum tolerated downtime (in seconds) for migrations.",
                "$ref": "#/definitions/ansible_number"
              },
              "localtime": {
                "description": "Sets the real time clock to local time.\nThis is enabled by default if ostype indicates a Microsoft OS.",
                "$ref": "#/definitions/ansible_truth"
              },
              "node": {
                "type": "string",
                "description": "Proxmox VE node, where the new VM will be created.\nOnly required for C(state=present).\nFor other states, it will be autodiscovered."
              },
              "agent": {
                "description": "Specify if the QEMU GuestAgent should be enabled/disabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "virtio": {
                "type": "object",
                "description": "A hash/dictionary of volume used as VIRTIO hard disk. C(virtio='{\"key\":\"value\", \"key\":\"value\"}').\nKeys allowed are - C(virto[n]) where 0 ≤ n ≤ 15.\nValues allowed are -  C(\"storage:size,format=value\").\nC(storage) is the storage identifier where to create the disk.\nC(size) is the size of the disk in GB.\nC(format) is the drive’s backing file’s data format. C(qcow2|raw|subvol)."
              },
              "template": {
                "description": "Default: no\n\nEnables/disables the template.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cpuunits": {
                "description": "Default: 1000\n\nSpecify CPU weight for a VM.\nYou can disable fair-scheduler configuration by setting this to 0",
                "$ref": "#/definitions/ansible_number"
              },
              "clone": {
                "type": "string",
                "description": "Name of VM to be cloned. If C(vmid) is setted, C(clone) can take arbitrary value but required for intiating the clone."
              },
              "args": {
                "type": "string",
                "description": "Default: -serial unix:/var/run/qemu-server/VMID.serial,server,nowait\n\nPass arbitrary arguments to kvm.\nThis option is for experts only!"
              },
              "api_password": {
                "type": "string",
                "description": "Specify the password to authenticate with.\nYou can use C(PROXMOX_PASSWORD) environment variable."
              },
              "snapname": {
                "type": "string",
                "description": "The name of the snapshot. Used only with clone."
              },
              "tdf": {
                "description": "Enables/disables time drift fix.",
                "$ref": "#/definitions/ansible_truth"
              },
              "kvm": {
                "description": "Default: yes\n\nEnable/disable KVM hardware virtualization.",
                "$ref": "#/definitions/ansible_truth"
              },
              "sata": {
                "type": "object",
                "description": "A hash/dictionary of volume used as sata hard disk or CD-ROM. C(sata='{\"key\":\"value\", \"key\":\"value\"}').\nKeys allowed are - C(sata[n]) where 0 ≤ n ≤ 5.\nValues allowed are -  C(\"storage:size,format=value\").\nC(storage) is the storage identifier where to create the disk.\nC(size) is the size of the disk in GB.\nC(format) is the drive’s backing file’s data format. C(qcow2|raw|subvol)."
              },
              "protection": {
                "description": "Enable/disable the protection flag of the VM. This will enable/disable the remove VM and remove disk operations.",
                "$ref": "#/definitions/ansible_truth"
              },
              "reboot": {
                "description": "Allow reboot. If set to yes, the VM exit on reboot.",
                "$ref": "#/definitions/ansible_truth"
              },
              "hotplug": {
                "type": "string",
                "description": "Selectively enable hotplug features.\nThis is a comma separated list of hotplug features C('network', 'disk', 'cpu', 'memory' and 'usb').\nValue 0 disables hotplug completely and value 1 is an alias for the default C('network,disk,usb')."
              },
              "api_user": {
                "type": "string",
                "description": "Specify the user to authenticate with."
              },
              "parallel": {
                "type": "object",
                "description": "A hash/dictionary of map host parallel devices. C(parallel='{\"key\":\"value\", \"key\":\"value\"}').\nKeys allowed are - (parallel[n]) where 0 ≤ n ≤ 2.\nValues allowed are - C(\"/dev/parport\\d+|/dev/usb/lp\\d+\")."
              },
              "pool": {
                "type": "string",
                "description": "Add the new VM to the specified pool."
              },
              "api_host": {
                "type": "string",
                "description": "Specify the target host of the Proxmox VE cluster."
              },
              "lock": {
                "enum": [
                  "migrate",
                  "backup",
                  "snapshot",
                  "rollback"
                ],
                "type": "string",
                "description": "Lock/unlock the VM."
              },
              "cpulimit": {
                "description": "Specify if CPU usage will be limited. Value 0 indicates no CPU limit.\nIf the computer has 2 CPUs, it has total of '2' CPU time",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Specifies the VM name. Only used on the configuration web interface.\nRequired only for C(state=present)."
              },
              "update": {
                "description": "Default: no\n\nIf C(yes), the VM will be update with new value.\nCause of the operations of the API and security reasons, I have disabled the update of the following parameters\nC(net, virtio, ide, sata, scsi). Per example updating C(net) update the MAC address and C(virtio) create always new disk...",
                "$ref": "#/definitions/ansible_truth"
              },
              "vmid": {
                "description": "Specifies the VM ID. Instead use I(name) parameter.\nIf vmid is not set, the next available VM ID will be fetched from ProxmoxAPI.",
                "$ref": "#/definitions/ansible_number"
              },
              "hugepages": {
                "enum": [
                  "any",
                  "2",
                  "1024"
                ],
                "type": "string",
                "description": "Enable/disable hugepages memory."
              },
              "bootdisk": {
                "type": "string",
                "description": "Enable booting from specified disk. C((ide|sata|scsi|virtio)\\d+)"
              },
              "acpi": {
                "description": "Default: yes\n\nSpecify if ACPI should be enables/disabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vcpus": {
                "description": "Sets number of hotplugged vcpus.",
                "$ref": "#/definitions/ansible_number"
              },
              "newid": {
                "description": "VMID for the clone. Used only with clone.\nIf newid is not set, the next available VM ID will be fetched from ProxmoxAPI.",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "Default: 30\n\nTimeout for operations.",
                "$ref": "#/definitions/ansible_number"
              },
              "smbios": {
                "type": "string",
                "description": "Specifies SMBIOS type 1 fields."
              },
              "ostype": {
                "enum": [
                  "other",
                  "wxp",
                  "w2k",
                  "w2k3",
                  "w2k8",
                  "wvista",
                  "win7",
                  "win8",
                  "l24",
                  "l26",
                  "solaris"
                ],
                "type": "string",
                "description": "Default: l26\n\nSpecifies guest operating system. This is used to enable special optimization/features for specific operating systems.\nThe l26 is Linux 2.6/3.X Kernel."
              },
              "cores": {
                "description": "Default: 1\n\nSpecify number of cores per socket.",
                "$ref": "#/definitions/ansible_number"
              },
              "scsi": {
                "type": "object",
                "description": "A hash/dictionary of volume used as SCSI hard disk or CD-ROM. C(scsi='{\"key\":\"value\", \"key\":\"value\"}').\nKeys allowed are - C(sata[n]) where 0 ≤ n ≤ 13.\nValues allowed are -  C(\"storage:size,format=value\").\nC(storage) is the storage identifier where to create the disk.\nC(size) is the size of the disk in GB.\nC(format) is the drive’s backing file’s data format. C(qcow2|raw|subvol)."
              },
              "ide": {
                "type": "object",
                "description": "A hash/dictionary of volume used as IDE hard disk or CD-ROM. C(ide='{\"key\":\"value\", \"key\":\"value\"}').\nKeys allowed are - C(ide[n]) where 0 ≤ n ≤ 3.\nValues allowed are - C(\"storage:size,format=value\").\nC(storage) is the storage identifier where to create the disk.\nC(size) is the size of the disk in GB.\nC(format) is the drive’s backing file’s data format. C(qcow2|raw|subvol)."
              },
              "validate_certs": {
                "description": "Default: no\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "onboot": {
                "description": "Default: yes\n\nSpecifies whether a VM will be started during system bootup.",
                "$ref": "#/definitions/ansible_truth"
              },
              "delete": {
                "type": "string",
                "description": "Specify a list of settings you want to delete."
              }
            }
          },
          "os_keystone_domain": {
            "type": "object",
            "description": "Create, update, or delete OpenStack Identity domains. If a domain with the supplied name already exists, it will be updated with the new description and enabled attributes.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "enabled": {
                "type": "string",
                "description": "Default: True\n\nIs the domain enabled"
              },
              "name": {
                "type": "string",
                "description": "Name that has to be given to the instance"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nDescription of the domain"
              }
            }
          },
          "dynamodb_table": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or delete AWS Dynamo DB tables.\nCan update the provisioned throughput on existing tables.\nReturns the status of the specified table.",
            "properties": {
              "hash_key_name": {
                "type": "string",
                "description": "Name of the hash key.\nRequired when C(state=present)."
              },
              "range_key_type": {
                "enum": [
                  "STRING",
                  "NUMBER",
                  "BINARY"
                ],
                "type": "string",
                "description": "Default: STRING\n\nType of the range key."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "write_capacity": {
                "description": "Default: 1\n\nWrite throughput capacity (units) to provision.",
                "$ref": "#/definitions/ansible_number"
              },
              "indexes": {
                "description": "list of dictionaries describing indexes to add to the table. global indexes can be updated. local indexes don't support updates or have throughput.\nrequired options: ['name', 'type', 'hash_key_name']\nvalid types: ['all', 'global_all', 'global_include', 'global_keys_only', 'include', 'keys_only']\nother options: ['hash_key_type', 'range_key_name', 'range_key_type', 'includes', 'read_capacity', 'write_capacity']",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete the table"
              },
              "hash_key_type": {
                "enum": [
                  "STRING",
                  "NUMBER",
                  "BINARY"
                ],
                "type": "string",
                "description": "Default: STRING\n\nType of the hash key."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "read_capacity": {
                "description": "Default: 1\n\nRead throughput capacity (units) to provision.",
                "$ref": "#/definitions/ansible_number"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "range_key_name": {
                "type": "string",
                "description": "Name of the range key."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the table."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "route53": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates and deletes DNS records in Amazons Route53 service",
            "properties": {
              "weight": {
                "description": "Weighted resource record sets only. Among resource record sets that have the same combination of DNS name and type, a value that determines what portion of traffic for the current resource record set is routed to the associated location.",
                "$ref": "#/definitions/ansible_number"
              },
              "ttl": {
                "description": "Default: 3600 (one hour)\n\nThe TTL to give the new record",
                "$ref": "#/definitions/ansible_number"
              },
              "hosted_zone_id": {
                "type": "string",
                "description": "The Hosted Zone ID of the DNS zone to modify"
              },
              "alias_evaluate_target_health": {
                "description": "Whether or not to evaluate an alias target health. Useful for aliases to Elastic Load Balancers.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "overwrite": {
                "description": "Whether an existing record should be overwritten on create if values do not match",
                "$ref": "#/definitions/ansible_truth"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "zone": {
                "type": "string",
                "description": "The DNS zone to modify"
              },
              "alias": {
                "description": "Indicates if this is an alias record.",
                "$ref": "#/definitions/ansible_truth"
              },
              "retry_interval": {
                "type": "string",
                "description": "Default: 500\n\nIn the case that route53 is still servicing a prior request, this module will wait and try again after this many seconds. If you have many domain names, the default of 500 seconds may be too long."
              },
              "private_zone": {
                "description": "If set to true, the private zone matching the requested name within the domain will be used if there are both public and private zones. The default is to use the public zone.",
                "$ref": "#/definitions/ansible_truth"
              },
              "type": {
                "enum": [
                  "A",
                  "CNAME",
                  "MX",
                  "AAAA",
                  "TXT",
                  "PTR",
                  "SRV",
                  "SPF",
                  "NS",
                  "SOA"
                ],
                "type": "string",
                "description": "The type of DNS record to create"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "health_check": {
                "type": "string",
                "description": "Health check to associate with this record"
              },
              "wait_timeout": {
                "description": "Default: 300\n\nHow long to wait for the changes to be replicated, in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Wait until the changes have been replicated to all Amazon Route 53 DNS servers.",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "alias_hosted_zone_id": {
                "type": "string",
                "description": "The hosted zone identifier."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": "Latency-based resource record sets only Among resource record sets that have the same combination of DNS name and type, a value that determines which region this should be associated with for the latency-based routing"
              },
              "value": {
                "type": "string",
                "description": "The new value when creating a DNS record.  Multiple comma-spaced values are allowed for non-alias records.  When deleting a record all values for the record must be specified or Route53 will not delete it."
              },
              "record": {
                "type": "string",
                "description": "The full DNS record to create or delete"
              },
              "command": {
                "enum": [
                  "get",
                  "create",
                  "delete"
                ],
                "type": "string",
                "description": "Specifies the action to take."
              },
              "vpc_id": {
                "type": "string",
                "description": "When used in conjunction with private_zone: true, this will only modify records in the private hosted zone attached to this VPC.\nThis allows you to have multiple private hosted zones, all with the same name, attached to different VPCs."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "identifier": {
                "type": "string",
                "description": "Have to be specified for Weighted, latency-based and failover resource record sets only. An identifier that differentiates among multiple resource record sets that have the same combination of DNS name and type."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "failover": {
                "enum": [
                  "PRIMARY",
                  "SECONDARY"
                ],
                "type": "string",
                "description": "Failover resource record sets only. Whether this is the primary or secondary resource record set. Allowed values are PRIMARY and SECONDARY"
              }
            }
          },
          "ovirt": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_mem",
                        "vmmem"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_cores",
                        "vmcores"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_cpus",
                        "vmcpus"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_hostname",
                        "hostname"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_disksize",
                        "vm_disksize"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_nic",
                        "vmnic"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_network",
                        "vmnetwork"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_type",
                        "vmtype"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_os",
                        "vmos"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_ip",
                        "ip"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_gateway",
                        "gateway"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_dns",
                        "dns"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_name",
                        "vmname"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "instance_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "vmname"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_netmask",
                        "netmask"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_key",
                        "key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_domain",
                        "domain"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "instance_rootpw",
                        "rootpw"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "allows you to create new instances, either from scratch or an image, in addition to deleting or stopping instances on the oVirt/RHEV platform",
            "properties": {
              "vmcores": {
                "type": "string",
                "description": "Default: 1\n\ndefine the instance's number of cores"
              },
              "instance_mem": {
                "type": "string",
                "description": "the instance's amount of memory in MB"
              },
              "key": {
                "type": "string",
                "description": "define the instance's Authorized key"
              },
              "vmnic": {
                "type": "string",
                "description": "name of the network interface in oVirt/RHEV"
              },
              "vmmem": {
                "type": "string",
                "description": "the instance's amount of memory in MB"
              },
              "instance_cpus": {
                "type": "string",
                "description": "Default: 1\n\nthe instance's number of cpu's"
              },
              "ip": {
                "type": "string",
                "description": "define the instance's IP"
              },
              "image": {
                "type": "string",
                "description": "template to use for the instance"
              },
              "domain": {
                "type": "string",
                "description": "define the instance's Domain"
              },
              "vmtype": {
                "enum": [
                  "server",
                  "desktop"
                ],
                "type": "string",
                "description": "Default: server\n\ndefine if the instance is a server or desktop"
              },
              "instance_nic": {
                "type": "string",
                "description": "name of the network interface in oVirt/RHEV"
              },
              "vmnetwork": {
                "type": "string",
                "description": "Default: rhevm\n\nthe logical network the machine should belong to"
              },
              "vmname": {
                "type": "string",
                "description": "the name of the instance to use"
              },
              "vm_disksize": {
                "type": "string",
                "description": "size of the instance's disk in GB"
              },
              "instance_cores": {
                "type": "string",
                "description": "Default: 1\n\ndefine the instance's number of cores"
              },
              "zone": {
                "type": "string",
                "description": "deploy the image to this oVirt cluster"
              },
              "vmos": {
                "type": "string",
                "description": "type of Operating System"
              },
              "hostname": {
                "type": "string",
                "description": "define the instance's Hostname"
              },
              "gateway": {
                "type": "string",
                "description": ""
              },
              "instance_netmask": {
                "type": "string",
                "description": "define the instance's Netmask"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "shutdown",
                  "started",
                  "restart"
                ],
                "type": "string",
                "description": "Default: present\n\ncreate, terminate or remove instances"
              },
              "instance_key": {
                "type": "string",
                "description": "define the instance's Authorized key"
              },
              "dns": {
                "type": "string",
                "description": "define the instance's Primary DNS server"
              },
              "instance_domain": {
                "type": "string",
                "description": "define the instance's Domain"
              },
              "rootpw": {
                "type": "string",
                "description": "define the instance's Root password"
              },
              "instance_rootpw": {
                "type": "string",
                "description": "define the instance's Root password"
              },
              "vmcpus": {
                "type": "string",
                "description": "Default: 1\n\nthe instance's number of cpu's"
              },
              "instance_hostname": {
                "type": "string",
                "description": "define the instance's Hostname"
              },
              "netmask": {
                "type": "string",
                "description": "define the instance's Netmask"
              },
              "disk_int": {
                "enum": [
                  "virtio",
                  "ide"
                ],
                "type": "string",
                "description": "Default: virtio\n\ninterface type of the disk"
              },
              "instance_network": {
                "type": "string",
                "description": "Default: rhevm\n\nthe logical network the machine should belong to"
              },
              "password": {
                "type": "string",
                "description": "password of the user to authenticate with"
              },
              "sdomain": {
                "type": "string",
                "description": "the Storage Domain where you want to create the instance's disk on."
              },
              "instance_os": {
                "type": "string",
                "description": "type of Operating System"
              },
              "instance_ip": {
                "type": "string",
                "description": "define the instance's IP"
              },
              "instance_gateway": {
                "type": "string",
                "description": ""
              },
              "instance_disksize": {
                "type": "string",
                "description": "size of the instance's disk in GB"
              },
              "url": {
                "type": "string",
                "description": "the url of the oVirt instance"
              },
              "region": {
                "type": "string",
                "description": "the oVirt/RHEV datacenter where you want to deploy to"
              },
              "disk_alloc": {
                "enum": [
                  "thin",
                  "preallocated"
                ],
                "type": "string",
                "description": "Default: thin\n\ndefine if disk is thin or preallocated"
              },
              "instance_dns": {
                "type": "string",
                "description": "define the instance's Primary DNS server"
              },
              "instance_name": {
                "type": "string",
                "description": "the name of the instance to use"
              },
              "instance_type": {
                "enum": [
                  "server",
                  "desktop"
                ],
                "type": "string",
                "description": "Default: server\n\ndefine if the instance is a server or desktop"
              },
              "resource_type": {
                "enum": [
                  "new",
                  "template"
                ],
                "type": "string",
                "description": "whether you want to deploy an image or create an instance from scratch."
              },
              "user": {
                "type": "string",
                "description": "the user to authenticate with"
              }
            }
          },
          "avi_poolgroup": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure PoolGroup object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "priority_labels_ref": {
                "type": "string",
                "description": "Uuid of the priority labels.\nIf not provided, pool group member priority label will be interpreted as a number with a larger number considered higher priority.\nIt is a reference to an object of type prioritylabels."
              },
              "uuid": {
                "type": "string",
                "description": "Uuid of the pool group."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "description": {
                "type": "string",
                "description": "Description of pool group."
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "created_by": {
                "type": "string",
                "description": "Name of the user who created the object."
              },
              "deployment_policy_ref": {
                "type": "string",
                "description": "When setup autoscale manager will automatically promote new pools into production when deployment goals are met.\nIt is a reference to an object of type poolgroupdeploymentpolicy."
              },
              "members": {
                "description": "List of pool group members object of type poolgroupmember.",
                "$ref": "#/definitions/ansible_array"
              },
              "cloud_ref": {
                "type": "string",
                "description": "It is a reference to an object of type cloud."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "cloud_config_cksum": {
                "type": "string",
                "description": "Checksum of cloud configuration for poolgroup.\nInternally set by cloud connector."
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "min_servers": {
                "description": "The minimum number of servers to distribute traffic to.\nDefault value when not specified in API or module is interpreted by Avi Controller as 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "fail_action": {
                "type": "object",
                "description": "Enable an action - close connection, http redirect, or local http response - when a pool group failure happens.\nBy default, a connection will be closed, in case the pool group experiences a failure."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the pool group."
              }
            }
          },
          "ios_command": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "wait_for",
                        "waitfor"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sends arbitrary commands to an ios node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.\nThis module does not support running commands in configuration mode. Please use M(ios_config) to configure IOS devices.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "retries": {
                "description": "Default: 10\n\nSpecifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.",
                "$ref": "#/definitions/ansible_number"
              },
              "commands": {
                "description": "List of commands to send to the remote ios device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "wait_for": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "interval": {
                "description": "Default: 1\n\nConfigures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "any",
                  "all"
                ],
                "type": "string",
                "description": "Default: all\n\nThe I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied."
              },
              "waitfor": {
                "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "netapp_e_amg": {
            "required": [
              "api_password",
              "ssid",
              "api_url",
              "secondaryArrayId",
              "name",
              "state",
              "api_username"
            ],
            "type": "object",
            "description": "Allows for the creation, removal and updating of Asynchronous Mirror Groups for NetApp E-series storage arrays",
            "properties": {
              "new_name": {
                "type": "string",
                "description": ""
              },
              "ssid": {
                "type": "string",
                "description": "The ID of the primary storage array for the async mirror action"
              },
              "syncIntervalMinutes": {
                "description": "Default: 10\n\nThe synchronization interval in minutes",
                "$ref": "#/definitions/ansible_number"
              },
              "recoveryWarnThresholdMinutes": {
                "description": "Default: 20\n\nRecovery point warning threshold (minutes). The user will be warned when the age of the last good failures point exceeds this value",
                "$ref": "#/definitions/ansible_number"
              },
              "secondaryArrayId": {
                "type": "string",
                "description": "The ID of the secondary array to be used in mirroing process"
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "name": {
                "type": "string",
                "description": "The name of the async array you wish to target, or create.\nIf C(state) is present and the name isn't found, it will attempt to create."
              },
              "repoUtilizationWarnThreshold": {
                "description": "Default: 80\n\nRecovery point warning threshold",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "A C(state) of present will either create or update the async mirror group.\nA C(state) of absent will remove the async mirror group."
              },
              "interfaceType": {
                "enum": [
                  "iscsi",
                  "fibre"
                ],
                "type": "string",
                "description": "The intended protocol to use if both Fibre and iSCSI are available."
              },
              "manualSync": {
                "description": "Setting this to true will cause other synchronization values to be ignored",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "syncWarnThresholdMinutes": {
                "description": "Default: 10\n\nThe threshold (in minutes) for notifying the user that periodic synchronization has taken too long to complete.",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              }
            }
          },
          "redhat_subscription": {
            "type": "object",
            "description": "Manage registration and subscription to the Red Hat Subscription Management entitlement platform using the C(subscription-manager) command",
            "properties": {
              "server_hostname": {
                "type": "string",
                "description": "Default: Current value from C(/etc/rhsm/rhsm.conf) is the default\n\nSpecify an alternative Red Hat Subscription Management or Sat6 server"
              },
              "username": {
                "type": "string",
                "description": "access.redhat.com or Sat6  username"
              },
              "password": {
                "type": "string",
                "description": "access.redhat.com or Sat6 password"
              },
              "consumer_type": {
                "type": "string",
                "description": "The type of unit to register, defaults to system"
              },
              "org_id": {
                "type": "string",
                "description": "Organization ID to use in conjunction with activationkey"
              },
              "consumer_id": {
                "type": "string",
                "description": "References an existing consumer ID to resume using a previous registration\nfor this system. If the  system's identity certificate is lost or corrupted,\nthis option allows it to resume using its previous identity and subscriptions.\nThe default is to not specify a consumer ID so a new ID is created.\n"
              },
              "environment": {
                "type": "string",
                "description": "Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello"
              },
              "force_register": {
                "description": "Register the system even if it is already registered",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nwhether to register and subscribe (C(present)), or unregister (C(absent)) a system"
              },
              "autosubscribe": {
                "description": "Upon successful registration, auto-consume available subscriptions",
                "$ref": "#/definitions/ansible_truth"
              },
              "activationkey": {
                "type": "string",
                "description": "supply an activation key for use with registration"
              },
              "server_insecure": {
                "type": "string",
                "description": "Default: Current value from C(/etc/rhsm/rhsm.conf) is the default\n\nEnable or disable https server certificate verification when connecting to C(server_hostname)"
              },
              "consumer_name": {
                "type": "string",
                "description": "Name of the system to register, defaults to the hostname"
              },
              "rhsm_baseurl": {
                "type": "string",
                "description": "Default: Current value from C(/etc/rhsm/rhsm.conf) is the default\n\nSpecify CDN baseurl"
              },
              "pool": {
                "type": "string",
                "description": "Default: ^$\n\nSpecify a subscription pool name to consume.  Regular expressions accepted."
              }
            }
          },
          "gconftool2": {
            "required": [
              "state",
              "key"
            ],
            "type": "object",
            "description": "This module allows for the manipulation of GNOME 2 Configuration via gconftool-2.  Please see the gconftool-2(1) man pages for more details.",
            "properties": {
              "direct": {
                "description": "Access the config database directly, bypassing server.  If direct is specified then the config_source must be specified as well. See man gconftool-2(1)",
                "$ref": "#/definitions/ansible_truth"
              },
              "value": {
                "type": "string",
                "description": "Preference keys typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is \"get\". See man gconftool-2(1)"
              },
              "config_source": {
                "type": "string",
                "description": "Specify a configuration source to use rather than the default path. See man gconftool-2(1)"
              },
              "state": {
                "enum": [
                  "get",
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "The action to take upon the key/value."
              },
              "value_type": {
                "enum": [
                  "int",
                  "bool",
                  "float",
                  "string"
                ],
                "type": "string",
                "description": "The type of value being set. This is ignored if the state is \"get\"."
              },
              "key": {
                "type": "string",
                "description": "A GConf preference key is an element in the GConf repository that corresponds to an application preference. See man gconftool-2(1)"
              }
            }
          },
          "pn_vrouterlbif": {
            "required": [
              "state",
              "pn_vrouter_name"
            ],
            "type": "object",
            "description": "Execute vrouter-loopback-interface-add, vrouter-loopback-interface-remove commands.\nEach fabric, cluster, standalone switch, or virtual network (VNET) can provide its tenants with a virtual router (vRouter) service that forwards traffic between networks and implements Layer 3 protocols.",
            "properties": {
              "pn_vrouter_name": {
                "type": "string",
                "description": "Specify the name of the vRouter."
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "pn_interface_ip": {
                "type": "string",
                "description": "Specify the IP address."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "State the action to perform. Use 'present' to add vrouter loopback interface and 'absent' to remove vrouter loopback interface."
              },
              "pn_index": {
                "description": "Specify the interface index from 1 to 255.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch(es) to run the cli on."
              }
            }
          },
          "capabilities": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "capability",
                        "cap"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "capability"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "cap"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "key"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "key"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module manipulates files privileges using the Linux capabilities(7) system.",
            "properties": {
              "capability": {
                "type": "string",
                "description": "Desired capability to set (with operator and flags, if state is C(present)) or remove (if state is C(absent))"
              },
              "path": {
                "type": "string",
                "description": "Specifies the path to the file to be managed."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the entry should be present or absent in the file's capabilities."
              },
              "cap": {
                "type": "string",
                "description": "Desired capability to set (with operator and flags, if state is C(present)) or remove (if state is C(absent))"
              },
              "key": {
                "type": "string",
                "description": "Specifies the path to the file to be managed."
              }
            }
          },
          "nxos_ip_interface": {
            "required": [
              "interface"
            ],
            "type": "object",
            "description": "Manages Layer 3 attributes for IPv4 and IPv6 interfaces.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "addr": {
                "type": "string",
                "description": "IPv4 or IPv6 Address."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "mask": {
                "type": "string",
                "description": "Subnet mask for IPv4 or IPv6 Address in decimal format."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify desired state of the resource."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "version": {
                "enum": [
                  "v4",
                  "v6"
                ],
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Full name of interface, i.e. Ethernet1/1, vlan10."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "subversion": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "repo",
                        "name",
                        "repository"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "repo"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "repository"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "revision",
                        "rev",
                        "version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Deploy given repository URL / revision to dest. If dest exists, update to the specified revision, otherwise perform a checkout.",
            "properties": {
              "username": {
                "type": "string",
                "description": "--username parameter passed to svn."
              },
              "executable": {
                "type": "string",
                "description": "Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
              },
              "force": {
                "description": "Default: no\n\nIf C(yes), modified files will be discarded. If C(no), module will fail if it encounters modified files. Prior to 1.9 the default was `yes`.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The subversion URL to the repository."
              },
              "repository": {
                "type": "string",
                "description": "The subversion URL to the repository."
              },
              "dest": {
                "type": "string",
                "description": "Absolute path where the repository should be deployed."
              },
              "rev": {
                "type": "string",
                "description": "Default: HEAD\n\nSpecific revision to checkout."
              },
              "update": {
                "description": "Default: yes\n\nIf no, do not retrieve new revisions from the origin repository",
                "$ref": "#/definitions/ansible_truth"
              },
              "repo": {
                "type": "string",
                "description": "The subversion URL to the repository."
              },
              "switch": {
                "description": "Default: yes\n\nIf C(no), do not call svn switch before update.",
                "$ref": "#/definitions/ansible_truth"
              },
              "version": {
                "type": "string",
                "description": "Default: HEAD\n\nSpecific revision to checkout."
              },
              "export": {
                "description": "Default: no\n\nIf C(yes), do export instead of checkout/update.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "--password parameter passed to svn."
              },
              "checkout": {
                "description": "Default: yes\n\nIf no, do not check out the repository if it does not exist locally",
                "$ref": "#/definitions/ansible_truth"
              },
              "revision": {
                "type": "string",
                "description": "Default: HEAD\n\nSpecific revision to checkout."
              }
            }
          },
          "ovirt_datacenters_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt datacenters.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search datacenter I(X) use following pattern: I(name=X)"
              }
            }
          },
          "group_by": {
            "type": "object",
            "description": "Use facts to create ad-hoc groups that can be used later in a playbook.",
            "properties": {
              "key": {
                "type": "string",
                "description": "The variables whose values will be used as groups"
              }
            }
          },
          "rax_mon_notification": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or delete a Rackspace Cloud Monitoring notification that specifies a channel that can be used to communicate alarms, such as email, webhooks, or PagerDuty. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> *rax_mon_notification* -> rax_mon_notification_plan -> rax_mon_alarm",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "label": {
                "type": "string",
                "description": "Defines a friendly name for this notification. String between 1 and 255 characters long."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Ensure that the notification with this C(label) exists or does not exist."
              },
              "details": {
                "type": "object",
                "description": "Dictionary of key-value pairs used to initialize the notification. Required keys and meanings vary with notification type. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/ service-notification-types-crud.html for details."
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "notification_type": {
                "enum": [
                  "webhook",
                  "email",
                  "pagerduty"
                ],
                "type": "string",
                "description": "A supported notification type."
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "gitlab_group": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "validate_certs",
                        "verify_ssl"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "When the group does not exists in Gitlab, it will be created.\nWhen the group does exists and state=absent, the group will be deleted.",
            "properties": {
              "verify_ssl": {
                "description": "Default: True\n\nWhen using https if SSL certificate needs to be verified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the group you want to create."
              },
              "login_user": {
                "type": "string",
                "description": "Gitlab user name."
              },
              "login_token": {
                "type": "string",
                "description": "Gitlab token for logging in."
              },
              "server_url": {
                "type": "string",
                "description": "Url of Gitlab server, with protocol (http or https)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\ncreate or delete group.\nPossible values are present and absent."
              },
              "login_password": {
                "type": "string",
                "description": "Gitlab password for login_user"
              },
              "path": {
                "type": "string",
                "description": "The path of the group you want to create, this will be server_url/group_path\nIf not supplied, the group_name will be used."
              },
              "validate_certs": {
                "description": "Default: True\n\nWhen using https if SSL certificate needs to be verified.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "junos_config": {
            "type": "object",
            "description": "This module provides an implementation for working with the active configuration running on Juniper JUNOS devices.  It provides a set of arguments for loading configuration, performing rollback operations and zeroing the active configuration on the device.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Default: configured by junos_config\n\nThe C(comment) argument specifies a text string to be used when committing the configuration.  If the C(confirm) argument is set to False, this argument is silently ignored."
              },
              "src": {
                "type": "string",
                "description": "The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) argument."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "rollback": {
                "description": "The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail.  To rollback to the most recent commit, set the C(rollback) argument to 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "src_format": {
                "enum": [
                  "xml",
                  "set",
                  "text",
                  "json"
                ],
                "type": "string",
                "description": "The I(src_format) argument specifies the format of the configuration found int I(src).  If the I(src_format) argument is not provided, the module will attempt to determine the format of the configuration file specified in I(src)."
              },
              "confirm": {
                "description": "The C(confirm) argument will configure a time out value for the commit to be confirmed before it is automatically rolled back.  If the C(confirm) argument is set to False, this argument is silently ignored.  If the value for this argument is set to 0, the commit is confirmed immediately.",
                "$ref": "#/definitions/ansible_number"
              },
              "lines": {
                "description": "This argument takes a list of C(set) or C(delete) configuration lines to push into the remote device.  Each line must start with either C(set) or C(delete).  This argument is mutually exclusive with the I(src) argument.",
                "$ref": "#/definitions/ansible_array"
              },
              "update": {
                "enum": [
                  "merge",
                  "override",
                  "replace",
                  "update"
                ],
                "type": "string",
                "description": "Default: merge\n\nThis argument will decide how to load the configuration data particulary when the candidate configuration and loaded configuration contain conflicting statements. Following are accepted values. C(merge) combines the data in the loaded configuration with the candidate configuration. If statements in the loaded configuration conflict with statements in the candidate configuration, the loaded statements replace the candidate ones. C(override) discards the entire candidate configuration and replaces it with the loaded configuration. C(replace) substitutes each hierarchy level in the loaded configuration for the corresponding level."
              },
              "replace": {
                "description": "The C(replace) argument will instruct the remote device to replace the current configuration hierarchy with the one specified in the corresponding hierarchy of the source configuration loaded from this module.\nNote this argument should be considered deprecated.  To achieve the equivalent, set the I(update) argument to C(replace). This argument will be removed in a future release. The C(replace) and C(update) argument is mutually exclusive.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "zeroize": {
                "description": "The C(zeroize) argument is used to completely sanitize the remote device configuration back to initial defaults.  This argument will effectively remove all current configuration statements on the remote device.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              }
            }
          },
          "uptimerobot": {
            "required": [
              "monitorid",
              "state",
              "apikey"
            ],
            "type": "object",
            "description": "This module will let you start and pause Uptime Robot Monitoring",
            "properties": {
              "monitorid": {
                "type": "string",
                "description": "ID of the monitor to check."
              },
              "state": {
                "enum": [
                  "started",
                  "paused"
                ],
                "type": "string",
                "description": "Define whether or not the monitor should be running or paused."
              },
              "apikey": {
                "type": "string",
                "description": "Uptime Robot API key."
              }
            }
          },
          "cnos_facts": {
            "type": "object",
            "description": "This module allows you to view the switch information. It executes the show sysinfo CLI command on a switch and returns a file containing all the system information of the target network device. This module uses SSH to manage network device configuration. The results of the operation can be viewed in results directory. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_facts.html)",
            "properties": {}
          },
          "lxd_profile": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Management of LXD profiles",
            "properties": {
              "new_name": {
                "type": "string",
                "description": "A new name of a profile.\nIf this parameter is specified a profile will be renamed to this name. See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-11)"
              },
              "description": {
                "type": "string",
                "description": ""
              },
              "url": {
                "type": "string",
                "description": "Default: unix:/var/lib/lxd/unix.socket\n\nThe unix domain socket path or the https URL for the LXD server."
              },
              "config": {
                "type": "object",
                "description": "The config for the container (e.g. {\"limits.memory\": \"4GB\"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)\nIf the profile already exists and its \"config\" value in metadata obtained from GET /1.0/profiles/<name> U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#get-19) are different, they this module tries to apply the configurations.\nNot all config values are supported to apply the existing profile. Maybe you need to delete and recreate a profile."
              },
              "cert_file": {
                "type": "string",
                "description": "Default: \"{}/.config/lxc/client.crt\" .format(os.environ[\"HOME\"])\n\nThe client certificate file path."
              },
              "devices": {
                "type": "object",
                "description": "The devices for the profile (e.g. {\"rootfs\": {\"path\": \"/dev/kvm\", \"type\": \"unix-char\"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDefine the state of a profile."
              },
              "key_file": {
                "type": "string",
                "description": "Default: \"{}/.config/lxc/client.key\" .format(os.environ[\"HOME\"])\n\nThe client certificate key file path."
              },
              "trust_password": {
                "type": "string",
                "description": "The client trusted password.\nYou need to set this password on the LXD server before running this module using the following command. lxc config set core.trust_password <some random password> See U(https://www.stgraber.org/2016/04/18/lxd-api-direct-interaction/)\nIf trust_password is set, this module send a request for authentication before sending any requests."
              },
              "name": {
                "type": "string",
                "description": "Name of a profile."
              }
            }
          },
          "avi_sslprofile": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module is used to configure SSLProfile object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "prefer_client_cipher_ordering": {
                "description": "Prefer the ssl cipher ordering presented by the client during the ssl handshake over the one specified in the ssl profile.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "accepted_versions": {
                "description": "Set of versions accepted by the server.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssl_session_timeout": {
                "description": "The amount of time before an ssl session expires.\nDefault value when not specified in API or module is interpreted by Avi Controller as 86400.",
                "$ref": "#/definitions/ansible_number"
              },
              "uuid": {
                "type": "string",
                "description": "Unique object identifier of the object."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "enable_ssl_session_reuse": {
                "description": "Enable ssl session re-use.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cipher_enums": {
                "description": "Cipher_enums of sslprofile.",
                "$ref": "#/definitions/ansible_array"
              },
              "send_close_notify": {
                "description": "Send 'close notify' alert message for a clean shutdown of the ssl connection.\nDefault value when not specified in API or module is interpreted by Avi Controller as True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dhparam": {
                "type": "string",
                "description": "Dh parameters used in ssl.\nAt this time, it is not configurable and is set to 2048 bits."
              },
              "ssl_rating": {
                "type": "object",
                "description": "Sslrating settings for sslprofile."
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "accepted_ciphers": {
                "type": "string",
                "description": "Ciphers suites represented as defined by U(http://www.openssl.org/docs/apps/ciphers.html).\nDefault value when not specified in API or module is interpreted by Avi Controller as AES:3DES:RC4."
              },
              "description": {
                "type": "string",
                "description": "User defined description for the object."
              },
              "tags": {
                "description": "List of tag.",
                "$ref": "#/definitions/ansible_array"
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the object."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              }
            }
          },
          "os_port": {
            "type": "object",
            "description": "Add, Update or Remove ports from an OpenStack cloud. A I(state) of 'present' will ensure the port is created or updated if required.",
            "properties": {
              "network": {
                "type": "string",
                "description": "Network ID or name this port belongs to."
              },
              "allowed_address_pairs": {
                "type": "string",
                "description": "Default: None\n\nAllowed address pairs list.  Allowed address pairs are supported with dictionary structure. e.g.  allowed_address_pairs: - ip_address: 10.1.0.12 mac_address: ab:cd:ef:12:34:56 - ip_address: ..."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "extra_dhcp_opts": {
                "type": "string",
                "description": "Default: None\n\nExtra dhcp options to be assigned to this port.  Extra options are supported with dictionary structure. e.g.  extra_dhcp_opts: - opt_name: opt name1 opt_value: value1 - opt_name: ..."
              },
              "admin_state_up": {
                "type": "string",
                "description": "Default: None\n\nSets admin state."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "device_owner": {
                "type": "string",
                "description": "Default: None\n\nThe ID of the entity that uses this port."
              },
              "no_security_groups": {
                "type": "string",
                "description": "Do not associate a security group with this port."
              },
              "mac_address": {
                "type": "string",
                "description": "Default: None\n\nMAC address of this port."
              },
              "device_id": {
                "type": "string",
                "description": "Default: None\n\nDevice ID of device using this port."
              },
              "fixed_ips": {
                "type": "string",
                "description": "Default: None\n\nDesired IP and/or subnet for this port.  Subnet is referenced by subnet_id and IP is referenced by ip_address."
              },
              "security_groups": {
                "type": "string",
                "description": "Default: None\n\nSecurity group(s) ID(s) or name(s) associated with the port (comma separated string or YAML list)"
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nName that has to be given to the port."
              }
            }
          },
          "mattermost": {
            "required": [
              "text",
              "url",
              "api_key"
            ],
            "type": "object",
            "description": "Sends notifications to U(http://your.mattermost.url) via the Incoming WebHook integration.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: Ansible\n\nThis is the sender of the message (Username Override need to be enabled by mattermost admin, see mattermost doc."
              },
              "url": {
                "type": "string",
                "description": "Mattermost url (i.e. http://mattermost.yourcompany.com)."
              },
              "text": {
                "type": "string",
                "description": "Text to send. Note that the module does not handle escaping characters."
              },
              "icon_url": {
                "type": "string",
                "description": "Default: https://www.ansible.com/favicon.ico\n\nUrl for the message sender's icon."
              },
              "api_key": {
                "type": "string",
                "description": "Mattermost webhook api key. Log into your mattermost site, go to Menu -> Integration -> Incomming Webhook -> Add Incomming Webhook. This will give you full URL. api_key is the last part. http://mattermost.example.com/hooks/C(API_KEY)"
              },
              "validate_certs": {
                "description": "Default: True\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "channel": {
                "type": "string",
                "description": "Channel to send the message to. If absent, the message goes to the channel selected for the I(api_key)."
              }
            }
          },
          "nxos_evpn_global": {
            "required": [
              "nv_overlay_evpn"
            ],
            "type": "object",
            "description": "Handles the EVPN control plane for VXLAN.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "nv_overlay_evpn": {
                "description": "EVPN control plane.",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "os_server": {
            "type": "object",
            "description": "Create or Remove compute instances from OpenStack.",
            "properties": {
              "availability_zone": {
                "type": "string",
                "description": "Availability zone in which to create the server."
              },
              "image": {
                "type": "string",
                "description": "The name or id of the base image to boot."
              },
              "image_exclude": {
                "type": "string",
                "description": "Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to \"(deprecated)\""
              },
              "flavor_include": {
                "type": "string",
                "description": "Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name."
              },
              "meta": {
                "type": "string",
                "description": "Default: None\n\nA list of key value pairs that should be provided as a metadata to the new instance or a string containing a list of key-value pairs. Eg:  meta: \"key1=value1,key2=value2\""
              },
              "flavor": {
                "type": "string",
                "description": "Default: 1\n\nThe name or id of the flavor in which the new instance has to be created. Mutually exclusive with flavor_ram"
              },
              "security_groups": {
                "type": "string",
                "description": "Default: None\n\nNames of the security groups to which the instance should be added. This may be a YAML list or a comma separated string."
              },
              "scheduler_hints": {
                "type": "string",
                "description": "Default: None\n\nArbitrary key/value pairs to the scheduler for custom use"
              },
              "boot_from_volume": {
                "type": "string",
                "description": "Should the instance boot from a persistent volume created based on the image given. Mututally exclusive with boot_volume."
              },
              "userdata": {
                "type": "string",
                "description": "Default: None\n\nOpaque blob of data which is made available to the instance"
              },
              "network": {
                "type": "string",
                "description": "Default: None\n\nName or ID of a network to attach this instance to. A simpler version of the nics parameter, only one of network or nics should be supplied."
              },
              "nics": {
                "type": "string",
                "description": "Default: None\n\nA list of networks to which the instance's interface should be attached. Networks may be referenced by net-id/net-name/port-id or port-name.\nAlso this accepts a string containing a list of (net/port)-(id/name) Eg: nics: \"net-id=uuid-1,port-name=myport\" Only one of network or nics should be supplied."
              },
              "floating_ips": {
                "type": "string",
                "description": "Default: None\n\nlist of valid floating IPs that pre-exist to assign to this node"
              },
              "flavor_ram": {
                "type": "string",
                "description": "Default: 1\n\nThe minimum amount of ram in MB that the flavor in which the new instance has to be created must have. Mutually exclusive with flavor."
              },
              "volume_size": {
                "type": "string",
                "description": "The size of the volume to create in GB if booting from volume based on an image."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "auto_ip": {
                "type": "string",
                "description": "Default: yes\n\nEnsure instance has public ip however the cloud wants to do that"
              },
              "config_drive": {
                "type": "string",
                "description": "Default: no\n\nWhether to boot the server with config drive enabled"
              },
              "terminate_volume": {
                "type": "string",
                "description": "If true, delete volume when deleting instance (if booted from volume)"
              },
              "key_name": {
                "type": "string",
                "description": "Default: None\n\nThe key pair name to be used when creating a instance"
              },
              "boot_volume": {
                "type": "string",
                "description": "Default: None\n\nVolume name or id to use as the volume to boot from. Implies boot_from_volume. Mutually exclusive with image and boot_from_volume."
              },
              "wait": {
                "type": "string",
                "description": "Default: yes\n\nIf the module should wait for the instance to be created."
              },
              "name": {
                "type": "string",
                "description": "Name that has to be given to the instance"
              },
              "timeout": {
                "type": "string",
                "description": "Default: 180\n\nThe amount of time the module should wait for the instance to get into active state."
              },
              "delete_fip": {
                "type": "string",
                "description": "When I(state) is absent and this option is true, any floating IP associated with the instance will be deleted along with the instance."
              },
              "volumes": {
                "type": "string",
                "description": "A list of preexisting volumes names or ids to attach to the instance"
              },
              "floating_ip_pools": {
                "type": "string",
                "description": "Default: None\n\nName of floating IP pool from which to choose a floating IP"
              },
              "reuse_ips": {
                "type": "string",
                "description": "Default: True\n\nWhen I(auto_ip) is true and this option is true, the I(auto_ip) code will attempt to re-use unassigned floating ips in the project before creating a new one. It is important to note that it is impossible to safely do this concurrently, so if your use case involves concurrent server creation, it is highly recommended to set this to false and to delete the floating ip associated with a server when the server is deleted using I(delete_fip)."
              }
            }
          },
          "ovirt_permissions": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "authz_name",
                        "domain"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "authz_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "domain"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage permissions of users/groups in oVirt",
            "properties": {
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "domain": {
                "type": "string",
                "description": "Authorization provider of the user/group. In previous versions of oVirt known as domain."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the permission be present/absent."
              },
              "authz_name": {
                "type": "string",
                "description": "Authorization provider of the user/group. In previous versions of oVirt known as domain."
              },
              "object_type": {
                "enum": [
                  "data_center",
                  "cluster",
                  "host",
                  "storage_domain",
                  "network",
                  "disk",
                  "vm",
                  "vm_pool",
                  "template",
                  "cpu_profile",
                  "disk_profile",
                  "vnic_profile",
                  "system"
                ],
                "type": "string",
                "description": "Default: vm\n\nThe object where the permissions should be managed."
              },
              "namespace": {
                "type": "string",
                "description": "Namespace of the authorization provider, where user/group resides."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "object_id": {
                "type": "string",
                "description": "ID of the object where the permissions should be managed."
              },
              "group_name": {
                "type": "string",
                "description": "Name of the the group to manage.\nNote that if group don't exist in the system this module will fail, you should ensure the group exists by using M(ovirt_groups) module."
              },
              "object_name": {
                "type": "string",
                "description": "Name of the object where the permissions should be managed."
              },
              "role": {
                "type": "string",
                "description": "Default: UserRole\n\nName of the the role to be assigned to user/group on specific object."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "user_name": {
                "type": "string",
                "description": "Username of the the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.\nNote that if user don't exist in the system this module will fail, you should ensure the user exists by using M(ovirt_users) module."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rax_mon_check": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or delete a Rackspace Cloud Monitoring check associated with an existing rax_mon_entity. A check is a specific test or measurement that is performed, possibly from different monitoring zones, on the systems you monitor. Rackspace monitoring module flow | rax_mon_entity -> *rax_mon_check* -> rax_mon_notification -> rax_mon_notification_plan -> rax_mon_alarm",
            "properties": {
              "entity_id": {
                "type": "string",
                "description": "ID of the rax_mon_entity to target with this check."
              },
              "check_type": {
                "type": "string",
                "description": "The type of check to create. C(remote.) checks may be created on any rax_mon_entity. C(agent.) checks may only be created on rax_mon_entities that have a non-null C(agent_id)."
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "period": {
                "description": "The number of seconds between each time the check is performed. Must be greater than the minimum period set on your account.",
                "$ref": "#/definitions/ansible_number"
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "disabled": {
                "description": "If \"yes\", ensure the check is created, but don't actually use it yet.",
                "$ref": "#/definitions/ansible_truth"
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "label": {
                "type": "string",
                "description": "Defines a label for this check, between 1 and 64 characters long."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Ensure that a check with this C(label) exists or does not exist."
              },
              "details": {
                "type": "object",
                "description": "Additional details specific to the check type. Must be a hash of strings between 1 and 255 characters long, or an array or object containing 0 to 256 items."
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "metadata": {
                "type": "object",
                "description": "Hash of arbitrary key-value pairs to accompany this check if it fires. Keys and values must be strings between 1 and 255 characters long."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "target_hostname": {
                "type": "string",
                "description": "One of `target_hostname` and `target_alias` is required for remote.* checks, but prohibited for agent.* checks. The hostname this check should target. Must be a valid IPv4, IPv6, or FQDN."
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "target_alias": {
                "type": "string",
                "description": "One of `target_alias` and `target_hostname` is required for remote.* checks, but prohibited for agent.* checks. Use the corresponding key in the entity's `ip_addresses` hash to resolve an IP address to target."
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "The number of seconds this check will wait when attempting to collect results. Must be less than the period.",
                "$ref": "#/definitions/ansible_number"
              },
              "monitoring_zones_poll": {
                "type": "string",
                "description": "Comma-separated list of the names of the monitoring zones the check should run from. Available monitoring zones include mzdfw, mzhkg, mziad, mzlon, mzord and mzsyd. Required for remote.* checks; prohibited for agent.* checks."
              }
            }
          },
          "ohai": {
            "type": "object",
            "description": "Similar to the M(facter) module, this runs the I(Ohai) discovery program (U(http://wiki.opscode.com/display/chef/Ohai)) on the remote host and returns JSON inventory data. I(Ohai) data is a bit more verbose and nested than I(facter).",
            "properties": {}
          },
          "ops_template": {
            "type": "object",
            "description": "The OpenSwitch platform provides a library for pushing JSON structured configuration files into the current running-config.  This module will read the current configuration from OpenSwitch and compare it against a provided candidate configuration. If there are changes, the candidate configuration is merged with the current configuration and pushed into OpenSwitch",
            "properties": {
              "src": {
                "type": "string",
                "description": "The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will search for the source file in role or playbook root folder in templates directory."
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "force": {
                "type": "string",
                "description": "The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured."
              },
              "backup": {
                "type": "string",
                "description": "When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backups/ in the root of the playbook directory."
              }
            }
          },
          "tower_host": {
            "required": [
              "inventory",
              "name"
            ],
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower hosts. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "description": {
                "type": "string",
                "description": "The description to use for the host."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "enabled": {
                "description": "Default: True\n\nIf the host should be enabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "inventory": {
                "type": "string",
                "description": "Inventory the host should be made a member of."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "variables": {
                "type": "string",
                "description": "Variables to use for the host. Use '@' for a file."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The name to use for the host."
              }
            }
          },
          "win_environment": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Uses .net Environment to set or remove environment variables and can set at User, Machine or Process level.\nUser level environment variables will be set, but not available until the user has logged off and on again.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\npresent to ensure environment variable is set, or absent to ensure it is removed"
              },
              "names": {
                "type": "string",
                "description": "Default: no default\n\nThe name of the environment variable"
              },
              "name": {
                "type": "string",
                "description": "Default: no default\n\nThe name of the environment variable"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "kinesis_stream": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tags",
                        "resource_tags"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or Delete a Kinesis Stream.\nUpdate the retention period of a Kinesis Stream.\nUpdate Tags on a Kinesis Stream.",
            "properties": {
              "retention_period": {
                "description": "Default: None\n\nThe default retention period is 24 hours and can not be less than 24 hours.\nThe retention period can be modified during any point in time.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or Delete the Kinesis Stream."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "wait_timeout": {
                "description": "Default: 300\n\nHow many seconds to wait for an operation to complete before timing out.",
                "$ref": "#/definitions/ansible_number"
              },
              "resource_tags": {
                "type": "object",
                "description": "A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: True\n\nWait for operation to complete before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the Kinesis Stream you are managing."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "shards": {
                "description": "Default: None\n\nThe number of shards you want to have with this stream. This can not be modified after being created.\nThis is required when state == present",
                "$ref": "#/definitions/ansible_number"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_smu": {
            "required": [
              "pkg"
            ],
            "type": "object",
            "description": "Perform software maintenance upgrades (SMUs) on Cisco NX-OS devices.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "file_system": {
                "type": "string",
                "description": "The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "pkg": {
                "type": "string",
                "description": "Name of the remote package."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "os_ironic_inspect": {
            "type": "object",
            "description": "Requests Ironic to set a node into inspect state in order to collect metadata regarding the node. This command may be out of band or in-band depending on the ironic driver configuration. This is only possible on nodes in 'manageable' and 'available' state.",
            "properties": {
              "mac": {
                "type": "string",
                "description": "Default: None\n\nunique mac address that is used to attempt to identify the host."
              },
              "ironic_url": {
                "type": "string",
                "description": "Default: None\n\nIf noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with \"auth\" and \"auth_type\" settings set to None."
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nunique name identifier to identify the host in Ironic."
              },
              "timeout": {
                "type": "string",
                "description": "Default: 1200\n\nA timeout in seconds to tell the role to wait for the node to complete introspection if wait is set to True."
              },
              "uuid": {
                "type": "string",
                "description": "Default: None\n\nglobally unique identifier (UUID) to identify the host."
              }
            }
          },
          "apt": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "install_recommends",
                        "install-recommends"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "package",
                        "pkg",
                        "name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "allow_unauthenticated",
                        "allow-unauthenticated"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "autoremove",
                        "autoclean"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "default_release",
                        "default-release"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages I(apt) packages (such as for Debian/Ubuntu).",
            "properties": {
              "dpkg_options": {
                "type": "string",
                "description": "Default: force-confdef,force-confold\n\nAdd dpkg options to apt command. Defaults to '-o \"Dpkg::Options::=--force-confdef\" -o \"Dpkg::Options::=--force-confold\"'\nOptions should be supplied as comma separated list"
              },
              "upgrade": {
                "enum": [
                  "no",
                  "yes",
                  "safe",
                  "full",
                  "dist"
                ],
                "type": "string",
                "description": "Default: no\n\nIf yes or safe, performs an aptitude safe-upgrade.\nIf full, performs an aptitude full-upgrade.\nIf dist, performs an apt-get dist-upgrade.\nNote: This does not upgrade a specific package, use state=latest for that."
              },
              "force": {
                "description": "Default: no\n\nIf C(yes), force installs/removes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "A package name, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.  Note that the apt-get commandline supports implicit regex matches here but we do not because it can let typos through easier (If you typo C(foo) as C(fo) apt-get would install packages that have \"fo\" in their name with a warning and a prompt for the user.  Since we don't have warnings and prompts before installing we disallow this.  Use an explicit fnmatch pattern if you want wildcarding)",
                "$ref": "#/definitions/ansible_array"
              },
              "install-recommends": {
                "description": "Corresponds to the C(--no-install-recommends) option for I(apt). C(yes) installs recommended packages.  C(no) does not install recommended packages. By default, Ansible will use the same defaults as the operating system. Suggested packages are never installed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "package": {
                "description": "A package name, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.  Note that the apt-get commandline supports implicit regex matches here but we do not because it can let typos through easier (If you typo C(foo) as C(fo) apt-get would install packages that have \"fo\" in their name with a warning and a prompt for the user.  Since we don't have warnings and prompts before installing we disallow this.  Use an explicit fnmatch pattern if you want wildcarding)",
                "$ref": "#/definitions/ansible_array"
              },
              "autoclean": {
                "description": "If C(yes), remove unused dependency packages for all module states except I(build-dep). It can also be used as the only option.",
                "$ref": "#/definitions/ansible_truth"
              },
              "purge": {
                "description": "Will force purging of configuration files if the module state is set to I(absent).",
                "$ref": "#/definitions/ansible_truth"
              },
              "allow_unauthenticated": {
                "description": "Default: no\n\nIgnore if packages cannot be authenticated. This is useful for bootstrapping environments that manage their own apt-key setup.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "installed",
                  "latest",
                  "removed",
                  "absent",
                  "present",
                  "build-dep"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicates the desired package state. C(latest) ensures that the latest version is installed. C(build-dep) ensures the package build dependencies are installed."
              },
              "autoremove": {
                "description": "If C(yes), remove unused dependency packages for all module states except I(build-dep). It can also be used as the only option.",
                "$ref": "#/definitions/ansible_truth"
              },
              "update_cache": {
                "description": "Run the equivalent of C(apt-get update) before the operation. Can be run as part of the package installation or as a separate step.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "A package name, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.  Note that the apt-get commandline supports implicit regex matches here but we do not because it can let typos through easier (If you typo C(foo) as C(fo) apt-get would install packages that have \"fo\" in their name with a warning and a prompt for the user.  Since we don't have warnings and prompts before installing we disallow this.  Use an explicit fnmatch pattern if you want wildcarding)",
                "$ref": "#/definitions/ansible_array"
              },
              "update-cache": {
                "description": "Run the equivalent of C(apt-get update) before the operation. Can be run as part of the package installation or as a separate step.",
                "$ref": "#/definitions/ansible_truth"
              },
              "allow-unauthenticated": {
                "description": "Default: no\n\nIgnore if packages cannot be authenticated. This is useful for bootstrapping environments that manage their own apt-key setup.",
                "$ref": "#/definitions/ansible_truth"
              },
              "default-release": {
                "type": "string",
                "description": "Corresponds to the C(-t) option for I(apt) and sets pin priorities"
              },
              "default_release": {
                "type": "string",
                "description": "Corresponds to the C(-t) option for I(apt) and sets pin priorities"
              },
              "only_upgrade": {
                "description": "Only upgrade a package if it is already installed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cache_valid_time": {
                "description": "Update the apt cache if its older than the I(cache_valid_time). This option is set in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "deb": {
                "type": "string",
                "description": "Path to a .deb package on the remote machine.\nIf :// in the path, ansible will attempt to download deb before installing. (Version added 2.1)"
              },
              "install_recommends": {
                "description": "Corresponds to the C(--no-install-recommends) option for I(apt). C(yes) installs recommended packages.  C(no) does not install recommended packages. By default, Ansible will use the same defaults as the operating system. Suggested packages are never installed.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "sqs_queue": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or delete AWS SQS queues.\nUpdate attributes on existing queues.",
            "properties": {
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "delivery_delay": {
                "description": "The delivery delay in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete the queue"
              },
              "policy": {
                "type": "object",
                "description": "The json dict policy to attach to queue"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "receive_message_wait_time": {
                "description": "The receive message wait time in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "message_retention_period": {
                "description": "The message retention period in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Name of the queue."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "default_visibility_timeout": {
                "description": "The default visibility timeout in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "maximum_message_size": {
                "description": "The maximum message size in bytes.",
                "$ref": "#/definitions/ansible_number"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "redrive_policy": {
                "type": "object",
                "description": "json dict with the redrive_policy (see example)"
              }
            }
          },
          "nxos_snmp_contact": {
            "required": [
              "contact"
            ],
            "type": "object",
            "description": "Manages SNMP contact information.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "contact": {
                "type": "string",
                "description": "Contact information."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "rabbitmq_binding": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "src",
                        "source"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "src"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "source"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "destination",
                        "dst",
                        "dest"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "destination"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dst"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "destination_type",
                        "type",
                        "dest_type"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "destination_type"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "type"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dest_type"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module uses rabbitMQ Rest API to create/delete bindings",
            "properties": {
              "login_port": {
                "type": "string",
                "description": "Default: 15672\n\nrabbitMQ management api port"
              },
              "name": {
                "type": "string",
                "description": "source exchange to create binding on"
              },
              "dest_type": {
                "enum": [
                  "queue",
                  "exchange"
                ],
                "type": "string",
                "description": "Either queue or exchange"
              },
              "src": {
                "type": "string",
                "description": "source exchange to create binding on"
              },
              "dest": {
                "type": "string",
                "description": "destination exchange or queue for the binding"
              },
              "login_user": {
                "type": "string",
                "description": "Default: guest\n\nrabbitMQ user for connection"
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nrabbitMQ host for connection"
              },
              "destination": {
                "type": "string",
                "description": "destination exchange or queue for the binding"
              },
              "routing_key": {
                "type": "string",
                "description": "Default: #\n\nrouting key for the binding\ndefault is"
              },
              "source": {
                "type": "string",
                "description": "source exchange to create binding on"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the exchange should be present or absent\nOnly present implemented atm"
              },
              "arguments": {
                "type": "object",
                "description": "extra arguments for exchange. If defined this argument is a key/value dictionary"
              },
              "login_password": {
                "type": "string",
                "description": "rabbitMQ password for connection"
              },
              "destination_type": {
                "enum": [
                  "queue",
                  "exchange"
                ],
                "type": "string",
                "description": "Either queue or exchange"
              },
              "vhost": {
                "type": "string",
                "description": "Default: /\n\nrabbitMQ virtual host\ndefault vhost is /"
              },
              "type": {
                "enum": [
                  "queue",
                  "exchange"
                ],
                "type": "string",
                "description": "Either queue or exchange"
              },
              "dst": {
                "type": "string",
                "description": "destination exchange or queue for the binding"
              }
            }
          },
          "fortios_config": {
            "type": "object",
            "description": "This module provides management of FortiOS Devices configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "The I(src) argument provides a path to the configuration file to load into the remote device."
              },
              "config_file": {
                "type": "string",
                "description": ""
              },
              "file_mode": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "backup_path": {
                "type": "string",
                "description": ""
              },
              "filter": {
                "type": "string",
                "description": "Only for partial backup, you can restrict by giving expected configuration path (ex. firewall address)."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "backup_filename": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "vdom": {
                "type": "string",
                "description": ""
              }
            }
          },
          "s3_lifecycle": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage s3 bucket lifecycle rules in AWS",
            "properties": {
              "status": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enabled\n\nIf 'enabled', the rule is currently being applied. If 'disabled', the rule is not currently being applied."
              },
              "prefix": {
                "type": "string",
                "description": "Prefix identifying one or more objects to which the rule applies.  If no prefix is specified, the rule will apply to the whole bucket."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "expiration_days": {
                "description": "Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.",
                "$ref": "#/definitions/ansible_number"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or remove the lifecycle rule"
              },
              "transition_date": {
                "type": "string",
                "description": "Indicates the lifetime of the objects that are subject to the rule by the date they will transition to a different storage class. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified. If transition_days is not specified, this parameter is required."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "requester_pays": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "transition_days": {
                "description": "Indicates when, in days, an object transitions to a different storage class. If transition_date is not specified, this parameter is required.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Name of the s3 bucket"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "expiration_date": {
                "type": "string",
                "description": "Indicates the lifetime of the objects that are subject to the rule by the date they will expire. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified."
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "storage_class": {
                "enum": [
                  "glacier",
                  "standard_ia"
                ],
                "type": "string",
                "description": "Default: glacier\n\nThe storage class to transition to. Currently there are two supported values - 'glacier' or 'standard_ia'.\nThe 'standard_ia' class is only being available from Ansible version 2.2."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "rule_id": {
                "type": "string",
                "description": "Unique identifier for the rule. The value cannot be longer than 255 characters. A unique value for the rule will be generated if no value is provided."
              }
            }
          },
          "iosxr_template": {
            "type": "object",
            "description": "Manages network device configurations over SSH.  This module allows implementers to work with the device running-config.  It provides a way to push a set of commands onto a network device by evaluating the current running-config and only pushing configuration commands that are not already configured.  The config source can be a set of commands or a template.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will first search for the source file in role or playbook root folder in templates unless a full path to the file is given."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "The force argument instructs the module not to consider the current device running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "nxos_vlan": {
            "type": "object",
            "description": "Manages VLAN configurations on NX-OS switches.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "vlan_range": {
                "type": "string",
                "description": "Range of VLANs such as 2-10 or 2,5,10-15, etc."
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of VLAN."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "mapped_vni": {
                "type": "string",
                "description": "The Virtual Network Identifier (VNI) ID that is mapped to the VLAN. Valid values are integer and keyword 'default'."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "vlan_state": {
                "enum": [
                  "active",
                  "suspend"
                ],
                "type": "string",
                "description": "Default: active\n\nManage the vlan operational state of the VLAN (equivalent to state {active | suspend} command."
              },
              "admin_state": {
                "enum": [
                  "up",
                  "down"
                ],
                "type": "string",
                "description": "Default: up\n\nManage the VLAN administrative state of the VLAN equivalent to shut/no shut in VLAN config mode."
              },
              "vlan_id": {
                "type": "string",
                "description": "Single VLAN ID."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "portinstall": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage packages for FreeBSD using 'portinstall'.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nstate of the package"
              },
              "use_packages": {
                "description": "Default: True\n\nuse packages instead of ports whenever available",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "name of package to install/remove"
              },
              "pkg": {
                "type": "string",
                "description": "name of package to install/remove"
              }
            }
          },
          "dellos6_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "OS6 configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with OS6 configuration sections in a deterministic way.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir.  This argument is mutually exclusive with I(lines)."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "This argument causes the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made.  As with I(before), the playbook desinger can use this to append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).",
                "$ref": "#/definitions/ansible_array"
              },
              "update": {
                "enum": [
                  "merge",
                  "check"
                ],
                "type": "string",
                "description": "Default: merge\n\nThe I(update) argument controls how the configuration statements are processed on the remote device.  Valid choices for the I(update) argument are I(merge) and I(check).  When you set this argument to I(merge), the configuration changes merge with the current device running configuration.  When you set this argument to I(check) the configuration updates are determined but not actually configured on the remote device."
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "replace": {
                "enum": [
                  "line",
                  "block"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If you set the replace argument to I(line), then the modified lines are pushed to the device in configuration mode.  If you set the replace argument to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct."
              },
              "save": {
                "description": "The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If you specify check mode, this argument is ignored.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If you do not specify the parents argument, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": "The playbook designer can use the C(config) argument to supply the base configuration to be used to validate necessary configuration changes.  If you specify this argument, the module does not download the running-config from the remote node."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If you set match to I(line), commands match line by line.  If you set match to I(strict), command lines matched by respect to position.  If you set match to I(exact), command lines must be an equal match.  Finally, if you set match to I(none), the module does  not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "seport": {
            "required": [
              "setype",
              "state",
              "ports",
              "proto"
            ],
            "type": "object",
            "description": "Manages SELinux network port type definitions.",
            "properties": {
              "reload": {
                "description": "Default: True\n\nReload SELinux policy after commit.",
                "$ref": "#/definitions/ansible_truth"
              },
              "setype": {
                "type": "string",
                "description": "SELinux type for the specified port."
              },
              "proto": {
                "enum": [
                  "tcp",
                  "udp"
                ],
                "type": "string",
                "description": "Protocol for the specified port."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired boolean value."
              },
              "ports": {
                "type": "string",
                "description": "Ports or port ranges, separated by a comma"
              }
            }
          },
          "ovirt_affinity_labels": {
            "required": [
              "name",
              "auth"
            ],
            "type": "object",
            "description": "This module manage affinity labels in oVirt. It can also manage assignments of those labels to hosts and VMs.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the the affinity label to manage."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the affinity label be present or absent."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "cluster": {
                "type": "string",
                "description": "Name of the cluster where vms and hosts resides."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "hosts": {
                "description": "List of the hosts names, which should have assigned this affinity label.",
                "$ref": "#/definitions/ansible_array"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "vms": {
                "description": "List of the VMs names, which should have assigned this affinity label.",
                "$ref": "#/definitions/ansible_array"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_vrf_interface": {
            "required": [
              "vrf",
              "interface"
            ],
            "type": "object",
            "description": "Manages interface specific VRF configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManages desired state of the resource."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "vrf": {
                "type": "string",
                "description": "Name of VRF to be managed."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Full name of interface to be managed, i.e. Ethernet1/1."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "os_security_group": {
            "type": "object",
            "description": "Add or Remove security groups from an OpenStack cloud.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nLong description of the purpose of the security group"
              },
              "name": {
                "type": "string",
                "description": "Name that has to be given to the security group. This module requires that security group names be unique."
              }
            }
          },
          "nxos_ospf": {
            "required": [
              "ospf"
            ],
            "type": "object",
            "description": "Manages configuration of an ospf instance.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "ospf": {
                "type": "string",
                "description": "Name of the ospf instance."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "panos_cert_gen_ssh": {
            "required": [
              "signed_by",
              "cert_friendly_name",
              "ip_address",
              "cert_cn"
            ],
            "type": "object",
            "description": "This module generates a self-signed certificate that can be used by GlobalProtect client, SSL connector, or\notherwise. Root certificate must be preset on the system first. This module depends on paramiko for ssh.",
            "properties": {
              "cert_friendly_name": {
                "type": "string",
                "description": "Human friendly certificate name (not CN but just a friendly name)."
              },
              "key_filename": {
                "type": "string",
                "description": "Location of the filename that is used for the auth. Either I(key_filename) or I(password) is required."
              },
              "rsa_nbits": {
                "type": "string",
                "description": "Default: 2048\n\nNumber of bits used by the RSA algorithm for the certificate generation."
              },
              "signed_by": {
                "type": "string",
                "description": "Undersigning authority (CA) that MUST already be presents on the device."
              },
              "password": {
                "type": "string",
                "description": "Password credentials to use for auth. Either I(key_filename) or I(password) is required."
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device being configured."
              },
              "cert_cn": {
                "type": "string",
                "description": "Certificate CN (common name) embeded in the certificate signature."
              }
            }
          },
          "iosxr_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Cisco IOS XR configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with IOS XR configuration sections in a deterministic way.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Default: configured by iosxr_config\n\nAllows a commit description to be specified to be included when the configuration is committed.  If the configuration is not changed or committed, this argument is ignored."
              },
              "src": {
                "type": "string",
                "description": "Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines)."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.\nNote this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release.",
                "$ref": "#/definitions/ansible_truth"
              },
              "backup": {
                "description": "This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "replace": {
                "enum": [
                  "line",
                  "block",
                  "config"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": "The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "nxos_snmp_traps": {
            "required": [
              "group"
            ],
            "type": "object",
            "description": "Manages SNMP traps configurations.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "group": {
                "enum": [
                  "aaa",
                  "bridge",
                  "callhome",
                  "cfs",
                  "config",
                  "entity",
                  "feature-control",
                  "hsrp",
                  "license",
                  "link",
                  "lldp",
                  "ospf",
                  "pim",
                  "rf",
                  "rmon",
                  "snmp",
                  "storm-control",
                  "stpx",
                  "sysmgr",
                  "system",
                  "upgrade",
                  "vtp",
                  "all"
                ],
                "type": "string",
                "description": "Case sensitive group."
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enabled\n\nManage the state of the resource."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "sensu_check": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Manage the checks that should be run on a machine by I(Sensu).\nMost options do not have a default and will not be added to the check definition unless specified.\nAll defaults except I(path), I(state), I(backup) and I(metric) are not managed by this module,\nthey are simply specified for your convenience.",
            "properties": {
              "metric": {
                "description": "Whether the check is a metric",
                "$ref": "#/definitions/ansible_truth"
              },
              "subdue_begin": {
                "type": "string",
                "description": "When to disable handling of check failures"
              },
              "occurrences": {
                "description": "Default: 1\n\nNumber of event occurrences before the handler should take action",
                "$ref": "#/definitions/ansible_number"
              },
              "low_flap_threshold": {
                "description": "The low threshhold for flap detection",
                "$ref": "#/definitions/ansible_number"
              },
              "handlers": {
                "description": "List of handlers to notify when the check fails",
                "$ref": "#/definitions/ansible_array"
              },
              "publish": {
                "description": "Default: True\n\nWhether the check should be scheduled at all.\nYou can still issue it via the sensu api",
                "$ref": "#/definitions/ansible_truth"
              },
              "custom": {
                "type": "object",
                "description": "A hash/dictionary of custom parameters for mixing to the configuration.\nYou can't rewrite others module parameters using this"
              },
              "source": {
                "type": "string",
                "description": "The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the check should be present or not"
              },
              "subdue_end": {
                "type": "string",
                "description": "When to enable handling of check failures"
              },
              "handle": {
                "description": "Default: True\n\nWhether the check should be handled or not",
                "$ref": "#/definitions/ansible_truth"
              },
              "dependencies": {
                "description": "Other checks this check depends on, if dependencies fail,\nhandling of this check will be disabled",
                "$ref": "#/definitions/ansible_array"
              },
              "subscribers": {
                "description": "List of subscribers/channels this check should run for\nSee sensu_subscribers to subscribe a machine to a channel",
                "$ref": "#/definitions/ansible_array"
              },
              "aggregate": {
                "description": "Classifies the check as an aggregate check,\nmaking it available via the aggregate API",
                "$ref": "#/definitions/ansible_truth"
              },
              "path": {
                "type": "string",
                "description": "Default: /etc/sensu/conf.d/checks.json\n\nPath to the json file of the check to be added/removed.\nWill be created if it does not exist (unless I(state=absent)).\nThe parent folders need to exist when I(state=present), otherwise an error will be thrown"
              },
              "name": {
                "type": "string",
                "description": "The name of the check\nThis is the key that is used to determine whether a check exists"
              },
              "standalone": {
                "description": "Whether the check should be scheduled by the sensu client or server\nThis option obviates the need for specifying the I(subscribers) option",
                "$ref": "#/definitions/ansible_truth"
              },
              "interval": {
                "description": "Check interval in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "refresh": {
                "description": "Number of seconds handlers should wait before taking second action",
                "$ref": "#/definitions/ansible_number"
              },
              "command": {
                "type": "string",
                "description": "Path to the sensu check to run (not required when I(state=absent))"
              },
              "high_flap_threshold": {
                "description": "The high threshhold for flap detection",
                "$ref": "#/definitions/ansible_number"
              },
              "timeout": {
                "description": "Default: 10\n\nTimeout for the check",
                "$ref": "#/definitions/ansible_number"
              },
              "backup": {
                "description": "Create a backup file (if yes), including the timestamp information so\nyou can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ipa_hostgroup": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cn",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "cn"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify and delete an IPA host-group using IPA API",
            "properties": {
              "ipa_port": {
                "description": "Default: 443\n\nPort of IPA server",
                "$ref": "#/definitions/ansible_number"
              },
              "description": {
                "type": "string",
                "description": "Description"
              },
              "ipa_prot": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nProtocol used by IPA server"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState to ensure."
              },
              "hostgroup": {
                "description": "List of host-groups than belong to that host-group.\nIf an empty list is passed all host-groups will be removed from the group.\nIf option is omitted host-groups will not be checked or changed.\nIf option is passed all assigned hostgroups that are not passed will be unassigned from the group.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Name of host-group.\nCan not be changed as it is the unique identifier."
              },
              "host": {
                "description": "List of hosts that belong to the host-group.\nIf an empty list is passed all hosts will be removed from the group.\nIf option is omitted hosts will not be checked or changed.\nIf option is passed all assigned hosts that are not passed will be unassigned from the group.",
                "$ref": "#/definitions/ansible_array"
              },
              "ipa_host": {
                "type": "string",
                "description": "Default: ipa.example.com\n\nIP or hostname of IPA server"
              },
              "ipa_user": {
                "type": "string",
                "description": "Default: admin\n\nAdministrative account used on IPA server"
              },
              "ipa_pass": {
                "type": "string",
                "description": "Password of administrative user"
              },
              "validate_certs": {
                "description": "Default: True\n\nThis only applies if C(ipa_prot) is I(https).\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cn": {
                "type": "string",
                "description": "Name of host-group.\nCan not be changed as it is the unique identifier."
              }
            }
          },
          "eos_facts": {
            "type": "object",
            "description": "Collects a base set of device facts from a remote device that is running eos.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "eapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "typetalk": {
            "required": [
              "msg",
              "topic",
              "client_id",
              "client_secret"
            ],
            "type": "object",
            "description": "Send a message to typetalk using typetalk API ( http://developers.typetalk.in/ )",
            "properties": {
              "msg": {
                "type": "string",
                "description": "message body"
              },
              "topic": {
                "description": "topic id to post message",
                "$ref": "#/definitions/ansible_number"
              },
              "client_id": {
                "type": "string",
                "description": "OAuth2 client ID"
              },
              "client_secret": {
                "type": "string",
                "description": "OAuth2 client secret"
              }
            }
          },
          "os_user_role": {
            "type": "object",
            "description": "Grant and revoke roles in either project or domain context for OpenStack Identity Users.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "ID of the domain to scope the role association to. Valid only with keystone version 3, and required if I(project) is not specified."
              },
              "group": {
                "type": "string",
                "description": "Name or ID for the group. Valid only with keystone version 3. If I(group) is not specified, then I(user) is required. Both may not be specified."
              },
              "project": {
                "type": "string",
                "description": "Name or ID of the project to scope the role assocation to. If you are using keystone version 2, then this value is required."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the roles be present or absent on the user."
              },
              "role": {
                "type": "string",
                "description": "Name or ID for the role."
              },
              "user": {
                "type": "string",
                "description": "Name or ID for the user. If I(user) is not specified, then I(group) is required. Both may not be specified."
              }
            }
          },
          "bigip_irule": {
            "type": "object",
            "description": "Manage iRules across different modules on a BIG-IP.",
            "properties": {
              "src": {
                "type": "string",
                "description": "The iRule file to interpret and upload to the BIG-IP. Either one of C(src) or C(content) must be provided."
              },
              "name": {
                "type": "string",
                "description": "The name of the iRule."
              },
              "partition": {
                "type": "string",
                "description": "Default: Common\n\nThe partition to create the iRule on."
              },
              "module": {
                "type": "string",
                "description": "The BIG-IP module to add the iRule to."
              },
              "content": {
                "type": "string",
                "description": "When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of C(src) or C(content) must be provided."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhether the iRule should exist or not."
              }
            }
          },
          "selinux_permissive": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "domain",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "domain"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add and remove domain from the list of permissive domain.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "the domain that will be added or removed from the list of permissive domains"
              },
              "store": {
                "type": "string",
                "description": "name of the SELinux policy store to use"
              },
              "name": {
                "type": "string",
                "description": "the domain that will be added or removed from the list of permissive domains"
              },
              "no_reload": {
                "description": "automatically reload the policy after a change\ndefault is set to 'false' as that's what most people would want after changing one domain\nNote that this doesn't work on older version of the library (example EL 6), the module will silently ignore it in this case",
                "$ref": "#/definitions/ansible_truth"
              },
              "permissive": {
                "description": "indicate if the domain should or should not be set as permissive",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rhn_register": {
            "type": "object",
            "description": "Manage registration to the Red Hat Network.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Red Hat Network username"
              },
              "systemorgid": {
                "type": "string",
                "description": "Default: None\n\nsupply an organizational id for use with registration"
              },
              "enable_eus": {
                "description": "If true, extended update support will be requested.",
                "$ref": "#/definitions/ansible_truth"
              },
              "server_url": {
                "type": "string",
                "description": "Default: Current value of I(serverURL) from C(/etc/sysconfig/rhn/up2date) is the default\n\nSpecify an alternative Red Hat Network server URL"
              },
              "channels": {
                "description": "Optionally specify a list of comma-separated channels to subscribe to upon successful registration.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nwhether to register (C(present)), or unregister (C(absent)) a system"
              },
              "sslcacert": {
                "type": "string",
                "description": "Default: None\n\nsupply a custom ssl CA certificate file for use with registration"
              },
              "activationkey": {
                "type": "string",
                "description": "supply an activation key for use with registration"
              },
              "profilename": {
                "type": "string",
                "description": "supply an profilename for use with registration"
              },
              "password": {
                "type": "string",
                "description": "Red Hat Network password"
              }
            }
          },
          "quantum_floating_ip": {
            "required": [
              "instance_name",
              "login_password",
              "network_name"
            ],
            "type": "object",
            "description": "Add or Remove a floating IP to an instance",
            "properties": {
              "region_name": {
                "type": "string",
                "description": "Default: None\n\nName of the region"
              },
              "availability_zone": {
                "type": "string",
                "description": ""
              },
              "login_password": {
                "type": "string",
                "description": "Default: yes\n\nPassword of login user"
              },
              "instance_name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the instance to which the IP address should be assigned"
              },
              "login_tenant_name": {
                "type": "string",
                "description": "Default: yes\n\nThe tenant name of the login user"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "auth_url": {
                "type": "string",
                "description": "Default: http://127.0.0.1:35357/v2.0/\n\nThe keystone url for authentication"
              },
              "internal_network_name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the network of the port to associate with the floating ip. Necessary when VM multiple networks."
              },
              "login_username": {
                "type": "string",
                "description": "Default: admin\n\nlogin username to authenticate to keystone"
              },
              "network_name": {
                "type": "string",
                "description": "Default: None\n\nName of the network from which IP has to be assigned to VM. Please make sure the network is an external network"
              }
            }
          },
          "win_get_url": {
            "type": "object",
            "description": "Fetches a file from a URL and saves to locally",
            "properties": {
              "username": {
                "type": "string",
                "description": "Basic authentication username"
              },
              "force": {
                "type": "string",
                "description": "Default: True\n\nIf C(yes), will always download the file. If C(no), will only download the file if it does not exist or the remote file has been modified more recently than the local file. This works by sending an http HEAD request to retrieve last modified time of the requested resource, so for this to work, the remote web server must support HEAD requests."
              },
              "url": {
                "type": "string",
                "description": "The full URL of a file to download"
              },
              "skip_certificate_validation": {
                "type": "string",
                "description": "Skip SSL certificate validation if true"
              },
              "proxy_url": {
                "type": "string",
                "description": "The full URL of the proxy server to download through."
              },
              "proxy_password": {
                "type": "string",
                "description": "Proxy authentication password"
              },
              "dest": {
                "type": "string",
                "description": "The absolute path of the location to save the file at the URL. Be sure to include a filename and extension as appropriate."
              },
              "proxy_username": {
                "type": "string",
                "description": "Proxy authentication username"
              },
              "password": {
                "type": "string",
                "description": "Basic authentication password"
              }
            }
          },
          "foreman": {
            "required": [
              "username",
              "params",
              "password",
              "server_url",
              "entity"
            ],
            "type": "object",
            "description": "Allows the management of Foreman resources inside your Foreman server",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username on Foreman server"
              },
              "server_url": {
                "type": "string",
                "description": "URL of Foreman server"
              },
              "entity": {
                "type": "string",
                "description": "The Foreman resource that the action will be performed on (e.g. organization, host)"
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "params": {
                "type": "object",
                "description": "Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description)"
              },
              "password": {
                "type": "string",
                "description": "Password for user accessing Foreman server"
              }
            }
          },
          "proxysql_backend_servers": {
            "required": [
              "hostname"
            ],
            "type": "object",
            "description": "The M(proxysql_backend_servers) module adds or removes mysql hosts using the proxysql admin interface.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Text field that can be used for any purposed defined by the user. Could be a description of what the host stores, a reminder of when the host was added or disabled, or a JSON processed by some checker script."
              },
              "status": {
                "enum": [
                  "ONLINE",
                  "OFFLINE_SOFT",
                  "OFFLINE_HARD"
                ],
                "type": "string",
                "description": "ONLINE - Backend server is fully operational. OFFLINE_SOFT - When a server is put into C(OFFLINE_SOFT) mode, connections are kept in use until the current transaction is completed. This allows to gracefully detach a backend. OFFLINE_HARD - When a server is put into C(OFFLINE_HARD) mode, the existing connections are dropped, while new incoming connections aren't accepted either.\nIf omitted the proxysql database default for I(status) is C(ONLINE)."
              },
              "hostname": {
                "type": "string",
                "description": "The ip address at which the mysqld instance can be contacted."
              },
              "config_file": {
                "type": "string",
                "description": "Specify a config file from which login_user and login_password are to be read."
              },
              "compression": {
                "description": "If the value of I(compression) is greater than 0, new connections to that server will use compression. If omitted the proxysql database default for I(compression) is 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "weight": {
                "description": "The bigger the weight of a server relative to other weights, the higher the probability of the server being chosen from the hostgroup. If omitted the proxysql database default for I(weight) is 1.",
                "$ref": "#/definitions/ansible_number"
              },
              "login_port": {
                "description": "Default: 6032\n\nThe port used to connect to ProxySQL admin interface.",
                "$ref": "#/definitions/ansible_number"
              },
              "login_user": {
                "type": "string",
                "description": "Default: None\n\nThe username used to authenticate to ProxySQL admin interface."
              },
              "login_host": {
                "type": "string",
                "description": "Default: 127.0.0.1\n\nThe host used to connect to ProxySQL admin interface."
              },
              "login_password": {
                "type": "string",
                "description": "Default: None\n\nThe password used to authenticate to ProxySQL admin interface."
              },
              "hostgroup_id": {
                "description": "The hostgroup in which this mysqld instance is included. An instance can be part of one or more hostgroups.",
                "$ref": "#/definitions/ansible_number"
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhen C(present) - adds the host, when C(absent) - removes the host."
              },
              "load_to_runtime": {
                "description": "Default: True\n\nDynamically load mysql host config to runtime memory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "save_to_disk": {
                "description": "Default: True\n\nSave mysql host config to sqlite db on disk to persist the configuration.",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_ssl": {
                "description": "If I(use_ssl) is set to C(True), connections to this server will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).",
                "$ref": "#/definitions/ansible_truth"
              },
              "max_replication_lag": {
                "description": "If greater than 0, ProxySQL will reguarly monitor replication lag. If replication lag goes above I(max_replication_lag), proxysql will temporarily shun the server until replication catches up. If omitted the proxysql database default for I(max_replication_lag) is 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "port": {
                "description": "Default: 3306\n\nThe port at which the mysqld instance can be contacted.",
                "$ref": "#/definitions/ansible_number"
              },
              "max_latency_ms": {
                "description": "Ping time is monitored regularly. If a host has a ping time greater than I(max_latency_ms) it is excluded from the connection pool (although the server stays ONLINE). If omitted the proxysql database default for I(max_latency_ms) is 0.",
                "$ref": "#/definitions/ansible_number"
              },
              "max_connections": {
                "description": "The maximum number of connections ProxySQL will open to this backend server. If omitted the proxysql database default for I(max_connections) is 1000.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "win_share": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify or remove Windows share and set share permissions.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify whether to add C(present) or remove C(absent) the specified share"
              },
              "names": {
                "type": "string",
                "description": "Share name"
              },
              "name": {
                "type": "string",
                "description": "Share name"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ec2_key": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "maintains ec2 key pairs. This module has a dependency on python-boto >= 2.5",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "force": {
                "description": "Default: True\n\nForce overwrite of already existing key pair if key has changed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the key pair."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Wait for the specified action to complete before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "key_material": {
                "type": "string",
                "description": "Public key material."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\ncreate or delete keypair"
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 300\n\nHow long before wait gives up, in seconds"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "nxos_bgp": {
            "required": [
              "asn"
            ],
            "type": "object",
            "description": "Manages BGP configurations on NX-OS switches.",
            "properties": {
              "neighbor_down_fib_accelerate": {
                "description": "Enable/Disable handle BGP neighbor down event, due to various reasons.",
                "$ref": "#/definitions/ansible_truth"
              },
              "confederation_peers": {
                "type": "string",
                "description": "AS confederation parameters."
              },
              "confederation_id": {
                "type": "string",
                "description": "Routing domain confederation AS."
              },
              "event_history_cli": {
                "enum": [
                  "true",
                  "false",
                  "default",
                  "size_small",
                  "size_medium",
                  "size_large",
                  "size_disable"
                ],
                "type": "string",
                "description": "Enable/Disable cli event history buffer."
              },
              "event_history_periodic": {
                "enum": [
                  "true",
                  "false",
                  "default",
                  "size_small",
                  "size_medium",
                  "size_large",
                  "size_disable"
                ],
                "type": "string",
                "description": "Enable/Disable periodic event history buffer."
              },
              "cluster_id": {
                "type": "string",
                "description": "Route Reflector Cluster-ID."
              },
              "shutdown": {
                "description": "Administratively shutdown the BGP protocol.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timer_bgp_hold": {
                "type": "string",
                "description": "Set BGP hold timer."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "bestpath_aspath_multipath_relax": {
                "description": "Enable/Disable load sharing across the providers with different (but equal-length) AS paths.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "graceful_restart_timers_stalepath_time": {
                "type": "string",
                "description": "Set maximum time that BGP keeps the stale routes from the restarting BGP peer."
              },
              "maxas_limit": {
                "type": "string",
                "description": "Specify Maximum number of AS numbers allowed in the AS-path attribute. Valid values are between 1 and 512."
              },
              "graceful_restart_timers_restart": {
                "type": "string",
                "description": "Set maximum time for a restart sent to the BGP peer."
              },
              "isolate": {
                "description": "Enable/Disable isolate this router from BGP perspective.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timer_bgp_keepalive": {
                "type": "string",
                "description": "Set BGP keepalive timer."
              },
              "bestpath_cost_community_ignore": {
                "description": "Enable/Disable Ignores the cost community for BGP best-path calculations.",
                "$ref": "#/definitions/ansible_truth"
              },
              "fast_external_fallover": {
                "description": "Enable/Disable immediately reset the session if the link to a directly connected BGP peer goes down.  Only supported in the global BGP context.",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "disable_policy_batching": {
                "description": "Enable/Disable the batching evaluation of prefix advertisement to all peers.",
                "$ref": "#/definitions/ansible_truth"
              },
              "disable_policy_batching_ipv6_prefix_list": {
                "type": "string",
                "description": "Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list."
              },
              "suppress_fib_pending": {
                "description": "Enable/Disable advertise only routes programmed in hardware to peers.",
                "$ref": "#/definitions/ansible_truth"
              },
              "bestpath_med_missing_as_worst": {
                "description": "Enable/Disable assigns the value of infinity to received routes that do not carry the MED attribute, making these routes the least desirable.",
                "$ref": "#/definitions/ansible_truth"
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "router_id": {
                "type": "string",
                "description": "Router Identifier (ID) of the BGP router VRF instance."
              },
              "timer_bestpath_limit": {
                "type": "string",
                "description": "Specify timeout for the first best path after a restart, in seconds."
              },
              "bestpath_compare_neighborid": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "local_as": {
                "type": "string",
                "description": "Local AS number to be used within a VRF instance."
              },
              "bestpath_always_compare_med": {
                "description": "Enable/Disable MED comparison on paths from different autonomous systems.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "disable_policy_batching_ipv4_prefix_list": {
                "type": "string",
                "description": "Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list."
              },
              "vrf": {
                "type": "string",
                "description": "Name of the VRF. The name 'default' is a valid VRF representing the global BGP."
              },
              "graceful_restart_helper": {
                "description": "Enable/Disable graceful restart helper mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "log_neighbor_changes": {
                "description": "Enable/Disable message logging for neighbor up/down event.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "asn": {
                "type": "string",
                "description": "BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation."
              },
              "event_history_events": {
                "enum": [
                  "true",
                  "false",
                  "defaultsize_small",
                  "size_medium",
                  "size_large",
                  "size_disable"
                ],
                "type": "string",
                "description": "Enable/Disable event history buffer."
              },
              "event_history_detail": {
                "enum": [
                  "true",
                  "false",
                  "default",
                  "size_small",
                  "size_medium",
                  "size_large",
                  "size_disable"
                ],
                "type": "string",
                "description": "Enable/Disable detail event history buffer."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "graceful_restart": {
                "description": "Enable/Disable graceful restart.",
                "$ref": "#/definitions/ansible_truth"
              },
              "flush_routes": {
                "description": "Enable/Disable flush routes in RIB upon controlled restart. On NX-OS, this property is only supported in the global BGP context.",
                "$ref": "#/definitions/ansible_truth"
              },
              "enforce_first_as": {
                "description": "Enable/Disable enforces the neighbor autonomous system to be the first AS number listed in the AS path attribute for eBGP. On NX-OS, this property is only supported in the global BGP context.",
                "$ref": "#/definitions/ansible_truth"
              },
              "bestpath_med_non_deterministic": {
                "description": "Enable/Disable deterministic selection of the best MED pat from among the paths from the same autonomous system.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "reconnect_interval": {
                "type": "string",
                "description": "The BGP reconnection interval for dropped sessions. Valid values are between 1 and 60."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "bestpath_med_confed": {
                "description": "Enable/Disable enforcement of bestpath to do a MED comparison only between paths originated within a confederation.",
                "$ref": "#/definitions/ansible_truth"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "bestpath_compare_routerid": {
                "description": "Enable/Disable comparison of router IDs for identical eBGP paths.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ipify_facts": {
            "type": "object",
            "description": "If behind NAT and need to know the public IP of your internet gateway.",
            "properties": {
              "api_url": {
                "type": "string",
                "description": "Default: https://api.ipify.org\n\nURL of the ipify.org API service.\nC(?format=json) will be appended per default."
              }
            }
          },
          "cs_network": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, update, restart and delete networks.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain the network is related to."
              },
              "end_ipv6": {
                "type": "string",
                "description": "The ending IPv6 address of the network belongs to.\nIf not specified, value of C(start_ipv6) is used.\nOnly considered on create."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "gateway": {
                "type": "string",
                "description": "The gateway of the network.\nRequired for shared networks and isolated networks when it belongs to a VPC.\nOnly considered on create."
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the network should be deployed.\nIf not set, default zone is used."
              },
              "start_ipv6": {
                "type": "string",
                "description": "The beginning IPv6 address of the network belongs to.\nOnly considered on create."
              },
              "cidr_ipv6": {
                "type": "string",
                "description": "CIDR of IPv6 network, must be at least /64.\nOnly considered on create."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "restarted"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the network."
              },
              "end_ip": {
                "type": "string",
                "description": "The ending IPv4 address of the network belongs to.\nIf not specified, value of C(start_ip) is used.\nOnly considered on create."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "vlan": {
                "type": "string",
                "description": "The ID or VID of the network."
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "clean_up": {
                "description": "Cleanup old network elements.\nOnly considered on C(state=restarted).",
                "$ref": "#/definitions/ansible_truth"
              },
              "netmask": {
                "type": "string",
                "description": "The netmask of the network.\nRequired for shared networks and isolated networks when it belongs to a VPC.\nOnly considered on create."
              },
              "network_offering": {
                "type": "string",
                "description": "Name of the offering for the network.\nRequired if C(state=present)."
              },
              "vpc": {
                "type": "string",
                "description": "Name of the VPC of the network."
              },
              "start_ip": {
                "type": "string",
                "description": "The beginning IPv4 address of the network belongs to.\nOnly considered on create."
              },
              "gateway_ipv6": {
                "type": "string",
                "description": "The gateway of the IPv6 network.\nRequired for shared networks.\nOnly considered on create."
              },
              "display_text": {
                "type": "string",
                "description": "Display text of the network.\nIf not specified, C(name) will be used as C(display_text)."
              },
              "isolated_pvlan": {
                "type": "string",
                "description": "The isolated private VLAN for this network."
              },
              "account": {
                "type": "string",
                "description": "Account the network is related to."
              },
              "acl_type": {
                "enum": [
                  "account",
                  "domain"
                ],
                "type": "string",
                "description": "Default: account\n\nAccess control type.\nOnly considered on create."
              },
              "name": {
                "type": "string",
                "description": "Name (case sensitive) of the network."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the network to be deployed in."
              },
              "network_domain": {
                "type": "string",
                "description": "The network domain."
              }
            }
          },
          "accelerate": {
            "required": [
              "password"
            ],
            "type": "object",
            "description": "This modules launches an ephemeral I(accelerate) daemon on the remote node which Ansible can use to communicate with nodes at high speed.\nThe daemon listens on a configurable port for a configurable amount of time.\nFireball mode is AES encrypted",
            "properties": {
              "timeout": {
                "type": "string",
                "description": "Default: 300\n\nThe number of seconds the socket will wait for data. If none is received when the timeout value is reached, the connection will be closed."
              },
              "ipv6": {
                "description": "The listener daemon on the remote host will bind to the ipv6 localhost socket if this parameter is set to true.",
                "$ref": "#/definitions/ansible_truth"
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "minutes": {
                "type": "string",
                "description": "Default: 30\n\nThe I(accelerate) listener daemon is started on nodes and will stay around for this number of minutes before turning itself off."
              },
              "port": {
                "type": "string",
                "description": "Default: 5099\n\nTCP port for the socket connection"
              },
              "multi_key": {
                "description": "When enabled, the daemon will open a local socket file which can be used by future daemon executions to upload a new key to the already running daemon, so that multiple users can connect using different keys. This access still requires an ssh connection as the uid for which the daemon is currently running.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "aos_logical_device": {
            "required": [
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS Logical Device module let you manage your Logical Devices easily. You can create create and delete Logical Device by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "content": {
                "type": "string",
                "description": "Datastructure of the Logical Device to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the Logical Device (present or not)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "id": {
                "type": "string",
                "description": "AOS Id of the Logical Device to manage (can't be used to create a new Logical Device), Only one of I(name), I(id) or I(content) can be set."
              },
              "name": {
                "type": "string",
                "description": "Name of the Logical Device to manage. Only one of I(name), I(id) or I(content) can be set."
              }
            }
          },
          "proxysql_manage_config": {
            "required": [
              "direction",
              "config_settings",
              "config_layer",
              "action"
            ],
            "type": "object",
            "description": "The M(proxysql_global_variables) module writes the proxysql configuration settings between layers. Currently this module will always report a changed state, so should typically be used with WHEN however this will change in a future version when the CHECKSUM table commands are available for all tables in proxysql.",
            "properties": {
              "login_port": {
                "description": "Default: 6032\n\nThe port used to connect to ProxySQL admin interface.",
                "$ref": "#/definitions/ansible_number"
              },
              "direction": {
                "enum": [
                  "FROM",
                  "TO"
                ],
                "type": "string",
                "description": "FROM - denotes we're reading values FROM the supplied I(config_layer) and writing to the next layer. TO - denotes we're reading from the previous layer and writing TO the supplied I(config_layer).\""
              },
              "config_file": {
                "type": "string",
                "description": "Specify a config file from which login_user and login_password are to be read."
              },
              "config_settings": {
                "type": "string",
                "description": "The I(config_settings) specifies which configuration we're writing.\n\nPossible choices:\nMYSQL USERS\nMYSQL SERVERS\nMYSQL QUERY RULES\nMYSQL VARIABLES\nADMIN VARIABLES\nSCHEDULER"
              },
              "login_user": {
                "type": "string",
                "description": "Default: None\n\nThe username used to authenticate to ProxySQL admin interface."
              },
              "login_host": {
                "type": "string",
                "description": "Default: 127.0.0.1\n\nThe host used to connect to ProxySQL admin interface."
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "login_password": {
                "type": "string",
                "description": "Default: None\n\nThe password used to authenticate to ProxySQL admin interface."
              },
              "config_layer": {
                "enum": [
                  "MEMORY",
                  "DISK",
                  "RUNTIME",
                  "CONFIG"
                ],
                "type": "string",
                "description": "RUNTIME - represents the in-memory data structures of ProxySQL used by the threads that are handling the requests. MEMORY - (sometimes also referred as main) represents the in-memory SQLite3 database. DISK - represents the on-disk SQLite3 database. CONFIG - is the classical config file. You can only LOAD FROM the config file."
              },
              "action": {
                "enum": [
                  "LOAD",
                  "SAVE"
                ],
                "type": "string",
                "description": "The supplied I(action) combines with the supplied I(direction) to provide the semantics of how we want to move the I(config_settings) between the I(config_layers)."
              }
            }
          },
          "cpanm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "system_lib",
                        "use_sudo"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage Perl library dependencies.",
            "properties": {
              "executable": {
                "type": "string",
                "description": "Override the path to the cpanm executable"
              },
              "name": {
                "type": "string",
                "description": "The name of the Perl library to install. You may use the \"full distribution path\", e.g.  MIYAGAWA/Plack-0.99_05.tar.gz"
              },
              "installdeps": {
                "description": "Only install dependencies",
                "$ref": "#/definitions/ansible_truth"
              },
              "system_lib": {
                "description": "Use this if you want to install modules to the system perl include path. You must be root or have \"passwordless\" sudo for this to work.\nThis uses the cpanm commandline option '--sudo', which has nothing to do with ansible privilege escalation.",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_sudo": {
                "description": "Use this if you want to install modules to the system perl include path. You must be root or have \"passwordless\" sudo for this to work.\nThis uses the cpanm commandline option '--sudo', which has nothing to do with ansible privilege escalation.",
                "$ref": "#/definitions/ansible_truth"
              },
              "mirror_only": {
                "description": "Use the mirror's index file instead of the CPAN Meta DB",
                "$ref": "#/definitions/ansible_truth"
              },
              "from_path": {
                "type": "string",
                "description": "The local directory from where to install"
              },
              "pkg": {
                "type": "string",
                "description": "The name of the Perl library to install. You may use the \"full distribution path\", e.g.  MIYAGAWA/Plack-0.99_05.tar.gz"
              },
              "version": {
                "type": "string",
                "description": "minimum version of perl module to consider acceptable"
              },
              "mirror": {
                "type": "string",
                "description": "Specifies the base URL for the CPAN mirror to use"
              },
              "locallib": {
                "type": "string",
                "description": "Specify the install base to install modules"
              },
              "notest": {
                "description": "Do not run unit tests",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "os_router": {
            "type": "object",
            "description": "Create or Delete routers from OpenStack. Although Neutron allows routers to share the same name, this module enforces name uniqueness to be more user friendly.",
            "properties": {
              "enable_snat": {
                "type": "string",
                "description": "Default: True\n\nEnable Source NAT (SNAT) attribute."
              },
              "network": {
                "type": "string",
                "description": "Default: None\n\nUnique name or ID of the external gateway network.\nrequired I(interfaces) or I(enable_snat) are provided."
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "interfaces": {
                "type": "string",
                "description": "Default: None\n\nList of subnets to attach to the router internal interface."
              },
              "admin_state_up": {
                "type": "string",
                "description": "Default: True\n\nDesired admin state of the created or existing router."
              },
              "project": {
                "type": "string",
                "description": "Default: None\n\nUnique name or ID of the project."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "external_fixed_ips": {
                "type": "string",
                "description": "Default: None\n\nThe IP address parameters for the external gateway network. Each is a dictionary with the subnet name or ID (subnet) and the IP address to assign on the subnet (ip). If no IP is specified, one is automatically assigned from that subnet."
              },
              "name": {
                "type": "string",
                "description": "Name to be give to the router"
              }
            }
          },
          "openvswitch_bridge": {
            "required": [
              "bridge"
            ],
            "type": "object",
            "description": "Manage Open vSwitch bridges",
            "properties": {
              "bridge": {
                "type": "string",
                "description": "Name of bridge to manage"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the bridge should exist"
              },
              "fail_mode": {
                "type": "string",
                "description": "Default: None\n\nSet bridge fail-mode. The default value (None) is a No-op."
              },
              "external_ids": {
                "type": "object",
                "description": "Default: None\n\nA dictionary of external-ids. Omitting this parameter is a No-op. To  clear all external-ids pass an empty value."
              },
              "timeout": {
                "description": "Default: 5\n\nHow long to wait for ovs-vswitchd to respond",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "digital_ocean_domain": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "id",
                        "droplet_id"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_token",
                        "API_TOKEN"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create/delete a DNS record in DigitalOcean.",
            "properties": {
              "droplet_id": {
                "description": "Numeric, the droplet id you want to operate on.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key, or the name of a domain."
              },
              "ip": {
                "type": "string",
                "description": "The IP address to point a domain at."
              },
              "API_TOKEN": {
                "type": "string",
                "description": "DigitalOcean api token."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the target."
              },
              "api_token": {
                "type": "string",
                "description": "DigitalOcean api token."
              },
              "id": {
                "description": "Numeric, the droplet id you want to operate on.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "flowadm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "flow"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "flow"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create/modify/remove networking bandwidth and associated resources for a type of traffic on a particular link.",
            "properties": {
              "dsfield": {
                "type": "string",
                "description": "- Identifies the 8-bit differentiated services field (as defined in RFC 2474). The optional dsfield_mask is used to state the bits of interest in the differentiated services field when comparing with the dsfield value. Both values must be in hexadecimal.\n"
              },
              "temporary": {
                "description": "Specifies that the configured flow is temporary. Temporary flows do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "- A flow is defined as a set of attributes based on Layer 3 and Layer 4 headers, which can be used to identify a protocol, service, or a zone.\n"
              },
              "maxbw": {
                "type": "string",
                "description": "- Sets the full duplex bandwidth for the flow. The bandwidth is specified as an integer with one of the scale suffixes(K, M, or G for Kbps, Mbps, and Gbps). If no units are specified, the input value will be read as Mbps.\n"
              },
              "local_port": {
                "type": "string",
                "description": "Identifies a service specified by the local port."
              },
              "local_ip": {
                "type": "string",
                "description": "Identifies a network flow by the local IP address."
              },
              "flow": {
                "type": "string",
                "description": "- A flow is defined as a set of attributes based on Layer 3 and Layer 4 headers, which can be used to identify a protocol, service, or a zone.\n"
              },
              "priority": {
                "enum": [
                  "low",
                  "medium",
                  "high"
                ],
                "type": "string",
                "description": "Default: medium\n\nSets the relative priority for the flow."
              },
              "state": {
                "enum": [
                  "absent",
                  "present",
                  "resetted"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate/delete/enable/disable an IP address on the network interface."
              },
              "link": {
                "type": "string",
                "description": "Specifiies a link to configure flow on."
              },
              "transport": {
                "enum": [
                  "tcp",
                  "udp",
                  "sctp",
                  "icmp",
                  "icmpv6"
                ],
                "type": "string",
                "description": "- Specifies a Layer 4 protocol to be used. It is typically used in combination with I(local_port) to identify the service that needs special attention.\n"
              },
              "remote_ip": {
                "type": "string",
                "description": ""
              }
            }
          },
          "asa_config": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lines",
                        "commands"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Cisco ASA configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with ASA configuration sections in a deterministic way.",
            "properties": {
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "replace": {
                "enum": [
                  "line",
                  "block"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "type": "string",
                "description": ""
              },
              "before": {
                "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "parents": {
                "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
                "$ref": "#/definitions/ansible_array"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node."
              },
              "match": {
                "enum": [
                  "line",
                  "strict",
                  "exact",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nInstructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "passwords": {
                "description": "This argument specifies to include passwords in the config when retrieving the running-config from the remote device.  This includes passwords related to VPN endpoints.  This argument is mutually exclusive with I(defaults).",
                "$ref": "#/definitions/ansible_truth"
              },
              "defaults": {
                "description": "This argument specifies whether or not to collect all defaults when getting the remote device running config.  When enabled, the module will get the current config by issuing the command C(show running-config all).",
                "$ref": "#/definitions/ansible_truth"
              },
              "after": {
                "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "src": {
                "type": "string",
                "description": "Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines)."
              },
              "commands": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "lines": {
                "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "backup": {
                "description": "This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "redis": {
            "type": "object",
            "description": "Unified utility to interact with redis instances. 'slave' sets a redis instance in slave or master mode. 'flush' flushes all the instance or a specified db. 'config' (new in 1.6), ensures a configuration setting on an instance.",
            "properties": {
              "login_port": {
                "description": "Default: 6379\n\nThe port to connect to",
                "$ref": "#/definitions/ansible_number"
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with (usually not used)"
              },
              "name": {
                "type": "string",
                "description": "A redis config key."
              },
              "flush_mode": {
                "enum": [
                  "all",
                  "db"
                ],
                "type": "string",
                "description": "Default: all\n\nType of flush (all the dbs in a redis instance or a specific one) [flush command]"
              },
              "master_host": {
                "type": "string",
                "description": "The host of the master instance [slave command]"
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nThe host running the database"
              },
              "master_port": {
                "description": "The port of the master instance [slave command]",
                "$ref": "#/definitions/ansible_number"
              },
              "db": {
                "description": "The database to flush (used in db mode) [flush command]",
                "$ref": "#/definitions/ansible_number"
              },
              "value": {
                "type": "string",
                "description": "A redis config value."
              },
              "command": {
                "enum": [
                  "slave",
                  "flush",
                  "config"
                ],
                "type": "string",
                "description": "The selected redis command"
              },
              "slave_mode": {
                "enum": [
                  "master",
                  "slave"
                ],
                "type": "string",
                "description": "Default: slave\n\nthe mode of the redis instance [slave command]"
              }
            }
          },
          "cnos_conditional_command": {
            "type": "object",
            "description": "This module allows you to modify the running configuration of a switch. It provides a way to execute a single CNOS command on a network device by evaluating the current running configuration and executing the command only if the specific settings have not been already configured. The CNOS command is passed as an argument of the method. This module functions the same as the cnos_command module. The only exception is that the following inventory variable can be specified [“condition = <flag string>”] When this inventory variable is specified as the variable of a task, the command is executed for the network element that matches the flag string. Usually, commands are executed across a group of network devices. When there is a requirement to skip the execution of the command on one or more devices, it is recommended to use this module. This module uses SSH to manage network device configuration. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_conditional_command.html)",
            "properties": {
              "flag": {
                "type": "string",
                "description": "If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device."
              },
              "clicommand": {
                "type": "string",
                "description": "This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory."
              },
              "condition": {
                "type": "string",
                "description": "If you specify condition=false in the inventory file against any device, the command execution is skipped for that device."
              }
            }
          },
          "panos_mgtconfig": {
            "required": [
              "password",
              "ip_address"
            ],
            "type": "object",
            "description": "Configure management settings of device",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "dns_server_secondary": {
                "type": "string",
                "description": "Default: None\n\naddress of secondary DNS server"
              },
              "panorama_primary": {
                "type": "string",
                "description": "Default: None\n\naddress of primary Panorama server"
              },
              "dns_server_primary": {
                "type": "string",
                "description": "Default: None\n\naddress of primary DNS server"
              },
              "panorama_secondary": {
                "type": "string",
                "description": "Default: None\n\naddress of secondary Panorama server"
              },
              "commit": {
                "description": "Default: True\n\ncommit if changed",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              }
            }
          },
          "campfire": {
            "required": [
              "msg",
              "token",
              "room",
              "subscription"
            ],
            "type": "object",
            "description": "Send a message to Campfire.\nMessages with newlines will result in a \"Paste\" message being sent.",
            "properties": {
              "msg": {
                "type": "string",
                "description": "The message body."
              },
              "token": {
                "type": "string",
                "description": "API token."
              },
              "subscription": {
                "type": "string",
                "description": "The subscription name to use."
              },
              "room": {
                "type": "string",
                "description": "Room number to which the message should be sent."
              },
              "notify": {
                "enum": [
                  "56k",
                  "bell",
                  "bezos",
                  "bueller",
                  "clowntown",
                  "cottoneyejoe",
                  "crickets",
                  "dadgummit",
                  "dangerzone",
                  "danielsan",
                  "deeper",
                  "drama",
                  "greatjob",
                  "greyjoy",
                  "guarantee",
                  "heygirl",
                  "horn",
                  "horror",
                  "inconceivable",
                  "live",
                  "loggins",
                  "makeitso",
                  "noooo",
                  "nyan",
                  "ohmy",
                  "ohyeah",
                  "pushit",
                  "rimshot",
                  "rollout",
                  "rumble",
                  "sax",
                  "secret",
                  "sexyback",
                  "story",
                  "tada",
                  "tmyk",
                  "trololo",
                  "trombone",
                  "unix",
                  "vuvuzela",
                  "what",
                  "whoomp",
                  "yeah",
                  "yodel"
                ],
                "type": "string",
                "description": "Send a notification sound before the message."
              }
            }
          },
          "tower_job_list": {
            "type": "object",
            "description": "List Ansible Tower jobs. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "status": {
                "type": "string",
                "description": "Only list jobs with this status."
              },
              "query": {
                "type": "string",
                "description": "Query used to further filter the list of jobs. {\"foo\":\"bar\"} will be passed at ?foo=bar"
              },
              "page": {
                "type": "string",
                "description": "Page number of the results to fetch."
              },
              "all_pages": {
                "type": "string",
                "description": "Fetch all the pages and return a single result."
              }
            }
          },
          "nxos_ntp_auth": {
            "required": [
              "md5string",
              "key_id"
            ],
            "type": "object",
            "description": "Manages NTP authentication.",
            "properties": {
              "auth_type": {
                "enum": [
                  "text",
                  "encrypt"
                ],
                "type": "string",
                "description": "Default: text\n\nWhether the given md5string is in cleartext or has been encrypted. If in cleartext, the device will encrypt it before storing it."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "key_id": {
                "type": "string",
                "description": "Authentication key identifier (numeric)."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "md5string": {
                "type": "string",
                "description": "MD5 String."
              },
              "authentication": {
                "enum": [
                  "on",
                  "off"
                ],
                "type": "string",
                "description": "Turns NTP authentication on or off."
              },
              "trusted_key": {
                "enum": [
                  "true",
                  "false"
                ],
                "type": "string",
                "description": "Whether the given key is required to be supplied by a time source for the device to synchronize to the time source."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "infini_fs": {
            "type": "object",
            "description": "This module creates, deletes or modifies filesystems on Infinibox.",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nCreates/Modifies file system when present or removes when absent."
              },
              "name": {
                "type": "string",
                "description": "File system name."
              },
              "pool": {
                "type": "string",
                "description": "Pool that will host file system."
              },
              "size": {
                "type": "string",
                "description": "File system size in MB, GB or TB units. See examples."
              }
            }
          },
          "slurp": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "src",
                        "path"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "src"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module works like M(fetch). It is used for fetching a base64- encoded blob containing the data in a remote file.",
            "properties": {
              "src": {
                "type": "string",
                "description": "The file on the remote system to fetch. This I(must) be a file, not a directory."
              },
              "path": {
                "type": "string",
                "description": "The file on the remote system to fetch. This I(must) be a file, not a directory."
              }
            }
          },
          "azure_rm_storageaccount": {
            "type": "object",
            "description": "Create, update or delete a storage account.",
            "properties": {
              "kind": {
                "type": "string",
                "description": "Default: Storage\n\nThe 'kind' of storage."
              },
              "account_type": {
                "type": "string",
                "description": "Type of storage account. Required when creating a storage account. NOTE: Standard_ZRS and Premium_LRS accounts cannot be changed to other account types, and other account types cannot be changed to Standard_ZRS or Premium_LRS."
              },
              "custom_domain": {
                "type": "string",
                "description": "User domain assigned to the storage account. Must be a dictionary with 'name' and 'use_sub_domain' keys where 'name' is the CNAME source. Only one custom domain is supported per storage account at this time. To clear the existing custom domain, use an empty string for the custom domain name property.\nCan be added to an existing storage account. Will be ignored during storage account creation."
              },
              "resource_group": {
                "type": "string",
                "description": "Name of the resource group to use."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nAssert the state of the storage account. Use 'present' to create or update a storage account and 'absent' to delete an account."
              },
              "location": {
                "type": "string",
                "description": "Default: resource_group location\n\nValid azure location. Defaults to location of the resource group."
              },
              "name": {
                "type": "string",
                "description": "Name of the storage account to update or create."
              }
            }
          },
          "lvol": {
            "required": [
              "vg",
              "lv"
            ],
            "type": "object",
            "description": "This module creates, removes or resizes logical volumes.",
            "properties": {
              "pvs": {
                "type": "string",
                "description": "Comma separated list of physical volumes e.g. /dev/sda,/dev/sdb"
              },
              "force": {
                "description": "Default: no\n\nShrink or remove operations of volumes requires this switch. Ensures that that filesystems get never corrupted/destroyed by mistake.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vg": {
                "type": "string",
                "description": "The volume group this logical volume is part of."
              },
              "lv": {
                "type": "string",
                "description": "The name of the logical volume."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nControl if the logical volume exists. If C(present) and the volume does not already exist then the C(size) option is required."
              },
              "snapshot": {
                "type": "string",
                "description": "The name of the snapshot volume"
              },
              "active": {
                "description": "Default: yes\n\nWhether the volume is activate and visible to the host.",
                "$ref": "#/definitions/ansible_truth"
              },
              "shrink": {
                "description": "Default: True\n\nshrink if current size is higher than size requested",
                "$ref": "#/definitions/ansible_truth"
              },
              "opts": {
                "type": "string",
                "description": "Free-form options to be passed to the lvcreate command"
              },
              "size": {
                "type": "string",
                "description": "The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1."
              }
            }
          },
          "rabbitmq_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "user",
                        "username",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove users to RabbitMQ and assign permissions",
            "properties": {
              "node": {
                "type": "string",
                "description": "Default: rabbit\n\nerlang node name of the rabbit we wish to configure"
              },
              "username": {
                "type": "string",
                "description": "Name of user to add"
              },
              "force": {
                "description": "Default: no\n\nDeletes and recreates the user.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of user to add"
              },
              "write_priv": {
                "type": "string",
                "description": "Default: ^$\n\nRegular expression to restrict configure actions on a resource for the specified vhost.\nBy default all actions are restricted.\nThis option will be ignored when permissions option is used."
              },
              "tags": {
                "type": "string",
                "description": "User tags specified as comma delimited"
              },
              "read_priv": {
                "type": "string",
                "description": "Default: ^$\n\nRegular expression to restrict configure actions on a resource for the specified vhost.\nBy default all actions are restricted.\nThis option will be ignored when permissions option is used."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify if user is to be added or removed"
              },
              "user": {
                "type": "string",
                "description": "Name of user to add"
              },
              "configure_priv": {
                "type": "string",
                "description": "Default: ^$\n\nRegular expression to restrict configure actions on a resource for the specified vhost.\nBy default all actions are restricted.\nThis option will be ignored when permissions option is used."
              },
              "vhost": {
                "type": "string",
                "description": "Default: /\n\nvhost to apply access privileges.\nThis option will be ignored when permissions option is used."
              },
              "password": {
                "type": "string",
                "description": "Password of user to add.\nTo change the password of an existing user, you must also specify C(force=yes)."
              },
              "permissions": {
                "description": "a list of dicts, each dict contains vhost, configure_priv, write_priv, and read_priv, and represents a permission rule for that vhost.\nThis option should be preferable when you care about all permissions of the user.\nYou should use vhost, configure_priv, write_priv, and read_priv options instead if you care about permissions for just some vhosts.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "mssql_db": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "db"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "db"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove MSSQL databases from a remote host.",
            "properties": {
              "autocommit": {
                "description": "Automatically commit the change only if the import succeed. Sometimes it is necessary to use autocommit=true, since some content can't be changed within a transaction.",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_port": {
                "type": "string",
                "description": "Default: 1433\n\nPort of the MSSQL server. Requires login_host be defined as other then localhost if login_port is used"
              },
              "target": {
                "type": "string",
                "description": "Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) files are supported."
              },
              "login_user": {
                "type": "string",
                "description": "The username used to authenticate with"
              },
              "login_host": {
                "type": "string",
                "description": "Host running the database"
              },
              "db": {
                "type": "string",
                "description": "name of the database to add or remove"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "import"
                ],
                "type": "string",
                "description": "Default: present\n\nThe database state"
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with"
              },
              "name": {
                "type": "string",
                "description": "name of the database to add or remove"
              }
            }
          },
          "bigip_sys_db": {
            "type": "object",
            "description": "Manage BIG-IP system database variables",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nThe state of the variable on the system. When C(present), guarantees that an existing variable is set to C(value). When C(reset) sets the variable back to the default value. At least one of value and state C(reset) are required."
              },
              "value": {
                "type": "string",
                "description": "The value to set the key to. At least one of value and state C(reset) are required."
              },
              "key": {
                "type": "string",
                "description": "The database variable to manipulate."
              }
            }
          },
          "cl_interface": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Configures a front panel, sub-interface, SVI, management or loopback port on a Cumulus Linux switch. For bridge ports use the cl_bridge module. For bond ports use the cl_bond module. When configuring bridge related features like the \"vid\" option, please follow the guidelines for configuring \"vlan aware\" bridging. For more details review the Layer2 Interface Guide at U(http://docs.cumulusnetworks.com)",
            "properties": {
              "clagd_sys_mac": {
                "type": "string",
                "description": "Clagd system mac address. Recommended to use the range starting with 44:38:39:ff. Needs to be the same between 2 Clag switches."
              },
              "name": {
                "type": "string",
                "description": "Name of the interface."
              },
              "clagd_enable": {
                "description": "Enables the clagd daemon. This command should only be applied to the clag peerlink interface.",
                "$ref": "#/definitions/ansible_truth"
              },
              "mstpctl_portnetwork": {
                "description": "Enables bridge assurance in vlan-aware mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "mstpctl_bpduguard": {
                "description": "Enables BPDU Guard on a port in vlan-aware mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ipv6": {
                "description": "List of IPv6 addresses to configure on the interface. In the form I(X:X:X::X/YYY).",
                "$ref": "#/definitions/ansible_array"
              },
              "clagd_priority": {
                "type": "string",
                "description": "Integer that changes the role the switch has in the clag domain. The lower priority switch will assume the primary role. The number can be between 0 and 65535."
              },
              "mstpctl_portadminedge": {
                "description": "Enables admin edge port.",
                "$ref": "#/definitions/ansible_truth"
              },
              "mtu": {
                "type": "string",
                "description": "Set MTU. Configure Jumbo Frame by setting MTU to I(9000)."
              },
              "pvid": {
                "type": "string",
                "description": "In vlan-aware mode, defines vlan that is the untagged vlan."
              },
              "vids": {
                "description": "In vlan-aware mode, lists VLANs defined under the interface.",
                "$ref": "#/definitions/ansible_array"
              },
              "virtual_ip": {
                "type": "string",
                "description": "Define IPv4 virtual IP used by the Cumulus Linux VRR feature."
              },
              "clagd_peer_ip": {
                "type": "string",
                "description": "IP address of the directly connected peer switch interface."
              },
              "virtual_mac": {
                "type": "string",
                "description": "Define Ethernet mac associated with Cumulus Linux VRR feature."
              },
              "addr_method": {
                "enum": [
                  "",
                  "loopback",
                  "dhcp"
                ],
                "type": "string",
                "description": "Address method."
              },
              "clagd_args": {
                "type": "string",
                "description": ""
              },
              "alias_name": {
                "type": "string",
                "description": "Description of the port."
              },
              "ipv4": {
                "description": "List of IPv4 addresses to configure on the interface. In the form I(X.X.X.X/YY).",
                "$ref": "#/definitions/ansible_array"
              },
              "speed": {
                "type": "string",
                "description": "Set speed of the swp(front panel) or management(eth0) interface. speed is in MB."
              },
              "location": {
                "type": "string",
                "description": "Default: ['/etc/network/interfaces.d']\n\nInterface directory location"
              }
            }
          },
          "pn_trunk": {
            "required": [
              "pn_name",
              "state"
            ],
            "type": "object",
            "description": "Execute trunk-create or trunk-delete command.\nTrunks can be used to aggregate network links at Layer 2 on the local switch. Use this command to create a new trunk.",
            "properties": {
              "pn_name": {
                "type": "string",
                "description": "Specify the name for the trunk configuration."
              },
              "pn_lacp_fallback_timeout": {
                "type": "string",
                "description": "Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds."
              },
              "pn_lacp_timeout": {
                "type": "string",
                "description": "Specify the LACP time out as slow (30 seconds) or fast (4seconds). The default value is slow."
              },
              "pn_host": {
                "description": "Host facing port control setting.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_port_macaddr": {
                "type": "string",
                "description": "Specify the MAC address of the port."
              },
              "pn_lacp_fallback": {
                "enum": [
                  "bundle",
                  "individual"
                ],
                "type": "string",
                "description": "Specify the LACP fallback mode as bundles or individual."
              },
              "pn_routing": {
                "description": "Specify if the port participates in routing on the network.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_mirror_receive": {
                "description": "Specify if the configuration receives mirrored traffic.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_egress_rate_limit": {
                "type": "string",
                "description": "Specify an egress port data rate limit for the configuration."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "update"
                ],
                "type": "string",
                "description": "State the action to perform. Use 'present' to create trunk, 'absent' to delete trunk and 'update' to modify trunk."
              },
              "pn_broadcast_level": {
                "type": "string",
                "description": "Specify a broadcast level in percent. The default value is 100%."
              },
              "pn_cliswitch": {
                "type": "string",
                "description": "Target switch(es) to run the cli on."
              },
              "pn_unknown_mcast_level": {
                "type": "string",
                "description": "Specify an unknown multicast level in percent. The default value is 100%."
              },
              "pn_unknown_ucast_level": {
                "type": "string",
                "description": "Specify an unknown unicast level in percent. The default value is 100%."
              },
              "pn_loopback": {
                "description": "Specify loopback if you want to use loopback.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_speed": {
                "enum": [
                  "disable",
                  "10m",
                  "100m",
                  "1g",
                  "2.5g",
                  "10g",
                  "40g"
                ],
                "type": "string",
                "description": "Specify the port speed or disable the port."
              },
              "pn_edge_switch": {
                "description": "Specify if the switch is an edge switch.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_jumbo": {
                "description": "Specify if the port can receive jumbo frames.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_clipassword": {
                "type": "string",
                "description": "Provide login password if user is not root."
              },
              "pn_ports": {
                "type": "string",
                "description": "Specify the port number(s) for the link(s) to aggregate into the trunk.\nRequired for trunk-create."
              },
              "pn_cliusername": {
                "type": "string",
                "description": "Provide login username if user is not root."
              },
              "pn_lacp_mode": {
                "enum": [
                  "off",
                  "passive",
                  "active"
                ],
                "type": "string",
                "description": "Specify the LACP mode for the configuration."
              },
              "pn_loopvlans": {
                "type": "string",
                "description": "Specify a list of looping vlans."
              },
              "pn_lacp_priority": {
                "description": "Specify the LACP priority. This is a number between 1 and 65535 with a default value of 32768.",
                "$ref": "#/definitions/ansible_number"
              },
              "pn_pause": {
                "description": "Specify if pause frames are sent.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pn_description": {
                "type": "string",
                "description": "Specify a description for the trunk configuration."
              }
            }
          },
          "vertica_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "roles",
                        "role"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "user",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Adds or removes Vertica database user and, optionally, assigns roles.\nA user will not be removed until all the dependencies have been dropped.\nIn such a situation, if the module tries to remove the user it will fail and only remove roles granted to the user.",
            "properties": {
              "resource_pool": {
                "type": "string",
                "description": "Sets the user's resource pool."
              },
              "profile": {
                "type": "string",
                "description": "Sets the user's profile."
              },
              "name": {
                "type": "string",
                "description": "Name of the user to add or remove."
              },
              "roles": {
                "type": "string",
                "description": "Comma separated list of roles to assign to the user."
              },
              "login_user": {
                "type": "string",
                "description": "Default: dbadmin\n\nThe username used to authenticate with."
              },
              "ldap": {
                "description": "Set to true if users are authenticated via LDAP.\nThe user will be created with password expired and set to I($ldap$).",
                "$ref": "#/definitions/ansible_truth"
              },
              "db": {
                "type": "string",
                "description": "Name of the Vertica database."
              },
              "cluster": {
                "type": "string",
                "description": "Default: localhost\n\nName of the Vertica cluster."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "locked"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to create C(present), drop C(absent) or lock C(locked) a user."
              },
              "role": {
                "type": "string",
                "description": "Comma separated list of roles to assign to the user."
              },
              "user": {
                "type": "string",
                "description": "Name of the user to add or remove."
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with."
              },
              "password": {
                "type": "string",
                "description": "The user's password encrypted by the MD5 algorithm.\nThe password must be generated with the format C(\"md5\" + md5[password + username]), resulting in a total of 35 characters. An easy way to do this is by querying the Vertica database with select 'md5'||md5('<user_password><user_name>')."
              },
              "expired": {
                "description": "Sets the user's password expiration.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "type": "string",
                "description": "Default: 5433\n\nVertica cluster port to connect to."
              }
            }
          },
          "tower_credential": {
            "required": [
              "kind",
              "name",
              "organization"
            ],
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower credentials. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "authorize": {
                "description": "Should use authroize for net type.",
                "$ref": "#/definitions/ansible_truth"
              },
              "domain": {
                "type": "string",
                "description": "Domain for openstack type."
              },
              "vault_password": {
                "type": "string",
                "description": "Valut password. Use ASK for prompting."
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "become_username": {
                "type": "string",
                "description": "Become username. Use ASK for prompting."
              },
              "become_method": {
                "type": "string",
                "description": "Default: None\n\nBecome method to Use for privledge escalation."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "secret": {
                "type": "string",
                "description": "Secret token for azure_rm type."
              },
              "ssh_key_unlock": {
                "type": "string",
                "description": "Unlock password for ssh_key. Use ASK for prompting."
              },
              "authorize_password": {
                "type": "string",
                "description": "Password for net credentials that require authroize."
              },
              "username": {
                "type": "string",
                "description": "Username for this credential. access_key for AWS."
              },
              "description": {
                "type": "string",
                "description": "The description to use for the credential."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "host": {
                "type": "string",
                "description": "Host for this credential."
              },
              "user": {
                "type": "string",
                "description": "User that should own this credential."
              },
              "become_password": {
                "type": "string",
                "description": "Become password. Use ASK for prompting."
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "password": {
                "type": "string",
                "description": "Password for this credential. Use ASK for prompting. secret_key for AWS. api_key for RAX."
              },
              "tenant": {
                "type": "string",
                "description": "Tenant ID for azure_rm type."
              },
              "subscription": {
                "type": "string",
                "description": "Subscription ID for azure_rm type."
              },
              "kind": {
                "enum": [
                  "ssh",
                  "net",
                  "scm",
                  "aws",
                  "rax",
                  "vmware",
                  "satellite6",
                  "cloudforms",
                  "gce",
                  "azure",
                  "azure_rm",
                  "openstack"
                ],
                "type": "string",
                "description": "Type of credential being added."
              },
              "name": {
                "type": "string",
                "description": "The name to use for the credential."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "project": {
                "type": "string",
                "description": "Project that should for this credential."
              },
              "client": {
                "type": "string",
                "description": "Client or application ID for azure_rm type."
              },
              "ssh_key_data": {
                "type": "string",
                "description": "Path to SSH private key."
              },
              "team": {
                "type": "string",
                "description": "Team that should own this credential."
              },
              "organization": {
                "type": "string",
                "description": "Organization that should own the credential."
              }
            }
          },
          "assemble": {
            "required": [
              "src",
              "dest"
            ],
            "type": "object",
            "description": "Assembles a configuration file from fragments. Often a particular program will take a single configuration file and does not support a C(conf.d) style structure where it is easy to build up the configuration from multiple sources. C(assemble) will take a directory of files that can be local or have already been transferred to the system, and concatenate them together to produce a destination file. Files are assembled in string sorting order. Puppet calls this idea I(fragments).",
            "properties": {
              "ignore_hidden": {
                "description": "A boolean that controls if files that start with a '.' will be included or not.",
                "$ref": "#/definitions/ansible_truth"
              },
              "src": {
                "type": "string",
                "description": "An already existing directory full of source files."
              },
              "remote_src": {
                "description": "Default: True\n\nIf False, it will search for src at originating/master machine, if True it will go to the remote/target machine for the src. Default is True.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dest": {
                "type": "string",
                "description": "A file to create using the concatenation of all of the source files."
              },
              "delimiter": {
                "type": "string",
                "description": "A delimiter to separate the file contents."
              },
              "regexp": {
                "type": "string",
                "description": "Assemble files only if C(regex) matches the filename. If not set, all files are assembled. All \"\\\" (backslash) must be escaped as \"\\\\\" to comply yaml syntax. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html)."
              },
              "validate": {
                "type": "string",
                "description": "The validation command to run before copying into place.  The path to the file to validate is passed in via '%s' which must be present as in the sshd example below. The command is passed securely so shell features like expansion and pipes won't work."
              },
              "backup": {
                "description": "Default: no\n\nCreate a backup file (if C(yes)), including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ipadm_if": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, delete, enable or disable IP interfaces on Solaris/illumos systems.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nCreate or delete Solaris/illumos IP interfaces."
              },
              "temporary": {
                "description": "Specifies that the IP interface is temporary. Temporary IP interfaces do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "IP interface name."
              }
            }
          },
          "netapp_e_hostgroup": {
            "required": [
              "ssid",
              "api_url",
              "api_password",
              "state",
              "api_username"
            ],
            "type": "object",
            "description": "Create, update or destroy host groups on a NetApp E-Series storage array.",
            "properties": {
              "new_name": {
                "type": "string",
                "description": "specify this when you need to update the name of a host group"
              },
              "ssid": {
                "type": "string",
                "description": "The ID of the array to manage (as configured on the web services proxy)."
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "name": {
                "type": "string",
                "description": "The name of the host group to manage. Either this or C(id_num) must be supplied."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified host group should exist or not."
              },
              "hosts": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "validate_certs": {
                "type": "string",
                "description": "Default: True\n\nShould https certificates be validated?"
              },
              "id": {
                "type": "string",
                "description": "The id number of the host group to manage. Either this or C(name) must be supplied."
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              }
            }
          },
          "win_dns_client": {
            "type": "object",
            "description": "The C(win_dns_client) module configures the DNS client on Windows network adapters.",
            "properties": {
              "adapter_names": {
                "type": "string",
                "description": "Adapter name or list of adapter names for which to manage DNS settings ('*' is supported as a wildcard value). The adapter name used is the connection caption in the Network Control Panel or via C(Get-NetAdapter), eg C(Local Area Connection)."
              },
              "ipv4_addresses": {
                "type": "string",
                "description": "Single or ordered list of DNS server IPv4 addresses to configure for lookup. An empty list will configure the adapter to use the DHCP-assigned values on connections where DHCP is enabled, or disable DNS lookup on statically-configured connections."
              }
            }
          },
          "os_flavor_facts": {
            "type": "object",
            "description": "Retrieve facts about available OpenStack instance flavors. By default, facts about ALL flavors are retrieved. Filters can be applied to get facts for only matching flavors. For example, you can filter on the amount of RAM available to the flavor, or the number of virtual CPUs available to the flavor, or both. When specifying multiple filters, *ALL* filters must match on a flavor before that flavor is returned as a fact.",
            "properties": {
              "vcpus": {
                "type": "string",
                "description": "A string used for filtering flavors based on the number of virtual CPUs desired. Format is the same as the I(ram) parameter."
              },
              "ram": {
                "type": "string",
                "description": "A string used for filtering flavors based on the amount of RAM (in MB) desired. This string accepts the following special values: 'MIN' (return flavors with the minimum amount of RAM), and 'MAX' (return flavors with the maximum amount of RAM).\nA specific amount of RAM may also be specified. Any flavors with this exact amount of RAM will be returned.\nA range of acceptable RAM may be given using a special syntax. Simply prefix the amount of RAM with one of these acceptable range values: '<', '>', '<=', '>='. These values represent less than, greater than, less than or equal to, and greater than or equal to, respectively."
              },
              "limit": {
                "type": "string",
                "description": "Default: None\n\nLimits the number of flavors returned. All matching flavors are returned by default."
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nA flavor name. Cannot be used with I(ram) or I(vcpus)."
              }
            }
          },
          "ufw": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "to_ip",
                        "to",
                        "dest"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "to_port",
                        "port"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "app",
                        "name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "from_ip",
                        "from",
                        "src"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "interface",
                        "if"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "proto",
                        "protocol"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "default",
                        "policy"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage firewall with UFW.",
            "properties": {
              "protocol": {
                "enum": [
                  "any",
                  "tcp",
                  "udp",
                  "ipv6",
                  "esp",
                  "ah"
                ],
                "type": "string",
                "description": "TCP/IP protocol."
              },
              "to_port": {
                "type": "string",
                "description": "Destination port."
              },
              "app": {
                "type": "string",
                "description": "Use profile located in C(/etc/ufw/applications.d)"
              },
              "port": {
                "type": "string",
                "description": "Destination port."
              },
              "if": {
                "type": "string",
                "description": "Specify interface for rule."
              },
              "from": {
                "type": "string",
                "description": "Default: any\n\nSource IP address."
              },
              "log": {
                "description": "Log new connections matched to this rule",
                "$ref": "#/definitions/ansible_truth"
              },
              "proto": {
                "enum": [
                  "any",
                  "tcp",
                  "udp",
                  "ipv6",
                  "esp",
                  "ah"
                ],
                "type": "string",
                "description": "TCP/IP protocol."
              },
              "to": {
                "type": "string",
                "description": "Default: any\n\nDestination IP address."
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled",
                  "reloaded",
                  "reset"
                ],
                "type": "string",
                "description": "C(enabled) reloads firewall and enables firewall on boot.\nC(disabled) unloads firewall and disables firewall on boot.\nC(reloaded) reloads firewall.\nC(reset) disables and resets firewall to installation defaults."
              },
              "policy": {
                "enum": [
                  "allow",
                  "deny",
                  "reject"
                ],
                "type": "string",
                "description": "Change the default policy for incoming or outgoing traffic."
              },
              "direction": {
                "enum": [
                  "in",
                  "out",
                  "incoming",
                  "outgoing",
                  "routed"
                ],
                "type": "string",
                "description": "Select direction for a rule or default policy command."
              },
              "from_port": {
                "type": "string",
                "description": "Source port."
              },
              "to_ip": {
                "type": "string",
                "description": "Default: any\n\nDestination IP address."
              },
              "insert": {
                "type": "string",
                "description": "Insert the corresponding rule as rule number NUM"
              },
              "dest": {
                "type": "string",
                "description": "Default: any\n\nDestination IP address."
              },
              "from_ip": {
                "type": "string",
                "description": "Default: any\n\nSource IP address."
              },
              "interface": {
                "type": "string",
                "description": "Specify interface for rule."
              },
              "src": {
                "type": "string",
                "description": "Default: any\n\nSource IP address."
              },
              "logging": {
                "enum": [
                  "on",
                  "off",
                  "low",
                  "medium",
                  "high",
                  "full"
                ],
                "type": "string",
                "description": "Toggles logging. Logged packets use the LOG_KERN syslog facility."
              },
              "name": {
                "type": "string",
                "description": "Use profile located in C(/etc/ufw/applications.d)"
              },
              "default": {
                "enum": [
                  "allow",
                  "deny",
                  "reject"
                ],
                "type": "string",
                "description": "Change the default policy for incoming or outgoing traffic."
              },
              "route": {
                "description": "Apply the rule to routed/forwarded packets.",
                "$ref": "#/definitions/ansible_truth"
              },
              "rule": {
                "enum": [
                  "allow",
                  "deny",
                  "reject",
                  "limit"
                ],
                "type": "string",
                "description": "Add firewall rule"
              },
              "delete": {
                "description": "Delete rule.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "haproxy": {
            "required": [
              "host",
              "state"
            ],
            "type": "object",
            "description": "Enable, disable, and set weights for HAProxy backend servers using socket commands.",
            "properties": {
              "socket": {
                "type": "string",
                "description": "Default: /var/run/haproxy.sock\n\nPath to the HAProxy socket file."
              },
              "weight": {
                "type": "string",
                "description": "The value passed in argument. If the value ends with the `%` sign, then the new weight will be relative to the initially configured weight. Relative weights are only permitted between 0 and 100% and absolute weights are permitted between 0 and 256."
              },
              "wait_interval": {
                "description": "Default: 5\n\nNumber of seconds to wait between retries.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Desired state of the provided backend host."
              },
              "backend": {
                "type": "string",
                "description": "Default: auto-detected\n\nName of the HAProxy backend pool."
              },
              "wait_retries": {
                "description": "Default: 25\n\nNumber of times to check for status after changing the state.",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": "Name of the backend host to change."
              },
              "fail_on_not_found": {
                "description": "Fail whenever trying to enable/disable a backend host that does not exist",
                "$ref": "#/definitions/ansible_truth"
              },
              "shutdown_sessions": {
                "description": "When disabling a server, immediately terminate all the sessions attached to the specified server. This can be used to terminate long-running sessions after a server is put into maintenance mode.",
                "$ref": "#/definitions/ansible_truth"
              },
              "wait": {
                "description": "Wait until the server reports a status of 'UP' when `state=enabled`, or status of 'MAINT' when `state=disabled`.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_rollback": {
            "type": "object",
            "description": "This module offers the ability to set a configuration checkpoint file or rollback to a configuration checkpoint file on Cisco NXOS switches.",
            "properties": {
              "checkpoint_file": {
                "type": "string",
                "description": "Name of checkpoint file to create. Mutually exclusive with rollback_to."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "rollback_to": {
                "type": "string",
                "description": "Name of checkpoint file to rollback to. Mutually exclusive with checkpoint_file."
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "katello": {
            "required": [
              "username",
              "params",
              "password",
              "server_url",
              "entity"
            ],
            "type": "object",
            "description": "Allows the management of Katello resources inside your Foreman server",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username on Foreman server"
              },
              "server_url": {
                "type": "string",
                "description": "URL of Foreman server"
              },
              "entity": {
                "type": "string",
                "description": "The Foreman resource that the action will be performed on (e.g. organization, host)"
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "params": {
                "type": "object",
                "description": "Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description)"
              },
              "action": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": "Password for user accessing Foreman server"
              }
            }
          },
          "win_copy": {
            "type": "object",
            "description": "The C(win_copy) module copies a file on the local box to remote windows locations.",
            "properties": {
              "content": {
                "type": "string",
                "description": "When used instead of C(src), sets the contents of a file directly to the specified value. This is for simple values, for anything complex or with formatting please switch to the template module."
              },
              "dest": {
                "type": "string",
                "description": "Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.\nUse \\ for path separators or \\\\ when in \"double quotes\"."
              },
              "src": {
                "type": "string",
                "description": "Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with \"/\", only inside contents of that directory are copied to destination. Otherwise, if it does not end with \"/\", the directory itself with all contents is copied. This behavior is similar to Rsync."
              },
              "force": {
                "type": "string",
                "description": "Default: True\n\nIf set to C(yes), the remote file will be replaced when content is different than the source.\nIf set to C(no), the remote file will only be transferred if the destination does not exist."
              },
              "remote_src": {
                "type": "string",
                "description": "If False, it will search for src at originating/master machine, if True it will go to the remote/target machine for the src."
              }
            }
          },
          "cs_facts": {
            "type": "object",
            "description": "This module fetches data from the metadata API in CloudStack. The module must be called from within the instance itself.",
            "properties": {
              "filter": {
                "enum": [
                  "cloudstack_service_offering",
                  "cloudstack_availability_zone",
                  "cloudstack_public_hostname",
                  "cloudstack_public_ipv4",
                  "cloudstack_local_hostname",
                  "cloudstack_local_ipv4",
                  "cloudstack_instance_id",
                  "cloudstack_user_data"
                ],
                "type": "string",
                "description": "Filter for a specific fact."
              }
            }
          },
          "package": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "expire-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Installs, upgrade and removes packages using the underlying OS package manager.",
            "properties": {
              "expire-cache": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "Package name, or package specifier with version, like C(name-1.0).\nBe aware that packages are not always named the same and this module will not 'translate' them per distro.",
                "$ref": "#/definitions/ansible_array"
              },
              "list": {
                "type": "string",
                "description": ""
              },
              "disable_gpg_check": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "conf_file": {
                "type": "string",
                "description": ""
              },
              "install_repoquery": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "absent",
                  "present",
                  "installed",
                  "removed",
                  "latest"
                ],
                "type": "string",
                "description": "Whether to install (C(present), C(latest)), or remove (C(absent)) a package."
              },
              "disablerepo": {
                "type": "string",
                "description": ""
              },
              "update_cache": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "Package name, or package specifier with version, like C(name-1.0).\nBe aware that packages are not always named the same and this module will not 'translate' them per distro.",
                "$ref": "#/definitions/ansible_array"
              },
              "enablerepo": {
                "type": "string",
                "description": ""
              },
              "exclude": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "installroot": {
                "type": "string",
                "description": ""
              },
              "skip_broken": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "cs_zone": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, update and remove zones.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain the zone is related to.\nZone is a public zone if not set."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "dhcp_provider": {
                "type": "string",
                "description": "DHCP provider for the Zone."
              },
              "id": {
                "type": "string",
                "description": "uuid of the exising zone."
              },
              "dns1_ipv6": {
                "type": "string",
                "description": "First DNS for IPv6 for the zone."
              },
              "internal_dns1": {
                "type": "string",
                "description": "First internal DNS for the zone.\nIf not set C(dns1) will be used on C(state=present)."
              },
              "internal_dns2": {
                "type": "string",
                "description": "Second internal DNS for the zone."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "enabled",
                  "disabled",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the zone."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "dns2_ipv6": {
                "type": "string",
                "description": "Second DNS for IPv6 for the zone."
              },
              "securitygroups_enabled": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the zone."
              },
              "dns2": {
                "type": "string",
                "description": "Second DNS for the zone."
              },
              "dns1": {
                "type": "string",
                "description": "First DNS for the zone.\nRequired if C(state=present)"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "guest_cidr_address": {
                "type": "string",
                "description": "Guest CIDR address for the zone."
              },
              "network_domain": {
                "type": "string",
                "description": "Network domain for the zone."
              },
              "local_storage_enabled": {
                "type": "string",
                "description": ""
              },
              "network_type": {
                "enum": [
                  "Basic",
                  "basic",
                  "Advanced",
                  "advanced"
                ],
                "type": "string",
                "description": "Default: basic\n\nNetwork type of the zone."
              }
            }
          },
          "iam_cert": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Allows for the management of server certificates",
            "properties": {
              "dup_ok": {
                "description": "By default the module will not upload a certificate that is already uploaded into AWS. If set to True, it will upload the certificate as long as the name is unique.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "cert_chain": {
                "type": "string",
                "description": "The path to the CA certificate chain in PEM encoded format."
              },
              "aws_secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "new_path": {
                "type": "string",
                "description": "When present, this will update the path of the cert with the value passed here."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether to create, delete certificate. When present is specified it will attempt to make an update if new_path or new_name is specified."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "key": {
                "type": "string",
                "description": "The path to the private key of the certificate in PEM encoded format."
              },
              "ec2_access_key": {
                "type": "string",
                "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "ec2_secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "secret_key": {
                "type": "string",
                "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "new_name": {
                "type": "string",
                "description": "When present, this will update the name of the cert with the value passed here."
              },
              "aws_access_key": {
                "type": "string",
                "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used."
              },
              "name": {
                "type": "string",
                "description": "Name of certificate to add, update or remove."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "cert": {
                "type": "string",
                "description": "The path to the certificate body in PEM encoded format."
              },
              "path": {
                "type": "string",
                "description": "Default: /\n\nWhen creating or updating, specify the desired path of the certificate"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_templates": {
            "required": [
              "auth",
              "name"
            ],
            "type": "object",
            "description": "Module to manage virtual machine templates in oVirt.",
            "properties": {
              "disks": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "exclusive": {
                "description": "When C(state) is I(exported) this parameter indicates if the existing templates with the same name should be overwritten.",
                "$ref": "#/definitions/ansible_truth"
              },
              "image_disk": {
                "type": "string",
                "description": "When C(state) is I(imported) and C(image_provider) is used this parameter specifies the name of disk to be imported as template."
              },
              "storage_domain": {
                "type": "string",
                "description": "When C(state) is I(imported) this parameter specifies the name of the destination data storage domain."
              },
              "description": {
                "type": "string",
                "description": "Description of the template."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "exported",
                  "imported"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the template be present/absent/exported/imported"
              },
              "export_domain": {
                "type": "string",
                "description": "When C(state) is I(exported) or I(imported) this parameter specifies the name of the export storage domain."
              },
              "cpu_profile": {
                "type": "string",
                "description": "CPU profile to be set to template."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "vm": {
                "type": "string",
                "description": "Name of the VM, which will be used to create template."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Name of the the template to manage."
              },
              "cluster": {
                "type": "string",
                "description": "Name of the cluster, where template should be created/imported."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "image_provider": {
                "type": "string",
                "description": "When C(state) is I(imported) this parameter specifies the name of the image provider to be used."
              },
              "clone_permissions": {
                "description": "If I(True) then the permissions of the VM (only the direct ones, not the inherited ones) will be copied to the created template.\nThis parameter is used only when C(state) I(present).",
                "$ref": "#/definitions/ansible_truth"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "acl": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sets and retrieves file ACL information.",
            "properties": {
              "use_nfsv4_acls": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "default": {
                "description": "if the target is a directory, setting this to yes will make it the default acl for entities created inside the directory. It causes an error if path is a file.",
                "$ref": "#/definitions/ansible_truth"
              },
              "recursive": {
                "description": "Recursively sets the specified ACL (added in Ansible 2.0). Incompatible with C(state=query).",
                "$ref": "#/definitions/ansible_truth"
              },
              "entity": {
                "type": "string",
                "description": "actual user or group that the ACL applies to when matching entity types user or group are selected."
              },
              "state": {
                "enum": [
                  "query",
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: query\n\ndefines whether the ACL should be present or not.  The C(query) state gets the current acl without changing it, for use in 'register' operations."
              },
              "entry": {
                "type": "string",
                "description": "DEPRECATED. The acl to set or remove.  This must always be quoted in the form of '<etype>:<qualifier>:<perms>'.  The qualifier may be empty for some types, but the type and perms are always required. '-' can be used as placeholder when you do not care about permissions. This is now superseded by entity, type and permissions fields."
              },
              "etype": {
                "enum": [
                  "user",
                  "group",
                  "mask",
                  "other"
                ],
                "type": "string",
                "description": "the entity type of the ACL to apply, see setfacl documentation for more info."
              },
              "follow": {
                "description": "Default: True\n\nwhether to follow symlinks on the path if a symlink is encountered.",
                "$ref": "#/definitions/ansible_truth"
              },
              "path": {
                "type": "string",
                "description": "The full path of the file or object."
              },
              "permissions": {
                "type": "string",
                "description": "Permissions to apply/remove can be any combination of r, w and  x (read, write and execute respectively)"
              },
              "name": {
                "type": "string",
                "description": "The full path of the file or object."
              }
            }
          },
          "gitlab_project": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "validate_certs",
                        "verify_ssl"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "When the project does not exists in Gitlab, it will be created.\nWhen the project does exists and state=absent, the project will be deleted.\nWhen changes are made to the project, the project will be updated.",
            "properties": {
              "verify_ssl": {
                "description": "Default: True\n\nWhen using https if SSL certificate needs to be verified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "snippets_enabled": {
                "description": "Default: True\n\nIf creating snippets should be available or not.\nPossible values are true and false.",
                "$ref": "#/definitions/ansible_truth"
              },
              "group": {
                "type": "string",
                "description": "The name of the group of which this projects belongs to.\nWhen not provided, project will belong to user which is configured in 'login_user' or 'login_token'\nWhen provided with username, project will be created for this user. 'login_user' or 'login_token' needs admin rights."
              },
              "merge_requests_enabled": {
                "description": "Default: True\n\nIf merge requests can be made or not.\nPossible values are true and false.",
                "$ref": "#/definitions/ansible_truth"
              },
              "import_url": {
                "type": "string",
                "description": "Git repository which will me imported into gitlab.\nGitlab server needs read access to this git repository."
              },
              "login_user": {
                "type": "string",
                "description": "Gitlab user name."
              },
              "login_token": {
                "type": "string",
                "description": "Gitlab token for logging in."
              },
              "server_url": {
                "type": "string",
                "description": "Url of Gitlab server, with protocol (http or https)."
              },
              "name": {
                "type": "string",
                "description": "The name of the project"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\ncreate or delete project.\nPossible values are present and absent."
              },
              "issues_enabled": {
                "description": "Default: True\n\nWhether you want to create issues or not.\nPossible values are true and false.",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_password": {
                "type": "string",
                "description": "Gitlab password for login_user"
              },
              "path": {
                "type": "string",
                "description": "The path of the project you want to create, this will be server_url/<group>/path\nIf not supplied, name will be used."
              },
              "wiki_enabled": {
                "description": "Default: True\n\nIf an wiki for this project should be available or not.\nPossible values are true and false.",
                "$ref": "#/definitions/ansible_truth"
              },
              "visibility_level": {
                "enum": [
                  "0",
                  "10",
                  "20"
                ],
                "type": "string",
                "description": "Private. visibility_level is 0. Project access must be granted explicitly for each user.\nInternal. visibility_level is 10. The project can be cloned by any logged in user.\nPublic. visibility_level is 20. The project can be cloned without any authentication.\nPossible values are 0, 10 and 20."
              },
              "validate_certs": {
                "description": "Default: True\n\nWhen using https if SSL certificate needs to be verified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "public": {
                "description": "If the project is public available or not.\nSetting this to true is same as setting visibility_level to 20.\nPossible values are true and false.",
                "$ref": "#/definitions/ansible_truth"
              },
              "description": {
                "type": "string",
                "description": "An description for the project."
              }
            }
          },
          "win_region": {
            "type": "object",
            "description": "Set the location settings of a Windows Server.\nSet the format settings of a Windows Server.\nSet the unicode language settings of a Windows Server.\nCopy across these settings to the default profile.",
            "properties": {
              "unicode_language": {
                "type": "string",
                "description": "The unicode language format to set for all users, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(format) is not set. After setting this value a reboot is required for it to take effect."
              },
              "copy_settings": {
                "type": "string",
                "description": "This will copy the current format and location values to new user profiles and the welcome screen. This will only run if C(location), C(format) or C(unicode_language) has resulted in a change. If this process runs then it will always result in a change."
              },
              "location": {
                "type": "string",
                "description": "The location to set for the current user, see U(https://msdn.microsoft.com/en-us/library/dd374073.aspx) for a list of GeoIDs you can use and what location it relates to. This needs to be set if C(format) or C(unicode_language) is not set."
              },
              "format": {
                "type": "string",
                "description": "The language format to set for the current user, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(unicode_language) is not set."
              }
            }
          },
          "postgresql_db": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "db",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "db"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add or remove PostgreSQL databases from a remote host.",
            "properties": {
              "ssl_rootcert": {
                "type": "string",
                "description": ""
              },
              "ssl_mode": {
                "enum": [
                  "disable",
                  "allow",
                  "prefer",
                  "require",
                  "verify-ca",
                  "verify-full"
                ],
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "name of the database to add or remove"
              },
              "encoding": {
                "type": "string",
                "description": "Encoding of the database"
              },
              "login_user": {
                "type": "string",
                "description": ""
              },
              "lc_collate": {
                "type": "string",
                "description": "Collation order (LC_COLLATE) to use in the database. Must match collation order of template database unless C(template0) is used as template."
              },
              "db": {
                "type": "string",
                "description": "name of the database to add or remove"
              },
              "lc_ctype": {
                "type": "string",
                "description": "Character classification (LC_CTYPE) to use in the database (e.g. lower, upper, ...) Must match LC_CTYPE of template database unless C(template0) is used as template."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe database state"
              },
              "template": {
                "type": "string",
                "description": "Template used to create the database"
              },
              "login_password": {
                "type": "string",
                "description": ""
              },
              "owner": {
                "type": "string",
                "description": "Name of the role to set as owner of the database"
              },
              "login_host": {
                "type": "string",
                "description": ""
              }
            }
          },
          "azure": {
            "type": "object",
            "description": "Creates or terminates azure instances. When created optionally waits for it to be 'running'.",
            "properties": {
              "endpoints": {
                "type": "string",
                "description": "Default: 22\n\na comma-separated list of TCP ports to expose on the virtual machine (e.g., \"22,80\")"
              },
              "role_size": {
                "enum": [
                  "ExtraSmall",
                  "Small",
                  "Medium",
                  "Large",
                  "ExtraLarge",
                  "A5",
                  "A6",
                  "A7",
                  "A8",
                  "A9",
                  "Basic_A0",
                  "Basic_A1",
                  "Basic_A2",
                  "Basic_A3",
                  "Basic_A4",
                  "Standard_D1",
                  "Standard_D2",
                  "Standard_D3",
                  "Standard_D4",
                  "Standard_D11",
                  "Standard_D12",
                  "Standard_D13",
                  "Standard_D14",
                  "Standard_D1_v2",
                  "Standard_D2_v2",
                  "Standard_D3_v2",
                  "Standard_D4_v2",
                  "Standard_D5_v2",
                  "Standard_D11_v2",
                  "Standard_D12_v2",
                  "Standard_D13_v2",
                  "Standard_D14_v2",
                  "Standard_DS1",
                  "Standard_DS2",
                  "Standard_DS3",
                  "Standard_DS4",
                  "Standard_DS11",
                  "Standard_DS12",
                  "Standard_DS13",
                  "Standard_DS14",
                  "Standard_G1",
                  "Standard_G2",
                  "Standard_G3",
                  "Standard_G4",
                  "Standard_G5"
                ],
                "type": "string",
                "description": "Default: Small\n\nazure role size for the new virtual machine (e.g., Small, ExtraLarge, A6). You have to pay attention to the fact that instances of type G and DS are not available in all regions (locations). Make sure if you selected the size and type of instance available in your chosen location."
              },
              "name": {
                "type": "string",
                "description": "name of the virtual machine and associated cloud service."
              },
              "location": {
                "type": "string",
                "description": "the azure location to use (e.g. 'East US')\n\nPossible choices:\nSouth Central US\nCentral US\nEast US 2\nEast US\nWest US\nNorth Central US\nNorth Europe\nWest Europe\nEast Asia\nSoutheast Asia\nJapan West\nJapan East\nBrazil South"
              },
              "virtual_network_name": {
                "type": "string",
                "description": "Name of virtual network."
              },
              "image": {
                "type": "string",
                "description": "system image for creating the virtual machine (e.g., b39f27a8b8c64d52b05eac6a62ebad85__Ubuntu_DAILY_BUILD-precise-12_04_3-LTS-amd64-server-20131205-en-us-30GB)"
              },
              "hostname": {
                "type": "string",
                "description": "hostname to write /etc/hostname. Defaults to <name>.cloudapp.net."
              },
              "enable_winrm": {
                "description": "Default: yes\n\nEnable winrm on Windows Machines",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\ncreate or terminate instances"
              },
              "wait_timeout_redirects": {
                "type": "string",
                "description": "Default: 300\n\nhow long before wait gives up for redirects, in seconds"
              },
              "management_cert_path": {
                "type": "string",
                "description": "path to an azure management certificate associated with the subscription id. Overrides the AZURE_CERT_PATH environment variable."
              },
              "ssh_cert_path": {
                "type": "string",
                "description": "path to an X509 certificate containing the public ssh key to install in the virtual machine. See http://www.windowsazure.com/en-us/manage/linux/tutorials/intro-to-linux/ for more details.\nif this option is specified, password-based ssh authentication will be disabled."
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 600\n\nhow long before wait gives up, in seconds"
              },
              "user": {
                "type": "string",
                "description": "the unix username for the new virtual machine."
              },
              "auto_updates": {
                "description": "Default: no\n\nEnable Auto Updates on Windows Machines",
                "$ref": "#/definitions/ansible_truth"
              },
              "storage_account": {
                "type": "string",
                "description": "the azure storage account in which to store the data disks."
              },
              "os_type": {
                "enum": [
                  "windows",
                  "linux"
                ],
                "type": "string",
                "description": "Default: linux\n\nThe type of the os that is gettings provisioned"
              },
              "password": {
                "type": "string",
                "description": "the unix password for the new virtual machine."
              },
              "subscription_id": {
                "type": "string",
                "description": "azure subscription id. Overrides the AZURE_SUBSCRIPTION_ID environment variable."
              },
              "wait": {
                "description": "Default: no\n\nwait for the instance to be in state 'running' before returning",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ecs_task": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates or deletes instances of task definitions.",
            "properties": {
              "cluster": {
                "type": "string",
                "description": "The name of the cluster to run the task on"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "operation": {
                "enum": [
                  "run",
                  "start",
                  "stop"
                ],
                "type": "string",
                "description": "Which task operation to execute"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "task_definition": {
                "type": "string",
                "description": "The task definition to start or run"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "container_instances": {
                "description": "The list of container instances on which to deploy the task",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "count": {
                "description": "How many new instances to start",
                "$ref": "#/definitions/ansible_number"
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "task": {
                "type": "string",
                "description": "The task to stop"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "started_by": {
                "type": "string",
                "description": "A value showing who or what started the task (for informational purposes)"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "overrides": {
                "type": "object",
                "description": "A dictionary of values to pass to the new instances"
              }
            }
          },
          "zabbix_host": {
            "type": "object",
            "description": "This module allows you to create, modify and delete Zabbix host entries and associated group and template data.",
            "properties": {
              "status": {
                "type": "string",
                "description": "Default: enabled\n\nMonitoring status of the host."
              },
              "http_login_password": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth password"
              },
              "inventory_mode": {
                "type": "string",
                "description": "Default: None\n\nConfigure the inventory mode."
              },
              "timeout": {
                "type": "string",
                "description": "Default: 10\n\nThe timeout of API request (seconds)."
              },
              "login_user": {
                "type": "string",
                "description": "Zabbix user name, used to authenticate against the server."
              },
              "interfaces": {
                "type": "string",
                "description": "List of interfaces to be created for the host (see example below).\nAvailable values are: dns, ip, main, port, type and useip.\nPlease review the interface documentation for more information on the supported properties\nhttps://www.zabbix.com/documentation/2.0/manual/appendix/api/hostinterface/definitions#host_interface"
              },
              "http_login_user": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth login"
              },
              "server_url": {
                "type": "string",
                "description": "Url of Zabbix server, with protocol (http or https)."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nState of the host.\nOn C(present), it will create if host does not exist or update the host if the associated data is different.\nOn C(absent) will remove a host if it exists."
              },
              "host_name": {
                "type": "string",
                "description": "Name of the host in Zabbix.\nhost_name is the unique identifier used and cannot be updated using this module."
              },
              "host_groups": {
                "type": "string",
                "description": "List of host groups the host is part of."
              },
              "login_password": {
                "type": "string",
                "description": "Zabbix user password."
              },
              "force": {
                "type": "string",
                "description": "Default: yes\n\nOverwrite the host configuration, even if already present"
              },
              "link_templates": {
                "type": "string",
                "description": "Default: None\n\nList of templates linked to the host."
              },
              "proxy": {
                "type": "string",
                "description": "Default: None\n\nThe name of the Zabbix Proxy to be used"
              }
            }
          },
          "swdepot": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Will install, upgrade and remove packages with swdepot package manager (HP-UX)",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "latest",
                  "absent"
                ],
                "type": "string",
                "description": "whether to install (C(present), C(latest)), or remove (C(absent)) a package."
              },
              "depot": {
                "type": "string",
                "description": "The source repository from which install or upgrade a package."
              },
              "name": {
                "type": "string",
                "description": "package name."
              },
              "pkg": {
                "type": "string",
                "description": "package name."
              }
            }
          },
          "os_user_group": {
            "type": "object",
            "description": "Add and remove users from groups",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the user be present or absent in the group"
              },
              "group": {
                "type": "string",
                "description": "Name or id for the group."
              },
              "user": {
                "type": "string",
                "description": "Name or id for the user"
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              }
            }
          },
          "linode": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "linode_id",
                        "lid"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "creates / deletes a Linode Public Cloud instance and optionally waits for it to be 'running'.",
            "properties": {
              "alert_diskio_enabled": {
                "description": "Default: True\n\nSet status of receiving disk IO alerts.",
                "$ref": "#/definitions/ansible_truth"
              },
              "payment_term": {
                "description": "Default: 1\n\npayment term to use for the instance (payment term in months)",
                "$ref": "#/definitions/ansible_number"
              },
              "alert_bwquota_enabled": {
                "description": "Default: True\n\nSet status of bandwidth quota alerts as percentage of network tranfer quota.",
                "$ref": "#/definitions/ansible_truth"
              },
              "alert_bwout_threshold": {
                "description": "Set threshold in MB of bandwidth out alerts.",
                "$ref": "#/definitions/ansible_number"
              },
              "watchdog": {
                "description": "Default: True\n\nSet status of Lassie watchdog.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_pub_key": {
                "type": "string",
                "description": "SSH public key applied to root user"
              },
              "lid": {
                "description": "Unique ID of a linode server",
                "$ref": "#/definitions/ansible_number"
              },
              "backupweeklyday": {
                "description": "Integer value for what day of the week to store weekly backups.",
                "$ref": "#/definitions/ansible_number"
              },
              "displaygroup": {
                "type": "string",
                "description": "Add the instance to a Display Group in Linode Manager"
              },
              "backupwindow": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "alert_bwout_enabled": {
                "description": "Default: True\n\nSet status of bandwidth out alerts.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "active",
                  "started",
                  "absent",
                  "deleted",
                  "stopped",
                  "restarted"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "swap": {
                "description": "Default: 512\n\nswap size in MB",
                "$ref": "#/definitions/ansible_number"
              },
              "api_key": {
                "type": "string",
                "description": "Linode API key"
              },
              "additional_disks": {
                "description": "List of dictionaries for creating additional disks that are added to the Linode configuration settings. Dictionary takes Size, Label, Type. Size is in MB.\n",
                "$ref": "#/definitions/ansible_array"
              },
              "alert_bwin_enabled": {
                "description": "Default: True\n\nSet status of bandwidth in alerts.",
                "$ref": "#/definitions/ansible_truth"
              },
              "alert_bwin_threshold": {
                "description": "Set threshold in MB of bandwidth in alerts.",
                "$ref": "#/definitions/ansible_number"
              },
              "alert_cpu_enabled": {
                "description": "Default: True\n\nSet status of receiving CPU usage alerts.",
                "$ref": "#/definitions/ansible_truth"
              },
              "linode_id": {
                "description": "Unique ID of a linode server",
                "$ref": "#/definitions/ansible_number"
              },
              "alert_diskio_threshold": {
                "description": "Set threshold for average IO ops/sec over 2 hour period.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 300\n\nhow long before wait gives up, in seconds"
              },
              "plan": {
                "description": "plan to use for the instance (Linode plan)",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": "root password to apply to a new server (auto generated if missing)"
              },
              "wait": {
                "description": "Default: no\n\nwait for the instance to be in state 'running' before returning",
                "$ref": "#/definitions/ansible_truth"
              },
              "datacenter": {
                "description": "datacenter to create an instance in (Linode Datacenter)",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Name to give the instance (alphanumeric, dashes, underscore)\nTo keep sanity on the Linode Web Console, name is prepended with LinodeID_"
              },
              "alert_cpu_threshold": {
                "description": "Set percentage threshold for receiving CPU usage alerts. Each CPU core adds 100% to total.",
                "$ref": "#/definitions/ansible_number"
              },
              "distribution": {
                "description": "distribution to use for the instance (Linode Distribution)",
                "$ref": "#/definitions/ansible_number"
              },
              "alert_bwquota_threshold": {
                "description": "Set threshold in MB of bandwidth quota alerts.",
                "$ref": "#/definitions/ansible_number"
              },
              "private_ip": {
                "description": "Default: no\n\nAdd private IPv4 address when Linode is created.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vyos_config": {
            "type": "object",
            "description": "This module provides configuration file management of VyOS devices.  It provides arguments for managing both the configuration file and state of the active configuration.   All configuration statements are based on `set` and `delete` commands in the device configuration.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Default: configured by vyos_config\n\nAllows a commit description to be specified to be included when the configuration is committed.  If the configuration is not changed or committed, this argument is ignored."
              },
              "src": {
                "type": "string",
                "description": "The C(src) argument specifies the path to the source config file to load.  The source config file can either be in bracket format or set format.  The source file can include Jinja2 template variables."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "The C(save) argument controls whether or not changes made to the active configuration are saved to disk.  This is independent of committing the config.  When set to True, the active configuration is saved.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": "The C(config) argument specifies the base configuration to use to compare against the desired configuration.  If this value is not specified, the module will automatically retrieve the current active configuration from the remote device."
              },
              "lines": {
                "description": "The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.",
                "$ref": "#/definitions/ansible_array"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "The C(backup) argument will backup the current devices active configuration to the Ansible control host prior to making any changes.  The backup file will be located in the backup folder in the root of the playbook",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "match": {
                "enum": [
                  "line",
                  "none"
                ],
                "type": "string",
                "description": "Default: line\n\nThe C(match) argument controls the method used to match against the current active configuration.  By default, the desired config is matched against the active config and the deltas are loaded.  If the C(match) argument is set to C(none) the active configuration is ignored and the configuration is always loaded."
              }
            }
          },
          "rax_dns_record": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage DNS records on Rackspace Cloud DNS",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Brief description of the domain. Maximum length of 160 characters"
              },
              "domain": {
                "type": "string",
                "description": "Domain name to create the record in. This is an invalid option when type=PTR"
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ttl": {
                "description": "Default: 3600\n\nTime to live of record in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "overwrite": {
                "description": "Default: True\n\nAdd new records if data doesn't match, instead of updating existing record with matching name. If there are already multiple records with matching name and overwrite=true, this module will fail.",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              },
              "priority": {
                "description": "Required for MX and SRV records, but forbidden for other record types. If specified, must be an integer from 0 to 65535.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "type": {
                "enum": [
                  "A",
                  "AAAA",
                  "CNAME",
                  "MX",
                  "NS",
                  "SRV",
                  "TXT",
                  "PTR"
                ],
                "type": "string",
                "description": "DNS record type"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "data": {
                "type": "string",
                "description": "IP address for A/AAAA record, FQDN for CNAME/MX/NS, or text data for SRV/TXT"
              },
              "name": {
                "type": "string",
                "description": "FQDN record name to create"
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "server": {
                "type": "string",
                "description": "Server ID to create a PTR record for. Only used with type=PTR"
              },
              "loadbalancer": {
                "type": "string",
                "description": "Load Balancer ID to create a PTR record for. Only used with type=PTR"
              }
            }
          },
          "docker_image_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cacert_path",
                        "tls_ca_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "docker_host",
                        "docker_url"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "key_path",
                        "tls_client_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cert_path",
                        "tls_client_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_version",
                        "docker_api_version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Provide one or more image names, and the module will inspect each, returning an array of inspection results.",
            "properties": {
              "filter_logger": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "tls": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cacert_path": {
                "type": "string",
                "description": ""
              },
              "name": {
                "description": "An image name or a list of image names. Name format will be name[:tag] or repository/name[:tag], where tag is optional. If a tag is not provided, 'latest' will be used.",
                "$ref": "#/definitions/ansible_array"
              },
              "docker_url": {
                "type": "string",
                "description": ""
              },
              "ssl_version": {
                "type": "string",
                "description": ""
              },
              "docker_api_version": {
                "type": "string",
                "description": ""
              },
              "tls_ca_cert": {
                "type": "string",
                "description": ""
              },
              "tls_hostname": {
                "type": "string",
                "description": ""
              },
              "docker_host": {
                "type": "string",
                "description": ""
              },
              "tls_verify": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "key_path": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cert_path": {
                "type": "string",
                "description": ""
              },
              "tls_client_cert": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "tls_client_key": {
                "type": "string",
                "description": ""
              }
            }
          },
          "redshift": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cluster_parameter_group_name",
                        "param_group_name"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "new_cluster_identifier",
                        "new_identifier"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "availability_zone",
                        "zone",
                        "aws_zone"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cluster_version",
                        "version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "allow_version_upgrade",
                        "version_upgrade"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cluster_subnet_group_name",
                        "subnet"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cluster_security_groups",
                        "security_groups"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "automated_snapshot_retention_period",
                        "retention_period"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "preferred_maintenance_window",
                        "maintance_window",
                        "maint_window"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "vpc_security_group_ids",
                        "vpc_security_groups"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, deletes, or modifies amazon Redshift cluster instances.",
            "properties": {
              "cluster_parameter_group_name": {
                "type": "string",
                "description": "name of the cluster parameter group"
              },
              "username": {
                "type": "string",
                "description": "Master database username. Used only when command=create."
              },
              "maint_window": {
                "type": "string",
                "description": "maintenance window"
              },
              "availability_zone": {
                "type": "string",
                "description": "availability zone in which to launch cluster"
              },
              "encrypted": {
                "description": "if the cluster is encrypted or not",
                "$ref": "#/definitions/ansible_truth"
              },
              "retention_period": {
                "type": "string",
                "description": "period when the snapshot take place"
              },
              "node_type": {
                "enum": [
                  "ds1.xlarge",
                  "ds1.8xlarge",
                  "ds2.xlarge",
                  "ds2.8xlarge",
                  "dc1.large",
                  "dc1.8xlarge",
                  "dw1.xlarge",
                  "dw1.8xlarge",
                  "dw2.large",
                  "dw2.8xlarge"
                ],
                "type": "string",
                "description": "The node type of the cluster. Must be specified when command=create."
              },
              "publicly_accessible": {
                "description": "if the cluster is accessible publicly or not",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "which port the cluster is listining",
                "$ref": "#/definitions/ansible_number"
              },
              "security_groups": {
                "description": "in which security group the cluster belongs",
                "$ref": "#/definitions/ansible_array"
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "subnet": {
                "type": "string",
                "description": "which subnet to place the cluster"
              },
              "vpc_security_groups": {
                "description": "VPC security group",
                "$ref": "#/definitions/ansible_array"
              },
              "password": {
                "type": "string",
                "description": "Master database password. Used only when command=create."
              },
              "zone": {
                "type": "string",
                "description": "availability zone in which to launch cluster"
              },
              "cluster_type": {
                "enum": [
                  "multi-node",
                  "single-node"
                ],
                "type": "string",
                "description": "Default: single-node\n\nThe type of cluster."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "version": {
                "enum": [
                  "1.0"
                ],
                "type": "string",
                "description": "which version the cluster should have"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "vpc_security_group_ids": {
                "description": "VPC security group",
                "$ref": "#/definitions/ansible_array"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "new_cluster_identifier": {
                "type": "string",
                "description": "Only used when command=modify."
              },
              "number_of_nodes": {
                "description": "Number of nodes. Only used when cluster_type=multi-node.",
                "$ref": "#/definitions/ansible_number"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "version_upgrade": {
                "description": "Default: True\n\nflag to determinate if upgrade of version is possible",
                "$ref": "#/definitions/ansible_truth"
              },
              "db_name": {
                "type": "string",
                "description": "Name of the database."
              },
              "param_group_name": {
                "type": "string",
                "description": "name of the cluster parameter group"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "cluster_subnet_group_name": {
                "type": "string",
                "description": "which subnet to place the cluster"
              },
              "wait": {
                "description": "Default: no\n\nWhen command=create, modify or restore then wait for the database to enter the 'available' state. When command=delete wait for the database to be terminated.",
                "$ref": "#/definitions/ansible_truth"
              },
              "aws_zone": {
                "type": "string",
                "description": "availability zone in which to launch cluster"
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "allow_version_upgrade": {
                "description": "Default: True\n\nflag to determinate if upgrade of version is possible",
                "$ref": "#/definitions/ansible_truth"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "cluster_security_groups": {
                "description": "in which security group the cluster belongs",
                "$ref": "#/definitions/ansible_array"
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "maintance_window": {
                "type": "string",
                "description": "maintenance window"
              },
              "elastic_ip": {
                "type": "string",
                "description": "if the cluster has an elastic IP or not"
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 300\n\nhow long before wait gives up, in seconds"
              },
              "command": {
                "enum": [
                  "create",
                  "facts",
                  "delete",
                  "modify"
                ],
                "type": "string",
                "description": "Specifies the action to take."
              },
              "new_identifier": {
                "type": "string",
                "description": "Only used when command=modify."
              },
              "automated_snapshot_retention_period": {
                "type": "string",
                "description": "period when the snapshot take place"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "identifier": {
                "type": "string",
                "description": "Redshift cluster identifier."
              },
              "cluster_version": {
                "enum": [
                  "1.0"
                ],
                "type": "string",
                "description": "which version the cluster should have"
              },
              "preferred_maintenance_window": {
                "type": "string",
                "description": "maintenance window"
              }
            }
          },
          "gce_pd": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "This module can create and destroy unformatted GCE persistent disks U(https://developers.google.com/compute/docs/disks#persistentdisks). It also supports attaching and detaching disks from running instances. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.",
            "properties": {
              "size_gb": {
                "type": "string",
                "description": "Default: 10\n\nwhole integer size of disk (in GB) to create, default is 10 GB"
              },
              "disk_type": {
                "type": "string",
                "description": "Default: pd-standard\n\ntype of disk provisioned"
              },
              "name": {
                "type": "string",
                "description": "name of the disk"
              },
              "zone": {
                "type": "string",
                "description": "Default: us-central1-b\n\nzone in which to create the disk"
              },
              "service_account_email": {
                "type": "string",
                "description": "service account email"
              },
              "image": {
                "type": "string",
                "description": "the source image to use for the disk"
              },
              "pem_file": {
                "type": "string",
                "description": "path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'."
              },
              "instance_name": {
                "type": "string",
                "description": "instance name if you wish to attach or detach the disk"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\ndesired state of the persistent disk"
              },
              "snapshot": {
                "type": "string",
                "description": "the source snapshot to use for the disk"
              },
              "mode": {
                "enum": [
                  "READ_WRITE",
                  "READ_ONLY"
                ],
                "type": "string",
                "description": "Default: READ_ONLY\n\nGCE mount mode of disk, READ_ONLY (default) or READ_WRITE"
              },
              "credentials_file": {
                "type": "string",
                "description": "path to the JSON file associated with the service account email"
              },
              "project_id": {
                "type": "string",
                "description": "your GCE project ID"
              },
              "delete_on_termination": {
                "description": "If yes, deletes the volume when instance is terminated",
                "$ref": "#/definitions/ansible_truth"
              },
              "detach_only": {
                "description": "Default: no\n\ndo not destroy the disk, merely detach it from an instance",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "tower_user": {
            "required": [
              "username",
              "email"
            ],
            "type": "object",
            "description": "Create, update, or destroy Ansible Tower users. See U(https://www.ansible.com/tower) for an overview.",
            "properties": {
              "username": {
                "type": "string",
                "description": "The username of the user."
              },
              "superuser": {
                "description": "User is a system wide administator.",
                "$ref": "#/definitions/ansible_truth"
              },
              "first_name": {
                "type": "string",
                "description": "First name of the user."
              },
              "last_name": {
                "type": "string",
                "description": "Last name of the user."
              },
              "tower_host": {
                "type": "string",
                "description": "URL to your Tower instance."
              },
              "email": {
                "type": "string",
                "description": "Email address of the user."
              },
              "tower_username": {
                "type": "string",
                "description": "Username for your Tower instance."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the resource."
              },
              "auditor": {
                "description": "User is a system wide auditor.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tower_password": {
                "type": "string",
                "description": "Password for your Tower instance."
              },
              "tower_config_file": {
                "type": "string",
                "description": "Path to the Tower config file. See notes."
              },
              "organization": {
                "type": "string",
                "description": "Organization the user should be made a member of."
              },
              "password": {
                "type": "string",
                "description": "Password of the user."
              },
              "tower_verify_ssl": {
                "description": "Default: True\n\nDis/allow insecure connections to Tower. If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "profitbricks_nic": {
            "type": "object",
            "description": "This module allows you to create or restore a volume snapshot. This module has a dependency on profitbricks >= 1.0.0",
            "properties": {
              "datacenter": {
                "type": "string",
                "description": "The datacenter in which to operate."
              },
              "lan": {
                "type": "string",
                "description": "The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create."
              },
              "name": {
                "type": "string",
                "description": "The name or ID of the NIC. This is only required on deletes, but not on create."
              },
              "subscription_user": {
                "type": "string",
                "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable."
              },
              "server": {
                "type": "string",
                "description": "The server name or ID."
              },
              "subscription_password": {
                "type": "string",
                "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the resource"
              },
              "wait_timeout": {
                "description": "Default: 600\n\nhow long before wait gives up, in seconds",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "Default: yes\n\nwait for the operation to complete before returning",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ecs_service": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates or terminates ecs services.",
            "properties": {
              "desired_count": {
                "description": "The count of how many instances of the service",
                "$ref": "#/definitions/ansible_number"
              },
              "cluster": {
                "type": "string",
                "description": "The name of the cluster in which the service exists"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "task_definition": {
                "type": "string",
                "description": "The task definition the service will run"
              },
              "delay": {
                "description": "Default: 10\n\nThe time to wait before checking that the service is available",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "deleting"
                ],
                "type": "string",
                "description": "The desired state of the service"
              },
              "role": {
                "type": "string",
                "description": "The name or full Amazon Resource Name (ARN) of the IAM role that allows your Amazon ECS container agent to make calls to your load balancer on your behalf. This parameter is only required if you are using a load balancer with your service."
              },
              "client_token": {
                "type": "string",
                "description": "Unique, case-sensitive identifier you provide to ensure the idempotency of the request. Up to 32 ASCII characters are allowed."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "repeat": {
                "description": "Default: 10\n\nThe number of times to check that the service is available",
                "$ref": "#/definitions/ansible_number"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "load_balancers": {
                "description": "The list of ELBs defined for this service",
                "$ref": "#/definitions/ansible_array"
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the service"
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vmware_guest": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "annotation",
                        "notes"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "template_src",
                        "template"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create new virtual machines (from templates or not)\nPower on/power off/restart a virtual machine\nModify, rename or remove a virtual machine",
            "properties": {
              "resource_pool": {
                "type": "string",
                "description": "Default: None\n\nAffect machine to the given resource pool\nResource pool should be child of the selected host parent"
              },
              "force": {
                "description": "Ignore warnings and complete the actions",
                "$ref": "#/definitions/ansible_truth"
              },
              "hardware": {
                "type": "object",
                "description": "Manage some VM hardware attributes.\nValid attributes are: memory_mb, num_cpus and scsi\nscsi: Valid values are buslogic, lsilogic, lsilogicsas and paravirtual (default)"
              },
              "cluster": {
                "type": "string",
                "description": "The cluster name where the VM will run."
              },
              "customization": {
                "type": "object",
                "description": "Parameters to customize template\nCommon parameters (Linux/Windows):\n  C(dns_servers) (list): List of DNS servers to configure\n  C(dns_suffix) (list): List of domain suffixes, aka DNS search path (default: C(domain) parameter)\n  C(domain) (string): DNS domain name to use\n  C(hostname) (string): Computer hostname (default: C(name) parameter)\nParameters related to windows customization:\n  C(autologon) (bool): Auto logon after VM customization (default: False)\n  C(autologoncount) (int): Number of autologon after reboot (default: 1)\n  C(domainadmin) (string): User used to join in AD domain (mandatory with joindomain)\n  C(domainadminpassword) (string): Password used to join in AD domain (mandatory with joindomain)\n  C(fullname) (string): Server owner name (default: Administrator)\n  C(joindomain) (string): AD domain to join (Not compatible with C(joinworkgroup))\n  C(joinworkgroup) (string): Workgroup to join (Not compatible with C(joindomain), default: WORKGROUP)\n  C(orgname) (string): Organisation name (default: ACME)\n  C(password) (string): Local administrator password (mandatory)\n  C(productid) (string): Product ID\n  C(runonce) (list): List of commands to run at first user logon\n  C(timezone) (int): Timezone (default: 85) See U(https://msdn.microsoft.com/en-us/library/ms912391(v=winembedded.11).aspx)"
              },
              "disk": {
                "description": "A list of disks to add\nValid attributes are: size_[tb,gb,mb,kb], type, datastore and autoselect_datastore\ntype: Valid value is thin (default: None)\ndatastore: Datastore to use for the disk. If autoselect_datastore is True, filter datastore selection.\nautoselect_datastore (bool): select the less used datastore.",
                "$ref": "#/definitions/ansible_array"
              },
              "networks": {
                "description": "Network to use should include C(name) or C(vlan) entry\nAdd an optional C(ip) and C(netmask) for network configuration\nAdd an optional C(gateway) entry to configure a gateway\nAdd an optional C(mac) entry to customize mac address\nAdd an optional C(dns_servers) or C(domain) entry per interface (Windows)\nAdd an optional C(device_type) to configure the virtual NIC (pcnet32, vmxnet2, vmxnet3, e1000, e1000e)",
                "$ref": "#/definitions/ansible_array"
              },
              "wait_for_ip_address": {
                "description": "Wait until vCenter detects an IP address for the VM\nThis requires vmware-tools (vmtoolsd) to properly work after creation",
                "$ref": "#/definitions/ansible_truth"
              },
              "uuid": {
                "type": "string",
                "description": "UUID of the instance to manage if known, this is VMware's unique identifier.\nThis is required if name is not supplied."
              },
              "customvalues": {
                "description": "Define a list of customvalues to set on VM.\nA customvalue object takes 2 fields 'key' and 'value'.",
                "$ref": "#/definitions/ansible_array"
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "template_src": {
                "type": "string",
                "description": "Template used to create VM.\nIf this value is not set, VM is created without using a template.\nIf the VM exists already this setting will be ignored."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "poweredon",
                  "poweredoff",
                  "restarted",
                  "suspended",
                  "shutdownguest",
                  "rebootguest"
                ],
                "type": "string",
                "description": "What state should the virtual machine be in?\nIf C(state) is set to C(present) and VM exists, ensure the VM configuration conforms to task arguments"
              },
              "template": {
                "type": "string",
                "description": "Template used to create VM.\nIf this value is not set, VM is created without using a template.\nIf the VM exists already this setting will be ignored."
              },
              "folder": {
                "type": "string",
                "description": "Destination folder, absolute path to find an existing guest or create the new guest"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "guest_id": {
                "type": "string",
                "description": "Set the guest ID (Debian, RHEL, Windows...)\nThis field is required when creating a VM\nValid values are referenced here: https://www.vmware.com/support/developer/converter-sdk/conv55_apireference/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html"
              },
              "name_match": {
                "type": "string",
                "description": "Default: first\n\nIf multiple VMs matching the name, use the first or last found"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "annotation": {
                "type": "string",
                "description": "A note or annotation to include in the VM"
              },
              "datacenter": {
                "type": "string",
                "description": "Default: ha-datacenter\n\nDestination datacenter for the deploy operation"
              },
              "name": {
                "type": "string",
                "description": "Name of the VM to work with"
              },
              "notes": {
                "type": "string",
                "description": "A note or annotation to include in the VM"
              },
              "is_template": {
                "description": "Flag the instance as a template",
                "$ref": "#/definitions/ansible_truth"
              },
              "esxi_hostname": {
                "type": "string",
                "description": "The esxi hostname where the VM will run."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vmware_vmotion": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "vm_name",
                        "vm"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "vm_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "vm"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "destination_host",
                        "destination"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "destination_host"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "destination"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Using VMware vCenter, move a virtual machine using vMotion to a different host.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "vm_name": {
                "type": "string",
                "description": "Name of the VM to perform a vMotion on"
              },
              "destination": {
                "type": "string",
                "description": "Name of the end host the VM should be running on"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "vm": {
                "type": "string",
                "description": "Name of the VM to perform a vMotion on"
              },
              "destination_host": {
                "type": "string",
                "description": "Name of the end host the VM should be running on"
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "wait_for_connection": {
            "required": [
              "password"
            ],
            "type": "object",
            "description": "Waits for a total of C(timeout) seconds.\nRetries the transport connection after a timeout of C(connect_timeout).\nTests the transport connection every C(sleep) seconds.\nThis module makes use of internal ansible transport (and configuration) and the ping/win_ping module to guarantee correct end-to-end functioning.",
            "properties": {
              "timeout": {
                "type": "string",
                "description": "Default: 600\n\nMaximum number of seconds to wait for."
              },
              "ipv6": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "minutes": {
                "type": "string",
                "description": ""
              },
              "port": {
                "type": "string",
                "description": ""
              },
              "multi_key": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "zabbix_hostmacro": {
            "type": "object",
            "description": "manages Zabbix host macros, it can create, update or delete them.",
            "properties": {
              "http_login_password": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth password"
              },
              "macro_name": {
                "type": "string",
                "description": "Name of the host macro."
              },
              "macro_value": {
                "type": "string",
                "description": "Value of the host macro."
              },
              "login_user": {
                "type": "string",
                "description": "Zabbix user name."
              },
              "http_login_user": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth login"
              },
              "server_url": {
                "type": "string",
                "description": "Url of Zabbix server, with protocol (http or https)."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nState of the macro.\nOn C(present), it will create if macro does not exist or update the macro if the associated data is different.\nOn C(absent) will remove a macro if it exists."
              },
              "host_name": {
                "type": "string",
                "description": "Name of the host."
              },
              "timeout": {
                "type": "string",
                "description": "Default: 10\n\nThe timeout of API request (seconds)."
              },
              "login_password": {
                "type": "string",
                "description": "Zabbix user password."
              }
            }
          },
          "azure_rm_securitygroup": {
            "required": [
              "resource_group",
              "name"
            ],
            "type": "object",
            "description": "Create, update or delete a network security group. A security group contains Access Control List (ACL) rules that allow or deny network traffic to subnets or individual network interfaces. A security group is created with a set of default security rules and an empty set of security rules. Shape traffic flow by adding rules to the empty set of security rules.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "resource_group": {
                "type": "string",
                "description": "Name of the resource group the security group belongs to."
              },
              "purge_rules": {
                "description": "Remove any existing rules not matching those defined in the rules parameters.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tags": {
                "type": "object",
                "description": ""
              },
              "rules": {
                "description": "Set of rules shaping traffic flow to or from a subnet or NIC. Each rule is a dictionary.",
                "$ref": "#/definitions/ansible_array"
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "append_tags": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "default_rules": {
                "description": "The set of default rules automatically added to a security group at creation. In general default rules will not be modified. Modify rules to shape the flow of traffic to or from a subnet or NIC. See rules below for the makeup of a rule dict.",
                "$ref": "#/definitions/ansible_array"
              },
              "purge_default_rules": {
                "description": "Remove any existing rules not matching those defined in the default_rules parameter.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nAssert the state of the security group. Set to 'present' to create or update a security group. Set to 'absent' to remove a security group."
              },
              "location": {
                "type": "string",
                "description": "Default: resource_group location\n\nValid azure location. Defaults to location of the resource group."
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the security group to operate on."
              }
            }
          },
          "ovirt_networks": {
            "required": [
              "name",
              "auth",
              "data_center"
            ],
            "type": "object",
            "description": "Module to manage logical networks in oVirt",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Comment of the network."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "description": {
                "type": "string",
                "description": "Description of the network."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "mtu": {
                "description": "Maximum transmission unit (MTU) of the network.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the network be present or absent"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "vm_network": {
                "description": "If I(True) network will be marked as network for VM.\nVM network carries traffic relevant to the virtual machine.",
                "$ref": "#/definitions/ansible_truth"
              },
              "data_center": {
                "type": "string",
                "description": "Datacenter name where network reside."
              },
              "clusters": {
                "description": "List of dictionaries describing how the network is managed in specific cluster.\nC(name) - Cluster name.\nC(assigned) - I(true) if the network should be assigned to cluster. Default is I(true).\nC(required) - I(true) if the network must remain operational for all hosts associated with this network.\nC(display) - I(true) if the network should marked as display network.\nC(migration) - I(true) if the network should marked as migration network.\nC(gluster) - I(true) if the network should marked as gluster network.",
                "$ref": "#/definitions/ansible_array"
              },
              "vlan_tag": {
                "description": "Specify VLAN tag.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the the network to manage."
              }
            }
          },
          "cs_account": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, disable, lock, enable and remove accounts.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Username of the user to be created if account did not exist.\nRequired on C(state=present)."
              },
              "domain": {
                "type": "string",
                "description": "Default: ROOT\n\nDomain the account is related to."
              },
              "last_name": {
                "type": "string",
                "description": "Last name of the user to be created if account did not exist.\nRequired on C(state=present)."
              },
              "account_type": {
                "enum": [
                  "user",
                  "root_admin",
                  "domain_admin"
                ],
                "type": "string",
                "description": "Default: user\n\nType of the account."
              },
              "name": {
                "type": "string",
                "description": "Name of account."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "network_domain": {
                "type": "string",
                "description": "Network domain of the account."
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "first_name": {
                "type": "string",
                "description": "First name of the user to be created if account did not exist.\nRequired on C(state=present)."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled",
                  "locked",
                  "unlocked"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the account.\nC(unlocked) is an alias for C(enabled)."
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timezone": {
                "type": "string",
                "description": "Timezone of the user to be created if account did not exist."
              },
              "password": {
                "type": "string",
                "description": "Password of the user to be created if account did not exist.\nRequired on C(state=present)."
              },
              "email": {
                "type": "string",
                "description": "Email of the user to be created if account did not exist.\nRequired on C(state=present)."
              },
              "api_url": {
                "type": "string",
                "description": ""
              }
            }
          },
          "seboolean": {
            "required": [
              "state",
              "name"
            ],
            "type": "object",
            "description": "Toggles SELinux booleans.",
            "properties": {
              "state": {
                "description": "Desired boolean value",
                "$ref": "#/definitions/ansible_truth"
              },
              "persistent": {
                "description": "Set to C(yes) if the boolean setting should survive a reboot",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the boolean to configure"
              }
            }
          },
          "postgresql_lang": {
            "required": [
              "lang",
              "db"
            ],
            "type": "object",
            "description": "Adds, removes or changes procedural languages with a PostgreSQL database.\nThis module allows you to add a language, remote a language or change the trust relationship with a PostgreSQL database. The module can be used on the machine where executed or on a remote host.\nWhen removing a language from a database, it is possible that dependencies prevent the database from being removed. In that case, you can specify casade to automatically drop objects that depend on the language (such as functions in the language). In case the language can't be deleted because it is required by the database system, you can specify fail_on_drop=no to ignore the error.\nBe carefull when marking a language as trusted since this could be a potential security breach. Untrusted languages allow only users with the PostgreSQL superuser privilege to use this language to create new functions.",
            "properties": {
              "lang": {
                "type": "string",
                "description": "name of the procedural language to add, remove or change"
              },
              "force_trust": {
                "description": "marks the language as trusted, even if it's marked as untrusted in pg_pltemplate.\nuse with care!",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_user": {
                "type": "string",
                "description": "Default: postgres\n\nUser used to authenticate with PostgreSQL"
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nHost running PostgreSQL where you want to execute the actions."
              },
              "db": {
                "type": "string",
                "description": "name of database where the language will be added, removed or changed"
              },
              "cascade": {
                "description": "when dropping a language, also delete object that depend on this language.\nonly used when C(state=absent).",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state of the language for the selected database"
              },
              "login_password": {
                "type": "string",
                "description": "Password used to authenticate with PostgreSQL (must match C(login_user))"
              },
              "trust": {
                "description": "make this language trusted for the selected db",
                "$ref": "#/definitions/ansible_truth"
              },
              "fail_on_drop": {
                "description": "Default: yes\n\nif C(yes), fail when removing a language. Otherwise just log and continue\nin some cases, it is not possible to remove a language (used by the db-system). When         dependencies block the removal, consider using C(cascade).",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "type": "string",
                "description": "Default: 5432\n\nDatabase port to connect to."
              }
            }
          },
          "consul_acl": {
            "type": "object",
            "description": "allows the addition, modification and deletion of ACL keys and associated rules in a consul cluster via the agent. For more details on using and configuring ACLs, see https://www.consul.io/docs/internals/acl.html.",
            "properties": {
              "name": {
                "type": "string",
                "description": "the name that should be associated with the acl key, this is opaque to Consul"
              },
              "rules": {
                "type": "string",
                "description": "an list of the rules that should be associated with a given token."
              },
              "token": {
                "type": "string",
                "description": "the token key indentifying an ACL rule set. If generated by consul this will be a UUID."
              },
              "token_type": {
                "type": "string",
                "description": "Default: client\n\nthe type of token that should be created, either management or client"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nwhether the ACL pair should be present or absent"
              },
              "mgmt_token": {
                "type": "string",
                "description": "a management token is required to manipulate the acl lists"
              },
              "host": {
                "type": "string",
                "description": "Default: localhost\n\nhost of the consul agent defaults to localhost"
              },
              "scheme": {
                "type": "string",
                "description": "Default: http\n\nthe protocol scheme on which the consul agent is running"
              },
              "validate_certs": {
                "type": "string",
                "description": "Default: True\n\nwhether to verify the tls certificate of the consul agent"
              },
              "port": {
                "type": "string",
                "description": "Default: 8500\n\nthe port on which the consul agent is running"
              }
            }
          },
          "lldp": {
            "type": "object",
            "description": "Reads data out of lldpctl",
            "properties": {}
          },
          "nxos_snmp_user": {
            "required": [
              "user",
              "group"
            ],
            "type": "object",
            "description": "Manages SNMP user configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "group": {
                "type": "string",
                "description": "Group to which the user will belong to."
              },
              "privacy": {
                "type": "string",
                "description": "Privacy password for the user."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "authentication": {
                "enum": [
                  "md5",
                  "sha"
                ],
                "type": "string",
                "description": ""
              },
              "encrypt": {
                "description": "Enables AES-128 bit encryption when using privacy password.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pwd": {
                "type": "string",
                "description": "Auth password when using md5 or sha."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "user": {
                "type": "string",
                "description": "Name of the user."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "vmadm": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "alias"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage SmartOS virtual machines through vmadm(1M).",
            "properties": {
              "virtio_txtimer": {
                "description": "Timeout (in nanoseconds) for the TX timer of virtio NICs.",
                "$ref": "#/definitions/ansible_number"
              },
              "archive_on_delete": {
                "description": "When enabled, the zone dataset will be mounted on C(/zones/archive) upon removal.",
                "$ref": "#/definitions/ansible_truth"
              },
              "disk_driver": {
                "type": "string",
                "description": "Default value for a virtual disk model for KVM guests."
              },
              "force": {
                "description": "Force a particular action (i.e. stop or delete a VM).",
                "$ref": "#/definitions/ansible_truth"
              },
              "zfs_root_compression": {
                "type": "string",
                "description": "Specifies compression algorithm used for this VMs root dataset. This option only has effect on the zoneroot dataset."
              },
              "indestructible_zoneroot": {
                "description": "Adds an C(@indestructible) snapshot to zoneroot.",
                "$ref": "#/definitions/ansible_truth"
              },
              "customer_metadata": {
                "type": "object",
                "description": "Metadata to be set and associated with this VM, this contain customer modifiable keys."
              },
              "spice_password": {
                "type": "string",
                "description": "Password required to connect to SPICE. By default no password is set. Please note this can be read from the Global Zone."
              },
              "zfs_io_priority": {
                "description": "IO throttle priority value relative to other VMs.",
                "$ref": "#/definitions/ansible_number"
              },
              "ram": {
                "description": "Amount of virtual RAM for a KVM guest (in MiBs).",
                "$ref": "#/definitions/ansible_number"
              },
              "dns_domain": {
                "type": "string",
                "description": "Domain value for C(/etc/hosts)."
              },
              "max_physical_memory": {
                "description": "Maximum amount of memory (in MiBs) on the host that the VM is allowed to use.",
                "$ref": "#/definitions/ansible_number"
              },
              "nic_driver": {
                "type": "string",
                "description": "Default value for a virtual NIC model for KVM guests."
              },
              "zfs_data_compression": {
                "type": "string",
                "description": "Specifies compression algorithm used for this VMs data dataset. This option only has effect on delegated datasets."
              },
              "image_uuid": {
                "type": "string",
                "description": "Image UUID."
              },
              "fs_allowed": {
                "type": "string",
                "description": "Comma separated list of filesystem types this zone is allowed to mount."
              },
              "qemu_opts": {
                "type": "string",
                "description": "Additional qemu arguments for KVM guests. This overwrites the default arguments provided by vmadm(1M) and should only be used for debugging."
              },
              "delegate_dataset": {
                "description": "Whether to delegate a ZFS dataset to an OS VM.",
                "$ref": "#/definitions/ansible_truth"
              },
              "firewall_enabled": {
                "description": "Enables the firewall, allowing fwadm(1M) rules to be applied.",
                "$ref": "#/definitions/ansible_truth"
              },
              "mdata_exec_timeout": {
                "description": "Timeout in seconds (or 0 to disable) for the C(svc:/smartdc/mdata:execute) service that runs user-scripts in the zone.",
                "$ref": "#/definitions/ansible_number"
              },
              "spice_opts": {
                "type": "string",
                "description": "Addition options for SPICE-enabled KVM VMs."
              },
              "nics": {
                "description": "A list of nics to add, valid properties are documented in vmadm(1M).",
                "$ref": "#/definitions/ansible_array"
              },
              "hostname": {
                "type": "string",
                "description": "Zone/VM hostname."
              },
              "boot": {
                "type": "string",
                "description": "Set the boot order for KVM VMs."
              },
              "vga": {
                "type": "string",
                "description": "Specify VGA emulation used by KVM VMs."
              },
              "zfs_snapshot_limit": {
                "description": "Number of snapshots the VM can have.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "running",
                  "absent",
                  "deleted",
                  "stopped",
                  "created",
                  "restarted",
                  "rebooted"
                ],
                "type": "string",
                "description": "States for the VM to be in. Please note that C(present), C(stopped) and C(restarted) operate on a VM that is currently provisioned. C(present) means that the VM will be created if it was absent, and that it will be in a running state. C(absent) will shutdown the zone before removing it. C(stopped) means the zone will be created if it doesn't exist already, before shutting it down."
              },
              "limit_priv": {
                "type": "string",
                "description": "Set (comma separated) list of privileges the zone is allowed to use."
              },
              "cpu_cap": {
                "description": "Sets a limit on the amount of CPU time that can be used by a VM. Use C(0) for no cap.",
                "$ref": "#/definitions/ansible_number"
              },
              "maintain_resolvers": {
                "description": "Resolvers in C(/etc/resolv.conf) will be updated when updating the I(resolvers) property.",
                "$ref": "#/definitions/ansible_truth"
              },
              "zfs_data_recsize": {
                "description": "Suggested block size (power of 2) for files in the delegated dataset's filesystem.",
                "$ref": "#/definitions/ansible_number"
              },
              "qemu_extra_opts": {
                "type": "string",
                "description": "Additional qemu cmdline arguments for KVM guests."
              },
              "vnc_password": {
                "type": "string",
                "description": "Password required to connect to VNC. By default no password is set. Please note this can be read from the Global Zone."
              },
              "nowait": {
                "description": "Consider the provisioning complete when the VM first starts, rather than when the VM has rebooted.",
                "$ref": "#/definitions/ansible_truth"
              },
              "zfs_root_recsize": {
                "description": "Suggested block size (power of 2) for files in the zoneroot dataset's filesystem.",
                "$ref": "#/definitions/ansible_number"
              },
              "brand": {
                "enum": [
                  "joyent",
                  "joyent-minimal",
                  "kvm",
                  "lx"
                ],
                "type": "string",
                "description": "Default: joyent\n\nType of virtual machine."
              },
              "zfs_filesystem_limit": {
                "description": "Maximum number of filesystems the VM can have.",
                "$ref": "#/definitions/ansible_number"
              },
              "quota": {
                "description": "Quota on zone filesystems (in MiBs).",
                "$ref": "#/definitions/ansible_number"
              },
              "filesystems": {
                "description": "Mount additional filesystems into an OS VM.",
                "$ref": "#/definitions/ansible_array"
              },
              "autoboot": {
                "description": "Whether or not a VM is booted when the system is rebooted.",
                "$ref": "#/definitions/ansible_truth"
              },
              "max_swap": {
                "description": "Maximum amount of virtual memory (in MiBs) the VM is allowed to use.",
                "$ref": "#/definitions/ansible_number"
              },
              "tmpfs": {
                "description": "Amount of memory (in MiBs) that will be available in the VM for the C(/tmp) filesystem.",
                "$ref": "#/definitions/ansible_number"
              },
              "indestructible_delegated": {
                "description": "Adds an C(@indestructible) snapshot to delegated datasets.",
                "$ref": "#/definitions/ansible_truth"
              },
              "resolvers": {
                "description": "List of resolvers to be put into C(/etc/resolv.conf).",
                "$ref": "#/definitions/ansible_array"
              },
              "max_lwps": {
                "description": "Maximum number of lightweight processes this VM is allowed to have running.",
                "$ref": "#/definitions/ansible_number"
              },
              "vnc_port": {
                "description": "TCP port to listen of the VNC server. Or set C(0) for random, or C(-1) to disable.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "Name of the VM. vmadm(1M) uses this as an optional name."
              },
              "routes": {
                "type": "object",
                "description": "Dictionary that maps destinations to gateways, these will be set as static routes in the VM."
              },
              "kernel_version": {
                "type": "string",
                "description": "Kernel version to emulate for LX VMs."
              },
              "max_locked_memory": {
                "description": "Total amount of memory (in MiBs) on the host that can be locked by this VM.",
                "$ref": "#/definitions/ansible_number"
              },
              "disks": {
                "description": "A list of disks to add, valid properties are documented in vmadm(1M).",
                "$ref": "#/definitions/ansible_array"
              },
              "uuid": {
                "type": "string",
                "description": "UUID of the VM. Can either be a full UUID or C(*) for all VMs."
              },
              "internal_metadata_namespace": {
                "type": "string",
                "description": "List of namespaces to be set as I(internal_metadata-only); these namespaces will come from I(internal_metadata) rather than I(customer_metadata)."
              },
              "virtio_txburst": {
                "description": "Number of packets that can be sent in a single flush of the tx queue of virtio NICs.",
                "$ref": "#/definitions/ansible_number"
              },
              "alias": {
                "type": "string",
                "description": "Name of the VM. vmadm(1M) uses this as an optional name."
              },
              "vcpus": {
                "description": "Number of virtual CPUs for a KVM guest.",
                "$ref": "#/definitions/ansible_number"
              },
              "internal_metadata": {
                "type": "object",
                "description": "Metadata to be set and associated with this VM, this contains operator generated keys."
              },
              "cpu_type": {
                "enum": [
                  "qemu64",
                  "host"
                ],
                "type": "string",
                "description": "Default: qemu64\n\nControl the type of virtual CPU exposed to KVM VMs."
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "zpool": {
                "type": "string",
                "description": "ZFS pool the VM's zone dataset will be created in."
              },
              "cpu_shares": {
                "description": "Sets a limit on the number of fair share scheduler (FSS) CPU shares for a VM. This limit is relative to all other VMs on the system.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "git": {
            "type": "object",
            "description": "Manage I(git) checkouts of repositories to deploy files or software.",
            "properties": {
              "depth": {
                "type": "string",
                "description": "Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly."
              },
              "executable": {
                "type": "string",
                "description": "Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
              },
              "refspec": {
                "type": "string",
                "description": "Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the 'git fetch' command. An example value could be \"refs/meta/config\"."
              },
              "force": {
                "type": "string",
                "description": "Default: no\n\nIf C(yes), any modified files in the working repository will be discarded.  Prior to 0.7, this was always 'yes' and could not be disabled.  Prior to 1.9, the default was `yes`"
              },
              "track_submodules": {
                "type": "string",
                "description": "Default: no\n\nif C(yes), submodules will track the latest commit on their master branch (or other branch specified in .gitmodules).  If C(no), submodules will be kept at the revision specified by the main project. This is equivalent to specifying the --remote flag to git submodule update."
              },
              "reference": {
                "type": "string",
                "description": "Reference repository (see \"git clone --reference ...\")"
              },
              "dest": {
                "type": "string",
                "description": "The path of where the repository should be checked out. This parameter is required, unless C(clone) is set to C(no)."
              },
              "verify_commit": {
                "type": "string",
                "description": "Default: no\n\nif C(yes), when cloning or checking out a C(version) verify the signature of a GPG signed commit. This requires C(git) version>=2.1.0 to be installed. The commit MUST be signed and the public key MUST be trusted in the GPG trustdb."
              },
              "clone": {
                "type": "string",
                "description": "Default: yes\n\nIf C(no), do not clone the repository if it does not exist locally"
              },
              "accept_hostkey": {
                "type": "string",
                "description": "Default: no\n\nif C(yes), adds the hostkey for the repo url if not already added. If ssh_opts contains \"-o StrictHostKeyChecking=no\", this parameter is ignored."
              },
              "update": {
                "type": "string",
                "description": "Default: yes\n\nIf C(no), do not retrieve new revisions from the origin repository"
              },
              "ssh_opts": {
                "type": "string",
                "description": "Default: None\n\nCreates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be \"-o StrictHostKeyChecking=no\""
              },
              "repo": {
                "type": "string",
                "description": "git, SSH, or HTTP(S) protocol address of the git repository."
              },
              "umask": {
                "type": "string",
                "description": "The umask to set before doing any checkouts, or any other repository maintenance."
              },
              "version": {
                "type": "string",
                "description": "Default: HEAD\n\nWhat version of the repository to check out.  This can be the the literal string C(HEAD), a branch name, a tag name. It can also be a I(SHA-1) hash, in which case C(refspec) needs to be specified if the given revision is not already available."
              },
              "bare": {
                "type": "string",
                "description": "Default: no\n\nif C(yes), repository will be created as a bare repo, otherwise it will be a standard repo with a workspace."
              },
              "remote": {
                "type": "string",
                "description": "Default: origin\n\nName of the remote."
              },
              "key_file": {
                "type": "string",
                "description": "Default: None\n\nSpecify an optional private key file to use for the checkout."
              },
              "recursive": {
                "type": "string",
                "description": "Default: yes\n\nif C(no), repository will be cloned without the --recursive option, skipping sub-modules."
              }
            }
          },
          "azure_rm_virtualnetwork_facts": {
            "type": "object",
            "description": "Get facts for a specific virtual network or all virtual networks within a resource group.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Only show results for a specific security group."
              },
              "resource_group": {
                "type": "string",
                "description": "Limit results by resource group. Required when filtering by name."
              },
              "tags": {
                "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
                "$ref": "#/definitions/ansible_array"
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "cnos_command": {
            "type": "object",
            "description": "This module allows you to modify the switch running configuration. It provides a way to execute a single CNOS command on a switch by evaluating the current running configuration and executing the command only if the specific setting has not been already configured. The CNOS command is passed as an argument of the method. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run. For more information about this module from Lenovo and customizing it usage for your use cases, please visit U(http://systemx.lenovofiles.com/help/index.jsp?topic=%2Fcom.lenovo.switchmgt.ansible.doc%2Fcnos_command.html)",
            "properties": {
              "clicommand": {
                "type": "string",
                "description": "This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory."
              }
            }
          },
          "vmware_vswitch": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add a VMware Standard Switch to an ESXi host",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "mtu": {
                "description": "MTU to configure on vswitch",
                "$ref": "#/definitions/ansible_number"
              },
              "nic_name": {
                "type": "string",
                "description": "vmnic name to attach to vswitch"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nAdd or remove the switch"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "number_of_ports": {
                "description": "Default: 128\n\nNumber of port to configure on vswitch",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "switch_name": {
                "type": "string",
                "description": "vSwitch name to add"
              }
            }
          },
          "ec2_vpc_nacl_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about Network ACLs in an AWS VPC",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "nacl_ids": {
                "description": "A list of Network ACL IDs to retrieve facts about.",
                "$ref": "#/definitions/ansible_array"
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See       U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html) for possible filters. Filter       names and values are case sensitive."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "netapp_e_volume": {
            "required": [
              "ssid",
              "name",
              "state"
            ],
            "type": "object",
            "description": "Create or remove volumes (standard and thin) for NetApp E/EF-series storage arrays.",
            "properties": {
              "segment_size_kb": {
                "description": "Default: 512\n\nThe segment size of the new volume",
                "$ref": "#/definitions/ansible_number"
              },
              "ssd_cache_enabled": {
                "description": "Default: None (ignores existing SSD cache setting)\n\nWhether an existing SSD cache should be enabled on the volume (fails if no SSD cache defined)",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssid": {
                "type": "string",
                "description": "The ID of the array to manage (as configured on the web services proxy)."
              },
              "data_assurance_enabled": {
                "description": "If data assurance should be enabled for the volume",
                "$ref": "#/definitions/ansible_truth"
              },
              "thin_provision": {
                "description": "Whether the volume should be thin provisioned.  Thin volumes can only be created on disk pools (raidDiskPool).",
                "$ref": "#/definitions/ansible_truth"
              },
              "log_path": {
                "type": "string",
                "description": ""
              },
              "api_password": {
                "type": "string",
                "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "size_unit": {
                "enum": [
                  "bytes",
                  "b",
                  "kb",
                  "mb",
                  "gb",
                  "tb",
                  "pb",
                  "eb",
                  "zb",
                  "yb"
                ],
                "type": "string",
                "description": "Default: gb\n\nThe unit used to interpret the size parameter"
              },
              "name": {
                "type": "string",
                "description": "The name of the volume to manage"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Whether the specified volume should exist or not."
              },
              "storage_pool_name": {
                "type": "string",
                "description": "Required only when requested state is 'present'.  The name of the storage pool the volume should exist on."
              },
              "thin_volume_max_repo_size": {
                "description": "Default: same as size (in size_unit)\n\nMaximum size that the thin volume repository volume will automatically expand to",
                "$ref": "#/definitions/ansible_number"
              },
              "api_username": {
                "type": "string",
                "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
              },
              "thin_volume_repo_size": {
                "description": "Initial size of the thin volume repository volume (in size_unit)",
                "$ref": "#/definitions/ansible_number"
              },
              "size": {
                "description": "Required only when state = 'present'.  The size of the volume in (size_unit).",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
              }
            }
          },
          "vertica_schema": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "create_roles",
                        "create_role"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "usage_roles",
                        "usage_role"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "schema",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "schema"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Adds or removes Vertica database schema and, optionally, roles with schema access privileges.\nA schema will not be removed until all the objects have been dropped.\nIn such a situation, if the module tries to remove the schema it will fail and only remove roles created for the schema if they have no dependencies.",
            "properties": {
              "create_roles": {
                "type": "string",
                "description": "Comma separated list of roles to create and grant usage and create access to the schema."
              },
              "name": {
                "type": "string",
                "description": "Name of the schema to add or remove."
              },
              "login_user": {
                "type": "string",
                "description": "Default: dbadmin\n\nThe username used to authenticate with."
              },
              "db": {
                "type": "string",
                "description": "Name of the Vertica database."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to create C(present), or drop C(absent) a schema."
              },
              "usage_roles": {
                "type": "string",
                "description": "Comma separated list of roles to create and grant usage access to the schema."
              },
              "cluster": {
                "type": "string",
                "description": "Default: localhost\n\nName of the Vertica cluster."
              },
              "usage_role": {
                "type": "string",
                "description": "Comma separated list of roles to create and grant usage access to the schema."
              },
              "create_role": {
                "type": "string",
                "description": "Comma separated list of roles to create and grant usage and create access to the schema."
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with."
              },
              "owner": {
                "type": "string",
                "description": "Name of the user to set as owner of the schema."
              },
              "port": {
                "type": "string",
                "description": "Default: 5433\n\nVertica cluster port to connect to."
              },
              "schema": {
                "type": "string",
                "description": "Name of the schema to add or remove."
              }
            }
          },
          "win_firewall_rule": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "allows you to create/remove/update firewall rules",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nshould this rule be added or removed"
              },
              "names": {
                "type": "string",
                "description": "the rules name"
              },
              "name": {
                "type": "string",
                "description": "the rules name"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vmware_vm_shell": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Start a program in a VM without the need for network connection",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "vm_shell_env": {
                "description": "Default: None\n\nComma seperated list of envirnoment variable, specified in the guest OS notation",
                "$ref": "#/definitions/ansible_array"
              },
              "vm_password": {
                "type": "string",
                "description": "Default: None\n\nThe password used to login to the VM."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "vm_shell_cwd": {
                "type": "string",
                "description": "Default: None\n\nThe current working directory of the application from which it will be run"
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "vm_shell_args": {
                "type": "string",
                "description": "Default: None\n\nThe argument to the program."
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "vm_username": {
                "type": "string",
                "description": "Default: None\n\nThe user to connect to the VM."
              },
              "vm_shell": {
                "type": "string",
                "description": "The absolute path to the program to start. On Linux this is executed via bash."
              },
              "cluster": {
                "type": "string",
                "description": "Default: None\n\nThe cluster hosting the VM\nWill help speed up search"
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "vm_id_type": {
                "enum": [
                  "uuid",
                  "dns_name",
                  "inventory_path",
                  "vm_name"
                ],
                "type": "string",
                "description": "Default: vm_name\n\nThe identification tag for the VM"
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "datacenter": {
                "type": "string",
                "description": "Default: None\n\nThe datacenter hosting the VM\nWill help speed up search"
              },
              "vm_id": {
                "type": "string",
                "description": "The identification for the VM"
              }
            }
          },
          "urpmi": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "no_recommends",
                        "no-recommends"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "package",
                        "pkg",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "package"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages packages with I(urpmi) (such as for Mageia or Mandriva)",
            "properties": {
              "force": {
                "description": "Default: True\n\nAssume \"yes\" is the answer to any question urpmi has to ask. Corresponds to the C(--force) option for I(urpmi).",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "name of package to install, upgrade or remove."
              },
              "package": {
                "type": "string",
                "description": "name of package to install, upgrade or remove."
              },
              "state": {
                "enum": [
                  "installed",
                  "removed",
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicates the desired package state"
              },
              "no-recommends": {
                "description": "Default: True\n\nCorresponds to the C(--no-recommends) option for I(urpmi).",
                "$ref": "#/definitions/ansible_truth"
              },
              "update_cache": {
                "description": "update the package database first C(urpmi.update -a).",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "type": "string",
                "description": "name of package to install, upgrade or remove."
              },
              "update-cache": {
                "description": "update the package database first C(urpmi.update -a).",
                "$ref": "#/definitions/ansible_truth"
              },
              "no_recommends": {
                "description": "Default: True\n\nCorresponds to the C(--no-recommends) option for I(urpmi).",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "proxysql_replication_hostgroups": {
            "required": [
              "reader_hostgroup",
              "writer_hostgroup"
            ],
            "type": "object",
            "description": "Each row in mysql_replication_hostgroups represent a pair of writer_hostgroup and reader_hostgroup. ProxySQL will monitor the value of read_only for all the servers in specified hostgroups, and based on the value of read_only will assign the server to the writer or reader hostgroups.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Text field that can be used for any purposed defined by the user."
              },
              "login_port": {
                "description": "Default: 6032\n\nThe port used to connect to ProxySQL admin interface.",
                "$ref": "#/definitions/ansible_number"
              },
              "reader_hostgroup": {
                "description": "Id of the reader hostgroup.",
                "$ref": "#/definitions/ansible_number"
              },
              "config_file": {
                "type": "string",
                "description": "Specify a config file from which login_user and login_password are to be read."
              },
              "login_user": {
                "type": "string",
                "description": "Default: None\n\nThe username used to authenticate to ProxySQL admin interface."
              },
              "login_host": {
                "type": "string",
                "description": "Default: 127.0.0.1\n\nThe host used to connect to ProxySQL admin interface."
              },
              "login_password": {
                "type": "string",
                "description": "Default: None\n\nThe password used to authenticate to ProxySQL admin interface."
              },
              "writer_hostgroup": {
                "description": "Id of the writer hostgroup.",
                "$ref": "#/definitions/ansible_number"
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhen C(present) - adds the replication hostgroup, when C(absent) - removes the replication hostgroup."
              },
              "load_to_runtime": {
                "description": "Default: True\n\nDynamically load mysql host config to runtime memory.",
                "$ref": "#/definitions/ansible_truth"
              },
              "save_to_disk": {
                "description": "Default: True\n\nSave mysql host config to sqlite db on disk to persist the configuration.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vsphere_guest": {
            "required": [
              "guest"
            ],
            "type": "object",
            "description": "Create/delete/reconfigure a guest VM through VMware vSphere. This module has a dependency on pysphere >= 1.7",
            "properties": {
              "resource_pool": {
                "type": "string",
                "description": "Default: None\n\nThe name of the resource_pool to create the VM in."
              },
              "vm_hw_version": {
                "type": "string",
                "description": "Desired hardware version identifier (for example, \"vmx-08\" for vms that needs to be managed with vSphere Client). Note that changing hardware version of existing vm is not supported."
              },
              "vcenter_hostname": {
                "type": "string",
                "description": "The hostname of the vcenter server the module will connect to, to create the guest."
              },
              "force": {
                "description": "Default: no\n\nBoolean. Allows you to run commands which may alter the running state of a guest. Also used to reconfigure and destroy.",
                "$ref": "#/definitions/ansible_truth"
              },
              "guest": {
                "type": "string",
                "description": "The virtual server name you wish to manage."
              },
              "vm_disk": {
                "type": "object",
                "description": "A key, value list of disks and their sizes and which datastore to keep it in."
              },
              "esxi": {
                "type": "object",
                "description": "Dictionary which includes datacenter and hostname on which the VM should be created. For standalone ESXi hosts, ha-datacenter should be used as the datacenter name"
              },
              "vm_nic": {
                "type": "object",
                "description": "A key, value list of nics, their types and what network to put them on."
              },
              "vm_hardware": {
                "type": "object",
                "description": "A key, value list of VM config settings. Must include ['memory_mb', 'num_cpus', 'osid', 'scsi']."
              },
              "from_template": {
                "description": "Specifies if the VM should be deployed from a template (mutually exclusive with 'state' parameter). No guest customization changes to hardware such as CPU, RAM, NICs or Disks can be applied when launching from template.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": "Username to connect to vcenter as."
              },
              "cluster": {
                "type": "string",
                "description": "Default: None\n\nThe name of the cluster to create the VM in. By default this is derived from the host you tell the module to build the guest on."
              },
              "state": {
                "enum": [
                  "present",
                  "powered_off",
                  "absent",
                  "powered_on",
                  "restarted",
                  "reconfigured"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the vm. 'reconfigured' only applies changes to 'vm_cdrom', 'memory_mb', and 'num_cpus' in vm_hardware parameter. The 'memory_mb' and 'num_cpus' changes are applied to powered-on vms when hot-plugging is enabled for the guest."
              },
              "vmware_guest_facts": {
                "description": "Gather facts from vCenter on a particular VM",
                "$ref": "#/definitions/ansible_truth"
              },
              "vm_extra_config": {
                "type": "object",
                "description": "A key, value pair of any extra values you want set or changed in the vmx file of the VM. Useful to set advanced options on the VM."
              },
              "power_on_after_clone": {
                "description": "Default: True\n\nSpecifies if the VM should be powered on after the clone.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "Password of the user to connect to vcenter as."
              },
              "validate_certs": {
                "description": "Default: True\n\nValidate SSL certs.  Note, if running on python without SSLContext support (typically, python < 2.7.9) you will have to set this to C(no) as pysphere does not support validating certificates on older python. Prior to 2.1, this module would always validate on python >= 2.7.9 and never validate on python <= 2.7.8.",
                "$ref": "#/definitions/ansible_truth"
              },
              "template_src": {
                "type": "string",
                "description": "Default: None\n\nName of the source template to deploy from"
              },
              "snapshot_to_clone": {
                "type": "string",
                "description": "Default: none\n\nA string that when specified, will create a linked clone copy of the VM. Snapshot must already be taken in vCenter."
              }
            }
          },
          "ovirt_hosts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "public_key",
                        "ssh_public_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage hosts in oVirt",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Description of the host."
              },
              "public_key": {
                "description": "I(True) if the public key should be used to authenticate to host.\nIt's required in case C(password) is not set.",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "Password of the root. It's required in case C(public_key) is set to I(False)."
              },
              "force": {
                "description": "If True host will be forcibly moved to desired state.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the the host to manage."
              },
              "kernel_params": {
                "description": "List of kernel boot parameters.\nFollowing are most common kernel parameters used for host:\nHostdev Passthrough & SR-IOV: intel_iommu=on\nNested Virtualization: kvm-intel.nested=1\nUnsafe Interrupts: vfio_iommu_type1.allow_unsafe_interrupts=1\nPCI Reallocation: pci=realloc\nC(Note:)\nModifying kernel boot parameters settings can lead to a host boot failure. Please consult the product documentation before doing any changes.\nKernel boot parameters changes require host deploy and restart. The host needs to be I(reinstalled) suceesfully and then to be I(rebooted) for kernel boot parameters to be applied.",
                "$ref": "#/definitions/ansible_array"
              },
              "spm_priority": {
                "description": "SPM priority of the host. Integer value from 1 to 10, where higher number means higher priority.",
                "$ref": "#/definitions/ansible_number"
              },
              "hosted_engine": {
                "enum": [
                  "deploy",
                  "undeploy"
                ],
                "type": "string",
                "description": "If I(deploy) it means this host should deploy also hosted engine components.\nIf I(undeploy) it means this host should un-deploy hosted engine components and this host will not function as part of the High Availability cluster."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "maintenance",
                  "upgraded",
                  "started",
                  "restarted",
                  "stopped",
                  "reinstalled"
                ],
                "type": "string",
                "description": "Default: present\n\nState which should a host to be in after successful completion."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "cluster": {
                "type": "string",
                "description": "Name of the cluster, where host should be created."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_public_key": {
                "description": "I(True) if the public key should be used to authenticate to host.\nIt's required in case C(password) is not set.",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "address": {
                "type": "string",
                "description": "Host address. It can be either FQDN (preferred) or IP address."
              },
              "override_iptables": {
                "description": "If True host iptables will be overridden by host deploy script.\nNote that C(override_iptables) is I(false) by default in oVirt.",
                "$ref": "#/definitions/ansible_truth"
              },
              "kdump_integration": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enabled\n\nSpecify if host will have enabled Kdump integration."
              },
              "override_display": {
                "type": "string",
                "description": "Override the display address of all VMs on this host with specified address."
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ipadm_addrprop": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "property",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "property"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "addrobj",
                        "nic, interface"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "addrobj"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "nic, interface"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Modify IP address properties on Solaris/illumos systems.",
            "properties": {
              "temporary": {
                "description": "Specifies that the address property value is temporary. Temporary values do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Specifies the name of the address property we want to manage."
              },
              "nic, interface": {
                "type": "string",
                "description": "Specifies the address object we want to manage."
              },
              "value": {
                "type": "string",
                "description": "Specifies the value we want to set for the address property."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "reset"
                ],
                "type": "string",
                "description": "Default: present\n\nSet or reset the property value."
              },
              "property": {
                "type": "string",
                "description": "Specifies the name of the address property we want to manage."
              },
              "addrobj": {
                "type": "string",
                "description": "Specifies the address object we want to manage."
              }
            }
          },
          "win_group": {
            "type": "object",
            "description": "Add and remove local groups",
            "properties": {
              "state": {
                "type": "string",
                "description": "Default: present\n\nCreate or remove the group"
              },
              "name": {
                "type": "string",
                "description": "Name of the group"
              },
              "description": {
                "type": "string",
                "description": "Description of the group"
              }
            }
          },
          "infini_host": {
            "type": "object",
            "description": "This module creates, deletes or modifies hosts on Infinibox.",
            "properties": {
              "volume": {
                "type": "string",
                "description": "Volume name to map to the host"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nCreates/Modifies Host when present or removes when absent"
              },
              "name": {
                "type": "string",
                "description": "Host Name"
              },
              "wwns": {
                "type": "string",
                "description": "List of wwns of the host"
              }
            }
          },
          "nxos_aaa_server_host": {
            "required": [
              "server_type",
              "address"
            ],
            "type": "object",
            "description": "Manages AAA server host-specific configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "key": {
                "type": "string",
                "description": "Shared secret for the specified host."
              },
              "server_type": {
                "enum": [
                  "radius",
                  "tacacs"
                ],
                "type": "string",
                "description": "The server type is either radius or tacacs."
              },
              "encrypt_type": {
                "enum": [
                  "0",
                  "7"
                ],
                "type": "string",
                "description": "The state of encryption applied to the entered key. O for clear text, 7 for encrypted. Type-6 encryption is not supported."
              },
              "address": {
                "type": "string",
                "description": "Address or name of the radius or tacacs host."
              },
              "auth_port": {
                "type": "string",
                "description": "Alternate UDP port for RADIUS authentication."
              },
              "host_timeout": {
                "type": "string",
                "description": "Timeout period for specified host, in seconds. Range is 1-60."
              },
              "tacacs_port": {
                "type": "string",
                "description": "Alternate TCP port TACACS Server."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "acct_port": {
                "type": "string",
                "description": "Alternate UDP port for RADIUS accounting."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "getent": {
            "required": [
              "database"
            ],
            "type": "object",
            "description": "Runs getent against one of it's various databases and returns information into the host's facts, in a getent_<database> prefixed variable",
            "properties": {
              "fail_key": {
                "description": "Default: True\n\nIf a supplied key is missing this will make the task fail if True",
                "$ref": "#/definitions/ansible_truth"
              },
              "split": {
                "type": "string",
                "description": "Default: None\n\ncharacter used to split the database values into lists/arrays such as ':' or '\t', otherwise  it will try to pick one depending on the database"
              },
              "key": {
                "type": "string",
                "description": "key from which to return values from the specified database, otherwise the full contents are returned."
              },
              "database": {
                "type": "string",
                "description": "the name of a getent database supported by the target system (passwd, group, hosts, etc)."
              }
            }
          },
          "vca_vapp": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "passwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "passwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module will actively managed vCloud Air vApp instances.  Instances can be created and deleted as well as both deployed and undeployed.",
            "properties": {
              "vm_name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the virtual machine instance in the vApp to manage."
              },
              "vm_memory": {
                "type": "string",
                "description": "Default: None\n\nThe amount of memory in MB to allocate to VMs in the vApp.  If the I(vm_name) argument is provided, then this becomes a per VM setting otherise it is applied to all VMs in the vApp."
              },
              "gateway_name": {
                "type": "string",
                "description": ""
              },
              "template_name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the vApp template to use to create the vApp instance.  If the I(state) is not `absent` then the I(template_name) value must be provided.  The I(template_name) must be previously uploaded to the catalog specified by I(catalog_name)"
              },
              "pass": {
                "type": "string",
                "description": "Default: None\n\nThe vCloud Air password to use during authentication"
              },
              "operation": {
                "enum": [
                  "noop",
                  "poweron",
                  "poweroff",
                  "suspend",
                  "shutdown",
                  "reboot",
                  "reset"
                ],
                "type": "string",
                "description": "Default: noop\n\nSpecifies an operation to be performed on the vApp."
              },
              "network_name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the network that should be attached to the virtual machine in the vApp.  The virtual network specified must already be created in the vCloud Air VDC.  If the I(state) is not 'absent' then the I(network_name) argument must be provided."
              },
              "vdc_name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the virtual data center (VDC) where the vm should be created or contains the vAPP."
              },
              "vm_cpus": {
                "type": "string",
                "description": "Default: None\n\nThe number of vCPUs to configure for the VM in the vApp.   If the I(vm_name) argument is provided, then this becomes a per VM setting otherwise it is applied to all VMs in the vApp."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "deployed",
                  "undeployed"
                ],
                "type": "string",
                "description": "Default: present\n\nConfigures the state of the vApp."
              },
              "service_type": {
                "enum": [
                  "vca",
                  "vchs",
                  "vcd"
                ],
                "type": "string",
                "description": "Default: vca\n\nThe type of service we are authenticating against"
              },
              "api_version": {
                "type": "string",
                "description": "Default: 5.7\n\nThe api version to be used with the vca"
              },
              "username": {
                "type": "string",
                "description": "Default: None\n\nThe vCloud Air username to use during authentication"
              },
              "passwd": {
                "type": "string",
                "description": "Default: None\n\nThe vCloud Air password to use during authentication"
              },
              "catalog_name": {
                "type": "string",
                "description": ""
              },
              "network_mode": {
                "enum": [
                  "pool",
                  "dhcp",
                  "static"
                ],
                "type": "string",
                "description": "Default: pool\n\nConfigures the mode of the network connection."
              },
              "vapp_name": {
                "type": "string",
                "description": "The name of the vCloud Air vApp instance"
              },
              "user": {
                "type": "string",
                "description": "Default: None\n\nThe vCloud Air username to use during authentication"
              },
              "org": {
                "type": "string",
                "description": "Default: None\n\nThe org to login to for creating vapp, mostly set when the service_type is vdc."
              },
              "password": {
                "type": "string",
                "description": "Default: None\n\nThe vCloud Air password to use during authentication"
              },
              "host": {
                "type": "string",
                "description": "Default: None\n\nThe authentication host to be used when service type  is vcd."
              },
              "instance_id": {
                "type": "string",
                "description": "Default: None\n\nThe instance id in a vchs environment to be used for creating the vapp"
              },
              "service_id": {
                "type": "string",
                "description": ""
              },
              "verify_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "lambda_event": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "lambda_function_arn",
                        "function_name",
                        "function_arn"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "lambda_function_arn"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "function_name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "function_arn"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module allows the management of AWS Lambda function event source mappings such as DynamoDB and Kinesis stream events via the Ansible framework. These event source mappings are relevant only in the AWS Lambda pull model, where AWS Lambda invokes the function. It is idempotent and supports \"Check\" mode.  Use module M(lambda) to manage the lambda function itself and M(lambda_alias) to manage function aliases.",
            "properties": {
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "event_source": {
                "enum": [
                  "stream"
                ],
                "type": "string",
                "description": "Default: stream\n\nSource of the event that triggers the lambda function."
              },
              "function_arn": {
                "type": "string",
                "description": "The name or ARN of the lambda function."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDescribes the desired state."
              },
              "version": {
                "description": "Version of the Lambda function. Mutually exclusive with C(alias).",
                "$ref": "#/definitions/ansible_number"
              },
              "function_name": {
                "type": "string",
                "description": "The name or ARN of the lambda function."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "source_params": {
                "type": "object",
                "description": "Sub-parameters required for event source.\nI(== stream event source ==)\nC(source_arn) The Amazon Resource Name (ARN) of the Kinesis or DynamoDB stream that is the event source.\nC(enabled) Indicates whether AWS Lambda should begin polling the event source. Default is True.\nC(batch_size) The largest number of records that AWS Lambda will retrieve from your event source at the time of invoking your function. Default is 100.\nC(starting_position) The position in the stream where AWS Lambda should start reading. Choices are TRIM_HORIZON or LATEST."
              },
              "lambda_function_arn": {
                "type": "string",
                "description": "The name or ARN of the lambda function."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "alias": {
                "type": "string",
                "description": "Name of the function alias. Mutually exclusive with C(version)."
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ipmi_power": {
            "required": [
              "state",
              "name",
              "password",
              "user"
            ],
            "type": "object",
            "description": "Use this module for power management",
            "properties": {
              "name": {
                "type": "string",
                "description": "Hostname or ip address of the BMC."
              },
              "state": {
                "enum": [
                  "on",
                  "off",
                  "shutdown",
                  "reset",
                  "boot"
                ],
                "type": "string",
                "description": "Whether to ensure that the machine in desired state."
              },
              "user": {
                "type": "string",
                "description": "Username to use to connect to the BMC."
              },
              "timeout": {
                "description": "Default: 300\n\nMaximum number of seconds before interrupt request.",
                "$ref": "#/definitions/ansible_number"
              },
              "password": {
                "type": "string",
                "description": "Password to connect to the BMC."
              },
              "port": {
                "description": "Default: 623\n\nRemote RMCP port.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "ovirt_disks": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "alias"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage Virtual Machine and floating disks in oVirt.",
            "properties": {
              "vm_name": {
                "type": "string",
                "description": "Name of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached)."
              },
              "profile": {
                "type": "string",
                "description": "Disk profile name to be attached to disk. By default profile is chosen by oVirt engine."
              },
              "storage_domain": {
                "type": "string",
                "description": "Storage domain name where disk should be created. By default storage is chosen by oVirt engine."
              },
              "name": {
                "type": "string",
                "description": "Name of the disk to manage. Either C(id) or C(name)/C(alias) is required."
              },
              "allocation_policy": {
                "type": "string",
                "description": ""
              },
              "format": {
                "enum": [
                  "raw",
                  "cow"
                ],
                "type": "string",
                "description": "Format of the disk. Either copy-on-write or raw."
              },
              "bootable": {
                "description": "I(True) if the disk should be bootable. By default when disk is created it isn't bootable.",
                "$ref": "#/definitions/ansible_truth"
              },
              "logical_unit": {
                "type": "object",
                "description": "Dictionary which describes LUN to be directly attached to VM:\nC(address) - Address of the storage server. Used by iSCSI.\nC(port) - Port of the storage server. Used by iSCSI.\nC(target) - iSCSI target.\nC(lun_id) - LUN id.\nC(username) - CHAP Username to be used to access storage server. Used by iSCSI.\nC(password) - CHAP Password of the user to be used to access storage server. Used by iSCSI.\nC(storage_type) - Storage type either I(fcp) or I(iscsi)."
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "attached",
                  "detached"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the Virtual Machine disk be present/absent/attached/detached."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "alias": {
                "type": "string",
                "description": "Name of the disk to manage. Either C(id) or C(name)/C(alias) is required."
              },
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "shareable": {
                "description": "I(True) if the disk should be shareable. By default when disk is created it isn't shareable.",
                "$ref": "#/definitions/ansible_truth"
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "interface": {
                "type": "string",
                "description": "Default: virtio\n\nDriver of the storage interface."
              },
              "size": {
                "type": "string",
                "description": "Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc."
              },
              "vm_id": {
                "type": "string",
                "description": "ID of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached)."
              },
              "id": {
                "type": "string",
                "description": "ID of the disk to manage. Either C(id) or C(name) is required."
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "bigip_gtm_virtual_server": {
            "type": "object",
            "description": "Manages F5 BIG-IP GTM virtual servers",
            "properties": {
              "host": {
                "type": "string",
                "description": "Default: None\n\nVirtual server host"
              },
              "virtual_server_name": {
                "type": "string",
                "description": "Virtual server name"
              },
              "virtual_server_server": {
                "type": "string",
                "description": "Virtual server server"
              },
              "port": {
                "type": "string",
                "description": "Default: None\n\nVirtual server port"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nVirtual server state"
              }
            }
          },
          "ios_vrf": {
            "type": "object",
            "description": "This module provides declarative management of VRF definitions on Cisco IOS devices.  It allows playbooks to manage individual or the entire VRF collection.  It also supports purging VRF definitions from the configuration that are not explicitly defined.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF."
              },
              "rd": {
                "type": "string",
                "description": "The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values."
              },
              "interfaces": {
                "description": "Identifies the set of interfaces that should be configured in the VRF.  Interfaces must be routed interfaces in order to be placed into a VRF.",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nConfigures the state of the VRF definition as it relates to the device operational configuration.  When set to I(present), the VRF should be configured in the device active configuration and when set to I(absent) the VRF should not be in the device active configuration"
              },
              "purge": {
                "description": "Instructs the module to consider the VRF definition absolute.  It will remove any previously configured VRFs on the device.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "vrfs": {
                "description": "The set of VRF definition objects to be configured on the remote IOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(vrfs) argument"
              }
            }
          },
          "nxos_interface_ospf": {
            "required": [
              "interface",
              "area",
              "ospf"
            ],
            "type": "object",
            "description": "Manages configuration of an OSPF interface instance.",
            "properties": {
              "ospf": {
                "type": "string",
                "description": "Name of the ospf instance."
              },
              "message_digest_encryption_type": {
                "enum": [
                  "cisco_type_7",
                  "3des"
                ],
                "type": "string",
                "description": "Specifies the scheme used for encrypting message_digest_password. Valid values are '3des' or 'cisco_type_7' encryption."
              },
              "dead_interval": {
                "type": "string",
                "description": "Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer or the keyword 'default'."
              },
              "hello_interval": {
                "type": "string",
                "description": "Time between sending successive hello packets. Valid values are an integer or the keyword 'default'."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "area": {
                "type": "string",
                "description": "Ospf area associated with this cisco_interface_ospf instance. Valid values are a string, formatted as an IP address (i.e. \"0.0.0.0\") or as an integer."
              },
              "message_digest_algorithm_type": {
                "enum": [
                  "md5"
                ],
                "type": "string",
                "description": "Algorithm used for authentication among neighboring routers within an area. Valid values is 'md5'."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "passive_interface": {
                "description": "Setting to true will prevent this interface from receiving HELLO packets. Valid values are 'true' and 'false'.",
                "$ref": "#/definitions/ansible_truth"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "message_digest": {
                "description": "Enables or disables the usage of message digest authentication. Valid values are 'true' and 'false'.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "message_digest_password": {
                "type": "string",
                "description": "Specifies the message_digest password. Valid value is a string."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Name of this cisco_interface resource. Valid value is a string."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "message_digest_key_id": {
                "type": "string",
                "description": "Md5 authentication key-id associated with the ospf instance. If this is present, message_digest_encryption_type, message_digest_algorithm_type and message_digest_password are mandatory. Valid value is an integer and 'default'."
              },
              "cost": {
                "type": "string",
                "description": "The cost associated with this cisco_interface_ospf instance."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "hg": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "repo",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "repo"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "revision",
                        "version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages Mercurial (hg) repositories. Supports SSH, HTTP/S and local address.",
            "properties": {
              "repo": {
                "type": "string",
                "description": "The repository address."
              },
              "executable": {
                "type": "string",
                "description": "Path to hg executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
              },
              "force": {
                "description": "Default: no\n\nDiscards uncommitted changes. Runs C(hg update -C).  Prior to 1.9, the default was `yes`.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "The repository address."
              },
              "dest": {
                "type": "string",
                "description": "Absolute path of where the repository should be cloned to. This parameter is required, unless clone and update are set to no"
              },
              "clone": {
                "description": "Default: yes\n\nIf C(no), do not clone the repository if it does not exist locally.",
                "$ref": "#/definitions/ansible_truth"
              },
              "update": {
                "description": "Default: yes\n\nIf C(no), do not retrieve new revisions from the origin repository",
                "$ref": "#/definitions/ansible_truth"
              },
              "purge": {
                "description": "Default: no\n\nDeletes untracked files. Runs C(hg purge).",
                "$ref": "#/definitions/ansible_truth"
              },
              "version": {
                "type": "string",
                "description": "Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag."
              },
              "revision": {
                "type": "string",
                "description": "Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag."
              }
            }
          },
          "win_uri": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Interacts with HTTP and HTTPS web services and supports Digest, Basic and WSSE HTTP authentication mechanisms.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": ""
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "bigip_vlan": {
            "type": "object",
            "description": "Manage VLANs on a BIG-IP system",
            "properties": {
              "description": {
                "type": "string",
                "description": "The description to give to the VLAN."
              },
              "untagged_interfaces": {
                "type": "string",
                "description": "Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nThe state of the VLAN on the system. When C(present), guarantees that the VLAN exists with the provided attributes. When C(absent), removes the VLAN from the system."
              },
              "tag": {
                "type": "string",
                "description": "Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value."
              },
              "tagged_interfaces": {
                "type": "string",
                "description": "Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs."
              },
              "name": {
                "type": "string",
                "description": "The VLAN to manage. If the special VLAN C(ALL) is specified with the C(state) value of C(absent) then all VLANs will be removed."
              }
            }
          },
          "exo_dns_record": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "prio",
                        "priority"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "content",
                        "value",
                        "address"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "record_type",
                        "rtype",
                        "type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, update and delete records.",
            "properties": {
              "content": {
                "type": "string",
                "description": "Content of the record.\nRequired if C(state=present) or C(name=\"\")"
              },
              "domain": {
                "type": "string",
                "description": "Domain the record is related to."
              },
              "multiple": {
                "description": "Whether there are more than one records with similar C(name).\nOnly allowed with C(record_type=A).\nC(content) will not be updated as it is used as key to find the record.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the record."
              },
              "prio": {
                "description": "Priority of the record.",
                "$ref": "#/definitions/ansible_number"
              },
              "rtype": {
                "enum": [
                  "A",
                  "ALIAS",
                  "CNAME",
                  "MX",
                  "SPF",
                  "URL",
                  "TXT",
                  "NS",
                  "SRV",
                  "NAPTR",
                  "PTR",
                  "AAAA",
                  "SSHFP",
                  "HINFO",
                  "POOL"
                ],
                "type": "string",
                "description": "Default: A\n\nType of the record."
              },
              "ttl": {
                "description": "Default: 3600\n\nTTL of the record in seconds.",
                "$ref": "#/definitions/ansible_number"
              },
              "api_secret": {
                "type": "string",
                "description": "Secret key of the Exoscale DNS API."
              },
              "api_timeout": {
                "description": "Default: 10\n\nHTTP timeout to Exoscale DNS API.",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": "Default: cloudstack\n\nName of the ini section in the C(cloustack.ini) file."
              },
              "value": {
                "type": "string",
                "description": "Content of the record.\nRequired if C(state=present) or C(name=\"\")"
              },
              "priority": {
                "description": "Priority of the record.",
                "$ref": "#/definitions/ansible_number"
              },
              "record_type": {
                "enum": [
                  "A",
                  "ALIAS",
                  "CNAME",
                  "MX",
                  "SPF",
                  "URL",
                  "TXT",
                  "NS",
                  "SRV",
                  "NAPTR",
                  "PTR",
                  "AAAA",
                  "SSHFP",
                  "HINFO",
                  "POOL"
                ],
                "type": "string",
                "description": "Default: A\n\nType of the record."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the record."
              },
              "address": {
                "type": "string",
                "description": "Content of the record.\nRequired if C(state=present) or C(name=\"\")"
              },
              "validate_certs": {
                "description": "Default: True\n\nValidate SSL certs of the Exoscale DNS API.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_key": {
                "type": "string",
                "description": "API key of the Exoscale DNS API."
              },
              "type": {
                "enum": [
                  "A",
                  "ALIAS",
                  "CNAME",
                  "MX",
                  "SPF",
                  "URL",
                  "TXT",
                  "NS",
                  "SRV",
                  "NAPTR",
                  "PTR",
                  "AAAA",
                  "SSHFP",
                  "HINFO",
                  "POOL"
                ],
                "type": "string",
                "description": "Default: A\n\nType of the record."
              }
            }
          },
          "zabbix_screen": {
            "type": "object",
            "description": "This module allows you to create, modify and delete Zabbix screens and associated graph data.",
            "properties": {
              "http_login_password": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth password"
              },
              "login_user": {
                "type": "string",
                "description": "Zabbix user name."
              },
              "http_login_user": {
                "type": "string",
                "description": "Default: None\n\nBasic Auth login"
              },
              "server_url": {
                "type": "string",
                "description": "Url of Zabbix server, with protocol (http or https)."
              },
              "screens": {
                "type": "string",
                "description": "List of screens to be created/updated/deleted(see example).\nIf the screen(s) already been added, the screen(s) name won't be updated.\nWhen creating or updating screen(s), C(screen_name), C(host_group) are required.\nWhen deleting screen(s), the C(screen_name) is required.\nThe available states are: C(present) (default) and C(absent). If the screen(s) already exists, and the state is not C(absent), the screen(s) will just be updated as needed."
              },
              "timeout": {
                "type": "string",
                "description": "Default: 10\n\nThe timeout of API request (seconds)."
              },
              "login_password": {
                "type": "string",
                "description": "Zabbix user password."
              }
            }
          },
          "panos_service": {
            "required": [
              "protocol",
              "service_name",
              "password",
              "ip_address",
              "port"
            ],
            "type": "object",
            "description": "Create a service object. Service objects are fundamental representation of the applications given src/dst ports and protocol",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nusername for authentication"
              },
              "protocol": {
                "enum": [
                  "tcp",
                  "udp"
                ],
                "type": "string",
                "description": "protocol for the service, should be tcp or udp"
              },
              "service_name": {
                "type": "string",
                "description": "name of the service"
              },
              "source_port": {
                "type": "string",
                "description": "Default: None\n\nsource port"
              },
              "commit": {
                "description": "Default: True\n\ncommit if changed",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": "password for authentication"
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device"
              },
              "port": {
                "type": "string",
                "description": "destination port"
              }
            }
          },
          "pacman": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg",
                        "package"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage packages with the I(pacman) package manager, which is used by Arch Linux and its variants.",
            "properties": {
              "upgrade": {
                "description": "Whether or not to upgrade whole system",
                "$ref": "#/definitions/ansible_truth"
              },
              "force": {
                "description": "When removing package - force remove package, without any checks. When update_cache - force redownload repo databases.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "description": "Name of the package to install, upgrade, or remove.",
                "$ref": "#/definitions/ansible_array"
              },
              "package": {
                "description": "Name of the package to install, upgrade, or remove.",
                "$ref": "#/definitions/ansible_array"
              },
              "recurse": {
                "description": "When removing a package, also remove its dependencies, provided that they are not required by other packages and were not explicitly installed by a user.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "latest",
                  "absent",
                  "removed"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the package."
              },
              "update_cache": {
                "description": "Whether or not to refresh the master package lists. This can be run as part of a package installation or as a separate step.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "description": "Name of the package to install, upgrade, or remove.",
                "$ref": "#/definitions/ansible_array"
              },
              "update-cache": {
                "description": "Whether or not to refresh the master package lists. This can be run as part of a package installation or as a separate step.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rabbitmq_plugin": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Enables or disables RabbitMQ plugins",
            "properties": {
              "prefix": {
                "type": "string",
                "description": "Specify a custom install prefix to a Rabbit"
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enabled\n\nSpecify if plugins are to be enabled or disabled"
              },
              "names": {
                "type": "string",
                "description": "Comma-separated list of plugin names"
              },
              "name": {
                "type": "string",
                "description": "Comma-separated list of plugin names"
              },
              "new_only": {
                "description": "Default: no\n\nOnly enable missing plugins\nDoes not disable plugins that are not in the names list",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "firewalld": {
            "required": [
              "state"
            ],
            "type": "object",
            "description": "This module allows for addition or deletion of services and ports either tcp or udp in either running or permanent firewalld rules.",
            "properties": {
              "zone": {
                "type": "string",
                "description": "Default: system-default(public)\n\nThe firewalld zone to add/remove to/from (NOTE: default zone can be configured per system but \"public\" is default from upstream. Available choices can be extended based on per-system configs, listed here are \"out of the box\" defaults)."
              },
              "service": {
                "type": "string",
                "description": "Name of a service to add/remove to/from firewalld - service must be listed in /etc/services."
              },
              "masquerade": {
                "type": "string",
                "description": "The masquerade setting you would like to enable/disable to/from zones within firewalld"
              },
              "immediate": {
                "description": "Should this configuration be applied immediately, if set as permanent",
                "$ref": "#/definitions/ansible_truth"
              },
              "source": {
                "type": "string",
                "description": "The source/network you would like to add/remove to/from firewalld"
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Should this port accept(enabled) or reject(disabled) connections."
              },
              "permanent": {
                "description": "Should this configuration be in the running firewalld configuration or persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout": {
                "description": "The amount of time the rule should be in effect for when non-permanent.",
                "$ref": "#/definitions/ansible_number"
              },
              "interface": {
                "type": "string",
                "description": "The interface you would like to add/remove to/from a zone in firewalld"
              },
              "port": {
                "type": "string",
                "description": "Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges."
              },
              "rich_rule": {
                "type": "string",
                "description": "Rich rule to add/remove to/from firewalld."
              }
            }
          },
          "grove": {
            "required": [
              "message",
              "channel_token"
            ],
            "type": "object",
            "description": "The M(grove) module sends a message for a service to a Grove.io channel.",
            "properties": {
              "service": {
                "type": "string",
                "description": "Default: ansible\n\nName of the service (displayed as the \"user\" in the message)"
              },
              "url": {
                "type": "string",
                "description": "Service URL for the web client"
              },
              "icon_url": {
                "type": "string",
                "description": "Icon for the service"
              },
              "channel_token": {
                "type": "string",
                "description": "Token of the channel to post to."
              },
              "message": {
                "type": "string",
                "description": "Message content"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "lvg": {
            "required": [
              "vg"
            ],
            "type": "object",
            "description": "This module creates, removes or resizes volume groups.",
            "properties": {
              "vg_options": {
                "type": "string",
                "description": "Additional options to pass to C(vgcreate) when creating the volume group."
              },
              "pvs": {
                "description": "List of comma-separated devices to use as physical devices in this volume group. Required when creating or resizing volume group.\nThe module will take care of running pvcreate if needed.",
                "$ref": "#/definitions/ansible_array"
              },
              "force": {
                "description": "Default: no\n\nIf yes, allows to remove volume group with logical volumes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vg": {
                "type": "string",
                "description": "The name of the volume group."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nControl if the volume group exists."
              },
              "pesize": {
                "description": "Default: 4\n\nThe size of the physical extent in megabytes. Must be a power of 2.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "vmware_dvs_portgroup": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create or remove a Distributed vSwitch portgroup",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "portgroup_name": {
                "type": "string",
                "description": "The name of the portgroup that is to be created or deleted"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "num_ports": {
                "description": "The number of ports the portgroup should contain",
                "$ref": "#/definitions/ansible_number"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "portgroup_type": {
                "enum": [
                  "earlyBinding",
                  "lateBinding",
                  "ephemeral"
                ],
                "type": "string",
                "description": "See VMware KB 1022312 regarding portgroup types"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "switch_name": {
                "type": "string",
                "description": "The name of the distributed vSwitch the port group should be created on."
              },
              "vlan_id": {
                "description": "The VLAN ID that should be configured with the portgroup",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "cs_volume": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, destroy, attach, detach volumes.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Name of the domain the volume to be deployed in."
              },
              "force": {
                "description": "Force removal of volume even it is attached to a VM.\nConsidered on C(state=absnet) only.",
                "$ref": "#/definitions/ansible_truth"
              },
              "disk_offering": {
                "type": "string",
                "description": "Name of the disk offering to be used.\nRequired one of C(disk_offering), C(snapshot) if volume is not already C(state=present)."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "shrink_ok": {
                "description": "Whether to allow to shrink the volume.",
                "$ref": "#/definitions/ansible_truth"
              },
              "display_volume": {
                "description": "Default: True\n\nWhether to display the volume to the end user or not.\nAllowed to Root Admins only.",
                "$ref": "#/definitions/ansible_truth"
              },
              "size": {
                "description": "Size of disk in GB",
                "$ref": "#/definitions/ansible_number"
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the volume should be deployed.\nIf not set, default zone is used."
              },
              "max_iops": {
                "description": "Max iops",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "attached",
                  "detached"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the volume."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "account": {
                "type": "string",
                "description": "Account the volume is related to."
              },
              "vm": {
                "type": "string",
                "description": "Name of the virtual machine to attach the volume to."
              },
              "min_iops": {
                "description": "Min iops",
                "$ref": "#/definitions/ansible_number"
              },
              "device_id": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "custom_id": {
                "type": "string",
                "description": "Custom id to the resource.\nAllowed to Root Admins only."
              },
              "name": {
                "type": "string",
                "description": "Name of the volume.\nC(name) can only contain ASCII letters."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the volume to be deployed in."
              },
              "snapshot": {
                "type": "string",
                "description": "The snapshot name for the disk volume.\nRequired one of C(disk_offering), C(snapshot) if volume is not already C(state=present)."
              }
            }
          },
          "mongodb_user": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "user"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "database",
                        "db"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "database"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "db"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Adds or removes a user from a MongoDB database.",
            "properties": {
              "login_port": {
                "type": "string",
                "description": "Default: 27017\n\nThe port to connect to"
              },
              "update_password": {
                "enum": [
                  "always",
                  "on_create"
                ],
                "type": "string",
                "description": "Default: always\n\nC(always) will update passwords if they differ.  C(on_create) will only set the password for newly created users."
              },
              "name": {
                "type": "string",
                "description": "The name of the user to add or remove"
              },
              "roles": {
                "description": "Default: readWrite\n\nThe database user roles valid values could either be one or more of the following strings: 'read', 'readWrite', 'dbAdmin', 'userAdmin', 'clusterAdmin', 'readAnyDatabase', 'readWriteAnyDatabase', 'userAdminAnyDatabase', 'dbAdminAnyDatabase'\nOr the following dictionary '{ db: DATABASE_NAME, role: ROLE_NAME }'.\nThis param requires pymongo 2.5+. If it is a string, mongodb 2.4+ is also required. If it is a dictionary, mongo 2.6+  is required.",
                "$ref": "#/definitions/ansible_array"
              },
              "database": {
                "type": "string",
                "description": "The name of the database to add/remove the user from"
              },
              "login_user": {
                "type": "string",
                "description": "The username used to authenticate with"
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nThe host running the database"
              },
              "login_password": {
                "type": "string",
                "description": "The password used to authenticate with"
              },
              "db": {
                "type": "string",
                "description": "The name of the database to add/remove the user from"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe database user state"
              },
              "ssl": {
                "description": "Whether to use an SSL connection when connecting to the database",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssl_cert_reqs": {
                "enum": [
                  "CERT_REQUIRED",
                  "CERT_OPTIONAL",
                  "CERT_NONE"
                ],
                "type": "string",
                "description": "Default: CERT_REQUIRED\n\nSpecifies whether a certificate is required from the other side of the connection, and whether it will be validated if provided."
              },
              "user": {
                "type": "string",
                "description": "The name of the user to add or remove"
              },
              "login_database": {
                "type": "string",
                "description": "The database where login credentials are stored"
              },
              "password": {
                "type": "string",
                "description": "The password to use for the user"
              },
              "pass": {
                "type": "string",
                "description": "The password to use for the user"
              },
              "replica_set": {
                "type": "string",
                "description": "Replica set to connect to (automatically connects to primary for writes)"
              }
            }
          },
          "vmware_target_canonical_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Return canonical (NAA) from an ESXi host based on SCSI target ID",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "target_id": {
                "description": "The target id based on order of scsi device",
                "$ref": "#/definitions/ansible_number"
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_bgp_af": {
            "required": [
              "afi",
              "safi",
              "asn"
            ],
            "type": "object",
            "description": "Manages BGP Address-family configurations on NX-OS switches.",
            "properties": {
              "table_map_filter": {
                "description": "Filters routes rejected by the route-map and does not download them to the RIB.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dampening_max_suppress_time": {
                "type": "string",
                "description": "Specify max suppress time for route-flap dampening stable route. Valid values are integer and keyword 'default'."
              },
              "additional_paths_send": {
                "description": "Enables the send capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "additional_paths_install": {
                "description": "Install a backup path into the forwarding table and provide prefix independent convergence (PIC) in case of a PE-CE link failure.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dampening_state": {
                "description": "Enable/disable route-flap dampening.",
                "$ref": "#/definitions/ansible_truth"
              },
              "additional_paths_receive": {
                "description": "Enables the receive capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.",
                "$ref": "#/definitions/ansible_truth"
              },
              "suppress_inactive": {
                "description": "Advertises only active routes to peers.",
                "$ref": "#/definitions/ansible_truth"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "dampening_routemap": {
                "type": "string",
                "description": "Specify route-map for route-flap dampening. Valid values are a string defining the name of the route-map."
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "distance_local": {
                "type": "string",
                "description": "Sets the administrative distance for local BGP routes. Valid values are Integer or keyword 'default'."
              },
              "advertise_l2vpn_evpn": {
                "description": "Advertise evpn routes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "afi": {
                "enum": [
                  "ipv4",
                  "ipv6",
                  "vpnv4",
                  "vpnv6",
                  "l2vpn"
                ],
                "type": "string",
                "description": "Address Family Identifier."
              },
              "default_information_originate": {
                "description": "Default information originate.",
                "$ref": "#/definitions/ansible_truth"
              },
              "networks": {
                "description": "Networks to configure. Valid value is a list of network prefixes to advertise. The list must be in the form of an array. Each entry in the array must include a prefix address and an optional route-map. For example [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1', 'Chicago'], ['192.168.2.0/24], ['192.168.3.0/24', 'routemap_NYC']].",
                "$ref": "#/definitions/ansible_array"
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "next_hop_route_map": {
                "type": "string",
                "description": "Configure a route-map for valid nexthops. Valid values are a string defining the name of the route-map."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "table_map": {
                "type": "string",
                "description": "Apply table-map to filter routes downloaded into URIB. Valid values are a string."
              },
              "safi": {
                "enum": [
                  "unicast",
                  "multicast",
                  "evpn"
                ],
                "type": "string",
                "description": "Sub Address Family Identifier."
              },
              "default_metric": {
                "type": "string",
                "description": "Sets default metrics for routes redistributed into BGP. Valid values are Integer or keyword 'default'"
              },
              "client_to_client": {
                "description": "Configure client-to-client route reflection.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dampen_igp_metric": {
                "type": "string",
                "description": "Specify dampen value for IGP metric-related changes, in seconds. Valid values are integer and keyword 'default'."
              },
              "distance_ibgp": {
                "type": "string",
                "description": "Sets the administrative distance for iBGP routes. Valid values are Integer or keyword 'default'."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "additional_paths_selection": {
                "type": "string",
                "description": "Configures the capability of selecting additional paths for a prefix. Valid values are a string defining the name of the route-map."
              },
              "maximum_paths_ibgp": {
                "type": "string",
                "description": "Configures the maximum number of ibgp equal-cost paths for load sharing. Valid value is an integer in the range 1-64."
              },
              "vrf": {
                "type": "string",
                "description": "Name of the VRF. The name 'default' is a valid VRF representing the global bgp."
              },
              "distance_ebgp": {
                "type": "string",
                "description": "Sets the administrative distance for eBGP routes. Valid values are Integer or keyword 'default'."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "asn": {
                "type": "string",
                "description": "BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation."
              },
              "redistribute": {
                "description": "A list of redistribute directives. Multiple redistribute entries are allowed. The list must be in the form of a nested array. the first entry of each array defines the source-protocol to redistribute from; the second entry defines a route-map name. A route-map is highly advised but may be optional on some platforms, in which case it may be omitted from the array list. For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].",
                "$ref": "#/definitions/ansible_array"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "dampening_suppress_time": {
                "type": "string",
                "description": "Specify route suppress time for route-flap dampening. Valid values are integer and keyword 'default'."
              },
              "maximum_paths": {
                "type": "string",
                "description": "Configures the maximum number of equal-cost paths for load sharing. Valid value is an integer in the range 1-64."
              },
              "inject_map": {
                "description": "An array of route-map names which will specify prefixes to inject. Each array entry must first specify the inject-map name, secondly an exist-map name, and optionally the copy-attributes keyword which indicates that attributes should be copied from the aggregate. For example [['lax_inject_map', 'lax_exist_map'], ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'], ['fsd_inject_map', 'fsd_exist_map']].",
                "$ref": "#/definitions/ansible_array"
              },
              "dampening_reuse_time": {
                "type": "string",
                "description": "Specify route reuse time for route-flap dampening. Valid values are integer and keyword 'default'."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "dampening_half_time": {
                "type": "string",
                "description": "Specify decay half-life in minutes for route-flap dampening. Valid values are integer and keyword 'default'."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "facter": {
            "type": "object",
            "description": "Runs the I(facter) discovery program (U(https://github.com/puppetlabs/facter)) on the remote system, returning JSON data that can be useful for inventory purposes.",
            "properties": {}
          },
          "openvswitch_port": {
            "required": [
              "bridge",
              "port"
            ],
            "type": "object",
            "description": "Manage Open vSwitch ports",
            "properties": {
              "bridge": {
                "type": "string",
                "description": "Name of bridge to manage"
              },
              "set": {
                "type": "string",
                "description": "Default: None\n\nSet a single property on a port."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the port should exist"
              },
              "tag": {
                "type": "string",
                "description": "VLAN tag for this port"
              },
              "timeout": {
                "description": "Default: 5\n\nHow long to wait for ovs-vswitchd to respond",
                "$ref": "#/definitions/ansible_number"
              },
              "external_ids": {
                "type": "object",
                "description": "Dictionary of external_ids applied to a port."
              },
              "port": {
                "type": "string",
                "description": "Name of port to manage on the bridge"
              }
            }
          },
          "panos_interface": {
            "required": [
              "zone_name",
              "password",
              "ip_address",
              "if_name"
            ],
            "type": "object",
            "description": "Configure data-port (DP) network interface for DHCP. By default DP interfaces are static.",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nUsername credentials to use for auth."
              },
              "if_name": {
                "type": "string",
                "description": "Name of the interface to configure."
              },
              "create_default_route": {
                "description": "Default: false\n\nWhether or not to add default route with router learned via DHCP.",
                "$ref": "#/definitions/ansible_truth"
              },
              "commit": {
                "description": "Default: True\n\nCommit if changed",
                "$ref": "#/definitions/ansible_truth"
              },
              "zone_name": {
                "type": "string",
                "description": "Name of the zone for the interface. If the zone does not exist it is created but if the zone exists and it is not of the layer3 type the operation will fail.\n"
              },
              "password": {
                "type": "string",
                "description": "Password credentials to use for auth."
              },
              "ip_address": {
                "type": "string",
                "description": "IP address (or hostname) of PAN-OS device being configured."
              }
            }
          },
          "cs_project": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "tags",
                        "tag"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, update, suspend, activate and remove projects.",
            "properties": {
              "display_text": {
                "type": "string",
                "description": "Display text of the project.\nIf not specified, C(name) will be used as C(display_text)."
              },
              "account": {
                "type": "string",
                "description": "Account the project is related to."
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "tags": {
                "description": "List of tags. Tags are a list of dictionaries having keys C(key) and C(value).\nIf you want to delete all tags, set a empty list e.g. C(tags: []).",
                "$ref": "#/definitions/ansible_array"
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "active",
                  "suspended"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the project."
              },
              "tag": {
                "description": "List of tags. Tags are a list of dictionaries having keys C(key) and C(value).\nIf you want to delete all tags, set a empty list e.g. C(tags: []).",
                "$ref": "#/definitions/ansible_array"
              },
              "domain": {
                "type": "string",
                "description": "Domain the project is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the project."
              }
            }
          },
          "mysql_variables": {
            "type": "object",
            "description": "Query / Set MySQL variables",
            "properties": {
              "ssl_key": {
                "type": "string",
                "description": ""
              },
              "ssl_cert": {
                "type": "string",
                "description": ""
              },
              "config_file": {
                "type": "string",
                "description": ""
              },
              "login_port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "login_user": {
                "type": "string",
                "description": ""
              },
              "login_host": {
                "type": "string",
                "description": ""
              },
              "value": {
                "type": "string",
                "description": "If set, then sets variable value to this"
              },
              "ssl_ca": {
                "type": "string",
                "description": ""
              },
              "login_unix_socket": {
                "type": "string",
                "description": ""
              },
              "login_password": {
                "type": "string",
                "description": ""
              },
              "variable": {
                "type": "string",
                "description": "Variable name to operate"
              },
              "connect_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "ovirt_nics_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt virtual machine network interfaces.",
            "properties": {
              "vm": {
                "type": "string",
                "description": "Name of the VM where NIC is attached."
              },
              "name": {
                "type": "string",
                "description": "Name of the NIC, can be used as glob expression."
              }
            }
          },
          "nxos_snapshot": {
            "required": [
              "action"
            ],
            "type": "object",
            "description": "Create snapshots of the running states of selected features, add new show commands for snapshot creation, delete and compare existing snapshots.",
            "properties": {
              "snapshot_name": {
                "type": "string",
                "description": "Snapshot name, to be used when C(action=create) or C(action=delete)."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "section": {
                "type": "string",
                "description": "Used to name the show command output, to be used when C(action=add)."
              },
              "show_command": {
                "type": "string",
                "description": "Specify a new show command, to be used when C(action=add)."
              },
              "element_key1": {
                "type": "string",
                "description": "Specify the tags used to distinguish among row entries, to be used when C(action=add)."
              },
              "element_key2": {
                "type": "string",
                "description": "Specify the tags used to distinguish among row entries, to be used when C(action=add)."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Snapshot description to be used when C(action=create)."
              },
              "snapshot1": {
                "type": "string",
                "description": "First snapshot to be used when C(action=compare)."
              },
              "snapshot2": {
                "type": "string",
                "description": "Second snapshot to be used when C(action=compare)."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": "Default: ./\n\nSpecify the path of the file where new created snapshot or snapshots comparison will be stored, to be used when C(action=create) and C(save_snapshot_locally=true) or C(action=compare)."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "compare_option": {
                "enum": [
                  "summary",
                  "ipv4routes",
                  "ipv6routes"
                ],
                "type": "string",
                "description": "Snapshot options to be used when C(action=compare)."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "save_snapshot_locally": {
                "description": "Specify to locally store a new created snapshot, to be used when C(action=create).",
                "$ref": "#/definitions/ansible_truth"
              },
              "comparison_results_file": {
                "type": "string",
                "description": "Name of the file where snapshots comparison will be store."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "action": {
                "enum": [
                  "create",
                  "add",
                  "compare",
                  "delete",
                  "delete_all"
                ],
                "type": "string",
                "description": "Define what snapshot action the module would perform."
              },
              "row_id": {
                "type": "string",
                "description": "Specifies the tag of each row entry of the show command's XML output, to be used when C(action=add)."
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nagios": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "services",
                        "service"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "The M(nagios) module has two basic functions: scheduling downtime and toggling alerts for services or hosts.\nAll actions require the I(host) parameter to be given explicitly. In playbooks you can use the C({{inventory_hostname}}) variable to refer to the host the playbook is currently running on.\nYou can specify multiple services at once by separating them with commas, .e.g., C(services=httpd,nfs,puppet).\nWhen specifying what service to handle there is a special service value, I(host), which will handle alerts/downtime for the I(host itself), e.g., C(service=host). This keyword may not be given with other services at the same time. I(Setting alerts/downtime for a host does not affect alerts/downtime for any of the services running on it.) To schedule downtime for all services on particular host use keyword \"all\", e.g., C(service=all).\nWhen using the M(nagios) module you will need to specify your Nagios server using the C(delegate_to) parameter.",
            "properties": {
              "comment": {
                "type": "string",
                "description": "Default: Scheduling downtime\n\nComment for C(downtime) action."
              },
              "servicegroup": {
                "type": "string",
                "description": "The Servicegroup we want to set downtimes/alerts for. B(Required) option when using the C(servicegroup_service_downtime) amd C(servicegroup_host_downtime)."
              },
              "service": {
                "type": "string",
                "description": "What to manage downtime/alerts for. Separate multiple services with commas. C(service) is an alias for C(services). B(Required) option when using the C(downtime), C(enable_alerts), and C(disable_alerts) actions."
              },
              "author": {
                "type": "string",
                "description": "Default: Ansible\n\nAuthor to leave downtime comments as. Only usable with the C(downtime) action."
              },
              "action": {
                "enum": [
                  "downtime",
                  "delete_downtime",
                  "enable_alerts",
                  "disable_alerts",
                  "silence",
                  "unsilence",
                  "silence_nagios",
                  "unsilence_nagios",
                  "command",
                  "servicegroup_service_downtime",
                  "servicegroup_host_downtime"
                ],
                "type": "string",
                "description": "Action to take.\nservicegroup options were added in 2.0.\ndelete_downtime options were added in 2.2."
              },
              "host": {
                "type": "string",
                "description": "Host to operate on in Nagios."
              },
              "command": {
                "type": "string",
                "description": "The raw command to send to nagios, which should not include the submitted time header or the line-feed B(Required) option when using the C(command) action."
              },
              "services": {
                "type": "string",
                "description": "What to manage downtime/alerts for. Separate multiple services with commas. C(service) is an alias for C(services). B(Required) option when using the C(downtime), C(enable_alerts), and C(disable_alerts) actions."
              },
              "minutes": {
                "type": "string",
                "description": "Default: 30\n\nMinutes to schedule downtime for.\nOnly usable with the C(downtime) action."
              },
              "cmdfile": {
                "type": "string",
                "description": "Default: auto-detected\n\nPath to the nagios I(command file) (FIFO pipe). Only required if auto-detection fails."
              }
            }
          },
          "cs_pod": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Create, update, delete pods.",
            "properties": {
              "api_key": {
                "type": "string",
                "description": ""
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "gateway": {
                "type": "string",
                "description": "Gateway for the Pod.\nRequired on C(state=present)"
              },
              "state": {
                "enum": [
                  "present",
                  "enabled",
                  "disabled",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the pod."
              },
              "end_ip": {
                "type": "string",
                "description": "Ending IP address for the Pod."
              },
              "start_ip": {
                "type": "string",
                "description": "Starting IP address for the Pod.\nRequired on C(state=present)"
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the pod belongs to.\nIf not set, default zone is used."
              },
              "netmask": {
                "type": "string",
                "description": "Netmask for the Pod.\nRequired on C(state=present)"
              },
              "id": {
                "type": "string",
                "description": "uuid of the exising pod."
              },
              "name": {
                "type": "string",
                "description": "Name of the pod."
              }
            }
          },
          "circonus_annotation": {
            "required": [
              "category",
              "description",
              "title",
              "api_key"
            ],
            "type": "object",
            "description": "Create an annotation event with a given category, title and description. Optionally start, end or durations can be provided",
            "properties": {
              "category": {
                "type": "string",
                "description": "Annotation Category"
              },
              "description": {
                "type": "string",
                "description": "Description of annotation"
              },
              "title": {
                "type": "string",
                "description": "Title of annotation"
              },
              "stop": {
                "description": "Unix timestamp of event end, defaults to now + duration",
                "$ref": "#/definitions/ansible_number"
              },
              "start": {
                "description": "Unix timestamp of event start, defaults to now",
                "$ref": "#/definitions/ansible_number"
              },
              "duration": {
                "description": "Duration in seconds of annotation, defaults to 0",
                "$ref": "#/definitions/ansible_number"
              },
              "api_key": {
                "type": "string",
                "description": "Circonus API key"
              }
            }
          },
          "aos_ip_pool": {
            "required": [
              "session"
            ],
            "type": "object",
            "description": "Apstra AOS Ip Pool module let you manage your IP Pool easily. You can create create and delete IP Pool by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.",
            "properties": {
              "subnets": {
                "description": "List of subnet that needs to be part of the IP Pool.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Name of the IP Pool to manage. Only one of I(name), I(id) or I(content) can be set."
              },
              "content": {
                "type": "string",
                "description": "Datastructure of the IP Pool to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate what is the expected state of the IP Pool (present or not)."
              },
              "session": {
                "type": "object",
                "description": "An existing AOS session as obtained by M(aos_login) module."
              },
              "id": {
                "type": "string",
                "description": "AOS Id of the IP Pool to manage (can't be used to create a new IP Pool), Only one of I(name), I(id) or I(content) can be set."
              }
            }
          },
          "clc_publicip": {
            "required": [
              "server_ids"
            ],
            "type": "object",
            "description": "An Ansible module to add or delete public ip addresses on an existing server or servers in CenturyLink Cloud.",
            "properties": {
              "server_ids": {
                "description": "A list of servers to create public ips on.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermine whether to create or delete public IPs. If present module will not create a second public ip if one already exists."
              },
              "protocol": {
                "enum": [
                  "TCP",
                  "UDP",
                  "ICMP"
                ],
                "type": "string",
                "description": "Default: TCP\n\nThe protocol that the public IP will listen for."
              },
              "ports": {
                "description": "Default: None\n\nA list of ports to expose. This is required when state is 'present'",
                "$ref": "#/definitions/ansible_array"
              },
              "wait": {
                "description": "Default: True\n\nWhether to wait for the tasks to finish before returning.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "os_user": {
            "type": "object",
            "description": "Manage OpenStack Identity users. Users can be created, updated or deleted using this module. A user will be updated if I(name) matches an existing user and I(state) is present. The value for I(name) cannot be updated without deleting and re-creating the user.",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Default: None\n\nDomain to create the user in if the cloud supports domains"
              },
              "name": {
                "type": "string",
                "description": "Username for the user"
              },
              "availability_zone": {
                "type": "string",
                "description": "Ignored. Present for backwards compatability"
              },
              "update_password": {
                "type": "string",
                "description": "Default: always\n\nC(always) will attempt to update password.  C(on_create) will only set the password for newly created users."
              },
              "enabled": {
                "type": "string",
                "description": "Default: True\n\nIs the user enabled"
              },
              "default_project": {
                "type": "string",
                "description": "Default: None\n\nProject name or ID that the user should be associated with by default"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "password": {
                "type": "string",
                "description": "Default: None\n\nPassword for the user"
              },
              "email": {
                "type": "string",
                "description": "Default: None\n\nEmail address for the user"
              }
            }
          },
          "at": {
            "type": "object",
            "description": "Use this module to schedule a command or script file to run once in the future.\nAll jobs are executed in the 'a' queue.",
            "properties": {
              "count": {
                "description": "The count of units in the future to execute the command or script file.",
                "$ref": "#/definitions/ansible_number"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state dictates if the command or script file should be evaluated as present(added) or absent(deleted)."
              },
              "command": {
                "type": "string",
                "description": "A command to be executed in the future."
              },
              "units": {
                "enum": [
                  "minutes",
                  "hours",
                  "days",
                  "weeks"
                ],
                "type": "string",
                "description": "The type of units in the future to execute the command or script file."
              },
              "unique": {
                "description": "If a matching job is present a new job will not be added.",
                "$ref": "#/definitions/ansible_truth"
              },
              "script_file": {
                "type": "string",
                "description": "An existing script file to be executed in the future."
              }
            }
          },
          "file": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "dest",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Sets attributes of files, symlinks, and directories, or removes files/symlinks/directories. Many other modules support the same options as the C(file) module - including M(copy), M(template), and M(assemble).",
            "properties": {
              "src": {
                "type": "string",
                "description": "path of the file to link to (applies only to C(state=link)). Will accept absolute, relative and nonexisting paths. Relative paths are not expanded."
              },
              "force": {
                "description": "Default: no\n\nforce the creation of the symlinks in two cases: the source file does not exist (but will appear later); the destination exists and is a file (so, we need to unlink the \"path\" file and create symlink to the \"src\" file in place of it).",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "path to the file being managed.  Aliases: I(dest), I(name)"
              },
              "dest": {
                "type": "string",
                "description": "path to the file being managed.  Aliases: I(dest), I(name)"
              },
              "recurse": {
                "description": "Default: no\n\nrecursively set the specified file attributes (applies only to state=directory)",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "file",
                  "link",
                  "directory",
                  "hard",
                  "touch",
                  "absent"
                ],
                "type": "string",
                "description": "Default: file\n\nIf C(directory), all immediate subdirectories will be created if they do not exist, since 1.7 they will be created with the supplied permissions. If C(file), the file will NOT be created if it does not exist, see the M(copy) or M(template) module if you want that behavior.  If C(link), the symbolic link will be created or changed. Use C(hard) for hardlinks. If C(absent), directories will be recursively deleted, and files or symlinks will be unlinked. Note that C(file) will not fail if the C(path) does not exist as the state did not change. If C(touch) (new in 1.4), an empty file will be created if the C(path) does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way `touch` works from the command line)."
              },
              "original_basename": {
                "type": "string",
                "description": ""
              },
              "diff_peek": {
                "type": "string",
                "description": ""
              },
              "path": {
                "type": "string",
                "description": "path to the file being managed.  Aliases: I(dest), I(name)"
              },
              "validate": {
                "type": "string",
                "description": ""
              }
            }
          },
          "clc_aa_policy": {
            "required": [
              "location",
              "name"
            ],
            "type": "object",
            "description": "An Ansible module to Create or Delete Anti Affinity Policies at CenturyLink Cloud.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to create or delete the policy."
              },
              "location": {
                "type": "string",
                "description": "Datacenter in which the policy lives/should live."
              },
              "name": {
                "type": "string",
                "description": "The name of the Anti Affinity Policy."
              },
              "wait": {
                "type": "string",
                "description": "Default: True\n\nWhether to wait for the tasks to finish before returning."
              }
            }
          },
          "pip": {
            "type": "object",
            "description": "Manage Python library dependencies. To use this module, one of the following keys is required: C(name) or C(requirements).",
            "properties": {
              "virtualenv": {
                "type": "string",
                "description": "An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv."
              },
              "virtualenv_site_packages": {
                "description": "Default: no\n\nWhether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.",
                "$ref": "#/definitions/ansible_truth"
              },
              "executable": {
                "type": "string",
                "description": "The explicit executable or a pathname to the executable to be used to run pip for a specific version of Python installed in the system. For example C(pip-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation. It cannot be specified together with the 'virtualenv' parameter (added in 2.1). By default, it will take the appropriate version for the python interpreter use by ansible, e.g. pip3 on python 3, and pip2 or pip on python 2."
              },
              "chdir": {
                "type": "string",
                "description": "cd into this directory before running the command"
              },
              "requirements": {
                "type": "string",
                "description": "The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option."
              },
              "name": {
                "description": "The name of a Python library to install or the url of the remote package.\nAs of 2.2 you can supply a list of names.",
                "$ref": "#/definitions/ansible_array"
              },
              "virtualenv_python": {
                "type": "string",
                "description": "The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used. This parameter should not be used when C(virtualenv_command) is using C(pyvenv) or the C(-m venv) module."
              },
              "umask": {
                "type": "string",
                "description": "The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., 0077) and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode in octal, with a leading 0 (e.g., 0077)."
              },
              "editable": {
                "description": "Default: True\n\nPass the editable flag for versioning URLs.",
                "$ref": "#/definitions/ansible_truth"
              },
              "virtualenv_command": {
                "type": "string",
                "description": "Default: virtualenv\n\nThe command or a pathname to the command to create the virtual environment with. For example C(pyvenv), C(virtualenv), C(virtualenv2), C(~/bin/virtualenv), C(/usr/local/bin/virtualenv)."
              },
              "use_mirrors": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "extra_args": {
                "type": "string",
                "description": "Extra arguments passed to pip."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "latest",
                  "forcereinstall"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state of module\nThe 'forcereinstall' option is only available in Ansible 2.1 and above."
              },
              "version": {
                "type": "string",
                "description": "The version number to install of the Python library specified in the I(name) parameter"
              }
            }
          },
          "timezone": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "hwclock",
                        "rtc"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module configures the timezone setting, both of the system clock and of the hardware clock. I(Currently only Linux platform is supported.) It is recommended to restart C(crond) after changing the timezone, otherwise the jobs may run at the wrong time. It uses the C(timedatectl) command if available. Otherwise, it edits C(/etc/sysconfig/clock) or C(/etc/timezone) for the system clock, and uses the C(hwclock) command for the hardware clock. If you want to set up the NTP, use M(service) module.",
            "properties": {
              "hwclock": {
                "enum": [
                  "UTC",
                  "local"
                ],
                "type": "string",
                "description": "Whether the hardware clock is in UTC or in local timezone. Default is to keep current setting. Note that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS."
              },
              "name": {
                "type": "string",
                "description": "Name of the timezone for the system clock. Default is to keep current setting."
              },
              "rtc": {
                "enum": [
                  "UTC",
                  "local"
                ],
                "type": "string",
                "description": "Whether the hardware clock is in UTC or in local timezone. Default is to keep current setting. Note that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS."
              }
            }
          },
          "ovirt_users_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt users.",
            "properties": {
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search user X use following pattern: name=X"
              }
            }
          },
          "rabbitmq_exchange": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "exchange_type",
                        "type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module uses rabbitMQ Rest API to create/delete exchanges",
            "properties": {
              "login_port": {
                "type": "string",
                "description": "Default: 15672\n\nrabbitMQ management api port"
              },
              "name": {
                "type": "string",
                "description": "Name of the exchange to create"
              },
              "login_user": {
                "type": "string",
                "description": "Default: guest\n\nrabbitMQ user for connection"
              },
              "login_host": {
                "type": "string",
                "description": "Default: localhost\n\nrabbitMQ host for connection"
              },
              "exchange_type": {
                "type": "string",
                "description": "Default: direct\n\ntype for the exchange"
              },
              "vhost": {
                "type": "string",
                "description": "Default: /\n\nrabbitMQ virtual host"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether the exchange should be present or absent\nOnly present implemented atm"
              },
              "internal": {
                "description": "exchange is available only for other exchanges",
                "$ref": "#/definitions/ansible_truth"
              },
              "arguments": {
                "type": "object",
                "description": "extra arguments for exchange. If defined this argument is a key/value dictionary"
              },
              "auto_delete": {
                "description": "if the exchange should delete itself after all queues/exchanges unbound from it",
                "$ref": "#/definitions/ansible_truth"
              },
              "login_password": {
                "type": "string",
                "description": "rabbitMQ password for connection"
              },
              "type": {
                "type": "string",
                "description": "Default: direct\n\ntype for the exchange"
              },
              "durable": {
                "description": "Default: True\n\nwhether exchange is durable or not",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "wakeonlan": {
            "required": [
              "mac"
            ],
            "type": "object",
            "description": "The M(wakeonlan) module sends magic Wake-on-LAN (WoL) broadcast packets.",
            "properties": {
              "broadcast": {
                "type": "string",
                "description": "Default: 255.255.255.255\n\nNetwork broadcast address to use for broadcasting magic Wake-on-LAN packet"
              },
              "mac": {
                "type": "string",
                "description": "MAC address to send Wake-on-LAN broadcast packet for"
              },
              "port": {
                "description": "Default: 7\n\nUDP port to use for magic Wake-on-LAN packet",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "cs_iso": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Register and remove ISO images.",
            "properties": {
              "is_featured": {
                "description": "Register the ISO to be featured. Only used if C(state) is present.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the ISO."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the ISO."
              },
              "bootable": {
                "description": "Default: True\n\nRegister the ISO to be bootable. Only used if C(state) is present.",
                "$ref": "#/definitions/ansible_truth"
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "domain": {
                "type": "string",
                "description": "Domain the ISO is related to."
              },
              "is_dynamically_scalable": {
                "description": "Register the ISO having XS/VMWare tools installed inorder to support dynamic scaling of VM cpu/memory. Only used if C(state) is present.",
                "$ref": "#/definitions/ansible_truth"
              },
              "project": {
                "type": "string",
                "description": "Name of the project the ISO to be registered in."
              },
              "url": {
                "type": "string",
                "description": "URL where the ISO can be downloaded from. Required if C(state) is present."
              },
              "iso_filter": {
                "enum": [
                  "featured",
                  "self",
                  "selfexecutable",
                  "sharedexecutable",
                  "executable",
                  "community"
                ],
                "type": "string",
                "description": "Default: self\n\nName of the filter used to search for the ISO."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "is_ready": {
                "description": "This flag is used for searching existing ISOs. If set to C(true), it will only list ISO ready for deployment e.g. successfully downloaded and installed. Recommended to set it to C(false).",
                "$ref": "#/definitions/ansible_truth"
              },
              "checksum": {
                "type": "string",
                "description": "The MD5 checksum value of this ISO. If set, we search by checksum instead of name."
              },
              "account": {
                "type": "string",
                "description": "Account the ISO is related to."
              },
              "os_type": {
                "type": "string",
                "description": "Name of the OS that best represents the OS of this ISO. If the iso is bootable this parameter needs to be passed. Required if C(state) is present."
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone you wish the ISO to be registered or deleted from. If not specified, first zone found will be used."
              },
              "api_url": {
                "type": "string",
                "description": ""
              }
            }
          },
          "cs_nic": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "vm_guest_ip",
                        "secondary_ip"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "vm",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "vm"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add and remove secondary IPs to and from a NIC.",
            "properties": {
              "vm_guest_ip": {
                "type": "string",
                "description": "Secondary IP address to be added to the instance nic.\nIf not set, the API always returns a new IP address and idempotency is not given."
              },
              "domain": {
                "type": "string",
                "description": "Domain the instance is related to."
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "poll_async": {
                "description": "Default: True\n\nPoll async jobs until job has finished.",
                "$ref": "#/definitions/ansible_truth"
              },
              "secondary_ip": {
                "type": "string",
                "description": "Secondary IP address to be added to the instance nic.\nIf not set, the API always returns a new IP address and idempotency is not given."
              },
              "api_http_method": {
                "enum": [
                  "get",
                  "post"
                ],
                "type": "string",
                "description": ""
              },
              "api_secret": {
                "type": "string",
                "description": ""
              },
              "api_timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "vm": {
                "type": "string",
                "description": "Name of instance."
              },
              "api_region": {
                "type": "string",
                "description": ""
              },
              "project": {
                "type": "string",
                "description": "Name of the project the instance is deployed in."
              },
              "network": {
                "type": "string",
                "description": "Name of the network.\nRequired to find the NIC if instance has multiple networks assigned."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the ipaddress."
              },
              "vpc": {
                "type": "string",
                "description": "Name of the VPC the C(vm) is related to."
              },
              "account": {
                "type": "string",
                "description": "Account the instance is related to."
              },
              "api_url": {
                "type": "string",
                "description": ""
              },
              "zone": {
                "type": "string",
                "description": "Name of the zone in which the instance is deployed in.\nIf not set, default zone is used."
              },
              "name": {
                "type": "string",
                "description": "Name of instance."
              }
            }
          },
          "cl_ports": {
            "type": "object",
            "description": "Set the initial port attribute defined in the Cumulus Linux ports.conf, file. This module does not do any error checking at the moment. Be careful to not include ports that do not exist on the switch. Carefully read the original ports.conf file for any exceptions or limitations. For more details go the Configure Switch Port Attribute Documentation at U(http://docs.cumulusnetworks.com).",
            "properties": {
              "speed_4_by_10g": {
                "description": "List of 40G ports that will be unganged to run as 4 10G ports.",
                "$ref": "#/definitions/ansible_array"
              },
              "speed_10g": {
                "description": "List of ports to run initial run at 10G.",
                "$ref": "#/definitions/ansible_array"
              },
              "speed_40g": {
                "description": "List of ports to run initial run at 40G.",
                "$ref": "#/definitions/ansible_array"
              },
              "speed_40g_div_4": {
                "description": "List of 10G ports that will be ganged to form a 40G port.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "github_hooks": {
            "required": [
              "repo",
              "oauthkey",
              "user",
              "action"
            ],
            "type": "object",
            "description": "Adds service hooks and removes service hooks that have an error status.",
            "properties": {
              "oauthkey": {
                "type": "string",
                "description": "The oauth key provided by github. It can be found/generated on github under \"Edit Your Profile\" >> \"Applications\" >> \"Personal Access Tokens\""
              },
              "hookurl": {
                "type": "string",
                "description": "When creating a new hook, this is the url that you want github to post to. It is only required when creating a new hook."
              },
              "repo": {
                "type": "string",
                "description": "This is the API url for the repository you want to manage hooks for. It should be in the form of: https://api.github.com/repos/user:/repo:. Note this is different than the normal repo url."
              },
              "user": {
                "type": "string",
                "description": "Github username."
              },
              "content_type": {
                "enum": [
                  "json",
                  "form"
                ],
                "type": "string",
                "description": "Default: json\n\nContent type to use for requests made to the webhook"
              },
              "action": {
                "enum": [
                  "create",
                  "cleanall",
                  "list",
                  "clean504"
                ],
                "type": "string",
                "description": "This tells the githooks module what you want it to do."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates for the target repo will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ec2_vpc_nacl": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Read the AWS documentation for Network ACLS U(http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html)",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "egress": {
                "description": "A list of rules for outgoing traffic.\nEach rule must be specified as a list.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "Tagged name identifying a network ACL."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "subnets": {
                "description": "The list of subnets that should be associated with the network ACL.\nMust be specified as a list\nEach subnet can be specified as subnet ID, or its tagged name.",
                "$ref": "#/definitions/ansible_array"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "tags": {
                "type": "object",
                "description": "Dictionary of tags to look for and apply when creating a network ACL."
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "vpc_id": {
                "type": "string",
                "description": "VPC id of the requesting VPC."
              },
              "ingress": {
                "description": "List of rules for incoming traffic.\nEach rule must be specified as a list.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nCreates or modifies an existing NACL\nDeletes a NACL and reassociates subnets to the default NACL"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "lambda_alias": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "function_version",
                        "version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "alias_name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "alias_name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module allows the management of AWS Lambda functions aliases via the Ansible framework.  It is idempotent and supports \"Check\" mode.    Use module M(lambda) to manage the lambda function itself and M(lambda_event) to manage event source mappings.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "A short, user-defined function alias description."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "alias_name": {
                "type": "string",
                "description": "Name of the function alias."
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the function alias."
              },
              "function_name": {
                "type": "string",
                "description": "The name of the function alias."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDescribes the desired state."
              },
              "version": {
                "description": "Version associated with the Lambda function alias. A value of 0 (or omitted parameter) sets the alias to the $LATEST version.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "function_version": {
                "description": "Version associated with the Lambda function alias. A value of 0 (or omitted parameter) sets the alias to the $LATEST version.",
                "$ref": "#/definitions/ansible_number"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ops_facts": {
            "type": "object",
            "description": "Collects facts from devices running the OpenSwitch operating system.  Fact collection is supported over both Cli and Rest transports.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.\nThe facts collected from pre Ansible 2.2 are still available and are collected for backwards compatibility; however, these facts should be considered deprecated and will be removed in a future release.",
            "properties": {
              "gather_subset": {
                "type": "string",
                "description": "Default: !config\n\nWhen supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, legacy, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected."
              },
              "endpoints": {
                "type": "string",
                "description": "Accepts a list of endpoints to retrieve from the remote device using the REST API.  The endpoints should be valid endpoints available on the device.  This argument is only valid when the C(transport=rest)."
              },
              "config": {
                "type": "string",
                "description": "When enabled, this argument will collect the current running configuration from the remote device.  If the C(transport=rest) then the collected configuration will be the full system configuration."
              }
            }
          },
          "avi_applicationprofile": {
            "required": [
              "name",
              "type"
            ],
            "type": "object",
            "description": "This module is used to configure ApplicationProfile object\nmore examples at U(https://github.com/avinetworks/devops)",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "tcp_app_profile": {
                "type": "object",
                "description": "Specifies the tcp application proxy profile parameters."
              },
              "uuid": {
                "type": "string",
                "description": "Uuid of the application profile."
              },
              "url": {
                "type": "string",
                "description": "Avi controller URL of the object."
              },
              "type": {
                "type": "string",
                "description": "Specifies which application layer proxy is enabled for the virtual service."
              },
              "description": {
                "type": "string",
                "description": "User defined description for the object."
              },
              "tenant_ref": {
                "type": "string",
                "description": "It is a reference to an object of type tenant."
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state that should be applied on the entity."
              },
              "http_profile": {
                "type": "object",
                "description": "Specifies the http application proxy profile parameters."
              },
              "dns_service_profile": {
                "type": "object",
                "description": "Specifies various dns service related controls for virtual service."
              },
              "controller": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "dos_rl_profile": {
                "type": "object",
                "description": "Specifies various security related controls for virtual service."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "preserve_client_ip": {
                "description": "Specifies if client ip needs to be preserved for backend connection.\nNot compatible with connection multiplexing.\nDefault value when not specified in API or module is interpreted by Avi Controller as False.",
                "$ref": "#/definitions/ansible_truth"
              },
              "tenant_uuid": {
                "type": "string",
                "description": ""
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the application profile."
              }
            }
          },
          "execute_lambda": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module executes AWS Lambda functions, allowing synchronous and asynchronous invocation.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the function to be invoked. This can only be used for invocations within the calling account. To invoke a function in another account, use I(function_arn) to specify the full ARN."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "dry_run": {
                "description": "Do not *actually* invoke the function. A C(DryRun) call will check that the caller has permissions to call the function, especially for checking cross-account permissions.",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: True\n\nWhether to wait for the function results or not. If I(wait) is false, the task will not return any results. To wait for the Lambda function to complete, set C(wait=true) and the result will be available in the I(output) key.",
                "$ref": "#/definitions/ansible_truth"
              },
              "function_arn": {
                "type": "string",
                "description": "Default: None\n\nThe name of the function to be invoked"
              },
              "tail_log": {
                "description": "If C(tail_log=true), the result of the task will include the last 4 KB of the CloudWatch log for the function execution. Log tailing only works if you use synchronous invocation C(wait=true). This is usually used for development or testing Lambdas.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "version_qualifier": {
                "type": "string",
                "description": "Default: LATEST\n\nWhich version/alias of the function to run. This defaults to the C(LATEST) revision, but can be set to any existing version or alias. See https;//docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html for details."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "payload": {
                "type": "object",
                "description": "A dictionary in any form to be provided as input to the Lambda function."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ipadm_ifprop": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "interface",
                        "nic"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "interface"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "nic"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "property",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "property"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Modify IP interface properties on Solaris/illumos systems.",
            "properties": {
              "temporary": {
                "description": "Specifies that the property value is temporary. Temporary property values do not persist across reboots.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Specifies the name of the property we want to manage."
              },
              "nic": {
                "type": "string",
                "description": "Specifies the IP interface we want to manage."
              },
              "value": {
                "type": "string",
                "description": "Specifies the value we want to set for the property."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "reset"
                ],
                "type": "string",
                "description": "Default: present\n\nSet or reset the property value."
              },
              "interface": {
                "type": "string",
                "description": "Specifies the IP interface we want to manage."
              },
              "protocol": {
                "enum": [
                  "ipv4",
                  "ipv6"
                ],
                "type": "string",
                "description": "Specifies the procotol for which we want to manage properties."
              },
              "property": {
                "type": "string",
                "description": "Specifies the name of the property we want to manage."
              }
            }
          },
          "win_lineinfile": {
            "type": "object",
            "description": "This module will search a file for a line, and ensure that it is present or absent.\nThis is primarily useful when you want to change a single line in a file only.",
            "properties": {
              "insertbefore": {
                "type": "string",
                "description": "Used with C(state=present). If specified, the line will be inserted before the last match of specified regular expression. A value is available; C(BOF) for inserting the line at the beginning of the file.\nIf specified regular expression has no matches, the line will be inserted at the end of the file. May not be used with C(backrefs)."
              },
              "encoding": {
                "type": "string",
                "description": "Default: auto\n\nSpecifies the encoding of the source text file to operate on (and thus what the output encoding will be). The default of C(auto) will cause the module to auto-detect the encoding of the source file and ensure that the modified file is written with the same encoding.\nAn explicit encoding can be passed as a string that is a valid value to pass to the .NET framework System.Text.Encoding.GetEncoding() method - see U(https://msdn.microsoft.com/en-us/library/system.text.encoding%28v=vs.110%29.aspx).\nThis is mostly useful with C(create=yes) if you want to create a new file with a specific encoding. If C(create=yes) is specified without a specific encoding, the default encoding (UTF-8, no BOM) will be used."
              },
              "create": {
                "type": "string",
                "description": "Default: no\n\nUsed with C(state=present). If specified, the file will be created if it does not already exist. By default it will fail if the file is missing."
              },
              "newline": {
                "type": "string",
                "description": "Default: windows\n\nSpecifies the line separator style to use for the modified file. This defaults to the windows line separator (C(\r\n)). Note that the indicated line separator will be used for file output regardless of the original line separator that appears in the input file."
              },
              "backrefs": {
                "type": "string",
                "description": "Default: no\n\nUsed with C(state=present). If set, line can contain backreferences (both positional and named) that will get populated if the C(regexp) matches. This flag changes the operation of the module slightly; C(insertbefore) and C(insertafter) will be ignored, and if the C(regexp) doesn't match anywhere in the file, the file will be left unchanged.\nIf the C(regexp) does match, the last matching line will be replaced by the expanded line parameter."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nWhether the line should be there or not."
              },
              "regexp": {
                "type": "string",
                "description": "The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove. Uses .NET compatible regular expressions; see U(https://msdn.microsoft.com/en-us/library/hs600312%28v=vs.110%29.aspx)."
              },
              "insertafter": {
                "type": "string",
                "description": "Default: EOF\n\nUsed with C(state=present). If specified, the line will be inserted after the last match of specified regular expression. A special value is available; C(EOF) for inserting the line at the end of the file.\nIf specified regular expression has no matches, EOF will be used instead. May not be used with C(backrefs)."
              },
              "path": {
                "type": "string",
                "description": "The path of the file to modify.\nNote that the Windows path delimiter C(\\) must be escaped as C(\\\\) when the line is double quoted.\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "line": {
                "type": "string",
                "description": "Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches."
              },
              "backup": {
                "type": "string",
                "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
              },
              "validate": {
                "type": "string",
                "description": "Default: None\n\nValidation to run before copying into place. Use %s in the command to indicate the current file to validate.\nThe command is passed securely so shell features like expansion and pipes won't work."
              }
            }
          },
          "dpkg_selections": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Change dpkg package selection state via --get-selections and --set-selections.",
            "properties": {
              "selection": {
                "enum": [
                  "install",
                  "hold",
                  "deinstall",
                  "purge"
                ],
                "type": "string",
                "description": "The selection state to set the package to."
              },
              "name": {
                "type": "string",
                "description": "Name of the package"
              }
            }
          },
          "ec2_ami": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates or deletes ec2 images.",
            "properties": {
              "launch_permissions": {
                "type": "object",
                "description": "Users and groups that should be able to launch the AMI. Expects dictionary with a key of user_ids and/or group_names. user_ids should be a list of account ids. group_name should be a list of groups, \"all\" is the only acceptable value currently."
              },
              "no_reboot": {
                "description": "Flag indicating that the bundling process should not attempt to shutdown the instance before bundling. If this flag is True, the responsibility of maintaining file system integrity is left to the owner of the instance.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nCreate or deregister/delete AMI."
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "virtualization_type": {
                "type": "string",
                "description": "The virtualization type of the image to register"
              },
              "root_device_name": {
                "type": "string",
                "description": "The root device name of the image to register"
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "description": {
                "type": "string",
                "description": "Human-readable string describing the contents and purpose of the AMI."
              },
              "tags": {
                "type": "object",
                "description": "A dictionary of tags to add to the new image; '{\"key\":\"value\"}' and '{\"key\":\"value\",\"key\":\"value\"}'"
              },
              "kernel_id": {
                "type": "string",
                "description": "The target kernel id of the image to register"
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "image_id": {
                "type": "string",
                "description": "Image ID to be deregistered."
              },
              "wait_timeout": {
                "type": "string",
                "description": "Default: 300\n\nHow long before wait gives up, in seconds."
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "wait": {
                "description": "Default: no\n\nWait for the AMI to be in state 'available' before returning.",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "The name of the new AMI."
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "delete_snapshot": {
                "description": "Default: no\n\nDelete snapshots when deregistering the AMI.",
                "$ref": "#/definitions/ansible_truth"
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "instance_id": {
                "type": "string",
                "description": "Instance ID to create the AMI from."
              },
              "architecture": {
                "type": "string",
                "description": "The target architecture of the image to register"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "device_mapping": {
                "description": "List of device hashes/dictionaries with custom configurations (same block-device-mapping parameters)\nValid properties include: device_name, volume_type, size (in GB), delete_on_termination (boolean), no_device (boolean), snapshot_id, iops (for io1 volume_type)",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "nxos_acl_interface": {
            "required": [
              "direction",
              "interface"
            ],
            "type": "object",
            "description": "Manages applying ACLs to interfaces.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "direction": {
                "enum": [
                  "ingress",
                  "egress"
                ],
                "type": "string",
                "description": "Direction ACL to be applied in on the interface."
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Case sensitive name of the access list (ACL)."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nSpecify desired state of the resource."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "interface": {
                "type": "string",
                "description": "Full name of interface, e.g. I(Ethernet1/1)."
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "clc_alert_policy": {
            "required": [
              "alias"
            ],
            "type": "object",
            "description": "An Ansible module to Create or Delete Alert Policies at CenturyLink Cloud.",
            "properties": {
              "name": {
                "type": "string",
                "description": "Default: None\n\nThe name of the alert policy. This is mutually exclusive with id"
              },
              "metric": {
                "enum": [
                  "cpu",
                  "memory",
                  "disk"
                ],
                "type": "string",
                "description": "Default: None\n\nThe metric on which to measure the condition that will trigger the alert. This is required for state 'present'"
              },
              "id": {
                "type": "string",
                "description": "Default: None\n\nThe alert policy id. This is mutually exclusive with name"
              },
              "alias": {
                "type": "string",
                "description": "The alias of your CLC Account"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to create or delete the policy."
              },
              "threshold": {
                "description": "Default: None\n\nThe threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0",
                "$ref": "#/definitions/ansible_number"
              },
              "alert_recipients": {
                "description": "Default: None\n\nA list of recipient email ids to notify the alert. This is required for state 'present'",
                "$ref": "#/definitions/ansible_array"
              },
              "duration": {
                "type": "string",
                "description": "Default: None\n\nThe length of time in minutes that the condition must exceed the threshold. This is required for state 'present'"
              }
            }
          },
          "ovirt_vms_facts": {
            "type": "object",
            "description": "Retrieve facts about one or more oVirt virtual machines.",
            "properties": {
              "all_content": {
                "type": "string",
                "description": "If I(true) all the attributes of the virtual machines should be included in the response."
              },
              "pattern": {
                "type": "string",
                "description": "Search term which is accepted by oVirt search backend.\nFor example to search VM X from cluster Y use following pattern: name=X and cluster=Y"
              },
              "max": {
                "type": "string",
                "description": "The maximum number of results to return."
              },
              "case_sensitive": {
                "type": "string",
                "description": "If I(true) performed search will take case into account."
              }
            }
          },
          "win_iis_virtualdirectory": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Creates, Removes and configures a virtual directory in IIS.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nWhether to add or remove the specified virtual directory"
              },
              "names": {
                "type": "string",
                "description": "The name of the virtual directory to create or remove"
              },
              "name": {
                "type": "string",
                "description": "The name of the virtual directory to create or remove"
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "win_domain_membership": {
            "type": "object",
            "description": "Manages domain membership or workgroup membership for a Windows host. Also supports hostname changes. This module may require subsequent use of the M(win_reboot) action if changes are made.",
            "properties": {
              "workgroup_name": {
                "type": "string",
                "description": "when C(state) is C(workgroup), the name of the workgroup that the Windows host should be in"
              },
              "domain_admin_user": {
                "type": "string",
                "description": "username of a domain admin for the target domain (required to join or leave the domain)"
              },
              "dns_domain_name": {
                "type": "string",
                "description": "when C(state) is C(domain), the DNS name of the domain to which the targeted Windows host should be joined"
              },
              "hostname": {
                "type": "string",
                "description": "the desired hostname for the Windows host"
              },
              "domain_admin_password": {
                "type": "string",
                "description": "password for the specified C(domain_admin_user)"
              },
              "state": {
                "type": "string",
                "description": "whether the target host should be a member of a domain or workgroup"
              }
            }
          },
          "win_domain": {
            "type": "object",
            "description": "Ensure that the domain named by C(dns_domain_name) exists and is reachable. If the domain is not reachable, the domain is created in a new forest on the target Windows Server 2012R2+ host. This module may require subsequent use of the M(win_reboot) action if changes are made.",
            "properties": {
              "dns_domain_name": {
                "type": "string",
                "description": "the DNS name of the domain which should exist and be reachable or reside on the target Windows host"
              },
              "safe_mode_password": {
                "type": "string",
                "description": "safe mode password for the domain controller"
              }
            }
          },
          "os_zone": {
            "type": "object",
            "description": "Manage OpenStack DNS zones. Zones can be created, deleted or updated. Only the I(email), I(description), I(ttl) and I(masters) values can be updated.",
            "properties": {
              "masters": {
                "type": "string",
                "description": "Default: None\n\nMaster nameservers (only applies if zone_type is secondary)"
              },
              "description": {
                "type": "string",
                "description": "Default: None\n\nZone description"
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nShould the resource be present or absent."
              },
              "ttl": {
                "type": "string",
                "description": "Default: None\n\nTTL (Time To Live) value in seconds"
              },
              "zone_type": {
                "type": "string",
                "description": "Default: None\n\nZone type"
              },
              "email": {
                "type": "string",
                "description": "Email of the zone owner (only applies if zone_type is primary)"
              },
              "name": {
                "type": "string",
                "description": "Zone name"
              }
            }
          },
          "crypttab": {
            "required": [
              "state",
              "name"
            ],
            "type": "object",
            "description": "Control Linux encrypted block devices that are set up during system boot in C(/etc/crypttab).",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionaly prefixed with C(/dev/mapper/), as it appears in the filesystem. I(/dev/mapper/) will be stripped from I(name)."
              },
              "backing_device": {
                "type": "string",
                "description": "Path to the underlying block device or file, or the UUID of a block-device prefixed with I(UUID=)"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "opts_present",
                  "opts_absent"
                ],
                "type": "string",
                "description": "Use I(present) to add a line to C(/etc/crypttab) or update it's definition if already present. Use I(absent) to remove a line with matching I(name). Use I(opts_present) to add options to those already present; options with different values will be updated. Use I(opts_absent) to remove options from the existing set."
              },
              "path": {
                "type": "string",
                "description": "Default: /etc/crypttab\n\nPath to file to use instead of C(/etc/crypttab). This might be useful in a chroot environment."
              },
              "password": {
                "type": "string",
                "description": "Default: none\n\nEncryption password, the path to a file containing the pasword, or 'none' or '-' if the password should be entered at boot."
              },
              "opts": {
                "type": "string",
                "description": "A comma-delimited list of options. See C(crypttab(5) ) for details."
              }
            }
          },
          "riak": {
            "type": "object",
            "description": "This module can be used to join nodes to a cluster, check the status of the cluster.",
            "properties": {
              "target_node": {
                "type": "string",
                "description": "Default: riak@127.0.0.1\n\nThe target node for certain operations (join, ping)"
              },
              "config_dir": {
                "type": "string",
                "description": "Default: /etc/riak\n\nThe path to the riak configuration directory"
              },
              "wait_for_service": {
                "enum": [
                  "kv"
                ],
                "type": "string",
                "description": "Default: None\n\nWaits for a riak service to come online before continuing."
              },
              "http_conn": {
                "type": "string",
                "description": "Default: 127.0.0.1:8098\n\nThe ip address and port that is listening for Riak HTTP queries"
              },
              "wait_for_ring": {
                "description": "Number of seconds to wait for all nodes to agree on the ring.",
                "$ref": "#/definitions/ansible_number"
              },
              "wait_for_handoffs": {
                "description": "Number of seconds to wait for handoffs to complete.",
                "$ref": "#/definitions/ansible_number"
              },
              "command": {
                "enum": [
                  "ping",
                  "kv_test",
                  "join",
                  "plan",
                  "commit"
                ],
                "type": "string",
                "description": "The command you would like to perform against the cluster."
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "serverless": {
            "required": [
              "service_path"
            ],
            "type": "object",
            "description": "Provides support for managing Serverless Framework (https://serverless.com/) project deployments and stacks.",
            "properties": {
              "functions": {
                "description": "A list of specific functions to deploy. If this is not provided, all functions in the service will be deployed.",
                "$ref": "#/definitions/ansible_array"
              },
              "deploy": {
                "description": "Default: True\n\nWhether or not to deploy artifacts after building them. When this option is `false` all the functions will be built, but no stack update will be run to send them out. This is mostly useful for generating artifacts to be stored/deployed elsewhere.",
                "$ref": "#/definitions/ansible_truth"
              },
              "region": {
                "type": "string",
                "description": "Default: us-east-1\n\nAWS region to deploy the service to"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nGoal state of given stage/project"
              },
              "service_path": {
                "type": "string",
                "description": "The path to the root of the Serverless Service to be operated on."
              },
              "stage": {
                "type": "string",
                "description": ""
              }
            }
          },
          "ec2_vol_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gather facts about ec2 volumes in AWS",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "filters": {
                "type": "object",
                "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html) for possible filters."
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              }
            }
          },
          "stat": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "checksum_algorithm",
                        "checksum_algo",
                        "checksum"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "get_mime",
                        "mime",
                        "mime_type",
                        "mime-type"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "get_attributes",
                        "attributes",
                        "attr"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Retrieves facts for a file similar to the linux/unix 'stat' command.",
            "properties": {
              "attr": {
                "description": "Default: True\n\nGet file attributes using lsattr tool if present.",
                "$ref": "#/definitions/ansible_truth"
              },
              "checksum_algorithm": {
                "enum": [
                  "sha1",
                  "sha224",
                  "sha256",
                  "sha384",
                  "sha512"
                ],
                "type": "string",
                "description": "Default: sha1\n\nAlgorithm to determine checksum of file. Will throw an error if the host is unable to use specified algorithm."
              },
              "mime-type": {
                "description": "Default: True\n\nUse file magic and return data about the nature of the file. this uses the 'file' utility found on most Linux/Unix systems.\nThis will add both `mime_type` and 'charset' fields to the return, if possible.\nIn 2.3 this option changed from 'mime' to 'get_mime' and the default changed to 'Yes'",
                "$ref": "#/definitions/ansible_truth"
              },
              "mime": {
                "description": "Default: True\n\nUse file magic and return data about the nature of the file. this uses the 'file' utility found on most Linux/Unix systems.\nThis will add both `mime_type` and 'charset' fields to the return, if possible.\nIn 2.3 this option changed from 'mime' to 'get_mime' and the default changed to 'Yes'",
                "$ref": "#/definitions/ansible_truth"
              },
              "get_attributes": {
                "description": "Default: True\n\nGet file attributes using lsattr tool if present.",
                "$ref": "#/definitions/ansible_truth"
              },
              "get_checksum": {
                "description": "Default: True\n\nWhether to return a checksum of the file (default sha1)",
                "$ref": "#/definitions/ansible_truth"
              },
              "checksum": {
                "enum": [
                  "sha1",
                  "sha224",
                  "sha256",
                  "sha384",
                  "sha512"
                ],
                "type": "string",
                "description": "Default: sha1\n\nAlgorithm to determine checksum of file. Will throw an error if the host is unable to use specified algorithm."
              },
              "checksum_algo": {
                "enum": [
                  "sha1",
                  "sha224",
                  "sha256",
                  "sha384",
                  "sha512"
                ],
                "type": "string",
                "description": "Default: sha1\n\nAlgorithm to determine checksum of file. Will throw an error if the host is unable to use specified algorithm."
              },
              "follow": {
                "description": "Whether to follow symlinks",
                "$ref": "#/definitions/ansible_truth"
              },
              "path": {
                "type": "string",
                "description": "The full path of the file/object to get the facts of"
              },
              "get_mime": {
                "description": "Default: True\n\nUse file magic and return data about the nature of the file. this uses the 'file' utility found on most Linux/Unix systems.\nThis will add both `mime_type` and 'charset' fields to the return, if possible.\nIn 2.3 this option changed from 'mime' to 'get_mime' and the default changed to 'Yes'",
                "$ref": "#/definitions/ansible_truth"
              },
              "get_md5": {
                "description": "Default: True\n\nWhether to return the md5 sum of the file.  Will return None if we're unable to use md5 (Common for FIPS-140 compliant systems)",
                "$ref": "#/definitions/ansible_truth"
              },
              "mime_type": {
                "description": "Default: True\n\nUse file magic and return data about the nature of the file. this uses the 'file' utility found on most Linux/Unix systems.\nThis will add both `mime_type` and 'charset' fields to the return, if possible.\nIn 2.3 this option changed from 'mime' to 'get_mime' and the default changed to 'Yes'",
                "$ref": "#/definitions/ansible_truth"
              },
              "attributes": {
                "description": "Default: True\n\nGet file attributes using lsattr tool if present.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "vmware_local_user_manager": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage local users on an ESXi host",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": ""
              },
              "hostname": {
                "type": "string",
                "description": ""
              },
              "pwd": {
                "type": "string",
                "description": ""
              },
              "local_user_password": {
                "type": "string",
                "description": "The password to be set"
              },
              "local_user_description": {
                "type": "string",
                "description": "Description for the user"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the user. If the user already exists when C(state=present), the user info is updated"
              },
              "user": {
                "type": "string",
                "description": ""
              },
              "pass": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "local_user_name": {
                "type": "string",
                "description": "The local user name to be changed"
              }
            }
          },
          "ipa_sudocmdgroup": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cn",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "cn"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, modify or delete sudo command group within IPA server using IPA API.",
            "properties": {
              "ipa_port": {
                "description": "Default: 443\n\nPort of IPA server",
                "$ref": "#/definitions/ansible_number"
              },
              "cn": {
                "type": "string",
                "description": "Sudo Command Group."
              },
              "description": {
                "type": "string",
                "description": "Group description."
              },
              "ipa_prot": {
                "enum": [
                  "http",
                  "https"
                ],
                "type": "string",
                "description": "Default: https\n\nProtocol used by IPA server"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState to ensure"
              },
              "ipa_host": {
                "type": "string",
                "description": "Default: ipa.example.com\n\nIP or hostname of IPA server"
              },
              "ipa_user": {
                "type": "string",
                "description": "Default: admin\n\nAdministrative account used on IPA server"
              },
              "ipa_pass": {
                "type": "string",
                "description": "Password of administrative user"
              },
              "sudocmd": {
                "description": "List of sudo commands to assign to the group.\nIf an empty list is passed all assigned commands will be removed from the group.\nIf option is omitted sudo commands will not be checked or changed.",
                "$ref": "#/definitions/ansible_array"
              },
              "validate_certs": {
                "description": "Default: True\n\nThis only applies if C(ipa_prot) is I(https).\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Sudo Command Group."
              }
            }
          },
          "kubernetes": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "url_password",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "url_username",
                        "username"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module can manage Kubernetes resources on an existing cluster using the Kubernetes server API. Users can specify in-line API data, or specify an existing Kubernetes YAML file. Currently, this module, Only supports HTTP Basic Auth Only supports 'strategic merge' for update, http://goo.gl/fCPYxT SSL certs are not working, use 'validate_certs=off' to disable",
            "properties": {
              "username": {
                "type": "string",
                "description": "Default: admin\n\nThe HTTP Basic Auth username for the API I(endpoint). This should be set unless using the C('insecure') option."
              },
              "url_password": {
                "type": "string",
                "description": "The HTTP Basic Auth password for the API I(endpoint). This should be set unless using the C('insecure') option."
              },
              "certificate_authority_data": {
                "type": "string",
                "description": "Certificate Authority data for Kubernetes server. Should be in either standard PEM format or base64 encoded PEM data. Note that certificate verification is broken until ansible supports a version of 'match_hostname' that can match the IP address against the CA data."
              },
              "inline_data": {
                "type": "string",
                "description": "The Kubernetes YAML data to send to the API I(endpoint). This option is mutually exclusive with C('file_reference')."
              },
              "insecure": {
                "description": "Reverts the connection to using HTTP instead of HTTPS. This option should only be used when execuing the M('kubernetes') module local to the Kubernetes cluster using the insecure local port (locahost:8080 by default).",
                "$ref": "#/definitions/ansible_truth"
              },
              "force_basic_auth": {
                "type": "string",
                "description": ""
              },
              "file_reference": {
                "type": "string",
                "description": "Specify full path to a Kubernets YAML file to send to API I(endpoint). This option is mutually exclusive with C('inline_data')."
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "update",
                  "replace"
                ],
                "type": "string",
                "description": "Default: present\n\nThe desired action to take on the Kubernetes data."
              },
              "api_endpoint": {
                "type": "string",
                "description": "The IPv4 API endpoint of the Kubernetes cluster."
              },
              "url_username": {
                "type": "string",
                "description": "Default: admin\n\nThe HTTP Basic Auth username for the API I(endpoint). This should be set unless using the C('insecure') option."
              },
              "password": {
                "type": "string",
                "description": "The HTTP Basic Auth password for the API I(endpoint). This should be set unless using the C('insecure') option."
              },
              "validate_certs": {
                "description": "Enable/disable certificate validation. Note that this is set to C(false) until Ansible can support IP address based certificate hostname matching (exists in >= python3.5.0).",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "docker_container": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "docker_host",
                        "docker_url"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force_kill",
                        "forcekill"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "log_options",
                        "log_opt"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "key_path",
                        "tls_client_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "published_ports",
                        "ports"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_version",
                        "docker_api_version"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "exposed_ports",
                        "exposed",
                        "expose"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cacert_path",
                        "tls_ca_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "cert_path",
                        "tls_client_cert"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage the life cycle of docker containers.\nSupports check mode. Run with --check and --diff to view config difference and list of actions to be taken.",
            "properties": {
              "tty": {
                "description": "Allocate a psuedo-TTY.",
                "$ref": "#/definitions/ansible_truth"
              },
              "dns_servers": {
                "description": "List of custom DNS servers.",
                "$ref": "#/definitions/ansible_array"
              },
              "labels": {
                "type": "object",
                "description": "Dictionary of key value pairs."
              },
              "docker_host": {
                "type": "string",
                "description": ""
              },
              "cpuset_cpus": {
                "type": "string",
                "description": "CPUs in which to allow execution C(1,3) or C(1-3)."
              },
              "tls_client_key": {
                "type": "string",
                "description": ""
              },
              "force_kill": {
                "description": "Use the kill command when stopping a running container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "networks": {
                "description": "List of networks the container belongs to.\nEach network is a dict with keys C(name), C(ipv4_address), C(ipv6_address), C(links), C(aliases).\nFor each network C(name) is required, all other keys are optional.\nIf included, C(links) or C(aliases) are lists.\nFor examples of the data structure and usage see EXAMPLES below.\nTo remove a container from one or more networks, use the C(purge_networks) option.",
                "$ref": "#/definitions/ansible_array"
              },
              "capabilities": {
                "description": "List of capabilities to add to the container.",
                "$ref": "#/definitions/ansible_array"
              },
              "tls_ca_cert": {
                "type": "string",
                "description": ""
              },
              "volumes_from": {
                "description": "List of container names or Ids to get volumes from.",
                "$ref": "#/definitions/ansible_array"
              },
              "log_options": {
                "type": "object",
                "description": "Dictionary of options specific to the chosen log_driver. See https://docs.docker.com/engine/admin/logging/overview/ for details."
              },
              "network_mode": {
                "type": "string",
                "description": "Connect the container to a network."
              },
              "detach": {
                "description": "Default: True\n\nEnable detached mode to leave the container running in background. If disabled, the task will reflect the status of the container run (failed if the command failed).",
                "$ref": "#/definitions/ansible_truth"
              },
              "restart": {
                "description": "Use with started state to force a matching container to be stopped and restarted.",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Assign a name to a new container or match an existing container.\nWhen identifying an existing container name may be a name or a long or short container ID."
              },
              "docker_api_version": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "debug": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ports": {
                "description": "List of ports to publish from the container to the host.\nUse docker CLI syntax: C(8000), C(9000:8000), or C(0.0.0.0:9000:8000), where 8000 is a container port, 9000 is a host port, and 0.0.0.0 is a host interface.\nContainer ports must be exposed either in the Dockerfile or via the C(expose) option.\nA value of all will publish all exposed container ports to random host ports, ignoring any other mappings.\nIf C(networks) parameter is provided, will inspect each network to see if there exists a bridge network with optional parameter com.docker.network.bridge.host_binding_ipv4. If such a network is found, then published ports where no host IP address is specified will be bound to the host IP pointed to by com.docker.network.bridge.host_binding_ipv4. Note that the first bridge network with a com.docker.network.bridge.host_binding_ipv4 value encountered in the list of C(networks) is the one that will be used.",
                "$ref": "#/definitions/ansible_array"
              },
              "ulimits": {
                "description": "List of ulimit options. A ulimit is specified as C(nofile:262144:262144)",
                "$ref": "#/definitions/ansible_array"
              },
              "cpu_shares": {
                "description": "CPU shares (relative weight).",
                "$ref": "#/definitions/ansible_number"
              },
              "exposed": {
                "description": "List of additional container ports which informs Docker that the container listens on the specified network ports at runtime. If the port is already exposed using EXPOSE in a Dockerfile, it does not need to be exposed again.",
                "$ref": "#/definitions/ansible_array"
              },
              "tls_verify": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "dns_search_domains": {
                "description": "List of custom DNS search domains.",
                "$ref": "#/definitions/ansible_array"
              },
              "env_file": {
                "type": "string",
                "description": "Path to a file containing environment variables I(FOO=BAR).\nIf variable also present in C(env), then C(env) value will override.\nRequires docker-py >= 1.4.0."
              },
              "cpu_quota": {
                "description": "Limit CPU CFS (Completely Fair Scheduler) quota",
                "$ref": "#/definitions/ansible_number"
              },
              "cpuset_mems": {
                "type": "string",
                "description": "Memory nodes (MEMs) in which to allow execution C(0-3) or C(0,1)"
              },
              "state": {
                "enum": [
                  "absent",
                  "present",
                  "stopped",
                  "started"
                ],
                "type": "string",
                "description": "Default: started\n\nI(absent) - A container matching the specified name will be stopped and removed. Use force_kill to kill the container rather than stopping it. Use keep_volumes to retain volumes associated with the removed container.\nI(present) - Asserts the existence of a container matching the name and any provided configuration parameters. If no container matches the name, a container will be created. If a container matches the name but the provided configuration does not match, the container will be updated, if it can be. If it cannot be updated, it will be removed and re-created with the requested config. Image version will be taken into account when comparing configuration. To ignore image version use the ignore_image option. Use the recreate option to force the re-creation of the matching container. Use force_kill to kill the container rather than stopping it. Use keep_volumes to retain volumes associated with a removed container.\nI(started) - Asserts there is a running container matching the name and any provided configuration. If no container matches the name, a container will be created and started. If a container matching the name is found but the configuration does not match, the container will be updated, if it can be. If it cannot be updated, it will be removed and a new container will be created with the requested configuration and started. Image version will be taken into account when comparing configuration. To ignore image version use the ignore_image option. Use recreate to always re-create a matching container, even if it is running. Use restart to force a matching container to be stopped and restarted. Use force_kill to kill a container rather than stopping it. Use keep_volumes to retain volumes associated with a removed container.\nI(stopped) - Asserts that the container is first I(present), and then if the container is running moves it to a stopped state. Use force_kill to kill a container rather than stopping it."
              },
              "tls_client_cert": {
                "type": "string",
                "description": ""
              },
              "key_path": {
                "type": "string",
                "description": ""
              },
              "published_ports": {
                "description": "List of ports to publish from the container to the host.\nUse docker CLI syntax: C(8000), C(9000:8000), or C(0.0.0.0:9000:8000), where 8000 is a container port, 9000 is a host port, and 0.0.0.0 is a host interface.\nContainer ports must be exposed either in the Dockerfile or via the C(expose) option.\nA value of all will publish all exposed container ports to random host ports, ignoring any other mappings.\nIf C(networks) parameter is provided, will inspect each network to see if there exists a bridge network with optional parameter com.docker.network.bridge.host_binding_ipv4. If such a network is found, then published ports where no host IP address is specified will be bound to the host IP pointed to by com.docker.network.bridge.host_binding_ipv4. Note that the first bridge network with a com.docker.network.bridge.host_binding_ipv4 value encountered in the list of C(networks) is the one that will be used.",
                "$ref": "#/definitions/ansible_array"
              },
              "api_version": {
                "type": "string",
                "description": ""
              },
              "exposed_ports": {
                "description": "List of additional container ports which informs Docker that the container listens on the specified network ports at runtime. If the port is already exposed using EXPOSE in a Dockerfile, it does not need to be exposed again.",
                "$ref": "#/definitions/ansible_array"
              },
              "cpu_period": {
                "description": "Limit CPU CFS (Completely Fair Scheduler) period",
                "$ref": "#/definitions/ansible_number"
              },
              "shm_size": {
                "type": "string",
                "description": "Size of `/dev/shm`. The format is `<number><unit>`. `number` must be greater than `0`. Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes).\nOmitting the unit defaults to bytes. If you omit the size entirely, the system uses `64m`."
              },
              "tls_hostname": {
                "type": "string",
                "description": ""
              },
              "volume_driver": {
                "type": "string",
                "description": "Default: none\n\nThe container volume driver."
              },
              "restart_retries": {
                "description": "Use with restart policy to control maximum number of restart attempts.",
                "$ref": "#/definitions/ansible_number"
              },
              "groups": {
                "description": "List of additional group names and/or IDs that the container process will run as.",
                "$ref": "#/definitions/ansible_array"
              },
              "tls": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ignore_image": {
                "description": "When C(state) is I(present) or I(started) the module compares the configuration of an existing container to requested configuration. The evaluation includes the image version. If the image version in the registry does not match the container, the container will be recreated. Stop this behavior by setting C(ignore_image) to I(True).",
                "$ref": "#/definitions/ansible_truth"
              },
              "dns_opts": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "ipc_mode": {
                "type": "string",
                "description": "Set the IPC mode for the container. Can be one of 'container:<name|id>' to reuse another container's IPC namespace or 'host' to use the host's IPC namespace within the container."
              },
              "forcekill": {
                "description": "Use the kill command when stopping a running container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "keep_volumes": {
                "description": "Default: True\n\nRetain volumes associated with a removed container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "image": {
                "type": "string",
                "description": "Repository path and tag used to create the container. If an image is not found or pull is true, the image will be pulled from the registry. If no tag is included, 'latest' will be used."
              },
              "recreate": {
                "description": "Use with present and started states to force the re-creation of an existing container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "pid_mode": {
                "type": "string",
                "description": "Set the PID namespace mode for the container. Currently only supports 'host'."
              },
              "filter_logger": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "memory": {
                "type": "string",
                "description": "Memory limit (format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g"
              },
              "expose": {
                "description": "List of additional container ports which informs Docker that the container listens on the specified network ports at runtime. If the port is already exposed using EXPOSE in a Dockerfile, it does not need to be exposed again.",
                "$ref": "#/definitions/ansible_array"
              },
              "mac_address": {
                "type": "string",
                "description": "Container MAC address (e.g. 92:d0:c6:0a:29:33)"
              },
              "memory_swappiness": {
                "description": "Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.",
                "$ref": "#/definitions/ansible_number"
              },
              "memory_swap": {
                "type": "string",
                "description": "Total memory limit (memory + swap, format:<number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g."
              },
              "pull": {
                "description": "If true, always pull the latest version of an image. Otherwise, will only pull an image when missing.",
                "$ref": "#/definitions/ansible_truth"
              },
              "stop_signal": {
                "type": "string",
                "description": "Override default signal used to stop the container."
              },
              "log_opt": {
                "type": "object",
                "description": "Dictionary of options specific to the chosen log_driver. See https://docs.docker.com/engine/admin/logging/overview/ for details."
              },
              "devices": {
                "description": "List of host device bindings to add to the container. Each binding is a mapping expressed in the format: <path_on_host>:<path_in_container>:<cgroup_permissions>",
                "$ref": "#/definitions/ansible_array"
              },
              "uts": {
                "type": "string",
                "description": "Set the UTS namespace mode for the container."
              },
              "blkio_weight": {
                "description": "Block IO (relative weight), between 10 and 1000.",
                "$ref": "#/definitions/ansible_number"
              },
              "interactive": {
                "description": "Keep stdin open after a container is launched, even if not attached.",
                "$ref": "#/definitions/ansible_truth"
              },
              "links": {
                "description": "List of name aliases for linked containers in the format C(container_name:alias)",
                "$ref": "#/definitions/ansible_array"
              },
              "oom_score_adj": {
                "description": "An integer value containing the score given to the container in order to tune OOM killer preferences.",
                "$ref": "#/definitions/ansible_number"
              },
              "restart_policy": {
                "enum": [
                  "no",
                  "on-failure",
                  "always",
                  "unless-stopped"
                ],
                "type": "string",
                "description": "Default: on-failure\n\nContainer restart policy. Place quotes around I(no) option."
              },
              "paused": {
                "description": "Use with the started state to pause running processes inside the container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "stop_timeout": {
                "description": "Number of seconds to wait for the container to stop before sending SIGKILL.",
                "$ref": "#/definitions/ansible_number"
              },
              "security_opts": {
                "description": "List of security options in the form of C(\"label:user:User\")",
                "$ref": "#/definitions/ansible_array"
              },
              "read_only": {
                "description": "Mount the container's root file system as read-only.",
                "$ref": "#/definitions/ansible_truth"
              },
              "hostname": {
                "type": "string",
                "description": "Container hostname."
              },
              "docker_url": {
                "type": "string",
                "description": ""
              },
              "cleanup": {
                "description": "Use with I(detach) to remove the container after successful execution.",
                "$ref": "#/definitions/ansible_truth"
              },
              "entrypoint": {
                "description": "Command that overwrites the default ENTRYPOINT of the image.",
                "$ref": "#/definitions/ansible_array"
              },
              "env": {
                "type": "object",
                "description": "Dictionary of key,value pairs."
              },
              "memory_reservation": {
                "type": "string",
                "description": "Memory soft limit (format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g"
              },
              "privileged": {
                "description": "Give extended privileges to the container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "trust_image_content": {
                "description": "If true, skip image verification.",
                "$ref": "#/definitions/ansible_truth"
              },
              "cacert_path": {
                "type": "string",
                "description": ""
              },
              "log_driver": {
                "enum": [
                  "none",
                  "json-file",
                  "syslog",
                  "journald",
                  "gelf",
                  "fluentd",
                  "awslogs",
                  "splunk"
                ],
                "type": "string",
                "description": "Specify the logging driver. Docker uses json-file by default."
              },
              "oom_killer": {
                "description": "Whether or not to disable OOM Killer for the container.",
                "$ref": "#/definitions/ansible_truth"
              },
              "kill_signal": {
                "type": "string",
                "description": "Override default signal used to kill a running container."
              },
              "user": {
                "type": "string",
                "description": "Sets the username or UID used and optionally the groupname or GID for the specified command.\nCan be [ user | user:group | uid | uid:gid | user:gid | uid:group ]"
              },
              "cert_path": {
                "type": "string",
                "description": ""
              },
              "purge_networks": {
                "description": "Remove the container from ALL networks not included in C(networks) parameter.\nAny default networks such as I(bridge), if not found in C(networks), will be removed as well.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssl_version": {
                "type": "string",
                "description": ""
              },
              "kernel_memory": {
                "type": "string",
                "description": "Kernel memory limit (format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g. Minimum is 4M."
              },
              "etc_hosts": {
                "type": "object",
                "description": "Dict of host-to-IP mappings, where each host name is a key in the dictionary. Each host name will be added to the container's /etc/hosts file."
              },
              "command": {
                "description": "Command to execute when the container starts.",
                "$ref": "#/definitions/ansible_array"
              },
              "volumes": {
                "description": "List of volumes to mount within the container.\nUse docker CLI-style syntax: C(/host:/container[:mode])\nYou can specify a read mode for the mount with either C(ro) or C(rw).\nSELinux hosts can additionally use C(z) or C(Z) to use a shared or private label for the volume.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "win_regedit": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Add, Edit, or Remove Registry Keys and Values using ItemProperties Cmdlets",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: present\n\nState of Registry Value"
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "azure_rm_virtualmachineimage_facts": {
            "required": [
              "location"
            ],
            "type": "object",
            "description": "Get facts for virtual machine images.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "tags": {
                "type": "object",
                "description": ""
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "append_tags": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "version": {
                "type": "string",
                "description": "Specific version number of an image."
              },
              "location": {
                "type": "string",
                "description": "Azure location value (ie. westus, eastus, eastus2, northcentralus, etc.). Supplying only a location value will yield a list of available publishers for the location."
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "sku": {
                "type": "string",
                "description": "Image offering SKU. Combine with offer to see a list of available versions."
              },
              "publisher": {
                "type": "string",
                "description": "Name of an image publisher. List image offerings associated with a particular publisher."
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "offer": {
                "type": "string",
                "description": "Name of an image offering. Combine with sku to see a list of available image versions."
              },
              "tenant": {
                "type": "string",
                "description": ""
              }
            }
          },
          "pear": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage PHP packages with the pear package manager.",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "latest",
                  "absent",
                  "removed"
                ],
                "type": "string",
                "description": "Default: present\n\nDesired state of the package."
              },
              "name": {
                "type": "string",
                "description": "Name of the package to install, upgrade, or remove."
              },
              "pkg": {
                "type": "string",
                "description": "Name of the package to install, upgrade, or remove."
              }
            }
          },
          "bigip_hostname": {
            "type": "object",
            "description": "Manage the hostname of a BIG-IP.",
            "properties": {
              "hostname": {
                "type": "string",
                "description": "Hostname of the BIG-IP host."
              }
            }
          },
          "win_find": {
            "type": "object",
            "description": "Return a list of files based on specified criteria.\nMultiple criteria are AND'd together.",
            "properties": {
              "paths": {
                "type": "string",
                "description": "List of paths of directories to search for files or folders in. This can be supplied as a single path or a list of paths."
              },
              "file_type": {
                "type": "string",
                "description": "Default: file\n\nType of file to search for"
              },
              "checksum_algorithm": {
                "type": "string",
                "description": "Default: sha1\n\nAlgorithm to determine the checksum of a file. Will throw an error if the host is unable to use specified algorithm."
              },
              "age": {
                "type": "string",
                "description": "Select files or folders whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days or weeks by specifying the first letter of an of those words (e.g., \"2s\", \"10d\", 1w\")."
              },
              "recurse": {
                "type": "string",
                "description": "Will recursively descend into the directory looking for files or folders"
              },
              "age_stamp": {
                "type": "string",
                "description": "Default: mtime\n\nChoose the file property against which we compare C(age). The default attribute we compare with is the last modification time."
              },
              "patterns": {
                "type": "string",
                "description": "One or more (powershell or regex) patterns to compare filenames with. The type of pattern matching is controlled by C(use_regex) option. The patterns retrict the list of files or folders to be returned based on the filenames. For a file to be matched it only has to match with one pattern in a list provided."
              },
              "get_checksum": {
                "type": "string",
                "description": "Default: True\n\nWhether to return a checksum of the file in the return info (default sha1), use C(checksum_algorithm) to change from the default."
              },
              "use_regex": {
                "type": "string",
                "description": "Will set patterns to run as a regex check if true"
              },
              "follow": {
                "type": "string",
                "description": "Set this to true to follow symlinks in the path. This needs to be used in conjunction with C(recurse)."
              },
              "hidden": {
                "type": "string",
                "description": "Set this to include hidden files or folders"
              },
              "size": {
                "type": "string",
                "description": "Select files or folders whose size is equal to or greater than the specified size. Use a negative value to find files equal to or less than the specified size. You can specify the size with a suffix of the byte type i.e. kilo = k, mega = m... Size is not evaluated for symbolic links."
              }
            }
          },
          "replace": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "path",
                        "dest",
                        "destfile",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "path"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "dest"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "destfile"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "This module will replace all instances of a pattern within a file.\nIt is up to the user to maintain idempotence by ensuring that the same pattern would never match any replacements made.",
            "properties": {
              "name": {
                "type": "string",
                "description": "The file to modify.\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "dest": {
                "type": "string",
                "description": "The file to modify.\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "destfile": {
                "type": "string",
                "description": "The file to modify.\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "replace": {
                "type": "string",
                "description": "The string to replace regexp matches. May contain backreferences that will get expanded with the regexp capture groups if the regexp matches. If not set, matches are removed entirely."
              },
              "path": {
                "type": "string",
                "description": "The file to modify.\nBefore 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
              },
              "regexp": {
                "type": "string",
                "description": "The regular expression to look for in the contents of the file. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html). Uses multiline mode, which means C(^) and C($) match the beginning and end respectively of I(each line) of the file."
              },
              "validate": {
                "type": "string",
                "description": ""
              },
              "backup": {
                "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "ovirt_host_networks": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "host"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "host"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Module to manage host networks in oVirt.",
            "properties": {
              "fetch_nested": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "Name of the the host to manage networks for."
              },
              "labels": {
                "description": "List of names of the network label to be assigned to bond or interface.",
                "$ref": "#/definitions/ansible_array"
              },
              "poll_interval": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "host": {
                "type": "string",
                "description": "Name of the the host to manage networks for."
              },
              "nested_attributes": {
                "description": "",
                "$ref": "#/definitions/ansible_array"
              },
              "check": {
                "description": "If I(true) verify connectivity between host and engine.\nNetwork configuration changes will be rolled back if connectivity between engine and the host is lost after changing network configuration.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nShould the host be present/absent."
              },
              "auth": {
                "type": "object",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "interface": {
                "type": "string",
                "description": "Name of the network interface where logical network should be attached."
              },
              "wait": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "save": {
                "description": "If I(true) network configuration will be persistent, by default they are temporary.",
                "$ref": "#/definitions/ansible_truth"
              },
              "networks": {
                "description": "List of dictionary describing networks to be attached to interface or bond:\nC(name) - Name of the logical network to be assigned to bond or interface.\nC(boot_protocol) - Boot protocol one of the I(none), I(static) or I(dhcp).\nC(address) - IP address in case of I(static) boot protocol is used.\nC(prefix) - Routing prefix in case of I(static) boot protocol is used.\nC(gateway) - Gateway in case of I(static) boot protocol is used.\nC(version) - IP version. Either v4 or v6. Default is v4.",
                "$ref": "#/definitions/ansible_array"
              },
              "bond": {
                "type": "object",
                "description": "Dictionary describing network bond:\nC(name) - Bond name.\nC(mode) - Bonding mode.\nC(interfaces) - List of interfaces to create a bond."
              }
            }
          },
          "ios_system": {
            "type": "object",
            "description": "This module provides declarative management of node system attributes on Cisco IOS devices.  It provides an option to configure host system parameters or remove those parameters from the device active configuration.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "lookup_source": {
                "type": "string",
                "description": "Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device."
              },
              "domain_search": {
                "description": "Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.",
                "$ref": "#/definitions/ansible_array"
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "domain_name": {
                "description": "Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.",
                "$ref": "#/definitions/ansible_array"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nState of the configuration values in the device's current active configuration.  When set to I(present), the values should be configured in the device active configuration and when set to I(absent) the values should not be in the device active configuration"
              },
              "hostname": {
                "type": "string",
                "description": "Configure the device hostname parameter. This option takes an ASCII string value."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "name_servers": {
                "description": "List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.",
                "$ref": "#/definitions/ansible_array"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "lookup_enabled": {
                "description": "Administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "rax_meta": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "credentials",
                        "creds_file"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "password"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manipulate metadata for Rackspace Cloud Servers",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Server name to modify metadata for"
              },
              "tenant_id": {
                "type": "string",
                "description": ""
              },
              "identity_type": {
                "type": "string",
                "description": ""
              },
              "tenant_name": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "creds_file": {
                "type": "string",
                "description": ""
              },
              "verify_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "meta": {
                "type": "object",
                "description": "A hash of metadata to associate with the instance"
              },
              "env": {
                "type": "string",
                "description": ""
              },
              "address": {
                "type": "string",
                "description": "Server IP address to modify metadata for, will match any IP assigned to the server"
              },
              "credentials": {
                "type": "string",
                "description": ""
              },
              "api_key": {
                "type": "string",
                "description": ""
              },
              "id": {
                "type": "string",
                "description": "Server ID to modify metadata for"
              },
              "auth_endpoint": {
                "type": "string",
                "description": ""
              }
            }
          },
          "nxos_pim_interface": {
            "required": [
              "interface"
            ],
            "type": "object",
            "description": "Manages PIM interface configuration settings.",
            "properties": {
              "jp_type_in": {
                "enum": [
                  "prefix",
                  "routemap"
                ],
                "type": "string",
                "description": "Type of policy mapped to C(jp_policy_in)."
              },
              "hello_interval": {
                "description": "Hello interval in milliseconds for this interface.",
                "$ref": "#/definitions/ansible_number"
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "border": {
                "description": "Configures interface to be a boundary of a PIM domain.",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "hello_auth_key": {
                "type": "string",
                "description": "Authentication for hellos on this interface."
              },
              "dr_prio": {
                "type": "string",
                "description": ""
              },
              "jp_policy_out": {
                "type": "string",
                "description": "Policy for join-prune messages (outbound)."
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "default"
                ],
                "type": "string",
                "description": "Default: present\n\nManages desired state of the resource."
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "jp_policy_in": {
                "type": "string",
                "description": "Policy for join-prune messages (inbound)."
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "sparse": {
                "description": "Default: True\n\nEnable/disable sparse-mode on the interface.",
                "$ref": "#/definitions/ansible_truth"
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "neighbor_policy": {
                "type": "string",
                "description": "Configures a neighbor policy for filtering adjacencies."
              },
              "interface": {
                "type": "string",
                "description": "Full name of the interface such as Ethernet1/33."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "neighbor_type": {
                "enum": [
                  "prefix",
                  "routemap"
                ],
                "type": "string",
                "description": "Type of policy mapped to neighbor_policy."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "jp_type_out": {
                "enum": [
                  "prefix",
                  "routemap"
                ],
                "type": "string",
                "description": "Type of policy mapped to C(jp_policy_out)."
              }
            }
          },
          "infini_export": {
            "type": "object",
            "description": "This module creates, deletes or modifies NFS exports on Infinibox.",
            "properties": {
              "inner_path": {
                "type": "string",
                "description": "Default: /\n\nInternal path of the export."
              },
              "state": {
                "type": "string",
                "description": "Default: present\n\nCreates/Modifies export when present and removes when absent."
              },
              "client_list": {
                "type": "string",
                "description": "Default: All Hosts(*), RW, no_root_squash: True\n\nList of dictionaries with client entries. See examples. Check infini_export_client module to modify individual NFS client entries for export."
              },
              "name": {
                "type": "string",
                "description": "Export name. Should always start with C(/). (ex. name=/data)"
              },
              "filesystem": {
                "type": "string",
                "description": "Name of exported file system."
              }
            }
          },
          "win_unzip": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "names",
                        "name"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "names"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Unzips compressed files and archives. For extracting any compression types other than .zip, the PowerShellCommunityExtensions (PSCX) Module is required.  This module (in conjunction with PSCX) has the ability to recursively unzip files within the src zip file provided and also functionality for many other compression types. If the destination directory does not exist, it will be created before unzipping the file.  Specifying rm parameter will force removal of the src file after extraction.",
            "properties": {
              "prefix": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": ""
              },
              "names": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": ""
              },
              "new_only": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "nxos_vrf_af": {
            "required": [
              "afi",
              "safi",
              "vrf"
            ],
            "type": "object",
            "description": "Manages VRF AF",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "m_facts": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "afi": {
                "enum": [
                  "ipv4",
                  "ipv6"
                ],
                "type": "string",
                "description": "Address-Family Identifier (AFI)."
              },
              "safi": {
                "enum": [
                  "unicast",
                  "multicast"
                ],
                "type": "string",
                "description": "Sub Address-Family Identifier (SAFI)."
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nDetermines whether the config should be present or not on the device."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "route_target_both_auto_evpn": {
                "description": "Enable/Disable the EVPN route-target 'auto' setting for both import and export target communities.",
                "$ref": "#/definitions/ansible_truth"
              },
              "vrf": {
                "type": "string",
                "description": "Name of the VRF."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "a10_virtual_server": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "username",
                        "user",
                        "admin"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "username"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "user"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "admin"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "virtual_server",
                        "vip",
                        "virtual"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "virtual_server"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "vip"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "virtual"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "force",
                        "thirsty"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "virtual_server_status",
                        "status"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "virtual_server_ip",
                        "ip",
                        "address"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "virtual_server_ip"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "ip"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "address"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "password",
                        "pass",
                        "pwd"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "password"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pass"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pwd"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manage slb virtual server objects on A10 Networks devices via aXAPI",
            "properties": {
              "status": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enable\n\nslb virtual server status"
              },
              "force": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "thirsty": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ip": {
                "type": "string",
                "description": "slb virtual server ip address"
              },
              "virtual_server_ports": {
                "description": "A list of ports to create for the virtual server. Each list item should be a dictionary which specifies the C(port:) and C(type:), but can also optionally specify the C(service_group:) as well as the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).",
                "$ref": "#/definitions/ansible_array"
              },
              "vip": {
                "type": "string",
                "description": "slb virtual server name"
              },
              "pass": {
                "type": "string",
                "description": "admin password of your A10 Networks device"
              },
              "virtual_server": {
                "type": "string",
                "description": "slb virtual server name"
              },
              "client_key": {
                "type": "string",
                "description": ""
              },
              "use_proxy": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "virtual": {
                "type": "string",
                "description": "slb virtual server name"
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": ""
              },
              "write_config": {
                "description": "Default: no\n\nIf C(yes), any changes will cause a write of the running configuration to non-volatile memory. This will save I(all) configuration changes, including those that may have been made manually or through other modules, so care should be taken when specifying C(yes).",
                "$ref": "#/definitions/ansible_truth"
              },
              "virtual_server_ip": {
                "type": "string",
                "description": "slb virtual server ip address"
              },
              "client_cert": {
                "type": "string",
                "description": ""
              },
              "username": {
                "type": "string",
                "description": "admin account of your A10 Networks device"
              },
              "force_basic_auth": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "http_agent": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": "hostname or ip of your A10 Networks device"
              },
              "user": {
                "type": "string",
                "description": "admin account of your A10 Networks device"
              },
              "address": {
                "type": "string",
                "description": "slb virtual server ip address"
              },
              "password": {
                "type": "string",
                "description": "admin password of your A10 Networks device"
              },
              "url_password": {
                "type": "string",
                "description": ""
              },
              "admin": {
                "type": "string",
                "description": "admin account of your A10 Networks device"
              },
              "pwd": {
                "type": "string",
                "description": "admin password of your A10 Networks device"
              },
              "url": {
                "type": "string",
                "description": ""
              },
              "virtual_server_status": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Default: enable\n\nslb virtual server status"
              },
              "url_username": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "macports": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "update_cache",
                        "update-cache"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "name",
                        "pkg"
                      ],
                      "type": "object"
                    }
                  },
                  {
                    "oneOf": [
                      {
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      {
                        "required": [
                          "pkg"
                        ],
                        "type": "object"
                      }
                    ]
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Manages MacPorts packages",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "installed",
                  "absent",
                  "removed",
                  "active",
                  "inactive"
                ],
                "type": "string",
                "description": "Default: present\n\nstate of the package"
              },
              "update_cache": {
                "description": "Default: no\n\nupdate the package db first",
                "$ref": "#/definitions/ansible_truth"
              },
              "name": {
                "type": "string",
                "description": "name of package to install/remove"
              },
              "update-cache": {
                "description": "Default: no\n\nupdate the package db first",
                "$ref": "#/definitions/ansible_truth"
              },
              "pkg": {
                "type": "string",
                "description": "name of package to install/remove"
              }
            }
          },
          "digital_ocean_sshkey": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "client_id",
                        "CLIENT_ID"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "api_key",
                        "API_KEY"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "id",
                        "droplet_id"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create/delete an SSH key.",
            "properties": {
              "API_KEY": {
                "type": "string",
                "description": "DigitalOcean api key."
              },
              "droplet_id": {
                "description": "Numeric, the SSH key id you want to operate on.",
                "$ref": "#/definitions/ansible_number"
              },
              "name": {
                "type": "string",
                "description": "String, this is the name of an SSH key to create or destroy."
              },
              "ssh_pub_key": {
                "type": "string",
                "description": "The public SSH key you want to add to your account."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nIndicate desired state of the target."
              },
              "client_id": {
                "type": "string",
                "description": "DigitalOcean manager id."
              },
              "CLIENT_ID": {
                "type": "string",
                "description": "DigitalOcean manager id."
              },
              "api_key": {
                "type": "string",
                "description": "DigitalOcean api key."
              },
              "id": {
                "description": "Numeric, the SSH key id you want to operate on.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "nxos_aaa_server": {
            "required": [
              "server_type"
            ],
            "type": "object",
            "description": "Manages AAA server global configuration",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "directed_request": {
                "enum": [
                  "enabled",
                  "disabled",
                  "default"
                ],
                "type": "string",
                "description": "Enables direct authentication requests to AAA server. Device default is disabled."
              },
              "server_type": {
                "enum": [
                  "radius",
                  "tacacs"
                ],
                "type": "string",
                "description": "The server type is either radius or tacacs."
              },
              "encrypt_type": {
                "enum": [
                  "0",
                  "7"
                ],
                "type": "string",
                "description": "The state of encryption applied to the entered global key. O clear text, 7 encrypted. Type-6 encryption is not supported."
              },
              "global_key": {
                "type": "string",
                "description": "Global AAA shared secret."
              },
              "state": {
                "enum": [
                  "present",
                  "default"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "server_timeout": {
                "type": "string",
                "description": "Global AAA server timeout period, in seconds. Range is 1-60. Device default is 5."
              },
              "deadtime": {
                "type": "string",
                "description": "Duration for which a non-reachable AAA server is skipped, in minutes. Range is 1-1440. Device default is 0."
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "svc": {
            "required": [
              "name"
            ],
            "type": "object",
            "description": "Controls daemontools services on remote hosts using the svc utility.",
            "properties": {
              "dist": {
                "type": "string",
                "description": ""
              },
              "name": {
                "type": "string",
                "description": "Name of the service to manage."
              },
              "downed": {
                "description": "Should a 'down' file exist or not, if it exists it disables auto startup. defaults to no. Downed does not imply stopped.",
                "$ref": "#/definitions/ansible_truth"
              },
              "enabled": {
                "description": "Wheater the service is enabled or not, if disabled it also implies stopped. Make note that a service can be enabled and downed (no auto restart).",
                "$ref": "#/definitions/ansible_truth"
              },
              "service_dir": {
                "type": "string",
                "description": "Default: /service\n\ndirectory svscan watches for services"
              },
              "state": {
                "enum": [
                  "started",
                  "stopped",
                  "restarted",
                  "killed",
                  "reloaded",
                  "once"
                ],
                "type": "string",
                "description": "C(Started)/C(stopped) are idempotent actions that will not run commands unless necessary.  C(restarted) will always bounce the svc (svc -t) and C(killed) will always bounce the svc (svc -k). C(reloaded) will send a sigusr1 (svc -1). C(once) will run a normally downed svc once (svc -o), not really an idempotent operation."
              },
              "service_src": {
                "type": "string",
                "description": "directory where services are defined, the source of symlinks to service_dir."
              }
            }
          },
          "dellos10_facts": {
            "type": "object",
            "description": "Collects a base set of device facts from a remote device that is running OS10.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module always collects a base set of facts from the device and can enable or disable collection of additional facts.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "authorize": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "auth_pass": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "gather_subset": {
                "description": "Default: !config\n\nWhen supplied, this argument restricts the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  You can specify a list of values to include a larger subset.  You can also use values with an initial M(!) to specify that a specific subset should not be collected.",
                "$ref": "#/definitions/ansible_array"
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "dnsmadeeasy": {
            "required": [
              "domain",
              "account_secret",
              "account_key",
              "state"
            ],
            "type": "object",
            "description": "Manages DNS records via the v2 REST API of the DNS Made Easy service.  It handles records only; there is no manipulation of domains or monitor/account support yet. See: U(https://www.dnsmadeeasy.com/integration/restapi/)",
            "properties": {
              "domain": {
                "type": "string",
                "description": "Domain to work with. Can be the domain name (e.g. \"mydomain.com\") or the numeric ID of the domain in DNS Made Easy (e.g. \"839989\") for faster resolution."
              },
              "record_name": {
                "type": "string",
                "description": "Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in \"result\" regardless of the state argument."
              },
              "record_ttl": {
                "description": "Default: 1800\n\nrecord's \"Time to live\".  Number of seconds the record remains cached in DNS servers.",
                "$ref": "#/definitions/ansible_number"
              },
              "account_secret": {
                "type": "string",
                "description": "Account Secret Key."
              },
              "account_key": {
                "type": "string",
                "description": "Account API Key."
              },
              "record_type": {
                "enum": [
                  "A",
                  "AAAA",
                  "CNAME",
                  "HTTPRED",
                  "MX",
                  "NS",
                  "PTR",
                  "SRV",
                  "TXT"
                ],
                "type": "string",
                "description": "Record type."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "whether the record should exist or not"
              },
              "record_value": {
                "type": "string",
                "description": "Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value>\nIf record_value is not specified; no changes will be made and the record will be returned in 'result' (in other words, this module can be used to fetch a record's current id, type, and ttl)"
              },
              "validate_certs": {
                "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "monit": {
            "required": [
              "state",
              "name"
            ],
            "type": "object",
            "description": "Manage the state of a program monitored via I(Monit)",
            "properties": {
              "state": {
                "enum": [
                  "present",
                  "started",
                  "stopped",
                  "restarted",
                  "monitored",
                  "unmonitored",
                  "reloaded"
                ],
                "type": "string",
                "description": "The state of service"
              },
              "name": {
                "type": "string",
                "description": "The name of the I(monit) program/process to manage"
              },
              "timeout": {
                "description": "Default: 300\n\nIf there are pending actions for the service monitored by monit, then Ansible will check for up to this many seconds to verify the the requested action has been performed. Ansible will sleep for five seconds between each check.",
                "$ref": "#/definitions/ansible_number"
              }
            }
          },
          "netapp_e_lun_mapping": {
            "required": [
              "api_url",
              "volume_name",
              "api_password",
              "state",
              "api_username"
            ],
            "type": "object",
            "description": "Allows for the creation and removal of volume to host mappings for NetApp E-series storage arrays.",
            "properties": {
              "ssid": {
                "type": "string",
                "description": "The storage system array identifier."
              },
              "target": {
                "type": "string",
                "description": "The name of host or hostgroup you wish to assign to the mapping\nIf omitted, the default hostgroup is used.\nIf the supplied I(volume_name) is associated with a different target, it will be updated to what is supplied here."
              },
              "api_username": {
                "type": "string",
                "description": "The username used to authenticate against the API. This can optionally be set via an environment variable, API_USERNAME"
              },
              "api_password": {
                "type": "string",
                "description": "The password used to authenticate against the API. This can optionally be set via an environment variable, API_PASSWORD"
              },
              "target_type": {
                "enum": [
                  "host",
                  "group"
                ],
                "type": "string",
                "description": "Whether the target is a host or group.\nRequired if supplying an explicit target."
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Present will ensure the mapping exists, absent will remove the mapping.\nAll parameters I(lun), I(target), I(target_type) and I(volume_name) must still be supplied."
              },
              "volume_name": {
                "type": "string",
                "description": "The name of the volume you wish to include in the mapping."
              },
              "validate_certs": {
                "description": "Default: True\n\nShould https certificates be validated?",
                "$ref": "#/definitions/ansible_truth"
              },
              "lun": {
                "description": "The LUN number you wish to give the mapping\nIf the supplied I(volume_name) is associated with a different LUN, it will be updated to what is supplied here.",
                "$ref": "#/definitions/ansible_number"
              },
              "api_url": {
                "type": "string",
                "description": "The full API url. Example: http://ENDPOINT:8080/devmgr/v2\nThis can optionally be set via an environment variable, API_URL"
              }
            }
          },
          "datadog_monitor": {
            "required": [
              "app_key",
              "name",
              "state",
              "api_key"
            ],
            "type": "object",
            "description": "Manages monitors within Datadog\nOptions like described on http://docs.datadoghq.com/api/",
            "properties": {
              "notify_audit": {
                "description": "A boolean indicating whether tagged users will be notified on changes to this monitor.",
                "$ref": "#/definitions/ansible_truth"
              },
              "locked": {
                "description": "A boolean indicating whether changes to this monitor should be restricted to the creator or admins.",
                "$ref": "#/definitions/ansible_truth"
              },
              "timeout_h": {
                "type": "string",
                "description": "The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state."
              },
              "tags": {
                "description": "Default: None\n\nA list of tags to associate with your monitor when creating or updating. This can help you categorize and filter monitors.",
                "$ref": "#/definitions/ansible_array"
              },
              "thresholds": {
                "type": "object",
                "description": "Default: {'warning': 1, 'ok': 1, 'critical': 1}\n\nA dictionary of thresholds by status. This option is only available for service checks and metric alerts. Because each of them can have multiple thresholds, we don't define them directly in the query."
              },
              "silenced": {
                "type": "object",
                "description": "Dictionary of scopes to timestamps or None. Each scope will be muted until the given POSIX timestamp or forever if the value is None. "
              },
              "app_key": {
                "type": "string",
                "description": "Your DataDog app key."
              },
              "notify_no_data": {
                "description": "A boolean indicating whether this monitor will notify when data stops reporting..",
                "$ref": "#/definitions/ansible_truth"
              },
              "renotify_interval": {
                "type": "string",
                "description": "The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved."
              },
              "state": {
                "type": "string",
                "description": "The designated state of the monitor."
              },
              "escalation_message": {
                "type": "string",
                "description": "A message to include with a re-notification. Supports the '@username' notification we allow elsewhere. Not applicable if renotify_interval is None"
              },
              "query": {
                "type": "string",
                "description": "The monitor query to notify on with syntax varying depending on what type of monitor you are creating."
              },
              "message": {
                "type": "string",
                "description": "A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same '@username' notation as events. Monitor message template variables can be accessed by using double square brackets, i.e '[[' and ']]'."
              },
              "api_key": {
                "type": "string",
                "description": "Your DataDog API key."
              },
              "type": {
                "type": "string",
                "description": "The type of the monitor.\nThe 'event alert'is available starting at Ansible 2.1"
              },
              "no_data_timeframe": {
                "type": "string",
                "description": "Default: 2x timeframe for metric, 2 minutes for service\n\nThe number of minutes before a monitor will notify when data stops reporting. Must be at least 2x the monitor timeframe for metric alerts or 2 minutes for service checks."
              },
              "name": {
                "type": "string",
                "description": "The name of the alert."
              }
            }
          },
          "azure_rm_virtualnetwork": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "purge_address_prefixes",
                        "purge"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "address_prefixes_cidr",
                        "address_prefixes"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Create, update or delete a virtual networks. Allows setting and updating the available IPv4 address ranges and setting custom DNS servers. Use the azure_rm_subnet module to associate subnets with a virtual network.",
            "properties": {
              "profile": {
                "type": "string",
                "description": ""
              },
              "cli_default_profile": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "dns_servers": {
                "description": "Custom list of DNS servers. Maximum length of two. The first server in the list will be treated as the Primary server. This is an explicit list. Existing DNS servers will be replaced with the specified list. Use the purge_dns_servers option to remove all custom DNS servers and revert to default Azure servers.",
                "$ref": "#/definitions/ansible_array"
              },
              "name": {
                "type": "string",
                "description": "name of the virtual network."
              },
              "resource_group": {
                "type": "string",
                "description": "name of resource group."
              },
              "tags": {
                "type": "object",
                "description": ""
              },
              "ad_user": {
                "type": "string",
                "description": ""
              },
              "append_tags": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "cloud_environment": {
                "type": "string",
                "description": ""
              },
              "secret": {
                "type": "string",
                "description": ""
              },
              "address_prefixes": {
                "description": "List of IPv4 address ranges where each is formatted using CIDR notation. Required when creating a new virtual network or using purge_address_prefixes.",
                "$ref": "#/definitions/ansible_array"
              },
              "purge": {
                "description": "Use with state present to remove any existing address_prefixes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "state": {
                "enum": [
                  "absent",
                  "present"
                ],
                "type": "string",
                "description": "Default: present\n\nAssert the state of the virtual network. Use 'present' to create or update and 'absent' to delete."
              },
              "location": {
                "type": "string",
                "description": "Default: resource_group location\n\nValid azure location. Defaults to location of the resource group."
              },
              "client_id": {
                "type": "string",
                "description": ""
              },
              "purge_dns_servers": {
                "description": "Use with state present to remove existing DNS servers, reverting to default Azure servers. Mutually exclusive with dns_servers.",
                "$ref": "#/definitions/ansible_truth"
              },
              "purge_address_prefixes": {
                "description": "Use with state present to remove any existing address_prefixes.",
                "$ref": "#/definitions/ansible_truth"
              },
              "subscription_id": {
                "type": "string",
                "description": ""
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "tenant": {
                "type": "string",
                "description": ""
              },
              "address_prefixes_cidr": {
                "description": "List of IPv4 address ranges where each is formatted using CIDR notation. Required when creating a new virtual network or using purge_address_prefixes.",
                "$ref": "#/definitions/ansible_array"
              }
            }
          },
          "nxos_igmp": {
            "type": "object",
            "description": "Manages IGMP global configuration configuration settings.",
            "properties": {
              "username": {
                "type": "string",
                "description": ""
              },
              "save": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "enforce_rtr_alert": {
                "description": "Enables or disables the enforce router alert option check for IGMPv2 and IGMPv3 packets.",
                "$ref": "#/definitions/ansible_truth"
              },
              "flush_routes": {
                "description": "Removes routes when the IGMP process is restarted. By default, routes are not flushed.",
                "$ref": "#/definitions/ansible_truth"
              },
              "config": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "default"
                ],
                "type": "string",
                "description": "Default: present\n\nManages desired state of the resource."
              },
              "include_defaults": {
                "type": "string",
                "description": ""
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "restart": {
                "description": "Restarts the igmp process (using an exec config command).",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          },
          "clc_server_snapshot": {
            "required": [
              "server_ids"
            ],
            "type": "object",
            "description": "An Ansible module to Create, Delete and Restore server snapshots in CenturyLink Cloud.",
            "properties": {
              "expiration_days": {
                "type": "string",
                "description": "Default: 7\n\nThe number of days to keep the server snapshot before it expires."
              },
              "server_ids": {
                "description": "The list of CLC server Ids.",
                "$ref": "#/definitions/ansible_array"
              },
              "state": {
                "enum": [
                  "present",
                  "absent",
                  "restore"
                ],
                "type": "string",
                "description": "Default: present\n\nThe state to insure that the provided resources are in."
              },
              "wait": {
                "type": "string",
                "description": "Default: True\n\nWhether to wait for the provisioning tasks to finish before returning."
              }
            }
          },
          "nxos_udld": {
            "type": "object",
            "description": "Manages UDLD global configuration params.",
            "properties": {
              "reset": {
                "description": "Ability to reset UDLD down interfaces.",
                "$ref": "#/definitions/ansible_truth"
              },
              "username": {
                "type": "string",
                "description": ""
              },
              "ssh_keyfile": {
                "type": "string",
                "description": ""
              },
              "state": {
                "enum": [
                  "present",
                  "absent"
                ],
                "type": "string",
                "description": "Default: present\n\nManage the state of the resource."
              },
              "msg_time": {
                "type": "string",
                "description": "Message time in seconds for UDLD packets."
              },
              "host": {
                "type": "string",
                "description": ""
              },
              "timeout": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "provider": {
                "type": "object",
                "description": ""
              },
              "use_ssl": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "aggressive": {
                "enum": [
                  "enabled",
                  "disabled"
                ],
                "type": "string",
                "description": "Toggles aggressive mode."
              },
              "password": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "port": {
                "description": "",
                "$ref": "#/definitions/ansible_number"
              },
              "transport": {
                "enum": [
                  "cli",
                  "nxapi"
                ],
                "type": "string",
                "description": ""
              }
            }
          },
          "cloudfront_facts": {
            "allOf": [
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_secret_key",
                        "ec2_secret_key",
                        "secret_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "aws_access_key",
                        "ec2_access_key",
                        "access_key"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "security_token",
                        "access_token"
                      ],
                      "type": "object"
                    }
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "not": {
                      "required": [
                        "region",
                        "aws_region",
                        "ec2_region"
                      ],
                      "type": "object"
                    }
                  }
                ]
              }
            ],
            "type": "object",
            "description": "Gets information about an AWS CloudFront distribution",
            "properties": {
              "list_origin_access_identities": {
                "description": "Get a list of cloudfront origin access identities. Requires I(origin_access_identity_id) to be set.",
                "$ref": "#/definitions/ansible_truth"
              },
              "list_distributions_by_web_acl_id": {
                "description": "Get a list of distributions using web acl id as a filter. Requires I(web_acl_id) to be set.",
                "$ref": "#/definitions/ansible_truth"
              },
              "streaming_distribution_config": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              },
              "all_lists": {
                "description": "Get all cloudfront lists that do not require parameters.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_url": {
                "type": "string",
                "description": ""
              },
              "aws_secret_key": {
                "type": "string",
                "description": ""
              },
              "streaming_distribution": {
                "description": "Get information about a specified RTMP distribution. Requires I(distribution_id) or I(domain_name_alias) to be specified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "distribution_id": {
                "type": "string",
                "description": "The id of the CloudFront distribution. Used with I(distribution), I(distribution_config), I(invalidation), I(streaming_distribution), I(streaming_distribution_config), I(list_invalidations)."
              },
              "distribution_config": {
                "description": "Get the configuration information about a distribution. Requires I(distribution_id) or I(domain_name_alias) to be specified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "invalidation_id": {
                "type": "string",
                "description": "The id of the invalidation to get information about. Used with I(invalidation)."
              },
              "profile": {
                "type": "string",
                "description": ""
              },
              "list_streaming_distributions": {
                "description": "Get a list of streaming distributions.",
                "$ref": "#/definitions/ansible_truth"
              },
              "origin_access_identity_config": {
                "description": "Get the configuration information about an origin access identity. Requires I(origin_access_identity_id) to be specified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "list_invalidations": {
                "description": "Get a list of invalidations. Requires I(distribution_id) or I(domain_name_alias) to be specified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "domain_name_alias": {
                "type": "string",
                "description": "Can be used instead of I(distribution_id) - uses the aliased CNAME for the cloudfront distribution to get the distribution id where required."
              },
              "invalidation": {
                "description": "Get information about an invalidation. Requires I(invalidation_id) to be specified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "origin_access_identity_id": {
                "type": "string",
                "description": "The id of the cloudfront origin access identity to get information about."
              },
              "origin_access_identity": {
                "description": "Get information about an origin access identity. Requires I(origin_access_identity_id) to be specified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_access_key": {
                "type": "string",
                "description": ""
              },
              "list_distributions": {
                "description": "Get a list of cloudfront distributions.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_secret_key": {
                "type": "string",
                "description": ""
              },
              "distribution": {
                "description": "Get information about a distribution. Requires I(distribution_id) or I(domain_name_alias) to be specified.",
                "$ref": "#/definitions/ansible_truth"
              },
              "ec2_region": {
                "type": "string",
                "description": ""
              },
              "access_key": {
                "type": "string",
                "description": ""
              },
              "aws_access_key": {
                "type": "string",
                "description": ""
              },
              "aws_region": {
                "type": "string",
                "description": ""
              },
              "security_token": {
                "type": "string",
                "description": ""
              },
              "access_token": {
                "type": "string",
                "description": ""
              },
              "region": {
                "type": "string",
                "description": ""
              },
              "summary": {
                "description": "Returns a summary of all distributions, streaming distributions and origin_access_identities. This is the default behaviour if no option is selected.",
                "$ref": "#/definitions/ansible_truth"
              },
              "secret_key": {
                "type": "string",
                "description": ""
              },
              "validate_certs": {
                "description": "",
                "$ref": "#/definitions/ansible_truth"
              }
            }
          }
        }
      }
    ]
  },
  "$contact": {
    "name": "Pavel Odvody",
    "issues": "https://github.com/shaded-enmity/ansible-schema-generator/issues"
  },
  "definitions": {
    "ansible_array": {
      "oneOf": [
        {
          "type": "string"
        },
        {
          "type": "array"
        },
        {
          "type": "object"
        }
      ]
    },
    "ansible_number": {
      "oneOf": [
        {
          "type": "integer"
        },
        {
          "type": "string"
        }
      ]
    },
    "ansible_truth": {
      "oneOf": [
        {
          "type": "boolean"
        },
        {
          "enum": [
            0,
            1
          ],
          "type": "integer"
        },
        {
          "enum": [
            "yes",
            "no",
            "Yes",
            "No",
            "YES",
            "NO",
            "on",
            "off",
            "On",
            "Off",
            "ON",
            "OFF",
            "1",
            "0",
            "true",
            "false",
            "True",
            "FalseTRUE",
            "FALSE"
          ],
          "type": "string"
        }
      ]
    }
  },
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "array"
}
