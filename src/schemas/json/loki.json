{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://json.schemastore.org/loki.json",
  "title": "Loki",
  "type": ["object", "null"],
  "additionalProperties": false,
  "properties": {
    "target": {
      "type": "string",
      "description": "A comma-separated list of components to run. The default value 'all' runs Loki in single binary mode. The value 'read' is an alias to run only read-path related components such as the querier and query-frontend, but all in the same process. The value 'write' is an alias to run only write-path related components such as the distributor and compactor, but all in the same process. Supported values: all, compactor, distributor, ingester, querier, query-scheduler, ingester-querier, query-frontend, index-gateway, ruler, table-manager, read, write. A full list of available targets can be printed when running Loki with the '-list-targets' command line flag."
    },
    "auth_enabled": {
      "type": "boolean",
      "description": "Enables authentication through the X-Scope-OrgID header, which must be present if true. If false, the OrgID will always be set to 'fake'."
    },
    "ballast_bytes": {
      "type": "integer",
      "description": "The amount of virtual memory in bytes to reserve as ballast in order to optimize garbage collection. Larger ballasts result in fewer garbage collection passes, reducing CPU overhead at the cost of heap size. The ballast will not consume physical memory, because it is never read from. It will, however, distort metrics, because it is counted as live memory. Default: 0."
    },
    "server": {
      "$ref": "#/definitions/server",
      "description": "Configures the server of the launched module(s)."
    },
    "distributor": {
      "$ref": "#/definitions/distributor",
      "description": "Configures the distributor."
    },
    "querier": {
      "$ref": "#/definitions/querier",
      "description": "Configures the querier. Only appropriate when running all modules or just the querier."
    },
    "query_scheduler": {
      "$ref": "#/definitions/query_scheduler",
      "description": "The query_scheduler block configures the Loki query scheduler. When configured it separates the tenant query queues from the query-frontend."
    },
    "frontend": {
      "$ref": "#/definitions/frontend",
      "description": "The frontend block configures the Loki query-frontend."
    },
    "query_range": {
      "$ref": "#/definitions/query_range",
      "description": "The query_range block configures the query splitting and caching in the Loki query-frontend."
    },
    "ruler": {
      "$ref": "#/definitions/ruler",
      "description": "The ruler block configures the Loki ruler."
    },
    "ingester_client": {
      "$ref": "#/definitions/ingester_client",
      "description": "The ingester_client block configures how the distributor will connect to ingesters. Only appropriate when running all components, the distributor, or the querier."
    },
    "ingester": {
      "$ref": "#/definitions/ingester",
      "description": "The ingester block configures the ingester and how the ingester will register itself to a key value store."
    },
    "pattern_ingester": {
      "description": "",
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Whether the pattern ingester is enabled."
        },
        "lifecycler": {
          "description": "Configures how the lifecycle of the pattern ingester will operate and where it will register for discovery.",
          "type": "object",
          "properties": {
            "ring": {
              "description": "",
              "type": "object",
              "properties": {
                "kvstore": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "store": {
                      "type": "string",
                      "description": "Backend storage to use for the ring. Supported values are: consul, etcd, inmemory, memberlist, multi."
                    },
                    "prefix": {
                      "type": "string",
                      "description": "The prefix for the keys in the store. Should end with a /."
                    },
                    "consul": {
                      "$ref": "#/definitions/consul",
                      "description": "Configuration for a Consul client. Only applies if the selected kvstore is consul."
                    },
                    "etcd": {
                      "$ref": "#/definitions/etcd",
                      "description": "Configuration for an ETCD v3 client. Only applies if the selected kvstore is etcd."
                    },
                    "multi": {
                      "description": "",
                      "type": "object",
                      "properties": {
                        "primary": {
                          "type": "string",
                          "description": "Primary backend storage used by multi-client."
                        },
                        "secondary": {
                          "type": "string",
                          "description": "Secondary backend storage used by multi-client."
                        },
                        "mirror_enabled": {
                          "type": "boolean",
                          "description": "Mirror writes to secondary store."
                        },
                        "mirror_timeout": {
                          "type": "string",
                          "description": "Timeout for storing value to secondary store."
                        }
                      }
                    }
                  }
                },
                "heartbeat_timeout": {
                  "type": "string",
                  "description": "The heartbeat timeout after which ingesters are skipped for reads/writes. 0 = never (timeout disabled)."
                },
                "replication_factor": {
                  "type": "integer",
                  "description": "The number of ingesters to write to and read from. Default: 1."
                },
                "zone_awareness_enabled": {
                  "type": "boolean",
                  "description": "True to enable the zone-awareness and replicate ingested samples across different availability zones."
                },
                "excluded_zones": {
                  "type": "string",
                  "description": "Comma-separated list of zones to exclude from the ring. Instances in excluded zones will be filtered out from the ring."
                }
              }
            },
            "num_tokens": {
              "type": "integer",
              "description": "Number of tokens for each ingester. Default: 128."
            },
            "heartbeat_period": {
              "type": "string",
              "description": "Period at which to heartbeat to consul. 0 = disabled."
            },
            "heartbeat_timeout": {
              "type": "string",
              "description": "Heartbeat timeout after which instance is assumed to be unhealthy. 0 = disabled."
            },
            "observe_period": {
              "type": "string",
              "description": "Observe tokens after generating to resolve collisions. Useful when using gossiping ring."
            },
            "join_after": {
              "type": "string",
              "description": "Period to wait for a claim from another member; will join automatically after this."
            },
            "min_ready_duration": {
              "type": "string",
              "description": "Minimum duration to wait after the internal readiness checks have passed but before succeeding the readiness endpoint. This is used to slowdown deployment controllers (eg. Kubernetes) after an instance is ready and before they proceed with a rolling update, to give the rest of the cluster instances enough time to receive ring updates."
            },
            "interface_names": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "Name of network interface to read address from."
            },
            "enable_inet6": {
              "type": "boolean",
              "description": "Enable IPv6 support. Required to make use of IP addresses from IPv6 interfaces."
            },
            "final_sleep": {
              "type": "string",
              "description": "Duration to sleep for before exiting, to ensure metrics are scraped."
            },
            "tokens_file_path": {
              "type": "string",
              "description": "File path where tokens are stored. If empty, tokens are not stored at shutdown and restored at startup."
            },
            "availability_zone": {
              "type": "string",
              "description": "The availability zone where this instance is running."
            },
            "unregister_on_shutdown": {
              "type": "boolean",
              "description": "Unregister from the ring upon clean shutdown. It can be useful to disable for rolling restarts with consistent naming in conjunction with -distributor.extend-writes=false."
            },
            "readiness_check_ring_health": {
              "type": "boolean",
              "description": "When enabled the readiness probe succeeds only after all instances are ACTIVE and healthy in the ring, otherwise only the instance itself is checked. This option should be disabled if in your cluster multiple instances can be rolled out simultaneously, otherwise rolling updates may be slowed down."
            },
            "address": {
              "type": "string",
              "description": "IP address to advertise in the ring."
            },
            "port": {
              "type": "integer",
              "description": "port to advertise in consul (defaults to server.grpc-listen-port). Default: 0."
            },
            "id": {
              "type": "string",
              "description": "ID to register in the ring."
            }
          }
        },
        "client_config": {
          "description": "Configures how the pattern ingester will connect to the ingesters.",
          "type": "object",
          "properties": {
            "pool_config": {
              "description": "Configures how connections are pooled.",
              "type": "object",
              "properties": {
                "client_cleanup_period": {
                  "type": "string",
                  "description": "How frequently to clean up clients for ingesters that have gone away."
                },
                "health_check_ingesters": {
                  "type": "boolean",
                  "description": "Run a health check on each ingester client during periodic cleanup."
                },
                "remote_timeout": {
                  "type": "string",
                  "description": "Timeout for the health check."
                }
              }
            },
            "remote_timeout": {
              "type": "string",
              "description": "The remote request timeout on the client side."
            },
            "grpc_client_config": {
              "$ref": "#/definitions/grpc_client",
              "description": "Configures how the gRPC connection to ingesters work as a client."
            }
          }
        },
        "concurrent_flushes": {
          "type": "integer",
          "description": "How many flushes can happen concurrently from each stream. Default: 32."
        },
        "flush_check_period": {
          "type": "string",
          "description": "How often should the ingester see if there are any blocks to flush. The first flush check is delayed by a random time up to 0.8x the flush check period. Additionally, there is +/- 1% jitter added to the interval."
        }
      }
    },
    "index_gateway": {
      "$ref": "#/definitions/index_gateway",
      "description": "The index_gateway block configures the Loki index gateway server, responsible for serving index queries without the need to constantly interact with the object store."
    },
    "bloom_compactor": {
      "$ref": "#/definitions/bloom_compactor",
      "description": "Experimental: The bloom_compactor block configures the Loki bloom compactor server, responsible for compacting stream indexes into bloom filters and merging them as bloom blocks."
    },
    "bloom_gateway": {
      "$ref": "#/definitions/bloom_gateway",
      "description": "Experimental: The bloom_gateway block configures the Loki bloom gateway server, responsible for serving queries for filtering chunks based on filter expressions."
    },
    "storage_config": {
      "$ref": "#/definitions/storage_config",
      "description": "The storage_config block configures one of many possible stores for both the index and chunks. Which configuration to be picked should be defined in schema_config block."
    },
    "chunk_store_config": {
      "$ref": "#/definitions/chunk_store_config",
      "description": "The chunk_store_config block configures how chunks will be cached and how long to wait before saving them to the backing store."
    },
    "schema_config": {
      "$ref": "#/definitions/schema_config",
      "description": "Configures the chunk index schema and where it is stored."
    },
    "compactor": {
      "$ref": "#/definitions/compactor",
      "description": "The compactor block configures the compactor component, which compacts index shards for performance."
    },
    "compactor_grpc_client": {
      "description": "",
      "type": "object",
      "properties": {
        "max_recv_msg_size": {
          "type": "integer",
          "description": "gRPC client max receive message size (bytes). Default: 104857600."
        },
        "max_send_msg_size": {
          "type": "integer",
          "description": "gRPC client max send message size (bytes). Default: 104857600."
        },
        "grpc_compression": {
          "type": "string",
          "description": "Use compression when sending messages. Supported values are: 'gzip', 'snappy' and '' (disable compression)"
        },
        "rate_limit": {
          "type": "number",
          "description": "Rate limit for gRPC client; 0 means disabled. Default: 0."
        },
        "rate_limit_burst": {
          "type": "integer",
          "description": "Rate limit burst for gRPC client. Default: 0."
        },
        "backoff_on_ratelimits": {
          "type": "boolean",
          "description": "Enable backoff and retry when we hit rate limits."
        },
        "backoff_config": {
          "description": "",
          "type": "object",
          "properties": {
            "min_period": {
              "type": "string",
              "description": "Minimum delay when backing off."
            },
            "max_period": {
              "type": "string",
              "description": "Maximum delay when backing off."
            },
            "max_retries": {
              "type": "integer",
              "description": "Number of times to backoff and retry before failing. Default: 10."
            }
          }
        },
        "initial_stream_window_size": {
          "type": "string",
          "description": "Initial stream window size. Values less than the default are not supported and are ignored. Setting this to a value other than the default disables the BDP estimator. Default: 63KiB1023B."
        },
        "initial_connection_window_size": {
          "type": "string",
          "description": "Initial connection window size. Values less than the default are not supported and are ignored. Setting this to a value other than the default disables the BDP estimator. Default: 63KiB1023B."
        },
        "tls_enabled": {
          "type": "boolean",
          "description": "Enable TLS in the gRPC client. This flag needs to be enabled when any other TLS flag is set. If set to false, insecure connection to gRPC server will be used."
        },
        "tls_cert_path": {
          "type": "string",
          "description": "Path to the client certificate, which will be used for authenticating with the server. Also requires the key path to be configured."
        },
        "tls_key_path": {
          "type": "string",
          "description": "Path to the key for the client certificate. Also requires the client certificate to be configured."
        },
        "tls_ca_path": {
          "type": "string",
          "description": "Path to the CA certificates to validate server certificate against. If not set, the host's root CA certificates are used."
        },
        "tls_server_name": {
          "type": "string",
          "description": "Override the expected name on the server certificate."
        },
        "tls_insecure_skip_verify": {
          "type": "boolean",
          "description": "Skip validating server certificate."
        },
        "tls_cipher_suites": {
          "type": "string",
          "description": "Override the default cipher suite list (separated by commas). Allowed values:\n\nSecure Ciphers:\n- TLS_AES_128_GCM_SHA256\n- TLS_AES_256_GCM_SHA384\n- TLS_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n\nInsecure Ciphers:\n- TLS_RSA_WITH_RC4_128_SHA\n- TLS_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA\n- TLS_RSA_WITH_AES_256_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA256\n- TLS_RSA_WITH_AES_128_GCM_SHA256\n- TLS_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n"
        },
        "tls_min_version": {
          "type": "string",
          "description": "Override the default minimum TLS version. Allowed values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13"
        },
        "connect_timeout": {
          "type": "string",
          "description": "The maximum amount of time to establish a connection. A value of 0 means default gRPC client connect timeout and backoff."
        },
        "connect_backoff_base_delay": {
          "type": "string",
          "description": "Initial backoff delay after first connection failure. Only relevant if ConnectTimeout > 0."
        },
        "connect_backoff_max_delay": {
          "type": "string",
          "description": "Maximum backoff delay when establishing a connection. Only relevant if ConnectTimeout > 0."
        }
      }
    },
    "limits_config": {
      "$ref": "#/definitions/limits_config",
      "description": "The limits_config block configures global and per-tenant limits in Loki. The values here can be overridden in the `overrides` section of the runtime_config file"
    },
    "frontend_worker": {
      "$ref": "#/definitions/frontend_worker",
      "description": "The frontend_worker configures the worker - running within the Loki querier - picking up and executing queries enqueued by the query-frontend."
    },
    "table_manager": {
      "$ref": "#/definitions/table_manager",
      "description": "The table_manager block configures the table manager for retention."
    },
    "memberlist": {
      "$ref": "#/definitions/memberlist",
      "description": "Configuration for memberlist client. Only applies if the selected kvstore is memberlist.\n\nWhen a memberlist config with at least 1 join_members is defined, kvstore of type memberlist is automatically selected for all the components that require a ring unless otherwise specified in the component's configuration section."
    },
    "runtime_config": {
      "$ref": "#/definitions/runtime_config",
      "description": "Configuration for 'runtime config' module, responsible for reloading runtime configuration file."
    },
    "operational_config": {
      "$ref": "#/definitions/operational_config",
      "description": "These are values which allow you to control aspects of Loki's operation, most commonly used for controlling types of higher verbosity logging, the values here can be overridden in the `configs` section of the `runtime_config` file."
    },
    "tracing": {
      "$ref": "#/definitions/tracing",
      "description": "Configuration for tracing."
    },
    "analytics": {
      "$ref": "#/definitions/analytics",
      "description": "Configuration for analytics."
    },
    "common": {
      "$ref": "#/definitions/common",
      "description": "Common configuration to be shared between multiple modules. If a more specific configuration is given in other sections, the related configuration within this section will be ignored."
    },
    "shutdown_delay": {
      "type": "string",
      "description": "How long to wait between SIGTERM and shutdown. After receiving SIGTERM, Loki will report 503 Service Unavailable status via /ready endpoint."
    },
    "metrics_namespace": {
      "type": "string",
      "description": "Namespace of the metrics that in previous releases had cortex as namespace. This setting is deprecated and will be removed in the next minor release."
    }
  },
  "definitions": {
    "alibabacloud_storage_config": {
      "type": "object",
      "properties": {
        "bucket": {
          "type": "string",
          "description": "Name of OSS bucket."
        },
        "endpoint": {
          "type": "string",
          "description": "oss Endpoint to connect to."
        },
        "access_key_id": {
          "type": "string",
          "description": "alibabacloud Access Key ID"
        },
        "secret_access_key": {
          "type": "string",
          "description": "alibabacloud Secret Access Key"
        }
      }
    },
    "analytics": {
      "type": "object",
      "properties": {
        "reporting_enabled": {
          "type": "boolean",
          "description": "Enable anonymous usage reporting."
        },
        "usage_stats_url": {
          "type": "string",
          "description": "URL to which reports are sent"
        }
      }
    },
    "attributes_config": {
      "type": "object",
      "properties": {
        "action": {
          "type": "string",
          "description": "Configures action to take on matching attributes. It allows one of [structured_metadata, drop] for all attribute types. It additionally allows index_label action for resource attributes"
        },
        "attributes": {
          "type": ["array", "null"],
          "items": {
            "type": "string"
          },
          "description": "List of attributes to configure how to store them or drop them altogether"
        },
        "regex": {
          "type": "string",
          "description": "Regex to choose attributes to configure how to store them or drop them altogether"
        }
      }
    },
    "aws_storage_config": {
      "type": "object",
      "properties": {
        "dynamodb": {
          "description": "Deprecated: Configures storing indexes in DynamoDB.",
          "type": "object",
          "properties": {
            "dynamodb_url": {
              "type": "string",
              "description": "DynamoDB endpoint URL with escaped Key and Secret encoded. If only region is specified as a host, proper endpoint will be deduced. Use inmemory:///<table-name> to use a mock in-memory implementation."
            },
            "api_limit": {
              "type": "number",
              "description": "DynamoDB table management requests per second limit. Default: 2."
            },
            "throttle_limit": {
              "type": "number",
              "description": "DynamoDB rate cap to back off when throttled. Default: 10."
            },
            "metrics": {
              "description": "",
              "type": "object",
              "properties": {
                "url": {
                  "type": "string",
                  "description": "Use metrics-based autoscaling, via this query URL"
                },
                "target_queue_length": {
                  "type": "integer",
                  "description": "Queue length above which we will scale up capacity. Default: 100000."
                },
                "scale_up_factor": {
                  "type": "number",
                  "description": "Scale up capacity by this multiple. Default: 1.3."
                },
                "ignore_throttle_below": {
                  "type": "number",
                  "description": "Ignore throttling below this level (rate per second). Default: 1."
                },
                "queue_length_query": {
                  "type": "string",
                  "description": "query to fetch ingester queue length"
                },
                "write_throttle_query": {
                  "type": "string",
                  "description": "query to fetch throttle rates per table"
                },
                "write_usage_query": {
                  "type": "string",
                  "description": "query to fetch write capacity usage per table"
                },
                "read_usage_query": {
                  "type": "string",
                  "description": "query to fetch read capacity usage per table"
                },
                "read_error_query": {
                  "type": "string",
                  "description": "query to fetch read errors per table"
                }
              }
            },
            "chunk_gang_size": {
              "type": "integer",
              "description": "Number of chunks to group together to parallelise fetches (zero to disable). Default: 10."
            },
            "chunk_get_max_parallelism": {
              "type": "integer",
              "description": "Max number of chunk-get operations to start in parallel. Default: 32."
            },
            "backoff_config": {
              "description": "",
              "type": "object",
              "properties": {
                "min_period": {
                  "type": "string",
                  "description": "Minimum backoff time"
                },
                "max_period": {
                  "type": "string",
                  "description": "Maximum backoff time"
                },
                "max_retries": {
                  "type": "integer",
                  "description": "Maximum number of times to retry an operation. Default: 20."
                }
              }
            },
            "kms_key_id": {
              "type": "string",
              "description": "KMS key used for encrypting DynamoDB items.  DynamoDB will use an Amazon owned KMS key if not provided."
            }
          }
        },
        "s3": {
          "type": "string",
          "description": "S3 endpoint URL with escaped Key and Secret encoded. If only region is specified as a host, proper endpoint will be deduced. Use inmemory:///<bucket-name> to use a mock in-memory implementation."
        },
        "s3forcepathstyle": {
          "type": "boolean",
          "description": "Set this to `true` to force the request to use path-style addressing."
        },
        "bucketnames": {
          "type": "string",
          "description": "Comma separated list of bucket names to evenly distribute chunks over. Overrides any buckets specified in s3.url flag"
        },
        "endpoint": {
          "type": "string",
          "description": "S3 Endpoint to connect to."
        },
        "region": {
          "type": "string",
          "description": "AWS region to use."
        },
        "access_key_id": {
          "type": "string",
          "description": "AWS Access Key ID"
        },
        "secret_access_key": {
          "type": "string",
          "description": "AWS Secret Access Key"
        },
        "session_token": {
          "type": "string",
          "description": "AWS Session Token"
        },
        "insecure": {
          "type": "boolean",
          "description": "Disable https on s3 connection."
        },
        "http_config": {
          "description": "",
          "type": "object",
          "properties": {
            "timeout": {
              "type": "string",
              "description": "Timeout specifies a time limit for requests made by s3 Client."
            },
            "idle_conn_timeout": {
              "type": "string",
              "description": "The maximum amount of time an idle connection will be held open."
            },
            "response_header_timeout": {
              "type": "string",
              "description": "If non-zero, specifies the amount of time to wait for a server's response headers after fully writing the request."
            },
            "insecure_skip_verify": {
              "type": "boolean",
              "description": "Set to true to skip verifying the certificate chain and hostname."
            },
            "ca_file": {
              "type": "string",
              "description": "Path to the trusted CA file that signed the SSL certificate of the S3 endpoint."
            }
          }
        },
        "signature_version": {
          "type": "string",
          "description": "The signature version to use for authenticating against S3. Supported values are: v4."
        },
        "storage_class": {
          "type": "string",
          "description": "The S3 storage class which objects will use. Supported values are: GLACIER, DEEP_ARCHIVE, GLACIER_IR, INTELLIGENT_TIERING, ONEZONE_IA, OUTPOSTS, REDUCED_REDUNDANCY, STANDARD, STANDARD_IA."
        },
        "sse": {
          "description": "",
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Enable AWS Server Side Encryption. Supported values: SSE-KMS, SSE-S3."
            },
            "kms_key_id": {
              "type": "string",
              "description": "KMS Key ID used to encrypt objects in S3"
            },
            "kms_encryption_context": {
              "type": "string",
              "description": "KMS Encryption Context used for object encryption. It expects JSON formatted string."
            }
          }
        },
        "backoff_config": {
          "description": "Configures back off when S3 get Object.",
          "type": "object",
          "properties": {
            "min_period": {
              "type": "string",
              "description": "Minimum backoff time when s3 get Object"
            },
            "max_period": {
              "type": "string",
              "description": "Maximum backoff time when s3 get Object"
            },
            "max_retries": {
              "type": "integer",
              "description": "Maximum number of times to retry when s3 get Object. Default: 5."
            }
          }
        }
      }
    },
    "azure_storage_config": {
      "type": "object",
      "properties": {
        "environment": {
          "type": "string",
          "description": "Azure Cloud environment. Supported values are: AzureGlobal, AzureChinaCloud, AzureGermanCloud, AzureUSGovernment."
        },
        "account_name": {
          "type": "string",
          "description": "Azure storage account name."
        },
        "account_key": {
          "type": "string",
          "description": "Azure storage account key."
        },
        "connection_string": {
          "type": "string",
          "description": "If `connection-string` is set, the values of `account-name` and `endpoint-suffix` values will not be used. Use this method over `account-key` if you need to authenticate via a SAS token. Or if you use the Azurite emulator."
        },
        "container_name": {
          "type": "string",
          "description": "Name of the storage account blob container used to store chunks. This container must be created before running cortex."
        },
        "endpoint_suffix": {
          "type": "string",
          "description": "Azure storage endpoint suffix without schema. The storage account name will be prefixed to this value to create the FQDN."
        },
        "use_managed_identity": {
          "type": "boolean",
          "description": "Use Managed Identity to authenticate to the Azure storage account."
        },
        "use_federated_token": {
          "type": "boolean",
          "description": "Use Federated Token to authenticate to the Azure storage account."
        },
        "user_assigned_id": {
          "type": "string",
          "description": "User assigned identity ID to authenticate to the Azure storage account."
        },
        "use_service_principal": {
          "type": "boolean",
          "description": "Use Service Principal to authenticate through Azure OAuth."
        },
        "client_id": {
          "type": "string",
          "description": "Azure Service Principal ID(GUID)."
        },
        "client_secret": {
          "type": "string",
          "description": "Azure Service Principal secret key."
        },
        "tenant_id": {
          "type": "string",
          "description": "Azure Tenant ID is used to authenticate through Azure OAuth."
        },
        "chunk_delimiter": {
          "type": "string",
          "description": "Chunk delimiter for blob ID to be used"
        },
        "download_buffer_size": {
          "type": "integer",
          "description": "Preallocated buffer size for downloads. Default: 512000."
        },
        "upload_buffer_size": {
          "type": "integer",
          "description": "Preallocated buffer size for uploads. Default: 256000."
        },
        "upload_buffer_count": {
          "type": "integer",
          "description": "Number of buffers used to used to upload a chunk. Default: 1."
        },
        "request_timeout": {
          "type": "string",
          "description": "Timeout for requests made against azure blob storage."
        },
        "max_retries": {
          "type": "integer",
          "description": "Number of retries for a request which times out. Default: 5."
        },
        "min_retry_delay": {
          "type": "string",
          "description": "Minimum time to wait before retrying a request."
        },
        "max_retry_delay": {
          "type": "string",
          "description": "Maximum time to wait before retrying a request."
        }
      }
    },
    "bloom_compactor": {
      "type": "object",
      "properties": {
        "ring": {
          "description": "Defines the ring to be used by the bloom-compactor servers. In case this isn't configured, this block supports inheriting configuration from the common ring section.",
          "type": "object",
          "properties": {
            "kvstore": {
              "description": "",
              "type": "object",
              "properties": {
                "store": {
                  "type": "string",
                  "description": "Backend storage to use for the ring. Supported values are: consul, etcd, inmemory, memberlist, multi."
                },
                "prefix": {
                  "type": "string",
                  "description": "The prefix for the keys in the store. Should end with a /."
                },
                "consul": {
                  "$ref": "#/definitions/consul",
                  "description": "Configuration for a Consul client. Only applies if the selected kvstore is consul."
                },
                "etcd": {
                  "$ref": "#/definitions/etcd",
                  "description": "Configuration for an ETCD v3 client. Only applies if the selected kvstore is etcd."
                },
                "multi": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "primary": {
                      "type": "string",
                      "description": "Primary backend storage used by multi-client."
                    },
                    "secondary": {
                      "type": "string",
                      "description": "Secondary backend storage used by multi-client."
                    },
                    "mirror_enabled": {
                      "type": "boolean",
                      "description": "Mirror writes to secondary store."
                    },
                    "mirror_timeout": {
                      "type": "string",
                      "description": "Timeout for storing value to secondary store."
                    }
                  }
                }
              }
            },
            "heartbeat_period": {
              "type": "string",
              "description": "Period at which to heartbeat to the ring. 0 = disabled."
            },
            "heartbeat_timeout": {
              "type": "string",
              "description": "The heartbeat timeout after which compactors are considered unhealthy within the ring. 0 = never (timeout disabled)."
            },
            "tokens_file_path": {
              "type": "string",
              "description": "File path where tokens are stored. If empty, tokens are not stored at shutdown and restored at startup."
            },
            "zone_awareness_enabled": {
              "type": "boolean",
              "description": "True to enable zone-awareness and replicate blocks across different availability zones."
            },
            "num_tokens": {
              "type": "integer",
              "description": "Number of tokens to use in the ring per compactor. Higher number of tokens will result in more and smaller files (metas and blocks.). Default: 10."
            },
            "replication_factor": {},
            "instance_id": {
              "type": "string",
              "description": "Instance ID to register in the ring."
            },
            "instance_interface_names": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "Name of network interface to read address from."
            },
            "instance_port": {
              "type": "integer",
              "description": "Port to advertise in the ring (defaults to server.grpc-listen-port). Default: 0."
            },
            "instance_addr": {
              "type": "string",
              "description": "IP address to advertise in the ring."
            },
            "instance_availability_zone": {
              "type": "string",
              "description": "The availability zone where this instance is running. Required if zone-awareness is enabled."
            },
            "instance_enable_ipv6": {
              "type": "boolean",
              "description": "Enable using a IPv6 instance address."
            }
          }
        },
        "enabled": {
          "type": "boolean",
          "description": "Flag to enable or disable the usage of the bloom-compactor component."
        },
        "compaction_interval": {
          "type": "string",
          "description": "Interval at which to re-run the compaction operation."
        },
        "min_table_offset": {
          "type": "integer",
          "description": "Newest day-table offset (from today, inclusive) to compact. Increase to lower cost by not re-writing data to object storage too frequently since recent data changes more often at the cost of not having blooms available as quickly. Default: 1."
        },
        "max_table_offset": {
          "type": "integer",
          "description": "Oldest day-table offset (from today, inclusive) to compact. This can be used to lower cost by not trying to compact older data which doesn't change. This can be optimized by aligning it with the maximum `reject_old_samples_max_age` setting of any tenant. Default: 2."
        },
        "worker_parallelism": {
          "type": "integer",
          "description": "Number of workers to run in parallel for compaction. Default: 1."
        },
        "compaction_retries_min_backoff": {
          "type": "string",
          "description": "Minimum backoff time between retries."
        },
        "compaction_retries_max_backoff": {
          "type": "string",
          "description": "Maximum backoff time between retries."
        },
        "compaction_retries": {
          "type": "integer",
          "description": "Number of retries to perform when compaction fails. Default: 3."
        },
        "max_compaction_parallelism": {
          "type": "integer",
          "description": "Maximum number of tables to compact in parallel. While increasing this value, please make sure compactor has enough disk space allocated to be able to store and compact as many tables. Default: 1."
        },
        "retention": {
          "description": "",
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Enable bloom retention."
            },
            "max_lookback_days": {
              "type": "integer",
              "description": "Max lookback days for retention. Default: 365."
            }
          }
        }
      }
    },
    "bloom_gateway": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Flag to enable or disable the bloom gateway component globally."
        },
        "client": {
          "description": "",
          "type": "object",
          "properties": {
            "pool_config": {
              "description": "Configures the behavior of the connection pool.",
              "type": "object",
              "properties": {
                "check_interval": {
                  "type": "string",
                  "description": "How frequently to clean up clients for servers that have gone away or are unhealthy."
                },
                "enable_health_check": {
                  "type": "boolean",
                  "description": "Run a health check on each server during periodic cleanup."
                },
                "health_check_timeout": {
                  "type": "string",
                  "description": "Timeout for the health check if health check is enabled."
                }
              }
            },
            "grpc_client_config": {
              "$ref": "#/definitions/grpc_client",
              "description": "The grpc_client block configures the gRPC client used to communicate between a client and server component in Loki."
            },
            "results_cache": {
              "description": "",
              "type": "object",
              "properties": {
                "cache": {
                  "$ref": "#/definitions/cache_config",
                  "description": "The cache_config block configures the cache backend for a specific Loki component."
                },
                "compression": {
                  "type": "string",
                  "description": "Use compression in cache. The default is an empty value '', which disables compression. Supported values are: 'snappy' and ''."
                }
              }
            },
            "cache_results": {
              "type": "boolean",
              "description": "Flag to control whether to cache bloom gateway client requests/responses."
            },
            "addresses": {
              "type": "string",
              "description": "Comma separated addresses list in DNS Service Discovery format: https://grafana.com/docs/mimir/latest/configure/about-dns-service-discovery/#supported-discovery-modes"
            }
          }
        },
        "worker_concurrency": {
          "type": "integer",
          "description": "Number of workers to use for filtering chunks concurrently. Usually set to 1x number of CPU cores. Default: 4."
        },
        "block_query_concurrency": {
          "type": "integer",
          "description": "Number of blocks processed concurrently on a single worker. Usually set to 2x number of CPU cores. Default: 8."
        },
        "max_outstanding_per_tenant": {
          "type": "integer",
          "description": "Maximum number of outstanding tasks per tenant. Default: 1024."
        },
        "num_multiplex_tasks": {
          "type": "integer",
          "description": "How many tasks are multiplexed at once. Default: 512."
        }
      }
    },
    "bos_storage_config": {
      "type": "object",
      "properties": {
        "bucket_name": {
          "type": "string",
          "description": "Name of BOS bucket."
        },
        "endpoint": {
          "type": "string",
          "description": "BOS endpoint to connect to."
        },
        "access_key_id": {
          "type": "string",
          "description": "Baidu Cloud Engine (BCE) Access Key ID."
        },
        "secret_access_key": {
          "type": "string",
          "description": "Baidu Cloud Engine (BCE) Secret Access Key."
        }
      }
    },
    "cache_config": {
      "type": "object",
      "properties": {
        "default_validity": {
          "type": "string",
          "description": "The default validity of entries for caches unless overridden."
        },
        "background": {
          "description": "",
          "type": "object",
          "properties": {
            "writeback_goroutines": {
              "type": "integer",
              "description": "At what concurrency to write back to cache. Default: 1."
            },
            "writeback_buffer": {
              "type": "integer",
              "description": "How many key batches to buffer for background write-back. Default is large to prefer size based limiting. Default: 500000."
            },
            "writeback_size_limit": {
              "type": "string",
              "description": "Size limit in bytes for background write-back. Default: 500MB."
            }
          }
        },
        "memcached": {
          "description": "",
          "type": "object",
          "properties": {
            "expiration": {
              "type": "string",
              "description": "How long keys stay in the memcache."
            },
            "batch_size": {
              "type": "integer",
              "description": "How many keys to fetch in each batch. Default: 4."
            },
            "parallelism": {
              "type": "integer",
              "description": "Maximum active requests to memcache. Default: 5."
            }
          }
        },
        "memcached_client": {
          "description": "",
          "type": "object",
          "properties": {
            "host": {
              "type": "string",
              "description": "Hostname for memcached service to use. If empty and if addresses is unset, no memcached will be used."
            },
            "service": {
              "type": "string",
              "description": "SRV service used to discover memcache servers."
            },
            "addresses": {
              "type": "string",
              "description": "Comma separated addresses list in DNS Service Discovery format: https://grafana.com/docs/mimir/latest/configure/about-dns-service-discovery/#supported-discovery-modes"
            },
            "timeout": {
              "type": "string",
              "description": "Maximum time to wait before giving up on memcached requests."
            },
            "max_idle_conns": {
              "type": "integer",
              "description": "Maximum number of idle connections in pool. Default: 16."
            },
            "max_item_size": {
              "type": "integer",
              "description": "The maximum size of an item stored in memcached. Bigger items are not stored. If set to 0, no maximum size is enforced. Default: 0."
            },
            "update_interval": {
              "type": "string",
              "description": "Period with which to poll DNS for memcache servers."
            },
            "consistent_hash": {
              "type": "boolean",
              "description": "Use consistent hashing to distribute to memcache servers."
            },
            "circuit_breaker_consecutive_failures": {
              "type": "integer",
              "description": "Trip circuit-breaker after this number of consecutive dial failures (if zero then circuit-breaker is disabled). Default: 10."
            },
            "circuit_breaker_timeout": {
              "type": "string",
              "description": "Duration circuit-breaker remains open after tripping (if zero then 60 seconds is used)."
            },
            "circuit_breaker_interval": {
              "type": "string",
              "description": "Reset circuit-breaker counts after this long (if zero then never reset)."
            },
            "tls_enabled": {
              "type": "boolean",
              "description": "Enable connecting to Memcached with TLS."
            },
            "tls_cert_path": {
              "type": "string",
              "description": "Path to the client certificate, which will be used for authenticating with the server. Also requires the key path to be configured."
            },
            "tls_key_path": {
              "type": "string",
              "description": "Path to the key for the client certificate. Also requires the client certificate to be configured."
            },
            "tls_ca_path": {
              "type": "string",
              "description": "Path to the CA certificates to validate server certificate against. If not set, the host's root CA certificates are used."
            },
            "tls_server_name": {
              "type": "string",
              "description": "Override the expected name on the server certificate."
            },
            "tls_insecure_skip_verify": {
              "type": "boolean",
              "description": "Skip validating server certificate."
            },
            "tls_cipher_suites": {
              "type": "string",
              "description": "Override the default cipher suite list (separated by commas). Allowed values:\n\nSecure Ciphers:\n- TLS_AES_128_GCM_SHA256\n- TLS_AES_256_GCM_SHA384\n- TLS_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n\nInsecure Ciphers:\n- TLS_RSA_WITH_RC4_128_SHA\n- TLS_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA\n- TLS_RSA_WITH_AES_256_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA256\n- TLS_RSA_WITH_AES_128_GCM_SHA256\n- TLS_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n"
            },
            "tls_min_version": {
              "type": "string",
              "description": "Override the default minimum TLS version. Allowed values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13"
            }
          }
        },
        "redis": {
          "description": "",
          "type": "object",
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "Redis Server or Cluster configuration endpoint to use for caching. A comma-separated list of endpoints for Redis Cluster or Redis Sentinel. If empty, no redis will be used."
            },
            "master_name": {
              "type": "string",
              "description": "Redis Sentinel master name. An empty string for Redis Server or Redis Cluster."
            },
            "timeout": {
              "type": "string",
              "description": "Maximum time to wait before giving up on redis requests."
            },
            "expiration": {
              "type": "string",
              "description": "How long keys stay in the redis."
            },
            "db": {
              "type": "integer",
              "description": "Database index. Default: 0."
            },
            "pool_size": {
              "type": "integer",
              "description": "Maximum number of connections in the pool. Default: 0."
            },
            "username": {
              "type": "string",
              "description": "Username to use when connecting to redis."
            },
            "password": {
              "type": "string",
              "description": "Password to use when connecting to redis."
            },
            "tls_enabled": {
              "type": "boolean",
              "description": "Enable connecting to redis with TLS."
            },
            "tls_insecure_skip_verify": {
              "type": "boolean",
              "description": "Skip validating server certificate."
            },
            "idle_timeout": {
              "type": "string",
              "description": "Close connections after remaining idle for this duration. If the value is zero, then idle connections are not closed."
            },
            "max_connection_age": {
              "type": "string",
              "description": "Close connections older than this duration. If the value is zero, then the pool does not close connections based on age."
            },
            "route_randomly": {
              "type": "boolean",
              "description": "By default, the Redis client only reads from the master node. Enabling this option can lower pressure on the master node by randomly routing read-only commands to the master and any available replicas."
            }
          }
        },
        "embedded_cache": {
          "description": "",
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Whether embedded cache is enabled."
            },
            "max_size_mb": {
              "type": "integer",
              "description": "Maximum memory size of the cache in MB. Default: 100."
            },
            "max_size_items": {
              "type": "integer",
              "description": "Maximum number of entries in the cache. Default: 0."
            },
            "ttl": {
              "type": "string",
              "description": "The time to live for items in the cache before they get purged."
            }
          }
        }
      }
    },
    "chunk_store_config": {
      "type": "object",
      "properties": {
        "chunk_cache_config": {
          "$ref": "#/definitions/cache_config",
          "description": "The cache_config block configures the cache backend for a specific Loki component."
        },
        "chunk_cache_config_l2": {
          "$ref": "#/definitions/cache_config",
          "description": "The cache_config block configures the cache backend for a specific Loki component."
        },
        "write_dedupe_cache_config": {
          "$ref": "#/definitions/cache_config",
          "description": "Write dedupe cache is deprecated along with legacy index types (aws, aws-dynamo, bigtable, bigtable-hashed, cassandra, gcp, gcp-columnkey, grpc-store).\nConsider using TSDB index which does not require a write dedupe cache."
        },
        "l2_chunk_cache_handoff": {
          "type": "string",
          "description": "Chunks will be handed off to the L2 cache after this duration. 0 to disable L2 cache."
        },
        "cache_lookups_older_than": {
          "type": "string",
          "description": "Cache index entries older than this period. 0 to disable."
        }
      }
    },
    "common": {
      "type": "object",
      "properties": {
        "path_prefix": {
          "type": "string"
        },
        "storage": {
          "description": "",
          "type": "object",
          "properties": {
            "s3": {
              "$ref": "#/definitions/s3_storage_config",
              "description": "The s3_storage_config block configures the connection to Amazon S3 object storage backend."
            },
            "gcs": {
              "$ref": "#/definitions/gcs_storage_config",
              "description": "The gcs_storage_config block configures the connection to Google Cloud Storage object storage backend."
            },
            "azure": {
              "$ref": "#/definitions/azure_storage_config",
              "description": "The azure_storage_config block configures the connection to Azure object storage backend."
            },
            "alibabacloud": {
              "$ref": "#/definitions/alibabacloud_storage_config",
              "description": "The alibabacloud_storage_config block configures the connection to Alibaba Cloud Storage object storage backend."
            },
            "bos": {
              "$ref": "#/definitions/bos_storage_config",
              "description": "The bos_storage_config block configures the connection to Baidu Object Storage (BOS) object storage backend."
            },
            "swift": {
              "$ref": "#/definitions/swift_storage_config",
              "description": "The swift_storage_config block configures the connection to OpenStack Object Storage (Swift) object storage backend."
            },
            "filesystem": {
              "description": "",
              "type": "object",
              "properties": {
                "chunks_directory": {
                  "type": "string",
                  "description": "Directory to store chunks in."
                },
                "rules_directory": {
                  "type": "string",
                  "description": "Directory to store rules in."
                }
              }
            },
            "hedging": {
              "description": "",
              "type": "object",
              "properties": {
                "at": {
                  "type": "string",
                  "description": "If set to a non-zero value a second request will be issued at the provided duration. Default is 0 (disabled)"
                },
                "up_to": {
                  "type": "integer",
                  "description": "The maximum of hedge requests allowed. Default: 2."
                },
                "max_per_second": {
                  "type": "integer",
                  "description": "The maximum of hedge requests allowed per seconds. Default: 5."
                }
              }
            },
            "cos": {
              "$ref": "#/definitions/cos_storage_config",
              "description": "The cos_storage_config block configures the connection to IBM Cloud Object Storage (COS) backend."
            },
            "congestion_control": {
              "description": "",
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Use storage congestion control (default: disabled)."
                },
                "controller": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "strategy": {
                      "type": "string",
                      "description": "Congestion control strategy to use (default: none, options: 'aimd')."
                    },
                    "aimd": {
                      "description": "",
                      "type": "object",
                      "properties": {
                        "start": {
                          "type": "integer",
                          "description": "AIMD starting throughput window size: how many requests can be sent per second (default: 2000). Default: 2000."
                        },
                        "upper_bound": {
                          "type": "integer",
                          "description": "AIMD maximum throughput window size: upper limit of requests sent per second (default: 10000). Default: 10000."
                        },
                        "backoff_factor": {
                          "type": "number",
                          "description": "AIMD backoff factor when upstream service is throttled to decrease number of requests sent per second (default: 0.5). Default: 0.5."
                        }
                      }
                    }
                  }
                },
                "retry": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "strategy": {
                      "type": "string",
                      "description": "Congestion control retry strategy to use (default: none, options: 'limited')."
                    },
                    "limit": {
                      "type": "integer",
                      "description": "Maximum number of retries allowed. Default: 2."
                    }
                  }
                },
                "hedging": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "config": {
                      "description": "",
                      "type": "object",
                      "properties": {
                        "at": {
                          "type": "string"
                        },
                        "up_to": {
                          "type": "integer"
                        },
                        "max_per_second": {
                          "type": "integer"
                        }
                      }
                    },
                    "strategy": {
                      "type": "string",
                      "description": "Congestion control hedge strategy to use (default: none, options: 'limited')."
                    }
                  }
                }
              }
            }
          }
        },
        "persist_tokens": {
          "type": "boolean"
        },
        "replication_factor": {
          "type": "integer"
        },
        "ring": {
          "description": "",
          "type": "object",
          "properties": {
            "kvstore": {
              "description": "",
              "type": "object",
              "properties": {
                "store": {
                  "type": "string",
                  "description": "Backend storage to use for the ring. Supported values are: consul, etcd, inmemory, memberlist, multi."
                },
                "prefix": {
                  "type": "string",
                  "description": "The prefix for the keys in the store. Should end with a /."
                },
                "consul": {
                  "$ref": "#/definitions/consul",
                  "description": "Configuration for a Consul client. Only applies if the selected kvstore is consul."
                },
                "etcd": {
                  "$ref": "#/definitions/etcd",
                  "description": "Configuration for an ETCD v3 client. Only applies if the selected kvstore is etcd."
                },
                "multi": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "primary": {
                      "type": "string",
                      "description": "Primary backend storage used by multi-client."
                    },
                    "secondary": {
                      "type": "string",
                      "description": "Secondary backend storage used by multi-client."
                    },
                    "mirror_enabled": {
                      "type": "boolean",
                      "description": "Mirror writes to secondary store."
                    },
                    "mirror_timeout": {
                      "type": "string",
                      "description": "Timeout for storing value to secondary store."
                    }
                  }
                }
              }
            },
            "heartbeat_period": {
              "type": "string",
              "description": "Period at which to heartbeat to the ring. 0 = disabled."
            },
            "heartbeat_timeout": {
              "type": "string",
              "description": "The heartbeat timeout after which compactors are considered unhealthy within the ring. 0 = never (timeout disabled)."
            },
            "tokens_file_path": {
              "type": "string",
              "description": "File path where tokens are stored. If empty, tokens are not stored at shutdown and restored at startup."
            },
            "zone_awareness_enabled": {
              "type": "boolean",
              "description": "True to enable zone-awareness and replicate blocks across different availability zones."
            },
            "num_tokens": {
              "type": "integer",
              "description": "Number of tokens to own in the ring. Default: 128."
            },
            "replication_factor": {
              "type": "integer",
              "description": "Factor for data replication. Default: 3."
            },
            "instance_id": {
              "type": "string",
              "description": "Instance ID to register in the ring."
            },
            "instance_interface_names": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "Name of network interface to read address from."
            },
            "instance_port": {
              "type": "integer",
              "description": "Port to advertise in the ring (defaults to server.grpc-listen-port). Default: 0."
            },
            "instance_addr": {
              "type": "string",
              "description": "IP address to advertise in the ring."
            },
            "instance_availability_zone": {
              "type": "string",
              "description": "The availability zone where this instance is running. Required if zone-awareness is enabled."
            },
            "instance_enable_ipv6": {
              "type": "boolean",
              "description": "Enable using a IPv6 instance address."
            }
          }
        },
        "instance_interface_names": {
          "type": ["array", "null"],
          "items": {
            "type": "string"
          }
        },
        "instance_addr": {
          "type": "string"
        },
        "compactor_address": {
          "type": "string",
          "description": "the http address of the compactor in the form http://host:port"
        },
        "compactor_grpc_address": {
          "type": "string",
          "description": "the grpc address of the compactor in the form host:port"
        }
      }
    },
    "compactor": {
      "type": "object",
      "properties": {
        "working_directory": {
          "type": "string",
          "description": "Directory where files can be downloaded for compaction."
        },
        "compaction_interval": {
          "type": "string",
          "description": "Interval at which to re-run the compaction operation."
        },
        "apply_retention_interval": {
          "type": "string",
          "description": "Interval at which to apply/enforce retention. 0 means run at same interval as compaction. If non-zero, it should always be a multiple of compaction interval."
        },
        "retention_enabled": {
          "type": "boolean",
          "description": "Activate custom (per-stream,per-tenant) retention."
        },
        "retention_delete_delay": {
          "type": "string",
          "description": "Delay after which chunks will be fully deleted during retention."
        },
        "retention_delete_worker_count": {
          "type": "integer",
          "description": "The total amount of worker to use to delete chunks. Default: 150."
        },
        "retention_table_timeout": {
          "type": "string",
          "description": "The maximum amount of time to spend running retention and deletion on any given table in the index."
        },
        "delete_request_store": {
          "type": "string",
          "description": "Store used for managing delete requests."
        },
        "delete_request_store_key_prefix": {
          "type": "string",
          "description": "Path prefix for storing delete requests."
        },
        "delete_batch_size": {
          "type": "integer",
          "description": "The max number of delete requests to run per compaction cycle. Default: 70."
        },
        "delete_request_cancel_period": {
          "type": "string",
          "description": "Allow cancellation of delete request until duration after they are created. Data would be deleted only after delete requests have been older than this duration. Ideally this should be set to at least 24h."
        },
        "delete_max_interval": {
          "type": "string",
          "description": "Constrain the size of any single delete request with line filters. When a delete request > delete_max_interval is input, the request is sharded into smaller requests of no more than delete_max_interval"
        },
        "max_compaction_parallelism": {
          "type": "integer",
          "description": "Maximum number of tables to compact in parallel. While increasing this value, please make sure compactor has enough disk space allocated to be able to store and compact as many tables. Default: 1."
        },
        "upload_parallelism": {
          "type": "integer",
          "description": "Number of upload/remove operations to execute in parallel when finalizing a compaction. NOTE: This setting is per compaction operation, which can be executed in parallel. The upper bound on the number of concurrent uploads is upload_parallelism * max_compaction_parallelism. Default: 10."
        },
        "compactor_ring": {
          "description": "The hash ring configuration used by compactors to elect a single instance for running compactions. The CLI flags prefix for this block config is: compactor.ring",
          "type": "object",
          "properties": {
            "kvstore": {
              "description": "",
              "type": "object",
              "properties": {
                "store": {
                  "type": "string",
                  "description": "Backend storage to use for the ring. Supported values are: consul, etcd, inmemory, memberlist, multi."
                },
                "prefix": {
                  "type": "string",
                  "description": "The prefix for the keys in the store. Should end with a /."
                },
                "consul": {
                  "$ref": "#/definitions/consul",
                  "description": "Configuration for a Consul client. Only applies if the selected kvstore is consul."
                },
                "etcd": {
                  "$ref": "#/definitions/etcd",
                  "description": "Configuration for an ETCD v3 client. Only applies if the selected kvstore is etcd."
                },
                "multi": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "primary": {
                      "type": "string",
                      "description": "Primary backend storage used by multi-client."
                    },
                    "secondary": {
                      "type": "string",
                      "description": "Secondary backend storage used by multi-client."
                    },
                    "mirror_enabled": {
                      "type": "boolean",
                      "description": "Mirror writes to secondary store."
                    },
                    "mirror_timeout": {
                      "type": "string",
                      "description": "Timeout for storing value to secondary store."
                    }
                  }
                }
              }
            },
            "heartbeat_period": {
              "type": "string",
              "description": "Period at which to heartbeat to the ring. 0 = disabled."
            },
            "heartbeat_timeout": {
              "type": "string",
              "description": "The heartbeat timeout after which compactors are considered unhealthy within the ring. 0 = never (timeout disabled)."
            },
            "tokens_file_path": {
              "type": "string",
              "description": "File path where tokens are stored. If empty, tokens are not stored at shutdown and restored at startup."
            },
            "zone_awareness_enabled": {
              "type": "boolean",
              "description": "True to enable zone-awareness and replicate blocks across different availability zones."
            },
            "num_tokens": {},
            "replication_factor": {},
            "instance_id": {
              "type": "string",
              "description": "Instance ID to register in the ring."
            },
            "instance_interface_names": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "Name of network interface to read address from."
            },
            "instance_port": {
              "type": "integer",
              "description": "Port to advertise in the ring (defaults to server.grpc-listen-port). Default: 0."
            },
            "instance_addr": {
              "type": "string",
              "description": "IP address to advertise in the ring."
            },
            "instance_availability_zone": {
              "type": "string",
              "description": "The availability zone where this instance is running. Required if zone-awareness is enabled."
            },
            "instance_enable_ipv6": {
              "type": "boolean",
              "description": "Enable using a IPv6 instance address."
            }
          }
        },
        "tables_to_compact": {
          "type": "integer",
          "description": "Number of tables that compactor will try to compact. Newer tables are chosen when this is less than the number of tables available. Default: 0."
        },
        "skip_latest_n_tables": {
          "type": "integer",
          "description": "Do not compact N latest tables. Together with -compactor.run-once and -compactor.tables-to-compact, this is useful when clearing compactor backlogs. Default: 0."
        }
      }
    },
    "consul": {
      "type": "object",
      "properties": {
        "host": {
          "type": "string",
          "description": "Hostname and port of Consul."
        },
        "acl_token": {
          "type": "string",
          "description": "ACL Token used to interact with Consul."
        },
        "http_client_timeout": {
          "type": "string",
          "description": "HTTP timeout when talking to Consul"
        },
        "consistent_reads": {
          "type": "boolean",
          "description": "Enable consistent reads to Consul."
        },
        "watch_rate_limit": {
          "type": "number",
          "description": "Rate limit when watching key or prefix in Consul, in requests per second. 0 disables the rate limit. Default: 1."
        },
        "watch_burst_size": {
          "type": "integer",
          "description": "Burst size used in rate limit. Values less than 1 are treated as 1. Default: 1."
        },
        "cas_retry_delay": {
          "type": "string",
          "description": "Maximum duration to wait before retrying a Compare And Swap (CAS) operation."
        }
      }
    },
    "cos_storage_config": {
      "type": "object",
      "properties": {
        "forcepathstyle": {
          "type": "boolean",
          "description": "Set this to `true` to force the request to use path-style addressing."
        },
        "bucketnames": {
          "type": "string",
          "description": "Comma separated list of bucket names to evenly distribute chunks over."
        },
        "endpoint": {
          "type": "string",
          "description": "COS Endpoint to connect to."
        },
        "region": {
          "type": "string",
          "description": "COS region to use."
        },
        "access_key_id": {
          "type": "string",
          "description": "COS HMAC Access Key ID."
        },
        "secret_access_key": {
          "type": "string",
          "description": "COS HMAC Secret Access Key."
        },
        "http_config": {
          "description": "",
          "type": "object",
          "properties": {
            "idle_conn_timeout": {
              "type": "string",
              "description": "The maximum amount of time an idle connection will be held open."
            },
            "response_header_timeout": {
              "type": "string",
              "description": "If non-zero, specifies the amount of time to wait for a server's response headers after fully writing the request."
            }
          }
        },
        "backoff_config": {
          "description": "Configures back off when cos get Object.",
          "type": "object",
          "properties": {
            "min_period": {
              "type": "string",
              "description": "Minimum backoff time when cos get Object."
            },
            "max_period": {
              "type": "string",
              "description": "Maximum backoff time when cos get Object."
            },
            "max_retries": {
              "type": "integer",
              "description": "Maximum number of times to retry when cos get Object. Default: 5."
            }
          }
        },
        "api_key": {
          "type": "string",
          "description": "IAM API key to access COS."
        },
        "service_instance_id": {
          "type": "string",
          "description": "COS service instance id to use."
        },
        "auth_endpoint": {
          "type": "string",
          "description": "IAM Auth Endpoint for authentication."
        },
        "cr_token_file_path": {
          "type": "string",
          "description": "Compute resource token file path."
        },
        "trusted_profile_name": {
          "type": "string",
          "description": "Name of the trusted profile."
        },
        "trusted_profile_id": {
          "type": "string",
          "description": "ID of the trusted profile."
        }
      }
    },
    "distributor": {
      "type": "object",
      "properties": {
        "ring": {
          "description": "",
          "type": "object",
          "properties": {
            "kvstore": {
              "description": "",
              "type": "object",
              "properties": {
                "store": {
                  "type": "string",
                  "description": "Backend storage to use for the ring. Supported values are: consul, etcd, inmemory, memberlist, multi."
                },
                "prefix": {
                  "type": "string",
                  "description": "The prefix for the keys in the store. Should end with a /."
                },
                "consul": {
                  "$ref": "#/definitions/consul",
                  "description": "Configuration for a Consul client. Only applies if the selected kvstore is consul."
                },
                "etcd": {
                  "$ref": "#/definitions/etcd",
                  "description": "Configuration for an ETCD v3 client. Only applies if the selected kvstore is etcd."
                },
                "multi": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "primary": {
                      "type": "string",
                      "description": "Primary backend storage used by multi-client."
                    },
                    "secondary": {
                      "type": "string",
                      "description": "Secondary backend storage used by multi-client."
                    },
                    "mirror_enabled": {
                      "type": "boolean",
                      "description": "Mirror writes to secondary store."
                    },
                    "mirror_timeout": {
                      "type": "string",
                      "description": "Timeout for storing value to secondary store."
                    }
                  }
                }
              }
            },
            "heartbeat_period": {
              "type": "string",
              "description": "Period at which to heartbeat to the ring. 0 = disabled."
            },
            "heartbeat_timeout": {
              "type": "string",
              "description": "The heartbeat timeout after which distributors are considered unhealthy within the ring. 0 = never (timeout disabled)."
            },
            "instance_interface_names": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "Name of network interface to read address from."
            }
          }
        },
        "rate_store": {
          "description": "",
          "type": "object",
          "properties": {
            "max_request_parallelism": {
              "type": "integer",
              "description": "The max number of concurrent requests to make to ingester stream apis. Default: 200."
            },
            "stream_rate_update_interval": {
              "type": "string",
              "description": "The interval on which distributors will update current stream rates from ingesters"
            },
            "ingester_request_timeout": {
              "type": "string",
              "description": "Timeout for communication between distributors and any given ingester when updating rates"
            },
            "debug": {
              "type": "boolean",
              "description": "If enabled, detailed logs and spans will be emitted."
            }
          }
        },
        "write_failures_logging": {
          "description": "Customize the logging of write failures.",
          "type": "object",
          "properties": {
            "rate": {
              "type": "string",
              "description": "Log volume allowed (per second). Default: 1KB. Default: 1KB."
            },
            "add_insights_label": {
              "type": "boolean",
              "description": "Whether a insight=true key should be logged or not. Default: false."
            }
          }
        },
        "otlp_config": {
          "description": "",
          "type": "object",
          "properties": {
            "default_resource_attributes_as_index_labels": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "List of default otlp resource attributes to be picked as index labels"
            }
          }
        }
      }
    },
    "etcd": {
      "type": "object",
      "properties": {
        "endpoints": {
          "type": ["array", "null"],
          "items": {
            "type": "string"
          },
          "description": "The etcd endpoints to connect to."
        },
        "dial_timeout": {
          "type": "string",
          "description": "The dial timeout for the etcd connection."
        },
        "max_retries": {
          "type": "integer",
          "description": "The maximum number of retries to do for failed ops. Default: 10."
        },
        "tls_enabled": {
          "type": "boolean",
          "description": "Enable TLS."
        },
        "tls_cert_path": {
          "type": "string",
          "description": "Path to the client certificate, which will be used for authenticating with the server. Also requires the key path to be configured."
        },
        "tls_key_path": {
          "type": "string",
          "description": "Path to the key for the client certificate. Also requires the client certificate to be configured."
        },
        "tls_ca_path": {
          "type": "string",
          "description": "Path to the CA certificates to validate server certificate against. If not set, the host's root CA certificates are used."
        },
        "tls_server_name": {
          "type": "string",
          "description": "Override the expected name on the server certificate."
        },
        "tls_insecure_skip_verify": {
          "type": "boolean",
          "description": "Skip validating server certificate."
        },
        "tls_cipher_suites": {
          "type": "string",
          "description": "Override the default cipher suite list (separated by commas). Allowed values:\n\nSecure Ciphers:\n- TLS_AES_128_GCM_SHA256\n- TLS_AES_256_GCM_SHA384\n- TLS_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n\nInsecure Ciphers:\n- TLS_RSA_WITH_RC4_128_SHA\n- TLS_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA\n- TLS_RSA_WITH_AES_256_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA256\n- TLS_RSA_WITH_AES_128_GCM_SHA256\n- TLS_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n"
        },
        "tls_min_version": {
          "type": "string",
          "description": "Override the default minimum TLS version. Allowed values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13"
        },
        "username": {
          "type": "string",
          "description": "Etcd username."
        },
        "password": {
          "type": "string",
          "description": "Etcd password."
        }
      }
    },
    "frontend": {
      "type": "object",
      "properties": {
        "log_queries_longer_than": {
          "type": "string",
          "description": "Log queries that are slower than the specified duration. Set to 0 to disable. Set to < 0 to enable on all queries."
        },
        "log_query_request_headers": {
          "type": "string",
          "description": "Comma-separated list of request header names to include in query logs. Applies to both query stats and slow queries logs."
        },
        "max_body_size": {
          "type": "integer",
          "description": "Max body size for downstream prometheus. Default: 10485760."
        },
        "query_stats_enabled": {
          "type": "boolean",
          "description": "True to enable query statistics tracking. When enabled, a message with some statistics is logged for every query."
        },
        "max_outstanding_per_tenant": {
          "type": "integer",
          "description": "Maximum number of outstanding requests per tenant per frontend; requests beyond this error with HTTP 429. Default: 2048."
        },
        "querier_forget_delay": {
          "type": "string",
          "description": "In the event a tenant is repeatedly sending queries that lead the querier to crash or be killed due to an out-of-memory error, the crashed querier will be disconnected from the query frontend and a new querier will be immediately assigned to the tenants shard. This invalidates the assumption that shuffle sharding can be used to reduce the impact on tenants. This option mitigates the impact by configuring a delay between when a querier disconnects because of a crash and when the crashed querier is actually removed from the tenant's shard."
        },
        "scheduler_address": {
          "type": "string",
          "description": "DNS hostname used for finding query-schedulers."
        },
        "scheduler_dns_lookup_period": {
          "type": "string",
          "description": "How often to resolve the scheduler-address, in order to look for new query-scheduler instances. Also used to determine how often to poll the scheduler-ring for addresses if the scheduler-ring is configured."
        },
        "scheduler_worker_concurrency": {
          "type": "integer",
          "description": "Number of concurrent workers forwarding queries to single query-scheduler. Default: 5."
        },
        "grpc_client_config": {
          "$ref": "#/definitions/grpc_client",
          "description": "The grpc_client block configures the gRPC client used to communicate between a client and server component in Loki."
        },
        "graceful_shutdown_timeout": {
          "type": "string",
          "description": "Time to wait for inflight requests to finish before forcefully shutting down. This needs to be aligned with the query timeout and the graceful termination period of the process orchestrator."
        },
        "instance_interface_names": {
          "type": ["array", "null"],
          "items": {
            "type": "string"
          },
          "description": "Name of network interface to read address from. This address is sent to query-scheduler and querier, which uses it to send the query response back to query-frontend."
        },
        "encoding": {
          "type": "string",
          "description": "Defines the encoding for requests to and responses from the scheduler and querier. Can be 'json' or 'protobuf' (defaults to 'json')."
        },
        "compress_responses": {
          "type": "boolean",
          "description": "Compress HTTP responses."
        },
        "downstream_url": {
          "type": "string",
          "description": "URL of downstream Loki."
        },
        "tail_proxy_url": {
          "type": "string",
          "description": "URL of querier for tail proxy."
        },
        "tail_tls_config": {
          "$ref": "#/definitions/tls_config",
          "description": "The TLS configuration."
        }
      }
    },
    "frontend_worker": {
      "type": "object",
      "properties": {
        "frontend_address": {
          "type": "string",
          "description": "Address of query frontend service, in host:port format. If -querier.scheduler-address is set as well, querier will use scheduler instead. Only one of -querier.frontend-address or -querier.scheduler-address can be set. If neither is set, queries are only received via HTTP endpoint."
        },
        "scheduler_address": {
          "type": "string",
          "description": "Hostname (and port) of scheduler that querier will periodically resolve, connect to and receive queries from. Only one of -querier.frontend-address or -querier.scheduler-address can be set. If neither is set, queries are only received via HTTP endpoint."
        },
        "dns_lookup_duration": {
          "type": "string",
          "description": "How often to query DNS for query-frontend or query-scheduler address. Also used to determine how often to poll the scheduler-ring for addresses if the scheduler-ring is configured."
        },
        "id": {
          "type": "string",
          "description": "Querier ID, sent to frontend service to identify requests from the same querier. Defaults to hostname."
        },
        "grpc_client_config": {
          "$ref": "#/definitions/grpc_client",
          "description": "The grpc_client block configures the gRPC client used to communicate between a client and server component in Loki."
        }
      }
    },
    "gcs_storage_config": {
      "type": "object",
      "properties": {
        "bucket_name": {
          "type": "string",
          "description": "Name of GCS bucket. Please refer to https://cloud.google.com/docs/authentication/production for more information about how to configure authentication."
        },
        "service_account": {
          "type": "string",
          "description": "Service account key content in JSON format, refer to https://cloud.google.com/iam/docs/creating-managing-service-account-keys for creation."
        },
        "chunk_buffer_size": {
          "type": "integer",
          "description": "The size of the buffer that GCS client for each PUT request. 0 to disable buffering. Default: 0."
        },
        "request_timeout": {
          "type": "string",
          "description": "The duration after which the requests to GCS should be timed out."
        },
        "enable_opencensus": {
          "type": "boolean",
          "description": "Enable OpenCensus (OC) instrumentation for all requests."
        },
        "enable_http2": {
          "type": "boolean",
          "description": "Enable HTTP2 connections."
        },
        "enable_retries": {
          "type": "boolean",
          "description": "Enable automatic retries of failed idempotent requests."
        }
      }
    },
    "grpc_client": {
      "type": "object",
      "properties": {
        "max_recv_msg_size": {
          "type": "integer",
          "description": "gRPC client max receive message size (bytes). Default: 104857600."
        },
        "max_send_msg_size": {
          "type": "integer",
          "description": "gRPC client max send message size (bytes). Default: 104857600."
        },
        "grpc_compression": {
          "type": "string",
          "description": "Use compression when sending messages. Supported values are: 'gzip', 'snappy' and '' (disable compression)"
        },
        "rate_limit": {
          "type": "number",
          "description": "Rate limit for gRPC client; 0 means disabled. Default: 0."
        },
        "rate_limit_burst": {
          "type": "integer",
          "description": "Rate limit burst for gRPC client. Default: 0."
        },
        "backoff_on_ratelimits": {
          "type": "boolean",
          "description": "Enable backoff and retry when we hit rate limits."
        },
        "backoff_config": {
          "description": "",
          "type": "object",
          "properties": {
            "min_period": {
              "type": "string",
              "description": "Minimum delay when backing off."
            },
            "max_period": {
              "type": "string",
              "description": "Maximum delay when backing off."
            },
            "max_retries": {
              "type": "integer",
              "description": "Number of times to backoff and retry before failing. Default: 10."
            }
          }
        },
        "initial_stream_window_size": {
          "type": "string",
          "description": "Initial stream window size. Values less than the default are not supported and are ignored. Setting this to a value other than the default disables the BDP estimator. Default: 63KiB1023B."
        },
        "initial_connection_window_size": {
          "type": "string",
          "description": "Initial connection window size. Values less than the default are not supported and are ignored. Setting this to a value other than the default disables the BDP estimator. Default: 63KiB1023B."
        },
        "tls_enabled": {
          "type": "boolean",
          "description": "Enable TLS in the gRPC client. This flag needs to be enabled when any other TLS flag is set. If set to false, insecure connection to gRPC server will be used."
        },
        "tls_cert_path": {
          "type": "string",
          "description": "Path to the client certificate, which will be used for authenticating with the server. Also requires the key path to be configured."
        },
        "tls_key_path": {
          "type": "string",
          "description": "Path to the key for the client certificate. Also requires the client certificate to be configured."
        },
        "tls_ca_path": {
          "type": "string",
          "description": "Path to the CA certificates to validate server certificate against. If not set, the host's root CA certificates are used."
        },
        "tls_server_name": {
          "type": "string",
          "description": "Override the expected name on the server certificate."
        },
        "tls_insecure_skip_verify": {
          "type": "boolean",
          "description": "Skip validating server certificate."
        },
        "tls_cipher_suites": {
          "type": "string",
          "description": "Override the default cipher suite list (separated by commas). Allowed values:\n\nSecure Ciphers:\n- TLS_AES_128_GCM_SHA256\n- TLS_AES_256_GCM_SHA384\n- TLS_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n\nInsecure Ciphers:\n- TLS_RSA_WITH_RC4_128_SHA\n- TLS_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA\n- TLS_RSA_WITH_AES_256_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA256\n- TLS_RSA_WITH_AES_128_GCM_SHA256\n- TLS_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n"
        },
        "tls_min_version": {
          "type": "string",
          "description": "Override the default minimum TLS version. Allowed values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13"
        },
        "connect_timeout": {
          "type": "string",
          "description": "The maximum amount of time to establish a connection. A value of 0 means default gRPC client connect timeout and backoff."
        },
        "connect_backoff_base_delay": {
          "type": "string",
          "description": "Initial backoff delay after first connection failure. Only relevant if ConnectTimeout > 0."
        },
        "connect_backoff_max_delay": {
          "type": "string",
          "description": "Maximum backoff delay when establishing a connection. Only relevant if ConnectTimeout > 0."
        }
      }
    },
    "index_gateway": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "description": "Defines in which mode the index gateway server will operate (default to 'simple'). It supports two modes:\n- 'simple': an index gateway server instance is responsible for handling, storing and returning requests for all indices for all tenants.\n- 'ring': an index gateway server instance is responsible for a subset of tenants instead of all tenants."
        },
        "ring": {
          "description": "Defines the ring to be used by the index gateway servers and clients in case the servers are configured to run in 'ring' mode. In case this isn't configured, this block supports inheriting configuration from the common ring section.",
          "type": "object",
          "properties": {
            "kvstore": {
              "description": "",
              "type": "object",
              "properties": {
                "store": {
                  "type": "string",
                  "description": "Backend storage to use for the ring. Supported values are: consul, etcd, inmemory, memberlist, multi."
                },
                "prefix": {
                  "type": "string",
                  "description": "The prefix for the keys in the store. Should end with a /."
                },
                "consul": {
                  "$ref": "#/definitions/consul",
                  "description": "Configuration for a Consul client. Only applies if the selected kvstore is consul."
                },
                "etcd": {
                  "$ref": "#/definitions/etcd",
                  "description": "Configuration for an ETCD v3 client. Only applies if the selected kvstore is etcd."
                },
                "multi": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "primary": {
                      "type": "string",
                      "description": "Primary backend storage used by multi-client."
                    },
                    "secondary": {
                      "type": "string",
                      "description": "Secondary backend storage used by multi-client."
                    },
                    "mirror_enabled": {
                      "type": "boolean",
                      "description": "Mirror writes to secondary store."
                    },
                    "mirror_timeout": {
                      "type": "string",
                      "description": "Timeout for storing value to secondary store."
                    }
                  }
                }
              }
            },
            "heartbeat_period": {
              "type": "string",
              "description": "Period at which to heartbeat to the ring. 0 = disabled."
            },
            "heartbeat_timeout": {
              "type": "string",
              "description": "The heartbeat timeout after which compactors are considered unhealthy within the ring. 0 = never (timeout disabled)."
            },
            "tokens_file_path": {
              "type": "string",
              "description": "File path where tokens are stored. If empty, tokens are not stored at shutdown and restored at startup."
            },
            "zone_awareness_enabled": {
              "type": "boolean",
              "description": "True to enable zone-awareness and replicate blocks across different availability zones."
            },
            "num_tokens": {},
            "replication_factor": {
              "type": "integer",
              "description": "Deprecated: How many index gateway instances are assigned to each tenant. Use -index-gateway.shard-size instead. The shard size is also a per-tenant setting. Default: 3."
            },
            "instance_id": {
              "type": "string",
              "description": "Instance ID to register in the ring."
            },
            "instance_interface_names": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "Name of network interface to read address from."
            },
            "instance_port": {
              "type": "integer",
              "description": "Port to advertise in the ring (defaults to server.grpc-listen-port). Default: 0."
            },
            "instance_addr": {
              "type": "string",
              "description": "IP address to advertise in the ring."
            },
            "instance_availability_zone": {
              "type": "string",
              "description": "The availability zone where this instance is running. Required if zone-awareness is enabled."
            },
            "instance_enable_ipv6": {
              "type": "boolean",
              "description": "Enable using a IPv6 instance address."
            }
          }
        }
      }
    },
    "ingester": {
      "type": "object",
      "properties": {
        "lifecycler": {
          "description": "Configures how the lifecycle of the ingester will operate and where it will register for discovery.",
          "type": "object",
          "properties": {
            "ring": {
              "description": "",
              "type": "object",
              "properties": {
                "kvstore": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "store": {
                      "type": "string",
                      "description": "Backend storage to use for the ring. Supported values are: consul, etcd, inmemory, memberlist, multi."
                    },
                    "prefix": {
                      "type": "string",
                      "description": "The prefix for the keys in the store. Should end with a /."
                    },
                    "consul": {
                      "$ref": "#/definitions/consul",
                      "description": "Configuration for a Consul client. Only applies if the selected kvstore is consul."
                    },
                    "etcd": {
                      "$ref": "#/definitions/etcd",
                      "description": "Configuration for an ETCD v3 client. Only applies if the selected kvstore is etcd."
                    },
                    "multi": {
                      "description": "",
                      "type": "object",
                      "properties": {
                        "primary": {
                          "type": "string",
                          "description": "Primary backend storage used by multi-client."
                        },
                        "secondary": {
                          "type": "string",
                          "description": "Secondary backend storage used by multi-client."
                        },
                        "mirror_enabled": {
                          "type": "boolean",
                          "description": "Mirror writes to secondary store."
                        },
                        "mirror_timeout": {
                          "type": "string",
                          "description": "Timeout for storing value to secondary store."
                        }
                      }
                    }
                  }
                },
                "heartbeat_timeout": {
                  "type": "string",
                  "description": "The heartbeat timeout after which ingesters are skipped for reads/writes. 0 = never (timeout disabled)."
                },
                "replication_factor": {
                  "type": "integer",
                  "description": "The number of ingesters to write to and read from. Default: 3."
                },
                "zone_awareness_enabled": {
                  "type": "boolean",
                  "description": "True to enable the zone-awareness and replicate ingested samples across different availability zones."
                },
                "excluded_zones": {
                  "type": "string",
                  "description": "Comma-separated list of zones to exclude from the ring. Instances in excluded zones will be filtered out from the ring."
                }
              }
            },
            "num_tokens": {
              "type": "integer",
              "description": "Number of tokens for each ingester. Default: 128."
            },
            "heartbeat_period": {
              "type": "string",
              "description": "Period at which to heartbeat to consul. 0 = disabled."
            },
            "heartbeat_timeout": {
              "type": "string",
              "description": "Heartbeat timeout after which instance is assumed to be unhealthy. 0 = disabled."
            },
            "observe_period": {
              "type": "string",
              "description": "Observe tokens after generating to resolve collisions. Useful when using gossiping ring."
            },
            "join_after": {
              "type": "string",
              "description": "Period to wait for a claim from another member; will join automatically after this."
            },
            "min_ready_duration": {
              "type": "string",
              "description": "Minimum duration to wait after the internal readiness checks have passed but before succeeding the readiness endpoint. This is used to slowdown deployment controllers (eg. Kubernetes) after an instance is ready and before they proceed with a rolling update, to give the rest of the cluster instances enough time to receive ring updates."
            },
            "interface_names": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "Name of network interface to read address from."
            },
            "enable_inet6": {
              "type": "boolean",
              "description": "Enable IPv6 support. Required to make use of IP addresses from IPv6 interfaces."
            },
            "final_sleep": {
              "type": "string",
              "description": "Duration to sleep for before exiting, to ensure metrics are scraped."
            },
            "tokens_file_path": {
              "type": "string",
              "description": "File path where tokens are stored. If empty, tokens are not stored at shutdown and restored at startup."
            },
            "availability_zone": {
              "type": "string",
              "description": "The availability zone where this instance is running."
            },
            "unregister_on_shutdown": {
              "type": "boolean",
              "description": "Unregister from the ring upon clean shutdown. It can be useful to disable for rolling restarts with consistent naming in conjunction with -distributor.extend-writes=false."
            },
            "readiness_check_ring_health": {
              "type": "boolean",
              "description": "When enabled the readiness probe succeeds only after all instances are ACTIVE and healthy in the ring, otherwise only the instance itself is checked. This option should be disabled if in your cluster multiple instances can be rolled out simultaneously, otherwise rolling updates may be slowed down."
            },
            "address": {
              "type": "string",
              "description": "IP address to advertise in the ring."
            },
            "port": {
              "type": "integer",
              "description": "port to advertise in consul (defaults to server.grpc-listen-port). Default: 0."
            },
            "id": {
              "type": "string",
              "description": "ID to register in the ring."
            }
          }
        },
        "concurrent_flushes": {
          "type": "integer",
          "description": "How many flushes can happen concurrently from each stream. Default: 32."
        },
        "flush_check_period": {
          "type": "string",
          "description": "How often should the ingester see if there are any blocks to flush. The first flush check is delayed by a random time up to 0.8x the flush check period. Additionally, there is +/- 1% jitter added to the interval."
        },
        "flush_op_timeout": {
          "type": "string",
          "description": "The timeout before a flush is cancelled."
        },
        "chunk_retain_period": {
          "type": "string",
          "description": "How long chunks should be retained in-memory after they've been flushed."
        },
        "chunk_idle_period": {
          "type": "string",
          "description": "How long chunks should sit in-memory with no updates before being flushed if they don't hit the max block size. This means that half-empty chunks will still be flushed after a certain period as long as they receive no further activity."
        },
        "chunk_block_size": {
          "type": "integer",
          "description": "The targeted _uncompressed_ size in bytes of a chunk block When this threshold is exceeded the head block will be cut and compressed inside the chunk. Default: 262144."
        },
        "chunk_target_size": {
          "type": "integer",
          "description": "A target _compressed_ size in bytes for chunks. This is a desired size not an exact size, chunks may be slightly bigger or significantly smaller if they get flushed for other reasons (e.g. chunk_idle_period). A value of 0 creates chunks with a fixed 10 blocks, a non zero value will create chunks with a variable number of blocks to meet the target size. Default: 1572864."
        },
        "chunk_encoding": {
          "type": "string",
          "description": "The algorithm to use for compressing chunk. (none, gzip, lz4-64k, snappy, lz4-256k, lz4-1M, lz4, flate, zstd)"
        },
        "max_chunk_age": {
          "type": "string",
          "description": "The maximum duration of a timeseries chunk in memory. If a timeseries runs for longer than this, the current chunk will be flushed to the store and a new chunk created."
        },
        "autoforget_unhealthy": {
          "type": "boolean",
          "description": "Forget about ingesters having heartbeat timestamps older than `ring.kvstore.heartbeat_timeout`. This is equivalent to clicking on the `/ring` `forget` button in the UI: the ingester is removed from the ring. This is a useful setting when you are sure that an unhealthy node won't return. An example is when not using stateful sets or the equivalent. Use `memberlist.rejoin_interval` > 0 to handle network partition cases when using a memberlist."
        },
        "sync_period": {
          "type": "string",
          "description": "Parameters used to synchronize ingesters to cut chunks at the same moment. Sync period is used to roll over incoming entry to a new chunk. If chunk's utilization isn't high enough (eg. less than 50% when sync_min_utilization is set to 0.5), then this chunk rollover doesn't happen."
        },
        "sync_min_utilization": {
          "type": "number",
          "description": "Minimum utilization of chunk when doing synchronization. Default: 0.1."
        },
        "max_returned_stream_errors": {
          "type": "integer",
          "description": "The maximum number of errors a stream will report to the user when a push fails. 0 to make unlimited. Default: 10."
        },
        "query_store_max_look_back_period": {
          "type": "string",
          "description": "How far back should an ingester be allowed to query the store for data, for use only with boltdb-shipper/tsdb index and filesystem object store. -1 for infinite."
        },
        "wal": {
          "description": "The ingester WAL (Write Ahead Log) records incoming logs and stores them on the local file systems in order to guarantee persistence of acknowledged data in the event of a process crash.",
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Enable writing of ingested data into WAL."
            },
            "dir": {
              "type": "string",
              "description": "Directory where the WAL data is stored and/or recovered from."
            },
            "checkpoint_duration": {
              "type": "string",
              "description": "Interval at which checkpoints should be created."
            },
            "flush_on_shutdown": {
              "type": "boolean",
              "description": "When WAL is enabled, should chunks be flushed to long-term storage on shutdown."
            },
            "replay_memory_ceiling": {
              "type": "string",
              "description": "Maximum memory size the WAL may use during replay. After hitting this, it will flush data to storage before continuing. A unit suffix (KB, MB, GB) may be applied. Default: 4GB."
            }
          }
        },
        "index_shards": {
          "type": "integer",
          "description": "Shard factor used in the ingesters for the in process reverse index. This MUST be evenly divisible by ALL schema shard factors or Loki will not start. Default: 32."
        },
        "max_dropped_streams": {
          "type": "integer",
          "description": "Maximum number of dropped streams to keep in memory during tailing. Default: 10."
        },
        "shutdown_marker_path": {
          "type": "string",
          "description": "Path where the shutdown marker file is stored. If not set and common.path_prefix is set then common.path_prefix will be used."
        }
      }
    },
    "ingester_client": {
      "type": "object",
      "properties": {
        "pool_config": {
          "description": "Configures how connections are pooled.",
          "type": "object",
          "properties": {
            "client_cleanup_period": {
              "type": "string",
              "description": "How frequently to clean up clients for ingesters that have gone away."
            },
            "health_check_ingesters": {
              "type": "boolean",
              "description": "Run a health check on each ingester client during periodic cleanup."
            },
            "remote_timeout": {
              "type": "string",
              "description": "How quickly a dead client will be removed after it has been detected to disappear. Set this to a value to allow time for a secondary health check to recover the missing client."
            }
          }
        },
        "remote_timeout": {
          "type": "string",
          "description": "The remote request timeout on the client side."
        },
        "grpc_client_config": {
          "$ref": "#/definitions/grpc_client",
          "description": "Configures how the gRPC connection to ingesters work as a client."
        }
      }
    },
    "limits_config": {
      "type": "object",
      "properties": {
        "ingestion_rate_strategy": {
          "type": "string",
          "description": "Whether the ingestion rate limit should be applied individually to each distributor instance (local), or evenly shared across the cluster (global). The ingestion rate strategy cannot be overridden on a per-tenant basis.\n- local: enforces the limit on a per distributor basis. The actual effective rate limit will be N times higher, where N is the number of distributor replicas.\n- global: enforces the limit globally, configuring a per-distributor local rate limiter as 'ingestion_rate / N', where N is the number of distributor replicas (it's automatically adjusted if the number of replicas change). The global strategy requires the distributors to form their own ring, which is used to keep track of the current number of healthy distributor replicas."
        },
        "ingestion_rate_mb": {
          "type": "number",
          "description": "Per-user ingestion rate limit in sample size per second. Units in MB. Default: 4."
        },
        "ingestion_burst_size_mb": {
          "type": "number",
          "description": "Per-user allowed ingestion burst size (in sample size). Units in MB. The burst size refers to the per-distributor local rate limiter even in the case of the 'global' strategy, and should be set at least to the maximum logs size expected in a single push request. Default: 6."
        },
        "max_label_name_length": {
          "type": "integer",
          "description": "Maximum length accepted for label names. Default: 1024."
        },
        "max_label_value_length": {
          "type": "integer",
          "description": "Maximum length accepted for label value. This setting also applies to the metric name. Default: 2048."
        },
        "max_label_names_per_series": {
          "type": "integer",
          "description": "Maximum number of label names per series. Default: 15."
        },
        "reject_old_samples": {
          "type": "boolean",
          "description": "Whether or not old samples will be rejected."
        },
        "reject_old_samples_max_age": {
          "type": "string",
          "description": "Maximum accepted sample age before rejecting."
        },
        "creation_grace_period": {
          "type": "string",
          "description": "Duration which table will be created/deleted before/after it's needed; we won't accept sample from before this time."
        },
        "max_line_size": {
          "type": "string",
          "description": "Maximum line size on ingestion path. Example: 256kb. Any log line exceeding this limit will be discarded unless `distributor.max-line-size-truncate` is set which in case it is truncated instead of discarding it completely. There is no limit when unset or set to 0. Default: 256KB."
        },
        "max_line_size_truncate": {
          "type": "boolean",
          "description": "Whether to truncate lines that exceed max_line_size."
        },
        "increment_duplicate_timestamp": {
          "type": "boolean",
          "description": "Alter the log line timestamp during ingestion when the timestamp is the same as the previous entry for the same stream. When enabled, if a log line in a push request has the same timestamp as the previous line for the same stream, one nanosecond is added to the log line. This will preserve the received order of log lines with the exact same timestamp when they are queried, by slightly altering their stored timestamp. NOTE: This is imperfect, because Loki accepts out of order writes, and another push request for the same stream could contain duplicate timestamps to existing entries and they will not be incremented."
        },
        "discover_service_name": {
          "type": ["array", "null"],
          "items": {
            "type": "string"
          },
          "description": "If no service_name label exists, Loki maps a single label from the configured list to service_name. If none of the configured labels exist in the stream, label is set to unknown_service. Empty list disables setting the label."
        },
        "discover_log_levels": {
          "type": "boolean",
          "description": "Discover and add log levels during ingestion, if not present already. Levels would be added to Structured Metadata with name 'level' and one of the values from 'debug', 'info', 'warn', 'error', 'critical', 'fatal'."
        },
        "max_streams_per_user": {
          "type": "integer",
          "description": "Maximum number of active streams per user, per ingester. 0 to disable. Default: 0."
        },
        "max_global_streams_per_user": {
          "type": "integer",
          "description": "Maximum number of active streams per user, across the cluster. 0 to disable. When the global limit is enabled, each ingester is configured with a dynamic local limit based on the replication factor and the current number of healthy ingesters, and is kept updated whenever the number of ingesters change. Default: 5000."
        },
        "unordered_writes": {
          "type": "boolean",
          "description": "Deprecated. When true, out-of-order writes are accepted."
        },
        "per_stream_rate_limit": {
          "type": "string",
          "description": "Maximum byte rate per second per stream, also expressible in human readable forms (1MB, 256KB, etc). Default: 3MB."
        },
        "per_stream_rate_limit_burst": {
          "type": "string",
          "description": "Maximum burst bytes per stream, also expressible in human readable forms (1MB, 256KB, etc). This is how far above the rate limit a stream can 'burst' before the stream is limited. Default: 15MB."
        },
        "max_chunks_per_query": {
          "type": "integer",
          "description": "Maximum number of chunks that can be fetched in a single query. Default: 2000000."
        },
        "max_query_series": {
          "type": "integer",
          "description": "Limit the maximum of unique series that is returned by a metric query. When the limit is reached an error is returned. Default: 500."
        },
        "max_query_lookback": {
          "type": "string",
          "description": "Limit how far back in time series data and metadata can be queried, up until lookback duration ago. This limit is enforced in the query frontend, the querier and the ruler. If the requested time range is outside the allowed range, the request will not fail, but will be modified to only query data within the allowed time range. The default value of 0 does not set a limit."
        },
        "max_query_length": {
          "type": "string",
          "description": "The limit to length of chunk store queries. 0 to disable."
        },
        "max_query_range": {
          "type": "string",
          "description": "Limit the length of the [range] inside a range query. Default is 0 or unlimited"
        },
        "max_query_parallelism": {
          "type": "integer",
          "description": "Maximum number of queries that will be scheduled in parallel by the frontend. Default: 32."
        },
        "tsdb_max_query_parallelism": {
          "type": "integer",
          "description": "Maximum number of queries will be scheduled in parallel by the frontend for TSDB schemas. Default: 128."
        },
        "tsdb_max_bytes_per_shard": {
          "type": "string",
          "description": "Target maximum number of bytes assigned to a single sharded query. Also expressible in human readable forms (1GB, etc). Note: This is a _target_ and not an absolute limit. The actual limit can be higher, but the query planner will try to build shards up to this limit. Default: 600MB."
        },
        "tsdb_sharding_strategy": {
          "type": "string",
          "description": "sharding strategy to use in query planning. Suggested to use bounded once all nodes can recognize it."
        },
        "cardinality_limit": {
          "type": "integer",
          "description": "Cardinality limit for index queries. Default: 100000."
        },
        "max_streams_matchers_per_query": {
          "type": "integer",
          "description": "Maximum number of stream matchers per query. Default: 1000."
        },
        "max_concurrent_tail_requests": {
          "type": "integer",
          "description": "Maximum number of concurrent tail requests. Default: 10."
        },
        "max_entries_limit_per_query": {
          "type": "integer",
          "description": "Maximum number of log entries that will be returned for a query. Default: 5000."
        },
        "max_cache_freshness_per_query": {
          "type": "string",
          "description": "Most recent allowed cacheable result per-tenant, to prevent caching very recent results that might still be in flux."
        },
        "max_metadata_cache_freshness": {
          "type": "string",
          "description": "Do not cache metadata request if the end time is within the frontend.max-metadata-cache-freshness window. Set this to 0 to apply no such limits. Defaults to 24h."
        },
        "max_stats_cache_freshness": {
          "type": "string",
          "description": "Do not cache requests with an end time that falls within Now minus this duration. 0 disables this feature (default)."
        },
        "max_queriers_per_tenant": {
          "type": "integer",
          "description": "Maximum number of queriers that can handle requests for a single tenant. If set to 0 or value higher than number of available queriers, *all* queriers will handle requests for the tenant. Each frontend (or query-scheduler, if used) will select the same set of queriers for the same tenant (given that all queriers are connected to all frontends / query-schedulers). This option only works with queriers connecting to the query-frontend / query-scheduler, not when using downstream URL. Default: 0."
        },
        "max_query_capacity": {
          "type": "number",
          "description": "How much of the available query capacity (\"querier\" components in distributed mode, \"read\" components in SSD mode) can be used by a single tenant. Allowed values are 0.0 to 1.0. For example, setting this to 0.5 would allow a tenant to use half of the available queriers for processing the query workload. If set to 0, query capacity is determined by frontend.max-queriers-per-tenant. When both frontend.max-queriers-per-tenant and frontend.max-query-capacity are configured, smaller value of the resulting querier replica count is considered: min(frontend.max-queriers-per-tenant, ceil(querier_replicas * frontend.max-query-capacity)). *All* queriers will handle requests for the tenant if neither limits are applied. This option only works with queriers connecting to the query-frontend / query-scheduler, not when using downstream URL. Use this feature in a multi-tenant setup where you need to limit query capacity for certain tenants. Default: 0."
        },
        "query_ready_index_num_days": {
          "type": "integer",
          "description": "Number of days of index to be kept always downloaded for queries. Applies only to per user index in boltdb-shipper index store. 0 to disable. Default: 0."
        },
        "query_timeout": {
          "type": "string",
          "description": "Timeout when querying backends (ingesters or storage) during the execution of a query request. When a specific per-tenant timeout is used, the global timeout is ignored."
        },
        "split_queries_by_interval": {
          "type": "string",
          "description": "Split queries by a time interval and execute in parallel. The value 0 disables splitting by time. This also determines how cache keys are chosen when result caching is enabled."
        },
        "split_metadata_queries_by_interval": {
          "type": "string",
          "description": "Split metadata queries by a time interval and execute in parallel. The value 0 disables splitting metadata queries by time. This also determines how cache keys are chosen when label/series result caching is enabled."
        },
        "split_recent_metadata_queries_by_interval": {
          "type": "string",
          "description": "Experimental. Split interval to use for the portion of metadata request that falls within `recent_metadata_query_window`. Rest of the request which is outside the window still uses `split_metadata_queries_by_interval`. If set to 0, the entire request defaults to using a split interval of `split_metadata_queries_by_interval.`."
        },
        "recent_metadata_query_window": {
          "type": "string",
          "description": "Experimental. Metadata query window inside which `split_recent_metadata_queries_by_interval` gets applied, portion of the metadata request that falls in this window is split using `split_recent_metadata_queries_by_interval`. The value 0 disables using a different split interval for recent metadata queries.\n\nThis is added to improve cacheability of recent metadata queries. Query split interval also determines the interval used in cache key. The default split interval of 24h is useful for caching long queries, each cache key holding 1 day's results. But metadata queries are often shorter than 24h, to cache them effectively we need a smaller split interval. `recent_metadata_query_window` along with `split_recent_metadata_queries_by_interval` help configure a shorter split interval for recent metadata queries."
        },
        "split_instant_metric_queries_by_interval": {
          "type": "string",
          "description": "Split instant metric queries by a time interval and execute in parallel. The value 0 disables splitting instant metric queries by time. This also determines how cache keys are chosen when instant metric query result caching is enabled."
        },
        "split_ingester_queries_by_interval": {
          "type": "string",
          "description": "Interval to use for time-based splitting when a request is within the `query_ingesters_within` window; defaults to `split-queries-by-interval` by setting to 0."
        },
        "min_sharding_lookback": {
          "type": "string",
          "description": "Limit queries that can be sharded. Queries within the time range of now and now minus this sharding lookback are not sharded. The default value of 0s disables the lookback, causing sharding of all queries at all times."
        },
        "max_query_bytes_read": {
          "type": "string",
          "description": "Max number of bytes a query can fetch. Enforced in log and metric queries only when TSDB is used. The default value of 0 disables this limit. Default: 0B."
        },
        "max_querier_bytes_read": {
          "type": "string",
          "description": "Max number of bytes a query can fetch after splitting and sharding. Enforced in log and metric queries only when TSDB is used. The default value of 0 disables this limit. Default: 150GB."
        },
        "volume_enabled": {
          "type": "boolean",
          "description": "Enable log-volume endpoints."
        },
        "volume_max_series": {
          "type": "integer",
          "description": "The maximum number of aggregated series in a log-volume response. Default: 1000."
        },
        "ruler_max_rules_per_rule_group": {
          "type": "integer",
          "description": "Maximum number of rules per rule group per-tenant. 0 to disable. Default: 0."
        },
        "ruler_max_rule_groups_per_tenant": {
          "type": "integer",
          "description": "Maximum number of rule groups per-tenant. 0 to disable. Default: 0."
        },
        "ruler_tenant_shard_size": {
          "type": "integer",
          "description": "The default tenant's shard size when shuffle-sharding is enabled in the ruler. When this setting is specified in the per-tenant overrides, a value of 0 disables shuffle sharding for the tenant. Default: 0."
        },
        "ruler_remote_write_disabled": {
          "type": "boolean",
          "description": "Disable recording rules remote-write."
        },
        "ruler_remote_write_url": {
          "type": "string",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. The URL of the endpoint to send samples to."
        },
        "ruler_remote_write_timeout": {
          "type": "string",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Timeout for requests to the remote write endpoint."
        },
        "ruler_remote_write_headers": {
          "type": "object",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Custom HTTP headers to be sent along with each remote write request. Be aware that headers that are set by Loki itself can't be overwritten."
        },
        "ruler_remote_write_relabel_configs": {
          "type": ["array", "null"],
          "items": {
            "type": "object"
          },
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. List of remote write relabel configurations."
        },
        "ruler_remote_write_queue_capacity": {
          "type": "integer",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Number of samples to buffer per shard before we block reading of more samples from the WAL. It is recommended to have enough capacity in each shard to buffer several requests to keep throughput up while processing occasional slow remote requests."
        },
        "ruler_remote_write_queue_min_shards": {
          "type": "integer",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Minimum number of shards, i.e. amount of concurrency."
        },
        "ruler_remote_write_queue_max_shards": {
          "type": "integer",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Maximum number of shards, i.e. amount of concurrency."
        },
        "ruler_remote_write_queue_max_samples_per_send": {
          "type": "integer",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Maximum number of samples per send."
        },
        "ruler_remote_write_queue_batch_send_deadline": {
          "type": "string",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Maximum time a sample will wait in buffer."
        },
        "ruler_remote_write_queue_min_backoff": {
          "type": "string",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Initial retry delay. Gets doubled for every retry."
        },
        "ruler_remote_write_queue_max_backoff": {
          "type": "string",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Maximum retry delay."
        },
        "ruler_remote_write_queue_retry_on_ratelimit": {
          "type": "boolean",
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Retry upon receiving a 429 status code from the remote-write storage. This is experimental and might change in the future."
        },
        "ruler_remote_write_sigv4_config": {
          "description": "Deprecated: Use 'ruler_remote_write_config' instead. Configures AWS's Signature Verification 4 signing process to sign every remote write request.",
          "type": "object",
          "properties": {
            "region": {
              "type": "string"
            },
            "access_key": {
              "type": "string"
            },
            "secret_key": {
              "type": "string"
            },
            "profile": {
              "type": "string"
            },
            "role_arn": {
              "type": "string"
            }
          }
        },
        "ruler_remote_write_config": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ruler/properties/remote_write"
          },
          "description": "Configures global and per-tenant limits for remote write clients. A map with remote client id as key."
        },
        "ruler_remote_evaluation_timeout": {
          "type": "string",
          "description": "Timeout for a remote rule evaluation. Defaults to the value of 'querier.query-timeout'."
        },
        "ruler_remote_evaluation_max_response_size": {
          "type": "integer",
          "description": "Maximum size (in bytes) of the allowable response size from a remote rule evaluation. Set to 0 to allow any response size (default)."
        },
        "deletion_mode": {
          "type": "string",
          "description": "Deletion mode. Can be one of 'disabled', 'filter-only', or 'filter-and-delete'. When set to 'filter-only' or 'filter-and-delete', and if retention_enabled is true, then the log entry deletion API endpoints are available."
        },
        "retention_period": {
          "type": "string",
          "description": "Retention period to apply to stored data, only applies if retention_enabled is true in the compactor config. As of version 2.8.0, a zero value of 0 or 0s disables retention. In previous releases, Loki did not properly honor a zero value to disable retention and a really large value should be used instead."
        },
        "retention_stream": {
          "type": ["array", "null"],
          "items": {
            "type": "object"
          },
          "description": "Per-stream retention to apply, if the retention is enable on the compactor side.\nExample:\n retention_stream:\n - selector: '{namespace=\"dev\"}'\n priority: 1\n period: 24h\n- selector: '{container=\"nginx\"}'\n priority: 1\n period: 744h\nSelector is a Prometheus labels matchers that will apply the 'period' retention only if the stream is matching. In case multiple stream are matching, the highest priority will be picked. If no rule is matched the 'retention_period' is used."
        },
        "per_tenant_override_config": {
          "type": "string",
          "description": "Feature renamed to 'runtime configuration', flag deprecated in favor of -runtime-config.file (runtime_config.file in YAML)."
        },
        "per_tenant_override_period": {
          "type": "string",
          "description": "Feature renamed to 'runtime configuration'; flag deprecated in favor of -runtime-config.reload-period (runtime_config.period in YAML)."
        },
        "allow_deletes": {
          "type": "boolean",
          "description": "Deprecated: Use deletion_mode per tenant configuration instead."
        },
        "shard_streams": {
          "description": "",
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean"
            },
            "logging_enabled": {
              "type": "boolean"
            },
            "desired_rate": {
              "type": "integer"
            }
          }
        },
        "blocked_queries": {
          "type": ["array", "null"],
          "items": {
            "type": "object"
          }
        },
        "required_labels": {
          "type": ["array", "null"],
          "items": {
            "type": "string"
          },
          "description": "Define a list of required selector labels."
        },
        "minimum_labels_number": {
          "type": "integer",
          "description": "Minimum number of label matchers a query should contain."
        },
        "index_gateway_shard_size": {
          "type": "integer",
          "description": "The shard size defines how many index gateways should be used by a tenant for querying. If the global shard factor is 0, the global shard factor is set to the deprecated -replication-factor for backwards compatibility reasons. Default: 0."
        },
        "bloom_gateway_shard_size": {
          "type": "integer",
          "description": "Experimental. The shard size defines how many bloom gateways should be used by a tenant for querying. Default: 0."
        },
        "bloom_gateway_enable_filtering": {
          "type": "boolean",
          "description": "Experimental. Whether to use the bloom gateway component in the read path to filter chunks."
        },
        "bloom_gateway_cache_key_interval": {
          "type": "string",
          "description": "Experimental. Interval for computing the cache key in the Bloom Gateway."
        },
        "bloom_compactor_shard_size": {
          "type": "integer",
          "description": "Experimental. The shard size defines how many bloom compactors should be used by a tenant when computing blooms. If it's set to 0, shuffle sharding is disabled. Default: 0."
        },
        "bloom_compactor_enable_compaction": {
          "type": "boolean",
          "description": "Experimental. Whether to compact chunks into bloom filters."
        },
        "bloom_compactor_max_block_size": {
          "type": "string",
          "description": "Experimental. The maximum bloom block size. A value of 0 sets an unlimited size. Default is 200MB. The actual block size might exceed this limit since blooms will be added to blocks until the block exceeds the maximum block size. Default: 200MB."
        },
        "bloom_compactor_max_bloom_size": {
          "type": "string",
          "description": "Experimental. The maximum bloom size per log stream. A log stream whose generated bloom filter exceeds this size will be discarded. A value of 0 sets an unlimited size. Default is 128MB. Default: 128MB."
        },
        "bloom_ngram_length": {
          "type": "integer",
          "description": "Experimental. Length of the n-grams created when computing blooms from log lines. Default: 4."
        },
        "bloom_ngram_skip": {
          "type": "integer",
          "description": "Experimental. Skip factor for the n-grams created when computing blooms from log lines. Default: 1."
        },
        "bloom_false_positive_rate": {
          "type": "number",
          "description": "Experimental. Scalable Bloom Filter desired false-positive rate. Default: 0.01."
        },
        "bloom_block_encoding": {
          "type": "string",
          "description": "Experimental. Compression algorithm for bloom block pages."
        },
        "allow_structured_metadata": {
          "type": "boolean",
          "description": "Allow user to send structured metadata in push payload."
        },
        "max_structured_metadata_size": {
          "type": "string",
          "description": "Maximum size accepted for structured metadata per log line. Default: 64KB."
        },
        "max_structured_metadata_entries_count": {
          "type": "integer",
          "description": "Maximum number of structured metadata entries per log line. Default: 128."
        },
        "otlp_config": {
          "description": "OTLP log ingestion configurations",
          "type": "object",
          "properties": {
            "resource_attributes": {
              "description": "Configuration for resource attributes to store them as index labels or Structured Metadata or drop them altogether",
              "type": "object",
              "properties": {
                "ignore_defaults": {
                  "type": "boolean",
                  "description": "Configure whether to ignore the default list of resource attributes set in 'distributor.otlp.default_resource_attributes_as_index_labels' to be stored as index labels and only use the given resource attributes config"
                },
                "attributes_config": {
                  "type": ["array", "null"],
                  "items": {
                    "$ref": "#/definitions/attributes_config"
                  }
                }
              }
            },
            "scope_attributes": {
              "type": ["array", "null"],
              "items": {
                "$ref": "#/definitions/attributes_config"
              },
              "description": "Configuration for scope attributes to store them as Structured Metadata or drop them altogether"
            },
            "log_attributes": {
              "type": ["array", "null"],
              "items": {
                "$ref": "#/definitions/attributes_config"
              },
              "description": "Configuration for log attributes to store them as Structured Metadata or drop them altogether"
            }
          }
        }
      }
    },
    "local_storage_config": {
      "type": "object",
      "properties": {
        "directory": {
          "type": "string",
          "description": "Directory to store chunks in."
        }
      }
    },
    "memberlist": {
      "type": "object",
      "properties": {
        "node_name": {
          "type": "string",
          "description": "Name of the node in memberlist cluster. Defaults to hostname."
        },
        "randomize_node_name": {
          "type": "boolean",
          "description": "Add random suffix to the node name."
        },
        "stream_timeout": {
          "type": "string",
          "description": "The timeout for establishing a connection with a remote node, and for read/write operations."
        },
        "retransmit_factor": {
          "type": "integer",
          "description": "Multiplication factor used when sending out messages (factor * log(N+1)). Default: 4."
        },
        "pull_push_interval": {
          "type": "string",
          "description": "How often to use pull/push sync."
        },
        "gossip_interval": {
          "type": "string",
          "description": "How often to gossip."
        },
        "gossip_nodes": {
          "type": "integer",
          "description": "How many nodes to gossip to. Default: 3."
        },
        "gossip_to_dead_nodes_time": {
          "type": "string",
          "description": "How long to keep gossiping to dead nodes, to give them chance to refute their death."
        },
        "dead_node_reclaim_time": {
          "type": "string",
          "description": "How soon can dead node's name be reclaimed with new address. 0 to disable."
        },
        "compression_enabled": {
          "type": "boolean",
          "description": "Enable message compression. This can be used to reduce bandwidth usage at the cost of slightly more CPU utilization."
        },
        "advertise_addr": {
          "type": "string",
          "description": "Gossip address to advertise to other members in the cluster. Used for NAT traversal."
        },
        "advertise_port": {
          "type": "integer",
          "description": "Gossip port to advertise to other members in the cluster. Used for NAT traversal. Default: 7946."
        },
        "cluster_label": {
          "type": "string",
          "description": "The cluster label is an optional string to include in outbound packets and gossip streams. Other members in the memberlist cluster will discard any message whose label doesn't match the configured one, unless the 'cluster-label-verification-disabled' configuration option is set to true."
        },
        "cluster_label_verification_disabled": {
          "type": "boolean",
          "description": "When true, memberlist doesn't verify that inbound packets and gossip streams have the cluster label matching the configured one. This verification should be disabled while rolling out the change to the configured cluster label in a live memberlist cluster."
        },
        "join_members": {
          "type": ["array", "null"],
          "items": {
            "type": "string"
          },
          "description": "Other cluster members to join. Can be specified multiple times. It can be an IP, hostname or an entry specified in the DNS Service Discovery format."
        },
        "min_join_backoff": {
          "type": "string",
          "description": "Min backoff duration to join other cluster members."
        },
        "max_join_backoff": {
          "type": "string",
          "description": "Max backoff duration to join other cluster members."
        },
        "max_join_retries": {
          "type": "integer",
          "description": "Max number of retries to join other cluster members. Default: 10."
        },
        "abort_if_cluster_join_fails": {
          "type": "boolean",
          "description": "If this node fails to join memberlist cluster, abort."
        },
        "rejoin_interval": {
          "type": "string",
          "description": "If not 0, how often to rejoin the cluster. Occasional rejoin can help to fix the cluster split issue, and is harmless otherwise. For example when using only few components as a seed nodes (via -memberlist.join), then it's recommended to use rejoin. If -memberlist.join points to dynamic service that resolves to all gossiping nodes (eg. Kubernetes headless service), then rejoin is not needed."
        },
        "left_ingesters_timeout": {
          "type": "string",
          "description": "How long to keep LEFT ingesters in the ring."
        },
        "leave_timeout": {
          "type": "string",
          "description": "Timeout for leaving memberlist cluster."
        },
        "message_history_buffer_bytes": {
          "type": "integer",
          "description": "How much space to use for keeping received and sent messages in memory for troubleshooting (two buffers). 0 to disable. Default: 0."
        },
        "bind_addr": {
          "type": ["array", "null"],
          "items": {
            "type": "string"
          },
          "description": "IP address to listen on for gossip messages. Multiple addresses may be specified. Defaults to 0.0.0.0"
        },
        "bind_port": {
          "type": "integer",
          "description": "Port to listen on for gossip messages. Default: 7946."
        },
        "packet_dial_timeout": {
          "type": "string",
          "description": "Timeout used when connecting to other nodes to send packet."
        },
        "packet_write_timeout": {
          "type": "string",
          "description": "Timeout for writing 'packet' data."
        },
        "tls_enabled": {
          "type": "boolean",
          "description": "Enable TLS on the memberlist transport layer."
        },
        "tls_cert_path": {
          "type": "string",
          "description": "Path to the client certificate, which will be used for authenticating with the server. Also requires the key path to be configured."
        },
        "tls_key_path": {
          "type": "string",
          "description": "Path to the key for the client certificate. Also requires the client certificate to be configured."
        },
        "tls_ca_path": {
          "type": "string",
          "description": "Path to the CA certificates to validate server certificate against. If not set, the host's root CA certificates are used."
        },
        "tls_server_name": {
          "type": "string",
          "description": "Override the expected name on the server certificate."
        },
        "tls_insecure_skip_verify": {
          "type": "boolean",
          "description": "Skip validating server certificate."
        },
        "tls_cipher_suites": {
          "type": "string",
          "description": "Override the default cipher suite list (separated by commas). Allowed values:\n\nSecure Ciphers:\n- TLS_AES_128_GCM_SHA256\n- TLS_AES_256_GCM_SHA384\n- TLS_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n\nInsecure Ciphers:\n- TLS_RSA_WITH_RC4_128_SHA\n- TLS_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA\n- TLS_RSA_WITH_AES_256_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA256\n- TLS_RSA_WITH_AES_128_GCM_SHA256\n- TLS_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n"
        },
        "tls_min_version": {
          "type": "string",
          "description": "Override the default minimum TLS version. Allowed values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13"
        }
      }
    },
    "named_stores_config": {
      "type": "object",
      "properties": {
        "aws": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/aws_storage_config"
          }
        },
        "azure": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/azure_storage_config"
          }
        },
        "bos": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/bos_storage_config"
          }
        },
        "filesystem": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/local_storage_config"
          }
        },
        "gcs": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/gcs_storage_config"
          }
        },
        "alibabacloud": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/alibabacloud_storage_config"
          }
        },
        "swift": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/swift_storage_config"
          }
        },
        "cos": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/cos_storage_config"
          }
        }
      }
    },
    "operational_config": {
      "type": "object",
      "properties": {
        "log_stream_creation": {
          "type": "boolean",
          "description": "Log every new stream created by a push request (very verbose, recommend to enable via runtime config only)."
        },
        "log_push_request": {
          "type": "boolean",
          "description": "Log every push request (very verbose, recommend to enable via runtime config only)."
        },
        "log_push_request_streams": {
          "type": "boolean",
          "description": "Log every stream in a push request (very verbose, recommend to enable via runtime config only)."
        },
        "limited_log_push_errors": {
          "type": "boolean",
          "description": "Log push errors with a rate limited logger, will show client push errors without overly spamming logs."
        }
      }
    },
    "period_config": {
      "type": "object",
      "properties": {
        "from": {
          "type": "string",
          "description": "The date of the first day that index buckets should be created. Use a date in the past if this is your only period_config, otherwise use a date when you want the schema to switch over. In YYYY-MM-DD format, for example: 2018-04-15."
        },
        "store": {
          "type": "string",
          "description": "store and object_store below affect which <storage_config> key is used. Which index to use. Either tsdb or boltdb-shipper. Following stores are deprecated: aws, aws-dynamo, gcp, gcp-columnkey, bigtable, bigtable-hashed, cassandra, grpc."
        },
        "object_store": {
          "type": "string",
          "description": "Which store to use for the chunks. Either aws (alias s3), azure, gcs, alibabacloud, bos, cos, swift, filesystem, or a named_store (refer to named_stores_config). Following stores are deprecated: aws-dynamo, gcp, gcp-columnkey, bigtable, bigtable-hashed, cassandra, grpc."
        },
        "schema": {
          "type": "string",
          "description": "The schema version to use, current recommended schema is v13."
        },
        "index": {
          "description": "Configures how the index is updated and stored.",
          "type": "object",
          "properties": {
            "path_prefix": {
              "type": "string",
              "description": "Path prefix for index tables. Prefix always needs to end with a path delimiter '/', except when the prefix is empty."
            },
            "prefix": {
              "type": "string",
              "description": "Table prefix for all period tables."
            },
            "period": {
              "type": "string",
              "description": "Table period."
            },
            "tags": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "description": "A map to be added to all managed tables."
            }
          }
        },
        "chunks": {
          "description": "Configured how the chunks are updated and stored.",
          "type": "object",
          "properties": {
            "prefix": {
              "type": "string",
              "description": "Table prefix for all period tables."
            },
            "period": {
              "type": "string",
              "description": "Table period."
            },
            "tags": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "description": "A map to be added to all managed tables."
            }
          }
        },
        "row_shards": {
          "type": "integer",
          "description": "How many shards will be created. Only used if schema is v10 or greater. Default: 16."
        }
      }
    },
    "querier": {
      "type": "object",
      "properties": {
        "tail_max_duration": {
          "type": "string",
          "description": "Maximum duration for which the live tailing requests are served."
        },
        "extra_query_delay": {
          "type": "string",
          "description": "Time to wait before sending more than the minimum successful query requests."
        },
        "query_ingesters_within": {
          "type": "string",
          "description": "Maximum lookback beyond which queries are not sent to ingester. 0 means all queries are sent to ingester."
        },
        "engine": {
          "description": "",
          "type": "object",
          "properties": {
            "max_look_back_period": {
              "type": "string",
              "description": "The maximum amount of time to look back for log lines. Used only for instant log queries."
            }
          }
        },
        "max_concurrent": {
          "type": "integer",
          "description": "The maximum number of queries that can be simultaneously processed by the querier. Default: 4."
        },
        "query_store_only": {
          "type": "boolean",
          "description": "Only query the store, and not attempt any ingesters. This is useful for running a standalone querier pool operating only against stored data."
        },
        "query_ingester_only": {
          "type": "boolean",
          "description": "When true, queriers only query the ingesters, and not stored data. This is useful when the object store is unavailable."
        },
        "multi_tenant_queries_enabled": {
          "type": "boolean",
          "description": "When true, allow queries to span multiple tenants."
        },
        "per_request_limits_enabled": {
          "type": "boolean",
          "description": "When true, querier limits sent via a header are enforced."
        }
      }
    },
    "query_range": {
      "type": "object",
      "properties": {
        "align_queries_with_step": {
          "type": "boolean",
          "description": "Mutate incoming queries to align their start and end with their step."
        },
        "results_cache": {
          "description": "",
          "type": "object",
          "properties": {
            "cache": {
              "$ref": "#/definitions/cache_config",
              "description": "The cache_config block configures the cache backend for a specific Loki component."
            },
            "compression": {
              "type": "string",
              "description": "Use compression in cache. The default is an empty value '', which disables compression. Supported values are: 'snappy' and ''."
            }
          }
        },
        "cache_results": {
          "type": "boolean",
          "description": "Cache query results."
        },
        "max_retries": {
          "type": "integer",
          "description": "Maximum number of retries for a single request; beyond this, the downstream error is returned. Default: 5."
        },
        "parallelise_shardable_queries": {
          "type": "boolean",
          "description": "Perform query parallelisations based on storage sharding configuration and query ASTs. This feature is supported only by the chunks storage engine."
        },
        "shard_aggregations": {
          "type": "string",
          "description": "A comma-separated list of LogQL vector and range aggregations that should be sharded"
        },
        "cache_index_stats_results": {
          "type": "boolean",
          "description": "Cache index stats query results."
        },
        "index_stats_results_cache": {
          "description": "If a cache config is not specified and cache_index_stats_results is true, the config for the results cache is used.",
          "type": "object",
          "properties": {
            "cache": {
              "$ref": "#/definitions/cache_config",
              "description": "The cache_config block configures the cache backend for a specific Loki component."
            },
            "compression": {
              "type": "string",
              "description": "Use compression in cache. The default is an empty value '', which disables compression. Supported values are: 'snappy' and ''."
            }
          }
        },
        "cache_volume_results": {
          "type": "boolean",
          "description": "Cache volume query results."
        },
        "volume_results_cache": {
          "description": "If a cache config is not specified and cache_volume_results is true, the config for the results cache is used.",
          "type": "object",
          "properties": {
            "cache": {
              "$ref": "#/definitions/cache_config",
              "description": "The cache_config block configures the cache backend for a specific Loki component."
            },
            "compression": {
              "type": "string",
              "description": "Use compression in cache. The default is an empty value '', which disables compression. Supported values are: 'snappy' and ''."
            }
          }
        },
        "cache_instant_metric_results": {
          "type": "boolean",
          "description": "Cache instant metric query results."
        },
        "instant_metric_results_cache": {
          "description": "If a cache config is not specified and cache_instant_metric_results is true, the config for the results cache is used.",
          "type": "object",
          "properties": {
            "cache": {
              "$ref": "#/definitions/cache_config",
              "description": "The cache_config block configures the cache backend for a specific Loki component."
            },
            "compression": {
              "type": "string",
              "description": "Use compression in cache. The default is an empty value '', which disables compression. Supported values are: 'snappy' and ''."
            }
          }
        },
        "instant_metric_query_split_align": {
          "type": "boolean",
          "description": "Whether to align the splits of instant metric query with splitByInterval and query's exec time. Useful when instant_metric_cache is enabled"
        },
        "cache_series_results": {
          "type": "boolean",
          "description": "Cache series query results."
        },
        "series_results_cache": {
          "description": "If series_results_cache is not configured and cache_series_results is true, the config for the results cache is used.",
          "type": "object",
          "properties": {
            "cache": {
              "$ref": "#/definitions/cache_config",
              "description": "The cache_config block configures the cache backend for a specific Loki component."
            },
            "compression": {
              "type": "string",
              "description": "Use compression in cache. The default is an empty value '', which disables compression. Supported values are: 'snappy' and ''."
            }
          }
        },
        "cache_label_results": {
          "type": "boolean",
          "description": "Cache label query results."
        },
        "label_results_cache": {
          "description": "If label_results_cache is not configured and cache_label_results is true, the config for the results cache is used.",
          "type": "object",
          "properties": {
            "cache": {
              "$ref": "#/definitions/cache_config",
              "description": "The cache_config block configures the cache backend for a specific Loki component."
            },
            "compression": {
              "type": "string",
              "description": "Use compression in cache. The default is an empty value '', which disables compression. Supported values are: 'snappy' and ''."
            }
          }
        }
      }
    },
    "query_scheduler": {
      "type": "object",
      "properties": {
        "max_outstanding_requests_per_tenant": {
          "type": "integer",
          "description": "Maximum number of outstanding requests per tenant per query-scheduler. In-flight requests above this limit will fail with HTTP response status code 429. Default: 32000."
        },
        "max_queue_hierarchy_levels": {
          "type": "integer",
          "description": "Maximum number of levels of nesting of hierarchical queues. 0 means that hierarchical queues are disabled. Default: 3."
        },
        "querier_forget_delay": {
          "type": "string",
          "description": "If a querier disconnects without sending notification about graceful shutdown, the query-scheduler will keep the querier in the tenant's shard until the forget delay has passed. This feature is useful to reduce the blast radius when shuffle-sharding is enabled."
        },
        "grpc_client_config": {
          "$ref": "#/definitions/grpc_client",
          "description": "This configures the gRPC client used to report errors back to the query-frontend."
        },
        "use_scheduler_ring": {
          "type": "boolean",
          "description": "Set to true to have the query schedulers create and place themselves in a ring. If no frontend_address or scheduler_address are present anywhere else in the configuration, Loki will toggle this value to true."
        },
        "scheduler_ring": {
          "description": "The hash ring configuration. This option is required only if use_scheduler_ring is true.",
          "type": "object",
          "properties": {
            "kvstore": {
              "description": "",
              "type": "object",
              "properties": {
                "store": {
                  "type": "string",
                  "description": "Backend storage to use for the ring. Supported values are: consul, etcd, inmemory, memberlist, multi."
                },
                "prefix": {
                  "type": "string",
                  "description": "The prefix for the keys in the store. Should end with a /."
                },
                "consul": {
                  "$ref": "#/definitions/consul",
                  "description": "Configuration for a Consul client. Only applies if the selected kvstore is consul."
                },
                "etcd": {
                  "$ref": "#/definitions/etcd",
                  "description": "Configuration for an ETCD v3 client. Only applies if the selected kvstore is etcd."
                },
                "multi": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "primary": {
                      "type": "string",
                      "description": "Primary backend storage used by multi-client."
                    },
                    "secondary": {
                      "type": "string",
                      "description": "Secondary backend storage used by multi-client."
                    },
                    "mirror_enabled": {
                      "type": "boolean",
                      "description": "Mirror writes to secondary store."
                    },
                    "mirror_timeout": {
                      "type": "string",
                      "description": "Timeout for storing value to secondary store."
                    }
                  }
                }
              }
            },
            "heartbeat_period": {
              "type": "string",
              "description": "Period at which to heartbeat to the ring. 0 = disabled."
            },
            "heartbeat_timeout": {
              "type": "string",
              "description": "The heartbeat timeout after which compactors are considered unhealthy within the ring. 0 = never (timeout disabled)."
            },
            "tokens_file_path": {
              "type": "string",
              "description": "File path where tokens are stored. If empty, tokens are not stored at shutdown and restored at startup."
            },
            "zone_awareness_enabled": {
              "type": "boolean",
              "description": "True to enable zone-awareness and replicate blocks across different availability zones."
            },
            "num_tokens": {},
            "replication_factor": {},
            "instance_id": {
              "type": "string",
              "description": "Instance ID to register in the ring."
            },
            "instance_interface_names": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "Name of network interface to read address from."
            },
            "instance_port": {
              "type": "integer",
              "description": "Port to advertise in the ring (defaults to server.grpc-listen-port). Default: 0."
            },
            "instance_addr": {
              "type": "string",
              "description": "IP address to advertise in the ring."
            },
            "instance_availability_zone": {
              "type": "string",
              "description": "The availability zone where this instance is running. Required if zone-awareness is enabled."
            },
            "instance_enable_ipv6": {
              "type": "boolean",
              "description": "Enable using a IPv6 instance address."
            }
          }
        }
      }
    },
    "ruler": {
      "type": "object",
      "properties": {
        "external_url": {
          "type": "string",
          "description": "Base URL of the Grafana instance."
        },
        "datasource_uid": {
          "type": "string",
          "description": "Datasource UID for the dashboard."
        },
        "external_labels": {
          "type": ["array", "null"],
          "items": {
            "type": "string"
          },
          "description": "Labels to add to all alerts."
        },
        "ruler_client": {
          "$ref": "#/definitions/grpc_client",
          "description": "The grpc_client block configures the gRPC client used to communicate between a client and server component in Loki."
        },
        "evaluation_interval": {
          "type": "string",
          "description": "How frequently to evaluate rules."
        },
        "poll_interval": {
          "type": "string",
          "description": "How frequently to poll for rule changes."
        },
        "storage": {
          "description": "Deprecated: Use -ruler-storage. CLI flags and their respective YAML config options instead.",
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Method to use for backend rule storage (configdb, azure, gcs, s3, swift, local, bos, cos)"
            },
            "azure": {
              "$ref": "#/definitions/azure_storage_config",
              "description": "Configures backend rule storage for Azure."
            },
            "alibabacloud": {
              "$ref": "#/definitions/alibabacloud_storage_config",
              "description": "Configures backend rule storage for AlibabaCloud Object Storage (OSS)."
            },
            "gcs": {
              "$ref": "#/definitions/gcs_storage_config",
              "description": "Configures backend rule storage for GCS."
            },
            "s3": {
              "$ref": "#/definitions/s3_storage_config",
              "description": "Configures backend rule storage for S3."
            },
            "bos": {
              "$ref": "#/definitions/bos_storage_config",
              "description": "Configures backend rule storage for Baidu Object Storage (BOS)."
            },
            "swift": {
              "$ref": "#/definitions/swift_storage_config",
              "description": "Configures backend rule storage for Swift."
            },
            "cos": {
              "$ref": "#/definitions/cos_storage_config",
              "description": "Configures backend rule storage for IBM Cloud Object Storage (COS)."
            },
            "local": {
              "description": "Configures backend rule storage for a local file system directory.",
              "type": "object",
              "properties": {
                "directory": {
                  "type": "string",
                  "description": "Directory to scan for rules"
                }
              }
            }
          }
        },
        "rule_path": {
          "type": "string",
          "description": "File path to store temporary rule files."
        },
        "alertmanager_url": {
          "type": "string",
          "description": "Comma-separated list of Alertmanager URLs to send notifications to. Each Alertmanager URL is treated as a separate group in the configuration. Multiple Alertmanagers in HA per group can be supported by using DNS resolution via '-ruler.alertmanager-discovery'."
        },
        "enable_alertmanager_discovery": {
          "type": "boolean",
          "description": "Use DNS SRV records to discover Alertmanager hosts."
        },
        "alertmanager_refresh_interval": {
          "type": "string",
          "description": "How long to wait between refreshing DNS resolutions of Alertmanager hosts."
        },
        "enable_alertmanager_v2": {
          "type": "boolean",
          "description": "If enabled requests to Alertmanager will utilize the V2 API."
        },
        "alert_relabel_configs": {
          "type": ["array", "null"],
          "items": {
            "type": "object"
          },
          "description": "List of alert relabel configs."
        },
        "notification_queue_capacity": {
          "type": "integer",
          "description": "Capacity of the queue for notifications to be sent to the Alertmanager. Default: 10000."
        },
        "notification_timeout": {
          "type": "string",
          "description": "HTTP timeout duration when sending notifications to the Alertmanager."
        },
        "alertmanager_client": {
          "description": "",
          "type": "object",
          "properties": {
            "tls_cert_path": {
              "type": "string",
              "description": "Path to the client certificate, which will be used for authenticating with the server. Also requires the key path to be configured."
            },
            "tls_key_path": {
              "type": "string",
              "description": "Path to the key for the client certificate. Also requires the client certificate to be configured."
            },
            "tls_ca_path": {
              "type": "string",
              "description": "Path to the CA certificates to validate server certificate against. If not set, the host's root CA certificates are used."
            },
            "tls_server_name": {
              "type": "string",
              "description": "Override the expected name on the server certificate."
            },
            "tls_insecure_skip_verify": {
              "type": "boolean",
              "description": "Skip validating server certificate."
            },
            "tls_cipher_suites": {
              "type": "string",
              "description": "Override the default cipher suite list (separated by commas). Allowed values:\n\nSecure Ciphers:\n- TLS_AES_128_GCM_SHA256\n- TLS_AES_256_GCM_SHA384\n- TLS_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n\nInsecure Ciphers:\n- TLS_RSA_WITH_RC4_128_SHA\n- TLS_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA\n- TLS_RSA_WITH_AES_256_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA256\n- TLS_RSA_WITH_AES_128_GCM_SHA256\n- TLS_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n"
            },
            "tls_min_version": {
              "type": "string",
              "description": "Override the default minimum TLS version. Allowed values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13"
            },
            "basic_auth_username": {
              "type": "string",
              "description": "HTTP Basic authentication username. It overrides the username set in the URL (if any)."
            },
            "basic_auth_password": {
              "type": "string",
              "description": "HTTP Basic authentication password. It overrides the password set in the URL (if any)."
            },
            "type": {
              "type": "string",
              "description": "HTTP Header authorization type (default: Bearer)."
            },
            "credentials": {
              "type": "string",
              "description": "HTTP Header authorization credentials."
            },
            "credentials_file": {
              "type": "string",
              "description": "HTTP Header authorization credentials file."
            }
          }
        },
        "for_outage_tolerance": {
          "type": "string",
          "description": "Max time to tolerate outage for restoring \"for\" state of alert."
        },
        "for_grace_period": {
          "type": "string",
          "description": "Minimum duration between alert and restored \"for\" state. This is maintained only for alerts with configured \"for\" time greater than the grace period."
        },
        "resend_delay": {
          "type": "string",
          "description": "Minimum amount of time to wait before resending an alert to Alertmanager."
        },
        "enable_sharding": {
          "type": "boolean",
          "description": "Distribute rule evaluation using ring backend."
        },
        "sharding_strategy": {
          "type": "string",
          "description": "The sharding strategy to use. Supported values are: default, shuffle-sharding."
        },
        "sharding_algo": {
          "type": "string",
          "description": "The sharding algorithm to use for deciding how rules & groups are sharded. Supported values are: by-group, by-rule."
        },
        "search_pending_for": {
          "type": "string",
          "description": "Time to spend searching for a pending ruler when shutting down."
        },
        "ring": {
          "description": "Ring used by Loki ruler. The CLI flags prefix for this block configuration is 'ruler.ring'.",
          "type": "object",
          "properties": {
            "kvstore": {
              "description": "",
              "type": "object",
              "properties": {
                "store": {
                  "type": "string",
                  "description": "Backend storage to use for the ring. Supported values are: consul, etcd, inmemory, memberlist, multi."
                },
                "prefix": {
                  "type": "string",
                  "description": "The prefix for the keys in the store. Should end with a /."
                },
                "consul": {
                  "$ref": "#/definitions/consul",
                  "description": "Configuration for a Consul client. Only applies if the selected kvstore is consul."
                },
                "etcd": {
                  "$ref": "#/definitions/etcd",
                  "description": "Configuration for an ETCD v3 client. Only applies if the selected kvstore is etcd."
                },
                "multi": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "primary": {
                      "type": "string",
                      "description": "Primary backend storage used by multi-client."
                    },
                    "secondary": {
                      "type": "string",
                      "description": "Secondary backend storage used by multi-client."
                    },
                    "mirror_enabled": {
                      "type": "boolean",
                      "description": "Mirror writes to secondary store."
                    },
                    "mirror_timeout": {
                      "type": "string",
                      "description": "Timeout for storing value to secondary store."
                    }
                  }
                }
              }
            },
            "heartbeat_period": {
              "type": "string",
              "description": "Interval between heartbeats sent to the ring. 0 = disabled."
            },
            "heartbeat_timeout": {
              "type": "string",
              "description": "The heartbeat timeout after which ruler ring members are considered unhealthy within the ring. 0 = never (timeout disabled)."
            },
            "instance_interface_names": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "Name of network interface to read addresses from."
            },
            "num_tokens": {
              "type": "integer",
              "description": "The number of tokens the lifecycler will generate and put into the ring if it joined without transferring tokens from another lifecycler. Default: 128."
            }
          }
        },
        "flush_period": {
          "type": "string",
          "description": "Period with which to attempt to flush rule groups."
        },
        "enable_api": {
          "type": "boolean",
          "description": "Enable the ruler API."
        },
        "enabled_tenants": {
          "type": "string",
          "description": "Comma separated list of tenants whose rules this ruler can evaluate. If specified, only these tenants will be handled by ruler, otherwise this ruler can process rules from all tenants. Subject to sharding."
        },
        "disabled_tenants": {
          "type": "string",
          "description": "Comma separated list of tenants whose rules this ruler cannot evaluate. If specified, a ruler that would normally pick the specified tenant(s) for processing will ignore them instead. Subject to sharding."
        },
        "query_stats_enabled": {
          "type": "boolean",
          "description": "Report the wall time for ruler queries to complete as a per user metric and as an info level log message."
        },
        "disable_rule_group_label": {
          "type": "boolean",
          "description": "Disable the rule_group label on exported metrics."
        },
        "wal": {
          "description": "",
          "type": "object",
          "properties": {
            "dir": {
              "type": "string",
              "description": "The directory in which to write tenant WAL files. Each tenant will have its own directory one level below this directory."
            },
            "truncate_frequency": {
              "type": "string",
              "description": "Frequency with which to run the WAL truncation process."
            },
            "min_age": {
              "type": "string",
              "description": "Minimum age that samples must exist in the WAL before being truncated."
            },
            "max_age": {
              "type": "string",
              "description": "Maximum age that samples must exist in the WAL before being truncated."
            }
          }
        },
        "wal_cleaner": {
          "description": "",
          "type": "object",
          "properties": {
            "min_age": {
              "type": "string",
              "description": "The minimum age of a WAL to consider for cleaning."
            },
            "period": {
              "type": "string",
              "description": "How often to run the WAL cleaner. 0 = disabled."
            }
          }
        },
        "remote_write": {
          "description": "Remote-write configuration to send rule samples to a Prometheus remote-write endpoint.",
          "type": "object",
          "properties": {
            "client": {
              "$ref": "#/definitions/ruler/properties/remote_write",
              "type": "object",
              "description": "Deprecated: Use 'clients' instead. Configure remote write client."
            },
            "clients": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/ruler/properties/remote_write"
              },
              "description": "Configure remote write clients. A map with remote client id as key."
            },
            "enabled": {
              "type": "boolean",
              "description": "Enable remote-write functionality."
            },
            "config_refresh_period": {
              "type": "string",
              "description": "Minimum period to wait between refreshing remote-write reconfigurations. This should be greater than or equivalent to -limits.per-user-override-period."
            },
            "add_org_id_header": {
              "type": "boolean",
              "description": "Add X-Scope-OrgID header in remote write requests."
            }
          }
        },
        "evaluation": {
          "description": "Configuration for rule evaluation.",
          "type": "object",
          "properties": {
            "mode": {
              "type": "string",
              "description": "The evaluation mode for the ruler. Can be either 'local' or 'remote'. If set to 'local', the ruler will evaluate rules locally. If set to 'remote', the ruler will evaluate rules remotely. If unset, the ruler will evaluate rules locally."
            },
            "max_jitter": {
              "type": "string",
              "description": "Upper bound of random duration to wait before rule evaluation to avoid contention during concurrent execution of rules. Jitter is calculated consistently for a given rule. Set 0 to disable (default)."
            },
            "query_frontend": {
              "description": "",
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "GRPC listen address of the query-frontend(s). Must be a DNS address (prefixed with dns:///) to enable client side load balancing."
                },
                "tls_enabled": {
                  "type": "boolean",
                  "description": "Set to true if query-frontend connection requires TLS."
                },
                "tls_cert_path": {
                  "type": "string",
                  "description": "Path to the client certificate, which will be used for authenticating with the server. Also requires the key path to be configured."
                },
                "tls_key_path": {
                  "type": "string",
                  "description": "Path to the key for the client certificate. Also requires the client certificate to be configured."
                },
                "tls_ca_path": {
                  "type": "string",
                  "description": "Path to the CA certificates to validate server certificate against. If not set, the host's root CA certificates are used."
                },
                "tls_server_name": {
                  "type": "string",
                  "description": "Override the expected name on the server certificate."
                },
                "tls_insecure_skip_verify": {
                  "type": "boolean",
                  "description": "Skip validating server certificate."
                },
                "tls_cipher_suites": {
                  "type": "string",
                  "description": "Override the default cipher suite list (separated by commas). Allowed values:\n\nSecure Ciphers:\n- TLS_AES_128_GCM_SHA256\n- TLS_AES_256_GCM_SHA384\n- TLS_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n\nInsecure Ciphers:\n- TLS_RSA_WITH_RC4_128_SHA\n- TLS_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA\n- TLS_RSA_WITH_AES_256_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA256\n- TLS_RSA_WITH_AES_128_GCM_SHA256\n- TLS_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n"
                },
                "tls_min_version": {
                  "type": "string",
                  "description": "Override the default minimum TLS version. Allowed values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13"
                }
              }
            }
          }
        }
      }
    },
    "runtime_config": {
      "type": "object",
      "properties": {
        "period": {
          "type": "string",
          "description": "How often to check runtime config files."
        },
        "file": {
          "type": "string",
          "description": "Comma separated list of yaml files with the configuration that can be updated at runtime. Runtime config files will be merged from left to right."
        }
      }
    },
    "s3_storage_config": {
      "type": "object",
      "properties": {
        "s3": {
          "type": "string",
          "description": "S3 endpoint URL with escaped Key and Secret encoded. If only region is specified as a host, proper endpoint will be deduced. Use inmemory:///<bucket-name> to use a mock in-memory implementation."
        },
        "s3forcepathstyle": {
          "type": "boolean",
          "description": "Set this to `true` to force the request to use path-style addressing."
        },
        "bucketnames": {
          "type": "string",
          "description": "Comma separated list of bucket names to evenly distribute chunks over. Overrides any buckets specified in s3.url flag"
        },
        "endpoint": {
          "type": "string",
          "description": "S3 Endpoint to connect to."
        },
        "region": {
          "type": "string",
          "description": "AWS region to use."
        },
        "access_key_id": {
          "type": "string",
          "description": "AWS Access Key ID"
        },
        "secret_access_key": {
          "type": "string",
          "description": "AWS Secret Access Key"
        },
        "session_token": {
          "type": "string",
          "description": "AWS Session Token"
        },
        "insecure": {
          "type": "boolean",
          "description": "Disable https on s3 connection."
        },
        "http_config": {
          "description": "",
          "type": "object",
          "properties": {
            "timeout": {
              "type": "string",
              "description": "Timeout specifies a time limit for requests made by s3 Client."
            },
            "idle_conn_timeout": {
              "type": "string",
              "description": "The maximum amount of time an idle connection will be held open."
            },
            "response_header_timeout": {
              "type": "string",
              "description": "If non-zero, specifies the amount of time to wait for a server's response headers after fully writing the request."
            },
            "insecure_skip_verify": {
              "type": "boolean",
              "description": "Set to true to skip verifying the certificate chain and hostname."
            },
            "ca_file": {
              "type": "string",
              "description": "Path to the trusted CA file that signed the SSL certificate of the S3 endpoint."
            }
          }
        },
        "signature_version": {
          "type": "string",
          "description": "The signature version to use for authenticating against S3. Supported values are: v4."
        },
        "storage_class": {
          "type": "string",
          "description": "The S3 storage class which objects will use. Supported values are: GLACIER, DEEP_ARCHIVE, GLACIER_IR, INTELLIGENT_TIERING, ONEZONE_IA, OUTPOSTS, REDUCED_REDUNDANCY, STANDARD, STANDARD_IA."
        },
        "sse": {
          "description": "",
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Enable AWS Server Side Encryption. Supported values: SSE-KMS, SSE-S3."
            },
            "kms_key_id": {
              "type": "string",
              "description": "KMS Key ID used to encrypt objects in S3"
            },
            "kms_encryption_context": {
              "type": "string",
              "description": "KMS Encryption Context used for object encryption. It expects JSON formatted string."
            }
          }
        },
        "backoff_config": {
          "description": "Configures back off when S3 get Object.",
          "type": "object",
          "properties": {
            "min_period": {
              "type": "string",
              "description": "Minimum backoff time when s3 get Object"
            },
            "max_period": {
              "type": "string",
              "description": "Maximum backoff time when s3 get Object"
            },
            "max_retries": {
              "type": "integer",
              "description": "Maximum number of times to retry when s3 get Object. Default: 5."
            }
          }
        }
      }
    },
    "schema_config": {
      "type": "object",
      "properties": {
        "configs": {
          "type": ["array", "null"],
          "items": {
            "$ref": "#/definitions/period_config"
          }
        }
      }
    },
    "server": {
      "type": "object",
      "properties": {
        "http_listen_network": {
          "type": "string",
          "description": "HTTP server listen network, default tcp"
        },
        "http_listen_address": {
          "type": "string",
          "description": "HTTP server listen address."
        },
        "http_listen_port": {
          "type": "integer",
          "description": "HTTP server listen port. Default: 3100."
        },
        "http_listen_conn_limit": {
          "type": "integer",
          "description": "Maximum number of simultaneous http connections, <=0 to disable. Default: 0."
        },
        "grpc_listen_network": {
          "type": "string",
          "description": "gRPC server listen network"
        },
        "grpc_listen_address": {
          "type": "string",
          "description": "gRPC server listen address."
        },
        "grpc_listen_port": {
          "type": "integer",
          "description": "gRPC server listen port. Default: 9095."
        },
        "grpc_listen_conn_limit": {
          "type": "integer",
          "description": "Maximum number of simultaneous grpc connections, <=0 to disable. Default: 0."
        },
        "tls_cipher_suites": {
          "type": "string",
          "description": "Comma-separated list of cipher suites to use. If blank, the default Go cipher suites is used."
        },
        "tls_min_version": {
          "type": "string",
          "description": "Minimum TLS version to use. Allowed values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13. If blank, the Go TLS minimum version is used."
        },
        "http_tls_config": {
          "description": "",
          "type": "object",
          "properties": {
            "cert": {
              "type": "string",
              "description": "Server TLS certificate. This configuration parameter is YAML only."
            },
            "key": {
              "type": "string",
              "description": "Server TLS key. This configuration parameter is YAML only."
            },
            "client_ca": {
              "type": "string",
              "description": "Root certificate authority used to verify client certificates. This configuration parameter is YAML only."
            },
            "cert_file": {
              "type": "string",
              "description": "HTTP server cert path."
            },
            "key_file": {
              "type": "string",
              "description": "HTTP server key path."
            },
            "client_auth_type": {
              "type": "string",
              "description": "HTTP TLS Client Auth type."
            },
            "client_ca_file": {
              "type": "string",
              "description": "HTTP TLS Client CA path."
            }
          }
        },
        "grpc_tls_config": {
          "description": "",
          "type": "object",
          "properties": {
            "cert": {
              "type": "string",
              "description": "Server TLS certificate. This configuration parameter is YAML only."
            },
            "key": {
              "type": "string",
              "description": "Server TLS key. This configuration parameter is YAML only."
            },
            "client_ca": {
              "type": "string",
              "description": "Root certificate authority used to verify client certificates. This configuration parameter is YAML only."
            },
            "cert_file": {
              "type": "string",
              "description": "GRPC TLS server cert path."
            },
            "key_file": {
              "type": "string",
              "description": "GRPC TLS server key path."
            },
            "client_auth_type": {
              "type": "string",
              "description": "GRPC TLS Client Auth type."
            },
            "client_ca_file": {
              "type": "string",
              "description": "GRPC TLS Client CA path."
            }
          }
        },
        "register_instrumentation": {
          "type": "boolean",
          "description": "Register the instrumentation handlers (/metrics etc)."
        },
        "report_grpc_codes_in_instrumentation_label_enabled": {
          "type": "boolean",
          "description": "If set to true, gRPC statuses will be reported in instrumentation labels with their string representations. Otherwise, they will be reported as \"error\"."
        },
        "graceful_shutdown_timeout": {
          "type": "string",
          "description": "Timeout for graceful shutdowns"
        },
        "http_server_read_timeout": {
          "type": "string",
          "description": "Read timeout for entire HTTP request, including headers and body."
        },
        "http_server_read_header_timeout": {
          "type": "string",
          "description": "Read timeout for HTTP request headers. If set to 0, value of -server.http-read-timeout is used."
        },
        "http_server_write_timeout": {
          "type": "string",
          "description": "Write timeout for HTTP server"
        },
        "http_server_idle_timeout": {
          "type": "string",
          "description": "Idle timeout for HTTP server"
        },
        "http_log_closed_connections_without_response_enabled": {
          "type": "boolean",
          "description": "Log closed connections that did not receive any response, most likely because client didn't send any request within timeout."
        },
        "grpc_server_max_recv_msg_size": {
          "type": "integer",
          "description": "Limit on the size of a gRPC message this server can receive (bytes). Default: 4194304."
        },
        "grpc_server_max_send_msg_size": {
          "type": "integer",
          "description": "Limit on the size of a gRPC message this server can send (bytes). Default: 4194304."
        },
        "grpc_server_max_concurrent_streams": {
          "type": "integer",
          "description": "Limit on the number of concurrent streams for gRPC calls per client connection (0 = unlimited). Default: 100."
        },
        "grpc_server_max_connection_idle": {
          "type": "string",
          "description": "The duration after which an idle connection should be closed. Default: infinity"
        },
        "grpc_server_max_connection_age": {
          "type": "string",
          "description": "The duration for the maximum amount of time a connection may exist before it will be closed. Default: infinity"
        },
        "grpc_server_max_connection_age_grace": {
          "type": "string",
          "description": "An additive period after max-connection-age after which the connection will be forcibly closed. Default: infinity"
        },
        "grpc_server_keepalive_time": {
          "type": "string",
          "description": "Duration after which a keepalive probe is sent in case of no activity over the connection., Default: 2h"
        },
        "grpc_server_keepalive_timeout": {
          "type": "string",
          "description": "After having pinged for keepalive check, the duration after which an idle connection should be closed, Default: 20s"
        },
        "grpc_server_min_time_between_pings": {
          "type": "string",
          "description": "Minimum amount of time a client should wait before sending a keepalive ping. If client sends keepalive ping more often, server will send GOAWAY and close the connection."
        },
        "grpc_server_ping_without_stream_allowed": {
          "type": "boolean",
          "description": "If true, server allows keepalive pings even when there are no active streams(RPCs). If false, and client sends ping when there are no active streams, server will send GOAWAY and close the connection."
        },
        "grpc_server_num_workers": {
          "type": "integer",
          "description": "If non-zero, configures the amount of GRPC server workers used to serve the requests. Default: 0."
        },
        "log_format": {
          "type": "string",
          "description": "Output log messages in the given format. Valid formats: [logfmt, json]"
        },
        "log_level": {
          "type": "string",
          "description": "Only log messages with the given severity or above. Valid levels: [debug, info, warn, error]"
        },
        "log_source_ips_enabled": {
          "type": "boolean",
          "description": "Optionally log the source IPs."
        },
        "log_source_ips_header": {
          "type": "string",
          "description": "Header field storing the source IPs. Only used if server.log-source-ips-enabled is true. If not set the default Forwarded, X-Real-IP and X-Forwarded-For headers are used"
        },
        "log_source_ips_regex": {
          "type": "string",
          "description": "Regex for matching the source IPs. Only used if server.log-source-ips-enabled is true. If not set the default Forwarded, X-Real-IP and X-Forwarded-For headers are used"
        },
        "log_request_headers": {
          "type": "boolean",
          "description": "Optionally log request headers."
        },
        "log_request_at_info_level_enabled": {
          "type": "boolean",
          "description": "Optionally log requests at info level instead of debug level. Applies to request headers as well if server.log-request-headers is enabled."
        },
        "log_request_exclude_headers_list": {
          "type": "string",
          "description": "Comma separated list of headers to exclude from logging. Only used if server.log-request-headers is true."
        },
        "http_path_prefix": {
          "type": "string",
          "description": "Base path to serve all API routes from (e.g. /v1/)"
        }
      }
    },
    "storage_config": {
      "type": "object",
      "properties": {
        "alibabacloud": {
          "$ref": "#/definitions/alibabacloud_storage_config",
          "description": "The alibabacloud_storage_config block configures the connection to Alibaba Cloud Storage object storage backend."
        },
        "aws": {
          "$ref": "#/definitions/aws_storage_config",
          "description": "The aws_storage_config block configures the connection to dynamoDB and S3 object storage. Either one of them or both can be configured."
        },
        "azure": {
          "$ref": "#/definitions/azure_storage_config",
          "description": "The azure_storage_config block configures the connection to Azure object storage backend."
        },
        "bos": {
          "$ref": "#/definitions/bos_storage_config",
          "description": "The bos_storage_config block configures the connection to Baidu Object Storage (BOS) object storage backend."
        },
        "bigtable": {
          "description": "Deprecated: Configures storing indexes in Bigtable. Required fields only required when bigtable is defined in config.",
          "type": "object",
          "properties": {
            "project": {
              "type": "string",
              "description": "Bigtable project ID."
            },
            "instance": {
              "type": "string",
              "description": "Bigtable instance ID. Please refer to https://cloud.google.com/docs/authentication/production for more information about how to configure authentication."
            },
            "grpc_client_config": {
              "$ref": "#/definitions/grpc_client",
              "description": "The grpc_client block configures the gRPC client used to communicate between a client and server component in Loki."
            },
            "table_cache_enabled": {
              "type": "boolean",
              "description": "If enabled, once a tables info is fetched, it is cached."
            },
            "table_cache_expiration": {
              "type": "string",
              "description": "Duration to cache tables before checking again."
            }
          }
        },
        "gcs": {
          "$ref": "#/definitions/gcs_storage_config",
          "description": "Configures storing chunks in GCS. Required fields only required when gcs is defined in config."
        },
        "cassandra": {
          "description": "Deprecated: Configures storing chunks and/or the index in Cassandra.",
          "type": "object",
          "properties": {
            "addresses": {
              "type": "string",
              "description": "Comma-separated hostnames or IPs of Cassandra instances."
            },
            "port": {
              "type": "integer",
              "description": "Port that Cassandra is running on. Default: 9042."
            },
            "keyspace": {
              "type": "string",
              "description": "Keyspace to use in Cassandra."
            },
            "consistency": {
              "type": "string",
              "description": "Consistency level for Cassandra."
            },
            "replication_factor": {
              "type": "integer",
              "description": "Replication factor to use in Cassandra. Default: 3."
            },
            "disable_initial_host_lookup": {
              "type": "boolean",
              "description": "Instruct the cassandra driver to not attempt to get host info from the system.peers table."
            },
            "SSL": {
              "type": "boolean",
              "description": "Use SSL when connecting to cassandra instances."
            },
            "host_verification": {
              "type": "boolean",
              "description": "Require SSL certificate validation."
            },
            "host_selection_policy": {
              "type": "string",
              "description": "Policy for selecting Cassandra host. Supported values are: round-robin, token-aware."
            },
            "CA_path": {
              "type": "string",
              "description": "Path to certificate file to verify the peer."
            },
            "tls_cert_path": {
              "type": "string",
              "description": "Path to certificate file used by TLS."
            },
            "tls_key_path": {
              "type": "string",
              "description": "Path to private key file used by TLS."
            },
            "auth": {
              "type": "boolean",
              "description": "Enable password authentication when connecting to cassandra."
            },
            "username": {
              "type": "string",
              "description": "Username to use when connecting to cassandra."
            },
            "password": {
              "type": "string",
              "description": "Password to use when connecting to cassandra."
            },
            "password_file": {
              "type": "string",
              "description": "File containing password to use when connecting to cassandra."
            },
            "custom_authenticators": {
              "type": ["array", "null"],
              "items": {
                "type": "string"
              },
              "description": "If set, when authenticating with cassandra a custom authenticator will be expected during the handshake. This flag can be set multiple times."
            },
            "timeout": {
              "type": "string",
              "description": "Timeout when connecting to cassandra."
            },
            "connect_timeout": {
              "type": "string",
              "description": "Initial connection timeout, used during initial dial to server."
            },
            "reconnect_interval": {
              "type": "string",
              "description": "Interval to retry connecting to cassandra nodes marked as DOWN."
            },
            "max_retries": {
              "type": "integer",
              "description": "Number of retries to perform on a request. Set to 0 to disable retries. Default: 0."
            },
            "retry_max_backoff": {
              "type": "string",
              "description": "Maximum time to wait before retrying a failed request."
            },
            "retry_min_backoff": {
              "type": "string",
              "description": "Minimum time to wait before retrying a failed request."
            },
            "query_concurrency": {
              "type": "integer",
              "description": "Limit number of concurrent queries to Cassandra. Set to 0 to disable the limit. Default: 0."
            },
            "num_connections": {
              "type": "integer",
              "description": "Number of TCP connections per host. Default: 2."
            },
            "convict_hosts_on_failure": {
              "type": "boolean",
              "description": "Convict hosts of being down on failure."
            },
            "table_options": {
              "type": "string",
              "description": "Table options used to create index or chunk tables. This value is used as plain text in the table `WITH` like this, \"CREATE TABLE <generated_by_cortex> (...) WITH <cassandra.table-options>\". For details, see https://cortexmetrics.io/docs/production/cassandra. By default it will use the default table options of your Cassandra cluster."
            }
          }
        },
        "boltdb": {
          "description": "Deprecated: Configures storing index in BoltDB. Required fields only required when boltdb is present in the configuration.",
          "type": "object",
          "properties": {
            "directory": {
              "type": "string",
              "description": "Location of BoltDB index files."
            }
          }
        },
        "filesystem": {
          "$ref": "#/definitions/local_storage_config",
          "description": "Configures storing the chunks on the local file system. Required fields only required when filesystem is present in the configuration."
        },
        "swift": {
          "$ref": "#/definitions/swift_storage_config",
          "description": "The swift_storage_config block configures the connection to OpenStack Object Storage (Swift) object storage backend."
        },
        "grpc_store": {
          "description": "Deprecated:",
          "type": "object",
          "properties": {
            "server_address": {
              "type": "string",
              "description": "Hostname or IP of the gRPC store instance."
            }
          }
        },
        "hedging": {
          "description": "",
          "type": "object",
          "properties": {
            "at": {
              "type": "string",
              "description": "If set to a non-zero value a second request will be issued at the provided duration. Default is 0 (disabled)"
            },
            "up_to": {
              "type": "integer",
              "description": "The maximum of hedge requests allowed. Default: 2."
            },
            "max_per_second": {
              "type": "integer",
              "description": "The maximum of hedge requests allowed per seconds. Default: 5."
            }
          }
        },
        "named_stores": {
          "$ref": "#/definitions/named_stores_config",
          "description": "Configures additional object stores for a given storage provider.\nSupported stores: aws, azure, bos, filesystem, gcs, swift.\nExample:\nstorage_config:\n  named_stores:\n    aws:\n      store-1:\n        endpoint: s3://foo-bucket\n        region: us-west1\nNamed store from this example can be used by setting object_store to store-1 in period_config."
        },
        "cos": {
          "$ref": "#/definitions/cos_storage_config",
          "description": "The cos_storage_config block configures the connection to IBM Cloud Object Storage (COS) backend."
        },
        "index_cache_validity": {
          "type": "string",
          "description": "Cache validity for active index entries. Should be no higher than -ingester.max-chunk-idle."
        },
        "congestion_control": {
          "description": "",
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Use storage congestion control (default: disabled)."
            },
            "controller": {
              "description": "",
              "type": "object",
              "properties": {
                "strategy": {
                  "type": "string",
                  "description": "Congestion control strategy to use (default: none, options: 'aimd')."
                },
                "aimd": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "start": {
                      "type": "integer",
                      "description": "AIMD starting throughput window size: how many requests can be sent per second (default: 2000). Default: 2000."
                    },
                    "upper_bound": {
                      "type": "integer",
                      "description": "AIMD maximum throughput window size: upper limit of requests sent per second (default: 10000). Default: 10000."
                    },
                    "backoff_factor": {
                      "type": "number",
                      "description": "AIMD backoff factor when upstream service is throttled to decrease number of requests sent per second (default: 0.5). Default: 0.5."
                    }
                  }
                }
              }
            },
            "retry": {
              "description": "",
              "type": "object",
              "properties": {
                "strategy": {
                  "type": "string",
                  "description": "Congestion control retry strategy to use (default: none, options: 'limited')."
                },
                "limit": {
                  "type": "integer",
                  "description": "Maximum number of retries allowed. Default: 2."
                }
              }
            },
            "hedging": {
              "description": "",
              "type": "object",
              "properties": {
                "config": {
                  "description": "",
                  "type": "object",
                  "properties": {
                    "at": {
                      "type": "string"
                    },
                    "up_to": {
                      "type": "integer"
                    },
                    "max_per_second": {
                      "type": "integer"
                    }
                  }
                },
                "strategy": {
                  "type": "string",
                  "description": "Congestion control hedge strategy to use (default: none, options: 'limited')."
                }
              }
            }
          }
        },
        "object_prefix": {
          "type": "string",
          "description": "Experimental. Sets a constant prefix for all keys inserted into object storage. Example: loki/"
        },
        "index_queries_cache_config": {
          "$ref": "#/definitions/cache_config",
          "description": "The cache_config block configures the cache backend for a specific Loki component."
        },
        "disable_broad_index_queries": {
          "type": "boolean",
          "description": "Disable broad index queries which results in reduced cache usage and faster query performance at the expense of somewhat higher QPS on the index store."
        },
        "max_parallel_get_chunk": {
          "type": "integer",
          "description": "Maximum number of parallel chunk reads. Default: 150."
        },
        "max_chunk_batch_size": {
          "type": "integer",
          "description": "The maximum number of chunks to fetch per batch. Default: 50."
        },
        "boltdb_shipper": {
          "description": "Configures storing index in an Object Store (GCS/S3/Azure/Swift/COS/Filesystem) in the form of boltdb files. Required fields only required when boltdb-shipper is defined in config.",
          "type": "object",
          "properties": {
            "active_index_directory": {
              "type": "string",
              "description": "Directory where ingesters would write index files which would then be uploaded by shipper to configured storage"
            },
            "cache_location": {
              "type": "string",
              "description": "Cache location for restoring index files from storage for queries"
            },
            "cache_ttl": {
              "type": "string",
              "description": "TTL for index files restored in cache for queries"
            },
            "resync_interval": {
              "type": "string",
              "description": "Resync downloaded files with the storage"
            },
            "query_ready_num_days": {
              "type": "integer",
              "description": "Number of days of common index to be kept downloaded for queries. For per tenant index query readiness, use limits overrides config. Default: 0."
            },
            "index_gateway_client": {
              "description": "",
              "type": "object",
              "properties": {
                "grpc_client_config": {
                  "$ref": "#/definitions/grpc_client",
                  "description": "The grpc_client block configures the gRPC client used to communicate between a client and server component in Loki."
                },
                "server_address": {
                  "type": "string",
                  "description": "Hostname or IP of the Index Gateway gRPC server running in simple mode. Can also be prefixed with dns+, dnssrv+, or dnssrvnoa+ to resolve a DNS A record with multiple IP's, a DNS SRV record with a followup A record lookup, or a DNS SRV record without a followup A record lookup, respectively."
                },
                "log_gateway_requests": {
                  "type": "boolean",
                  "description": "Whether requests sent to the gateway should be logged or not."
                }
              }
            },
            "ingestername": {
              "type": "string"
            },
            "mode": {
              "type": "string"
            },
            "ingesterdbretainperiod": {
              "type": "string"
            },
            "build_per_tenant_index": {
              "type": "boolean",
              "description": "Build per tenant index files"
            }
          }
        },
        "tsdb_shipper": {
          "description": "Configures storing index in an Object Store (GCS/S3/Azure/Swift/COS/Filesystem) in a prometheus TSDB-like format. Required fields only required when TSDB is defined in config.",
          "type": "object",
          "properties": {
            "active_index_directory": {
              "type": "string",
              "description": "Directory where ingesters would write index files which would then be uploaded by shipper to configured storage"
            },
            "cache_location": {
              "type": "string",
              "description": "Cache location for restoring index files from storage for queries"
            },
            "cache_ttl": {
              "type": "string",
              "description": "TTL for index files restored in cache for queries"
            },
            "resync_interval": {
              "type": "string",
              "description": "Resync downloaded files with the storage"
            },
            "query_ready_num_days": {
              "type": "integer",
              "description": "Number of days of common index to be kept downloaded for queries. For per tenant index query readiness, use limits overrides config. Default: 0."
            },
            "index_gateway_client": {
              "description": "",
              "type": "object",
              "properties": {
                "grpc_client_config": {
                  "$ref": "#/definitions/grpc_client",
                  "description": "The grpc_client block configures the gRPC client used to communicate between a client and server component in Loki."
                },
                "server_address": {
                  "type": "string",
                  "description": "Hostname or IP of the Index Gateway gRPC server running in simple mode. Can also be prefixed with dns+, dnssrv+, or dnssrvnoa+ to resolve a DNS A record with multiple IP's, a DNS SRV record with a followup A record lookup, or a DNS SRV record without a followup A record lookup, respectively."
                },
                "log_gateway_requests": {
                  "type": "boolean",
                  "description": "Whether requests sent to the gateway should be logged or not."
                }
              }
            },
            "ingestername": {
              "type": "string"
            },
            "mode": {
              "type": "string"
            },
            "ingesterdbretainperiod": {
              "type": "string"
            }
          }
        },
        "bloom_shipper": {
          "description": "Experimental: Configures the bloom shipper component, which contains the store abstraction to fetch bloom filters from and put them to object storage.",
          "type": "object",
          "properties": {
            "working_directory": {
              "type": "string",
              "description": "Working directory to store downloaded bloom blocks. Supports multiple directories, separated by comma."
            },
            "max_query_page_size": {
              "type": "string",
              "description": "Maximum size of bloom pages that should be queried. Larger pages than this limit are skipped when querying blooms to limit memory usage. Default: 64MiB."
            },
            "download_parallelism": {
              "type": "integer",
              "description": "The amount of maximum concurrent bloom blocks downloads. Usually set to 2x number of CPU cores. Default: 8."
            },
            "blocks_cache": {
              "description": "",
              "type": "object",
              "properties": {
                "soft_limit": {
                  "type": "string",
                  "description": "Cache for bloom blocks. Soft limit of the cache in bytes. Exceeding this limit will trigger evictions of least recently used items in the background. Default: 32GiB."
                },
                "hard_limit": {
                  "type": "string",
                  "description": "Cache for bloom blocks. Hard limit of the cache in bytes. Exceeding this limit will block execution until soft limit is deceeded. Default: 64GiB."
                },
                "ttl": {
                  "type": "string",
                  "description": "Cache for bloom blocks. The time to live for items in the cache before they get purged."
                }
              }
            },
            "metas_cache": {
              "$ref": "#/definitions/cache_config",
              "description": "The cache_config block configures the cache backend for a specific Loki component."
            }
          }
        }
      }
    },
    "swift_storage_config": {
      "type": "object",
      "properties": {
        "auth_version": {
          "type": "integer",
          "description": "OpenStack Swift authentication API version. 0 to autodetect. Default: 0."
        },
        "auth_url": {
          "type": "string",
          "description": "OpenStack Swift authentication URL"
        },
        "internal": {
          "type": "boolean",
          "description": "Set this to true to use the internal OpenStack Swift endpoint URL"
        },
        "username": {
          "type": "string",
          "description": "OpenStack Swift username."
        },
        "user_domain_name": {
          "type": "string",
          "description": "OpenStack Swift user's domain name."
        },
        "user_domain_id": {
          "type": "string",
          "description": "OpenStack Swift user's domain ID."
        },
        "user_id": {
          "type": "string",
          "description": "OpenStack Swift user ID."
        },
        "password": {
          "type": "string",
          "description": "OpenStack Swift API key."
        },
        "domain_id": {
          "type": "string",
          "description": "OpenStack Swift user's domain ID."
        },
        "domain_name": {
          "type": "string",
          "description": "OpenStack Swift user's domain name."
        },
        "project_id": {
          "type": "string",
          "description": "OpenStack Swift project ID (v2,v3 auth only)."
        },
        "project_name": {
          "type": "string",
          "description": "OpenStack Swift project name (v2,v3 auth only)."
        },
        "project_domain_id": {
          "type": "string",
          "description": "ID of the OpenStack Swift project's domain (v3 auth only), only needed if it differs the from user domain."
        },
        "project_domain_name": {
          "type": "string",
          "description": "Name of the OpenStack Swift project's domain (v3 auth only), only needed if it differs from the user domain."
        },
        "region_name": {
          "type": "string",
          "description": "OpenStack Swift Region to use (v2,v3 auth only)."
        },
        "container_name": {
          "type": "string",
          "description": "Name of the OpenStack Swift container to put chunks in."
        },
        "max_retries": {
          "type": "integer",
          "description": "Max retries on requests error. Default: 3."
        },
        "connect_timeout": {
          "type": "string",
          "description": "Time after which a connection attempt is aborted."
        },
        "request_timeout": {
          "type": "string",
          "description": "Time after which an idle request is aborted. The timeout watchdog is reset each time some data is received, so the timeout triggers after X time no data is received on a request."
        }
      }
    },
    "table_manager": {
      "type": "object",
      "properties": {
        "throughput_updates_disabled": {
          "type": "boolean",
          "description": "If true, disable all changes to DB capacity"
        },
        "retention_deletes_enabled": {
          "type": "boolean",
          "description": "If true, enables retention deletes of DB tables"
        },
        "retention_period": {
          "type": "string",
          "description": "Tables older than this retention period are deleted. Must be either 0 (disabled) or a multiple of 24h. When enabled, be aware this setting is destructive to data!"
        },
        "poll_interval": {
          "type": "string",
          "description": "How frequently to poll backend to learn our capacity."
        },
        "creation_grace_period": {
          "type": "string",
          "description": "Periodic tables grace period (duration which table will be created/deleted before/after it's needed)."
        },
        "index_tables_provisioning": {
          "description": "",
          "type": "object",
          "properties": {
            "enable_ondemand_throughput_mode": {
              "type": "boolean",
              "description": "Enables on demand throughput provisioning for the storage provider (if supported). Applies only to tables which are not autoscaled. Supported by DynamoDB"
            },
            "provisioned_write_throughput": {
              "type": "integer",
              "description": "Table default write throughput. Supported by DynamoDB. Default: 1000."
            },
            "provisioned_read_throughput": {
              "type": "integer",
              "description": "Table default read throughput. Supported by DynamoDB. Default: 300."
            },
            "write_scale": {
              "description": "",
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Should we enable autoscale for the table."
                },
                "role_arn": {
                  "type": "string",
                  "description": "AWS AutoScaling role ARN"
                },
                "min_capacity": {
                  "type": "integer",
                  "description": "DynamoDB minimum provision capacity. Default: 3000."
                },
                "max_capacity": {
                  "type": "integer",
                  "description": "DynamoDB maximum provision capacity. Default: 6000."
                },
                "out_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale up. Default: 1800."
                },
                "in_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale down. Default: 1800."
                },
                "target": {
                  "type": "number",
                  "description": "DynamoDB target ratio of consumed capacity to provisioned capacity. Default: 80."
                }
              }
            },
            "read_scale": {
              "description": "",
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Should we enable autoscale for the table."
                },
                "role_arn": {
                  "type": "string",
                  "description": "AWS AutoScaling role ARN"
                },
                "min_capacity": {
                  "type": "integer",
                  "description": "DynamoDB minimum provision capacity. Default: 3000."
                },
                "max_capacity": {
                  "type": "integer",
                  "description": "DynamoDB maximum provision capacity. Default: 6000."
                },
                "out_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale up. Default: 1800."
                },
                "in_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale down. Default: 1800."
                },
                "target": {
                  "type": "number",
                  "description": "DynamoDB target ratio of consumed capacity to provisioned capacity. Default: 80."
                }
              }
            },
            "enable_inactive_throughput_on_demand_mode": {
              "type": "boolean",
              "description": "Enables on demand throughput provisioning for the storage provider (if supported). Applies only to tables which are not autoscaled. Supported by DynamoDB"
            },
            "inactive_write_throughput": {
              "type": "integer",
              "description": "Table write throughput for inactive tables. Supported by DynamoDB. Default: 1."
            },
            "inactive_read_throughput": {
              "type": "integer",
              "description": "Table read throughput for inactive tables. Supported by DynamoDB. Default: 300."
            },
            "inactive_write_scale": {
              "description": "",
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Should we enable autoscale for the table."
                },
                "role_arn": {
                  "type": "string",
                  "description": "AWS AutoScaling role ARN"
                },
                "min_capacity": {
                  "type": "integer",
                  "description": "DynamoDB minimum provision capacity. Default: 3000."
                },
                "max_capacity": {
                  "type": "integer",
                  "description": "DynamoDB maximum provision capacity. Default: 6000."
                },
                "out_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale up. Default: 1800."
                },
                "in_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale down. Default: 1800."
                },
                "target": {
                  "type": "number",
                  "description": "DynamoDB target ratio of consumed capacity to provisioned capacity. Default: 80."
                }
              }
            },
            "inactive_read_scale": {
              "description": "",
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Should we enable autoscale for the table."
                },
                "role_arn": {
                  "type": "string",
                  "description": "AWS AutoScaling role ARN"
                },
                "min_capacity": {
                  "type": "integer",
                  "description": "DynamoDB minimum provision capacity. Default: 3000."
                },
                "max_capacity": {
                  "type": "integer",
                  "description": "DynamoDB maximum provision capacity. Default: 6000."
                },
                "out_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale up. Default: 1800."
                },
                "in_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale down. Default: 1800."
                },
                "target": {
                  "type": "number",
                  "description": "DynamoDB target ratio of consumed capacity to provisioned capacity. Default: 80."
                }
              }
            },
            "inactive_write_scale_lastn": {
              "type": "integer",
              "description": "Number of last inactive tables to enable write autoscale. Default: 4."
            },
            "inactive_read_scale_lastn": {
              "type": "integer",
              "description": "Number of last inactive tables to enable read autoscale. Default: 4."
            }
          }
        },
        "chunk_tables_provisioning": {
          "description": "",
          "type": "object",
          "properties": {
            "enable_ondemand_throughput_mode": {
              "type": "boolean",
              "description": "Enables on demand throughput provisioning for the storage provider (if supported). Applies only to tables which are not autoscaled. Supported by DynamoDB"
            },
            "provisioned_write_throughput": {
              "type": "integer",
              "description": "Table default write throughput. Supported by DynamoDB. Default: 1000."
            },
            "provisioned_read_throughput": {
              "type": "integer",
              "description": "Table default read throughput. Supported by DynamoDB. Default: 300."
            },
            "write_scale": {
              "description": "",
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Should we enable autoscale for the table."
                },
                "role_arn": {
                  "type": "string",
                  "description": "AWS AutoScaling role ARN"
                },
                "min_capacity": {
                  "type": "integer",
                  "description": "DynamoDB minimum provision capacity. Default: 3000."
                },
                "max_capacity": {
                  "type": "integer",
                  "description": "DynamoDB maximum provision capacity. Default: 6000."
                },
                "out_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale up. Default: 1800."
                },
                "in_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale down. Default: 1800."
                },
                "target": {
                  "type": "number",
                  "description": "DynamoDB target ratio of consumed capacity to provisioned capacity. Default: 80."
                }
              }
            },
            "read_scale": {
              "description": "",
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Should we enable autoscale for the table."
                },
                "role_arn": {
                  "type": "string",
                  "description": "AWS AutoScaling role ARN"
                },
                "min_capacity": {
                  "type": "integer",
                  "description": "DynamoDB minimum provision capacity. Default: 3000."
                },
                "max_capacity": {
                  "type": "integer",
                  "description": "DynamoDB maximum provision capacity. Default: 6000."
                },
                "out_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale up. Default: 1800."
                },
                "in_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale down. Default: 1800."
                },
                "target": {
                  "type": "number",
                  "description": "DynamoDB target ratio of consumed capacity to provisioned capacity. Default: 80."
                }
              }
            },
            "enable_inactive_throughput_on_demand_mode": {
              "type": "boolean",
              "description": "Enables on demand throughput provisioning for the storage provider (if supported). Applies only to tables which are not autoscaled. Supported by DynamoDB"
            },
            "inactive_write_throughput": {
              "type": "integer",
              "description": "Table write throughput for inactive tables. Supported by DynamoDB. Default: 1."
            },
            "inactive_read_throughput": {
              "type": "integer",
              "description": "Table read throughput for inactive tables. Supported by DynamoDB. Default: 300."
            },
            "inactive_write_scale": {
              "description": "",
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Should we enable autoscale for the table."
                },
                "role_arn": {
                  "type": "string",
                  "description": "AWS AutoScaling role ARN"
                },
                "min_capacity": {
                  "type": "integer",
                  "description": "DynamoDB minimum provision capacity. Default: 3000."
                },
                "max_capacity": {
                  "type": "integer",
                  "description": "DynamoDB maximum provision capacity. Default: 6000."
                },
                "out_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale up. Default: 1800."
                },
                "in_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale down. Default: 1800."
                },
                "target": {
                  "type": "number",
                  "description": "DynamoDB target ratio of consumed capacity to provisioned capacity. Default: 80."
                }
              }
            },
            "inactive_read_scale": {
              "description": "",
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Should we enable autoscale for the table."
                },
                "role_arn": {
                  "type": "string",
                  "description": "AWS AutoScaling role ARN"
                },
                "min_capacity": {
                  "type": "integer",
                  "description": "DynamoDB minimum provision capacity. Default: 3000."
                },
                "max_capacity": {
                  "type": "integer",
                  "description": "DynamoDB maximum provision capacity. Default: 6000."
                },
                "out_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale up. Default: 1800."
                },
                "in_cooldown": {
                  "type": "integer",
                  "description": "DynamoDB minimum seconds between each autoscale down. Default: 1800."
                },
                "target": {
                  "type": "number",
                  "description": "DynamoDB target ratio of consumed capacity to provisioned capacity. Default: 80."
                }
              }
            },
            "inactive_write_scale_lastn": {
              "type": "integer",
              "description": "Number of last inactive tables to enable write autoscale. Default: 4."
            },
            "inactive_read_scale_lastn": {
              "type": "integer",
              "description": "Number of last inactive tables to enable read autoscale. Default: 4."
            }
          }
        }
      }
    },
    "tls_config": {
      "type": "object",
      "properties": {
        "tls_cert_path": {
          "type": "string",
          "description": "Path to the client certificate, which will be used for authenticating with the server. Also requires the key path to be configured."
        },
        "tls_key_path": {
          "type": "string",
          "description": "Path to the key for the client certificate. Also requires the client certificate to be configured."
        },
        "tls_ca_path": {
          "type": "string",
          "description": "Path to the CA certificates to validate server certificate against. If not set, the host's root CA certificates are used."
        },
        "tls_server_name": {
          "type": "string",
          "description": "Override the expected name on the server certificate."
        },
        "tls_insecure_skip_verify": {
          "type": "boolean",
          "description": "Skip validating server certificate."
        },
        "tls_cipher_suites": {
          "type": "string",
          "description": "Override the default cipher suite list (separated by commas). Allowed values:\n\nSecure Ciphers:\n- TLS_AES_128_GCM_SHA256\n- TLS_AES_256_GCM_SHA384\n- TLS_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n- TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n\nInsecure Ciphers:\n- TLS_RSA_WITH_RC4_128_SHA\n- TLS_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA\n- TLS_RSA_WITH_AES_256_CBC_SHA\n- TLS_RSA_WITH_AES_128_CBC_SHA256\n- TLS_RSA_WITH_AES_128_GCM_SHA256\n- TLS_RSA_WITH_AES_256_GCM_SHA384\n- TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_RC4_128_SHA\n- TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n"
        },
        "tls_min_version": {
          "type": "string",
          "description": "Override the default minimum TLS version. Allowed values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13"
        }
      }
    },
    "tracing": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Set to false to disable tracing."
        }
      }
    }
  }
}
